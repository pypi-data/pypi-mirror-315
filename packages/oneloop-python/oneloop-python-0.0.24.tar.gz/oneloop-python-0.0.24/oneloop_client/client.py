# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx

from .core.api_error import ApiError
from .core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .core.jsonable_encoder import jsonable_encoder
from .core.remove_none_from_dict import remove_none_from_dict
from .core.request_options import RequestOptions
from .environment import OneloopEnvironment
from .errors.bad_request_error import BadRequestError
from .errors.forbidden_error import ForbiddenError
from .errors.unauthorized_error import UnauthorizedError
from .types.api_key_scope import ApiKeyScope
from .types.create_api_key_request_scopes_item import CreateApiKeyRequestScopesItem
from .types.create_api_key_response import CreateApiKeyResponse
from .types.create_customer_billing_meter_response import CreateCustomerBillingMeterResponse
from .types.create_jwt_response import CreateJwtResponse
from .types.create_workspace_response import CreateWorkspaceResponse
from .types.create_workspace_scope_response import CreateWorkspaceScopeResponse
from .types.delete_api_key_response import DeleteApiKeyResponse
from .types.edit_api_key_response import EditApiKeyResponse
from .types.error_response import ErrorResponse
from .types.generate_link_token_response import GenerateLinkTokenResponse
from .types.get_customer_billing_meter_response import GetCustomerBillingMeterResponse
from .types.migrate_api_key_request_scopes_item import MigrateApiKeyRequestScopesItem
from .types.migrate_api_key_response import MigrateApiKeyResponse
from .types.record_usage_api_key_response import RecordUsageApiKeyResponse
from .types.refill_customer_billing_meter_response import RefillCustomerBillingMeterResponse
from .types.retrieve_all_workspace_scopes_response import RetrieveAllWorkspaceScopesResponse
from .types.retrieve_api_key_by_id_response import RetrieveApiKeyByIdResponse
from .types.retrieve_api_keys_response import RetrieveApiKeysResponse
from .types.retrieve_customer_billing_meter_usage_response import RetrieveCustomerBillingMeterUsageResponse
from .types.retrieve_workspace_by_id_response import RetrieveWorkspaceByIdResponse
from .types.retrieve_workspace_response import RetrieveWorkspaceResponse
from .types.rotate_api_key_response import RotateApiKeyResponse
from .types.update_workspace_response import UpdateWorkspaceResponse
from .types.validate_link_token_response import ValidateLinkTokenResponse
from .types.verify_api_key_request_billing import VerifyApiKeyRequestBilling
from .types.verify_api_key_request_rate_limit_config import VerifyApiKeyRequestRateLimitConfig
from .types.verify_api_key_response import VerifyApiKeyResponse
from .types.verify_jwt_request_rate_limit_config import VerifyJwtRequestRateLimitConfig
from .types.verify_jwt_response import VerifyJwtResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class Oneloop:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propogate to these functions.

    Parameters:
        - base_url: typing.Optional[str]. The base url to use for requests from the client.

        - environment: OneloopEnvironment. The environment to use for requests from the client. from .environment import OneloopEnvironment

                                           Defaults to OneloopEnvironment.DEFAULT

        - token: typing.Union[str, typing.Callable[[], str]].

        - timeout: typing.Optional[float]. The timeout to be used, in seconds, for requests by default the timeout is 60 seconds.

        - httpx_client: typing.Optional[httpx.Client]. The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.
    ---
    from oneloop.client import Oneloop

    client = Oneloop(
        token="YOUR_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: OneloopEnvironment = OneloopEnvironment.DEFAULT,
        token: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.Client] = None,
    ):
        self._client_wrapper = SyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            token=token,
            httpx_client=httpx.Client(timeout=timeout) if httpx_client is None else httpx_client,
        )

    def get_workspace(self, *, request_options: typing.Optional[RequestOptions] = None) -> RetrieveWorkspaceResponse:
        """
        Parameters:
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.get_workspace()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/workspace"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveWorkspaceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_workspace(
        self, *, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> CreateWorkspaceResponse:
        """
        Parameters:
            - name: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.create_workspace(
            name="name",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/workspace"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder({"name": name})
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder({"name": name}),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateWorkspaceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workspace_by_id(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveWorkspaceByIdResponse:
        """
        Parameters:
            - id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.get_workspace_by_id(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveWorkspaceByIdResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_workspace(
        self,
        id: str,
        *,
        default_key_prefix: typing.Optional[str] = OMIT,
        default_allowed_i_ps: typing.List[str],
        default_rate_limit_per_second: typing.Optional[int] = OMIT,
        default_expiration: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateWorkspaceResponse:
        """
        Parameters:
            - id: str.

            - default_key_prefix: typing.Optional[str].

            - default_allowed_i_ps: typing.List[str].

            - default_rate_limit_per_second: typing.Optional[int].

            - default_expiration: typing.Optional[int].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.update_workspace(
            id="id",
            default_allowed_i_ps=["defaultAllowedIPs"],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"defaultAllowedIPs": default_allowed_i_ps}
        if default_key_prefix is not OMIT:
            _request["defaultKeyPrefix"] = default_key_prefix
        if default_rate_limit_per_second is not OMIT:
            _request["defaultRateLimitPerSecond"] = default_rate_limit_per_second
        if default_expiration is not OMIT:
            _request["defaultExpiration"] = default_expiration
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UpdateWorkspaceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_workspace_scopes(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveAllWorkspaceScopesResponse:
        """
        Parameters:
            - id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.get_workspace_scopes(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/scopes"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveAllWorkspaceScopesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_workspace_scopes(
        self,
        id: str,
        *,
        name: str,
        representation: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateWorkspaceScopeResponse:
        """
        Parameters:
            - id: str.

            - name: str.

            - representation: str.

            - description: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.create_workspace_scopes(
            id="id",
            name="name",
            representation="representation",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "representation": representation}
        if description is not OMIT:
            _request["description"] = description
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/scope"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateWorkspaceScopeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_api_key(
        self,
        *,
        name: str,
        workspace_id: str,
        prefix: typing.Optional[str] = OMIT,
        expires_at: typing.Optional[int] = OMIT,
        scopes: typing.List[CreateApiKeyRequestScopesItem],
        enabled: bool,
        customer_id: str,
        external_meter_id: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateApiKeyResponse:
        """
        Parameters:
            - name: str.

            - workspace_id: str.

            - prefix: typing.Optional[str].

            - expires_at: typing.Optional[int].

            - scopes: typing.List[CreateApiKeyRequestScopesItem].

            - enabled: bool.

            - customer_id: str.

            - external_meter_id: typing.Optional[str].

            - metadata: typing.Optional[typing.Dict[str, str]].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop import CreateApiKeyRequestScopesItem
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.create_api_key(
            name="name",
            workspace_id="workspaceId",
            scopes=[
                CreateApiKeyRequestScopesItem(
                    representation="representation",
                    create=True,
                    read=True,
                    update=True,
                    del_=True,
                )
            ],
            enabled=True,
            customer_id="customerId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "workspaceId": workspace_id,
            "scopes": scopes,
            "enabled": enabled,
            "customerId": customer_id,
        }
        if prefix is not OMIT:
            _request["prefix"] = prefix
        if expires_at is not OMIT:
            _request["expiresAt"] = expires_at
        if external_meter_id is not OMIT:
            _request["externalMeterId"] = external_meter_id
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_api_keys(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveApiKeysResponse:
        """
        Parameters:
            - id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.get_api_keys(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveApiKeysResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_api_key_by_id(
        self, id: str, akid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveApiKeyByIdResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.get_api_key_by_id(
            id="id",
            akid="akid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveApiKeyByIdResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_api_key(
        self, id: str, akid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DeleteApiKeyResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.delete_api_key(
            id="id",
            akid="akid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def edit_api_key(
        self,
        id: str,
        akid: str,
        *,
        name: typing.Optional[str] = OMIT,
        enabled: typing.Optional[bool] = OMIT,
        scopes: typing.Optional[typing.List[ApiKeyScope]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EditApiKeyResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - name: typing.Optional[str].

            - enabled: typing.Optional[bool].

            - scopes: typing.Optional[typing.List[ApiKeyScope]].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.edit_api_key(
            id="id",
            akid="akid",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if enabled is not OMIT:
            _request["enabled"] = enabled
        if scopes is not OMIT:
            _request["scopes"] = scopes
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EditApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def verify_api_key(
        self,
        *,
        key: str,
        requested_scopes: typing.List[ApiKeyScope],
        route: typing.Optional[str] = OMIT,
        billing: typing.Optional[VerifyApiKeyRequestBilling] = OMIT,
        rate_limit_config: typing.Optional[VerifyApiKeyRequestRateLimitConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerifyApiKeyResponse:
        """
        Parameters:
            - key: str.

            - requested_scopes: typing.List[ApiKeyScope].

            - route: typing.Optional[str].

            - billing: typing.Optional[VerifyApiKeyRequestBilling].

            - rate_limit_config: typing.Optional[VerifyApiKeyRequestRateLimitConfig].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop import ApiKeyScope
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.verify_api_key(
            key="key",
            requested_scopes=[
                ApiKeyScope(
                    representation="representation",
                    create=True,
                    read=True,
                    update=True,
                    del_=True,
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"key": key, "requestedScopes": requested_scopes}
        if route is not OMIT:
            _request["route"] = route
        if billing is not OMIT:
            _request["billing"] = billing
        if rate_limit_config is not OMIT:
            _request["rateLimitConfig"] = rate_limit_config
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key/verify"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VerifyApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def record_api_key_usage(
        self,
        *,
        key: str,
        usage: typing.Optional[str] = OMIT,
        usage_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RecordUsageApiKeyResponse:
        """
        Parameters:
            - key: str.

            - usage: typing.Optional[str].

            - usage_name: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.record_api_key_usage(
            key="key",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"key": key}
        if usage is not OMIT:
            _request["usage"] = usage
        if usage_name is not OMIT:
            _request["usageName"] = usage_name
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key/record-usage"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordUsageApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def rotate_api_key(
        self, id: str, akid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RotateApiKeyResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.rotate_api_key(
            id="id",
            akid="akid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}/rotate"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RotateApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def generate_link_token(
        self,
        *,
        customer_id: str,
        workspace_id: str,
        external_billing_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GenerateLinkTokenResponse:
        """
        Parameters:
            - customer_id: str.

            - workspace_id: str.

            - external_billing_id: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.generate_link_token(
            customer_id="customerId",
            workspace_id="workspaceId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"customerId": customer_id, "workspaceId": workspace_id}
        if external_billing_id is not OMIT:
            _request["externalBillingId"] = external_billing_id
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/link-token"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GenerateLinkTokenResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def validate_link_token(
        self, token: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ValidateLinkTokenResponse:
        """
        Parameters:
            - token: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.validate_link_token(
            token="token",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/link-token/{token}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ValidateLinkTokenResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_billing_usage(
        self, bid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveCustomerBillingMeterUsageResponse:
        """
        Parameters:
            - bid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.get_billing_usage(
            bid="bid",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/usage/{bid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveCustomerBillingMeterUsageResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_customer_billing(
        self, *, workspace_id: str, external_meter_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> GetCustomerBillingMeterResponse:
        """
        Parameters:
            - workspace_id: str.

            - external_meter_id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.get_customer_billing(
            workspace_id="workspaceId",
            external_meter_id="externalMeterId",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/customer-billing"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "workspaceId": workspace_id,
                        "externalMeterId": external_meter_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCustomerBillingMeterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_customer_billing(
        self,
        *,
        total_credits: typing.Optional[str] = OMIT,
        allow_overages: typing.Optional[bool] = OMIT,
        spend_cap: typing.Optional[str] = OMIT,
        external_meter_id: str,
        workspace_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateCustomerBillingMeterResponse:
        """
        Parameters:
            - total_credits: typing.Optional[str].

            - allow_overages: typing.Optional[bool].

            - spend_cap: typing.Optional[str].

            - external_meter_id: str.

            - workspace_id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.create_customer_billing(
            external_meter_id="externalMeterId",
            workspace_id="workspaceId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"externalMeterId": external_meter_id, "workspaceId": workspace_id}
        if total_credits is not OMIT:
            _request["totalCredits"] = total_credits
        if allow_overages is not OMIT:
            _request["allowOverages"] = allow_overages
        if spend_cap is not OMIT:
            _request["spendCap"] = spend_cap
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/customer-billing"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateCustomerBillingMeterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def refill_billing_limit(
        self,
        *,
        workspace_id: str,
        external_meter_id: str,
        refill: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RefillCustomerBillingMeterResponse:
        """
        Parameters:
            - workspace_id: str.

            - external_meter_id: str.

            - refill: typing.Optional[int].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.refill_billing_limit(
            workspace_id="workspaceId",
            external_meter_id="externalMeterId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"workspaceId": workspace_id, "externalMeterId": external_meter_id}
        if refill is not OMIT:
            _request["refill"] = refill
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/customer-billing/refill"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RefillCustomerBillingMeterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def migrate_api_key(
        self,
        *,
        key: str,
        name: str,
        workspace_id: str,
        scopes: typing.List[MigrateApiKeyRequestScopesItem],
        enabled: bool,
        customer_id: str,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> MigrateApiKeyResponse:
        """
        Parameters:
            - key: str.

            - name: str.

            - workspace_id: str.

            - scopes: typing.List[MigrateApiKeyRequestScopesItem].

            - enabled: bool.

            - customer_id: str.

            - metadata: typing.Optional[typing.Dict[str, str]].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop import MigrateApiKeyRequestScopesItem
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.migrate_api_key(
            key="key",
            name="name",
            workspace_id="workspaceId",
            scopes=[
                MigrateApiKeyRequestScopesItem(
                    representation="representation",
                    create=True,
                    read=True,
                    update=True,
                    del_=True,
                )
            ],
            enabled=True,
            customer_id="customerId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "key": key,
            "name": name,
            "workspaceId": workspace_id,
            "scopes": scopes,
            "enabled": enabled,
            "customerId": customer_id,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key/migrate"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MigrateApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_jwt(
        self,
        *,
        payload: typing.Dict[str, str],
        aud: typing.Optional[str] = OMIT,
        exp: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateJwtResponse:
        """
        Parameters:
            - payload: typing.Dict[str, str].

            - aud: typing.Optional[str].

            - exp: typing.Optional[int].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.create_jwt(
            payload={"payload": "payload"},
        )
        """
        _request: typing.Dict[str, typing.Any] = {"payload": payload}
        if aud is not OMIT:
            _request["aud"] = aud
        if exp is not OMIT:
            _request["exp"] = exp
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/jwt"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateJwtResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def verify_jwt(
        self,
        *,
        jwt: str,
        rate_limit_config: typing.Optional[VerifyJwtRequestRateLimitConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerifyJwtResponse:
        """
        Parameters:
            - jwt: str.

            - rate_limit_config: typing.Optional[VerifyJwtRequestRateLimitConfig].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import Oneloop

        client = Oneloop(
            token="YOUR_TOKEN",
        )
        client.verify_jwt(
            jwt="jwt",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"jwt": jwt}
        if rate_limit_config is not OMIT:
            _request["rateLimitConfig"] = rate_limit_config
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/jwt/verify"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VerifyJwtResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncOneloop:
    """
    Use this class to access the different functions within the SDK. You can instantiate any number of clients with different configuration that will propogate to these functions.

    Parameters:
        - base_url: typing.Optional[str]. The base url to use for requests from the client.

        - environment: OneloopEnvironment. The environment to use for requests from the client. from .environment import OneloopEnvironment

                                           Defaults to OneloopEnvironment.DEFAULT

        - token: typing.Union[str, typing.Callable[[], str]].

        - timeout: typing.Optional[float]. The timeout to be used, in seconds, for requests by default the timeout is 60 seconds.

        - httpx_client: typing.Optional[httpx.AsyncClient]. The httpx client to use for making requests, a preconfigured client is used by default, however this is useful should you want to pass in any custom httpx configuration.
    ---
    from oneloop.client import AsyncOneloop

    client = AsyncOneloop(
        token="YOUR_TOKEN",
    )
    """

    def __init__(
        self,
        *,
        base_url: typing.Optional[str] = None,
        environment: OneloopEnvironment = OneloopEnvironment.DEFAULT,
        token: typing.Union[str, typing.Callable[[], str]],
        timeout: typing.Optional[float] = 60,
        httpx_client: typing.Optional[httpx.AsyncClient] = None,
    ):
        self._client_wrapper = AsyncClientWrapper(
            base_url=_get_base_url(base_url=base_url, environment=environment),
            token=token,
            httpx_client=httpx.AsyncClient(timeout=timeout) if httpx_client is None else httpx_client,
        )

    async def get_workspace(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveWorkspaceResponse:
        """
        Parameters:
            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.get_workspace()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/workspace"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveWorkspaceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_workspace(
        self, *, name: str, request_options: typing.Optional[RequestOptions] = None
    ) -> CreateWorkspaceResponse:
        """
        Parameters:
            - name: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.create_workspace(
            name="name",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/workspace"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder({"name": name})
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder({"name": name}),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateWorkspaceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workspace_by_id(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveWorkspaceByIdResponse:
        """
        Parameters:
            - id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.get_workspace_by_id(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveWorkspaceByIdResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_workspace(
        self,
        id: str,
        *,
        default_key_prefix: typing.Optional[str] = OMIT,
        default_allowed_i_ps: typing.List[str],
        default_rate_limit_per_second: typing.Optional[int] = OMIT,
        default_expiration: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateWorkspaceResponse:
        """
        Parameters:
            - id: str.

            - default_key_prefix: typing.Optional[str].

            - default_allowed_i_ps: typing.List[str].

            - default_rate_limit_per_second: typing.Optional[int].

            - default_expiration: typing.Optional[int].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.update_workspace(
            id="id",
            default_allowed_i_ps=["defaultAllowedIPs"],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"defaultAllowedIPs": default_allowed_i_ps}
        if default_key_prefix is not OMIT:
            _request["defaultKeyPrefix"] = default_key_prefix
        if default_rate_limit_per_second is not OMIT:
            _request["defaultRateLimitPerSecond"] = default_rate_limit_per_second
        if default_expiration is not OMIT:
            _request["defaultExpiration"] = default_expiration
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(UpdateWorkspaceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_workspace_scopes(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveAllWorkspaceScopesResponse:
        """
        Parameters:
            - id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.get_workspace_scopes(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/scopes"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveAllWorkspaceScopesResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_workspace_scopes(
        self,
        id: str,
        *,
        name: str,
        representation: str,
        description: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateWorkspaceScopeResponse:
        """
        Parameters:
            - id: str.

            - name: str.

            - representation: str.

            - description: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.create_workspace_scopes(
            id="id",
            name="name",
            representation="representation",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "representation": representation}
        if description is not OMIT:
            _request["description"] = description
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/scope"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateWorkspaceScopeResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_api_key(
        self,
        *,
        name: str,
        workspace_id: str,
        prefix: typing.Optional[str] = OMIT,
        expires_at: typing.Optional[int] = OMIT,
        scopes: typing.List[CreateApiKeyRequestScopesItem],
        enabled: bool,
        customer_id: str,
        external_meter_id: typing.Optional[str] = OMIT,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateApiKeyResponse:
        """
        Parameters:
            - name: str.

            - workspace_id: str.

            - prefix: typing.Optional[str].

            - expires_at: typing.Optional[int].

            - scopes: typing.List[CreateApiKeyRequestScopesItem].

            - enabled: bool.

            - customer_id: str.

            - external_meter_id: typing.Optional[str].

            - metadata: typing.Optional[typing.Dict[str, str]].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop import CreateApiKeyRequestScopesItem
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.create_api_key(
            name="name",
            workspace_id="workspaceId",
            scopes=[
                CreateApiKeyRequestScopesItem(
                    representation="representation",
                    create=True,
                    read=True,
                    update=True,
                    del_=True,
                )
            ],
            enabled=True,
            customer_id="customerId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "name": name,
            "workspaceId": workspace_id,
            "scopes": scopes,
            "enabled": enabled,
            "customerId": customer_id,
        }
        if prefix is not OMIT:
            _request["prefix"] = prefix
        if expires_at is not OMIT:
            _request["expiresAt"] = expires_at
        if external_meter_id is not OMIT:
            _request["externalMeterId"] = external_meter_id
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_api_keys(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveApiKeysResponse:
        """
        Parameters:
            - id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.get_api_keys(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveApiKeysResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_api_key_by_id(
        self, id: str, akid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveApiKeyByIdResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.get_api_key_by_id(
            id="id",
            akid="akid",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveApiKeyByIdResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_api_key(
        self, id: str, akid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DeleteApiKeyResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.delete_api_key(
            id="id",
            akid="akid",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DeleteApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def edit_api_key(
        self,
        id: str,
        akid: str,
        *,
        name: typing.Optional[str] = OMIT,
        enabled: typing.Optional[bool] = OMIT,
        scopes: typing.Optional[typing.List[ApiKeyScope]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> EditApiKeyResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - name: typing.Optional[str].

            - enabled: typing.Optional[bool].

            - scopes: typing.Optional[typing.List[ApiKeyScope]].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.edit_api_key(
            id="id",
            akid="akid",
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if enabled is not OMIT:
            _request["enabled"] = enabled
        if scopes is not OMIT:
            _request["scopes"] = scopes
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EditApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def verify_api_key(
        self,
        *,
        key: str,
        requested_scopes: typing.List[ApiKeyScope],
        route: typing.Optional[str] = OMIT,
        billing: typing.Optional[VerifyApiKeyRequestBilling] = OMIT,
        rate_limit_config: typing.Optional[VerifyApiKeyRequestRateLimitConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerifyApiKeyResponse:
        """
        Parameters:
            - key: str.

            - requested_scopes: typing.List[ApiKeyScope].

            - route: typing.Optional[str].

            - billing: typing.Optional[VerifyApiKeyRequestBilling].

            - rate_limit_config: typing.Optional[VerifyApiKeyRequestRateLimitConfig].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop import ApiKeyScope
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.verify_api_key(
            key="key",
            requested_scopes=[
                ApiKeyScope(
                    representation="representation",
                    create=True,
                    read=True,
                    update=True,
                    del_=True,
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"key": key, "requestedScopes": requested_scopes}
        if route is not OMIT:
            _request["route"] = route
        if billing is not OMIT:
            _request["billing"] = billing
        if rate_limit_config is not OMIT:
            _request["rateLimitConfig"] = rate_limit_config
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key/verify"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VerifyApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def record_api_key_usage(
        self,
        *,
        key: str,
        usage: typing.Optional[str] = OMIT,
        usage_name: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RecordUsageApiKeyResponse:
        """
        Parameters:
            - key: str.

            - usage: typing.Optional[str].

            - usage_name: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.record_api_key_usage(
            key="key",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"key": key}
        if usage is not OMIT:
            _request["usage"] = usage
        if usage_name is not OMIT:
            _request["usageName"] = usage_name
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key/record-usage"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RecordUsageApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def rotate_api_key(
        self, id: str, akid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RotateApiKeyResponse:
        """
        Parameters:
            - id: str.

            - akid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.rotate_api_key(
            id="id",
            akid="akid",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v1/workspace/{id}/api-key/{akid}/rotate"
            ),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RotateApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def generate_link_token(
        self,
        *,
        customer_id: str,
        workspace_id: str,
        external_billing_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GenerateLinkTokenResponse:
        """
        Parameters:
            - customer_id: str.

            - workspace_id: str.

            - external_billing_id: typing.Optional[str].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.generate_link_token(
            customer_id="customerId",
            workspace_id="workspaceId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"customerId": customer_id, "workspaceId": workspace_id}
        if external_billing_id is not OMIT:
            _request["externalBillingId"] = external_billing_id
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/link-token"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GenerateLinkTokenResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def validate_link_token(
        self, token: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ValidateLinkTokenResponse:
        """
        Parameters:
            - token: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.validate_link_token(
            token="token",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/link-token/{token}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ValidateLinkTokenResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_billing_usage(
        self, bid: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> RetrieveCustomerBillingMeterUsageResponse:
        """
        Parameters:
            - bid: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.get_billing_usage(
            bid="bid",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/usage/{bid}"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RetrieveCustomerBillingMeterUsageResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_customer_billing(
        self, *, workspace_id: str, external_meter_id: str, request_options: typing.Optional[RequestOptions] = None
    ) -> GetCustomerBillingMeterResponse:
        """
        Parameters:
            - workspace_id: str.

            - external_meter_id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.get_customer_billing(
            workspace_id="workspaceId",
            external_meter_id="externalMeterId",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/customer-billing"),
            params=jsonable_encoder(
                remove_none_from_dict(
                    {
                        "workspaceId": workspace_id,
                        "externalMeterId": external_meter_id,
                        **(
                            request_options.get("additional_query_parameters", {})
                            if request_options is not None
                            else {}
                        ),
                    }
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetCustomerBillingMeterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_customer_billing(
        self,
        *,
        total_credits: typing.Optional[str] = OMIT,
        allow_overages: typing.Optional[bool] = OMIT,
        spend_cap: typing.Optional[str] = OMIT,
        external_meter_id: str,
        workspace_id: str,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateCustomerBillingMeterResponse:
        """
        Parameters:
            - total_credits: typing.Optional[str].

            - allow_overages: typing.Optional[bool].

            - spend_cap: typing.Optional[str].

            - external_meter_id: str.

            - workspace_id: str.

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.create_customer_billing(
            external_meter_id="externalMeterId",
            workspace_id="workspaceId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"externalMeterId": external_meter_id, "workspaceId": workspace_id}
        if total_credits is not OMIT:
            _request["totalCredits"] = total_credits
        if allow_overages is not OMIT:
            _request["allowOverages"] = allow_overages
        if spend_cap is not OMIT:
            _request["spendCap"] = spend_cap
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/customer-billing"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateCustomerBillingMeterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def refill_billing_limit(
        self,
        *,
        workspace_id: str,
        external_meter_id: str,
        refill: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> RefillCustomerBillingMeterResponse:
        """
        Parameters:
            - workspace_id: str.

            - external_meter_id: str.

            - refill: typing.Optional[int].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.refill_billing_limit(
            workspace_id="workspaceId",
            external_meter_id="externalMeterId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"workspaceId": workspace_id, "externalMeterId": external_meter_id}
        if refill is not OMIT:
            _request["refill"] = refill
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/customer-billing/refill"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(RefillCustomerBillingMeterResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def migrate_api_key(
        self,
        *,
        key: str,
        name: str,
        workspace_id: str,
        scopes: typing.List[MigrateApiKeyRequestScopesItem],
        enabled: bool,
        customer_id: str,
        metadata: typing.Optional[typing.Dict[str, str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> MigrateApiKeyResponse:
        """
        Parameters:
            - key: str.

            - name: str.

            - workspace_id: str.

            - scopes: typing.List[MigrateApiKeyRequestScopesItem].

            - enabled: bool.

            - customer_id: str.

            - metadata: typing.Optional[typing.Dict[str, str]].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop import MigrateApiKeyRequestScopesItem
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.migrate_api_key(
            key="key",
            name="name",
            workspace_id="workspaceId",
            scopes=[
                MigrateApiKeyRequestScopesItem(
                    representation="representation",
                    create=True,
                    read=True,
                    update=True,
                    del_=True,
                )
            ],
            enabled=True,
            customer_id="customerId",
        )
        """
        _request: typing.Dict[str, typing.Any] = {
            "key": key,
            "name": name,
            "workspaceId": workspace_id,
            "scopes": scopes,
            "enabled": enabled,
            "customerId": customer_id,
        }
        if metadata is not OMIT:
            _request["metadata"] = metadata
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/api-key/migrate"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(MigrateApiKeyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_jwt(
        self,
        *,
        payload: typing.Dict[str, str],
        aud: typing.Optional[str] = OMIT,
        exp: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateJwtResponse:
        """
        Parameters:
            - payload: typing.Dict[str, str].

            - aud: typing.Optional[str].

            - exp: typing.Optional[int].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.create_jwt(
            payload={"payload": "payload"},
        )
        """
        _request: typing.Dict[str, typing.Any] = {"payload": payload}
        if aud is not OMIT:
            _request["aud"] = aud
        if exp is not OMIT:
            _request["exp"] = exp
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/jwt"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateJwtResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def verify_jwt(
        self,
        *,
        jwt: str,
        rate_limit_config: typing.Optional[VerifyJwtRequestRateLimitConfig] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> VerifyJwtResponse:
        """
        Parameters:
            - jwt: str.

            - rate_limit_config: typing.Optional[VerifyJwtRequestRateLimitConfig].

            - request_options: typing.Optional[RequestOptions]. Request-specific configuration.
        ---
        from oneloop.client import AsyncOneloop

        client = AsyncOneloop(
            token="YOUR_TOKEN",
        )
        await client.verify_jwt(
            jwt="jwt",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"jwt": jwt}
        if rate_limit_config is not OMIT:
            _request["rateLimitConfig"] = rate_limit_config
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/jwt/verify"),
            params=jsonable_encoder(
                request_options.get("additional_query_parameters") if request_options is not None else None
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else 60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VerifyJwtResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


def _get_base_url(*, base_url: typing.Optional[str] = None, environment: OneloopEnvironment) -> str:
    if base_url is not None:
        return base_url
    elif environment is not None:
        return environment.value
    else:
        raise Exception("Please pass in either base_url or environment to construct the client")
