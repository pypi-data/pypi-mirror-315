# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pyaqcv
else:
    import _pyaqcv

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


__cplusplus = _pyaqcv.__cplusplus
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_SwigPyIterator

    def value(self):
        return _pyaqcv.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _pyaqcv.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _pyaqcv.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _pyaqcv.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _pyaqcv.SwigPyIterator_equal(self, x)

    def copy(self):
        return _pyaqcv.SwigPyIterator_copy(self)

    def next(self):
        return _pyaqcv.SwigPyIterator_next(self)

    def __next__(self):
        return _pyaqcv.SwigPyIterator___next__(self)

    def previous(self):
        return _pyaqcv.SwigPyIterator_previous(self)

    def advance(self, n):
        return _pyaqcv.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _pyaqcv.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _pyaqcv.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _pyaqcv.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _pyaqcv.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _pyaqcv.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _pyaqcv.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pyaqcv:
_pyaqcv.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _pyaqcv.SHARED_PTR_DISOWN
class InitializerListChar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListChar_swiginit(self, _pyaqcv.new_InitializerListChar())
    __swig_destroy__ = _pyaqcv.delete_InitializerListChar

# Register InitializerListChar in _pyaqcv:
_pyaqcv.InitializerListChar_swigregister(InitializerListChar)
class InitializerListUChar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListUChar_swiginit(self, _pyaqcv.new_InitializerListUChar())
    __swig_destroy__ = _pyaqcv.delete_InitializerListUChar

# Register InitializerListUChar in _pyaqcv:
_pyaqcv.InitializerListUChar_swigregister(InitializerListUChar)
class InitializerListShort(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListShort_swiginit(self, _pyaqcv.new_InitializerListShort())
    __swig_destroy__ = _pyaqcv.delete_InitializerListShort

# Register InitializerListShort in _pyaqcv:
_pyaqcv.InitializerListShort_swigregister(InitializerListShort)
class InitializerListUshort(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListUshort_swiginit(self, _pyaqcv.new_InitializerListUshort())
    __swig_destroy__ = _pyaqcv.delete_InitializerListUshort

# Register InitializerListUshort in _pyaqcv:
_pyaqcv.InitializerListUshort_swigregister(InitializerListUshort)
class InitializerListInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListInt_swiginit(self, _pyaqcv.new_InitializerListInt())
    __swig_destroy__ = _pyaqcv.delete_InitializerListInt

# Register InitializerListInt in _pyaqcv:
_pyaqcv.InitializerListInt_swigregister(InitializerListInt)
class InitializerListUInt(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListUInt_swiginit(self, _pyaqcv.new_InitializerListUInt())
    __swig_destroy__ = _pyaqcv.delete_InitializerListUInt

# Register InitializerListUInt in _pyaqcv:
_pyaqcv.InitializerListUInt_swigregister(InitializerListUInt)
class InitializerListFloat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListFloat_swiginit(self, _pyaqcv.new_InitializerListFloat())
    __swig_destroy__ = _pyaqcv.delete_InitializerListFloat

# Register InitializerListFloat in _pyaqcv:
_pyaqcv.InitializerListFloat_swigregister(InitializerListFloat)
class InitializerListDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.InitializerListDouble_swiginit(self, _pyaqcv.new_InitializerListDouble())
    __swig_destroy__ = _pyaqcv.delete_InitializerListDouble

# Register InitializerListDouble in _pyaqcv:
_pyaqcv.InitializerListDouble_swigregister(InitializerListDouble)
class ByteVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.ByteVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.ByteVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.ByteVec___bool__(self)

    def __len__(self):
        return _pyaqcv.ByteVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.ByteVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.ByteVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.ByteVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.ByteVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.ByteVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.ByteVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.ByteVec_pop(self)

    def append(self, x):
        return _pyaqcv.ByteVec_append(self, x)

    def empty(self):
        return _pyaqcv.ByteVec_empty(self)

    def size(self):
        return _pyaqcv.ByteVec_size(self)

    def swap(self, v):
        return _pyaqcv.ByteVec_swap(self, v)

    def begin(self):
        return _pyaqcv.ByteVec_begin(self)

    def end(self):
        return _pyaqcv.ByteVec_end(self)

    def rbegin(self):
        return _pyaqcv.ByteVec_rbegin(self)

    def rend(self):
        return _pyaqcv.ByteVec_rend(self)

    def clear(self):
        return _pyaqcv.ByteVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.ByteVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.ByteVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.ByteVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.ByteVec_swiginit(self, _pyaqcv.new_ByteVec(*args))

    def push_back(self, x):
        return _pyaqcv.ByteVec_push_back(self, x)

    def front(self):
        return _pyaqcv.ByteVec_front(self)

    def back(self):
        return _pyaqcv.ByteVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.ByteVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.ByteVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.ByteVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.ByteVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.ByteVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_ByteVec

# Register ByteVec in _pyaqcv:
_pyaqcv.ByteVec_swigregister(ByteVec)
class ShortVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.ShortVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.ShortVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.ShortVec___bool__(self)

    def __len__(self):
        return _pyaqcv.ShortVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.ShortVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.ShortVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.ShortVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.ShortVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.ShortVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.ShortVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.ShortVec_pop(self)

    def append(self, x):
        return _pyaqcv.ShortVec_append(self, x)

    def empty(self):
        return _pyaqcv.ShortVec_empty(self)

    def size(self):
        return _pyaqcv.ShortVec_size(self)

    def swap(self, v):
        return _pyaqcv.ShortVec_swap(self, v)

    def begin(self):
        return _pyaqcv.ShortVec_begin(self)

    def end(self):
        return _pyaqcv.ShortVec_end(self)

    def rbegin(self):
        return _pyaqcv.ShortVec_rbegin(self)

    def rend(self):
        return _pyaqcv.ShortVec_rend(self)

    def clear(self):
        return _pyaqcv.ShortVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.ShortVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.ShortVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.ShortVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.ShortVec_swiginit(self, _pyaqcv.new_ShortVec(*args))

    def push_back(self, x):
        return _pyaqcv.ShortVec_push_back(self, x)

    def front(self):
        return _pyaqcv.ShortVec_front(self)

    def back(self):
        return _pyaqcv.ShortVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.ShortVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.ShortVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.ShortVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.ShortVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.ShortVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_ShortVec

# Register ShortVec in _pyaqcv:
_pyaqcv.ShortVec_swigregister(ShortVec)
class IntVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.IntVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.IntVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.IntVec___bool__(self)

    def __len__(self):
        return _pyaqcv.IntVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.IntVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.IntVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.IntVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.IntVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.IntVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.IntVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.IntVec_pop(self)

    def append(self, x):
        return _pyaqcv.IntVec_append(self, x)

    def empty(self):
        return _pyaqcv.IntVec_empty(self)

    def size(self):
        return _pyaqcv.IntVec_size(self)

    def swap(self, v):
        return _pyaqcv.IntVec_swap(self, v)

    def begin(self):
        return _pyaqcv.IntVec_begin(self)

    def end(self):
        return _pyaqcv.IntVec_end(self)

    def rbegin(self):
        return _pyaqcv.IntVec_rbegin(self)

    def rend(self):
        return _pyaqcv.IntVec_rend(self)

    def clear(self):
        return _pyaqcv.IntVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.IntVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.IntVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.IntVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.IntVec_swiginit(self, _pyaqcv.new_IntVec(*args))

    def push_back(self, x):
        return _pyaqcv.IntVec_push_back(self, x)

    def front(self):
        return _pyaqcv.IntVec_front(self)

    def back(self):
        return _pyaqcv.IntVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.IntVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.IntVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.IntVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.IntVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.IntVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_IntVec

# Register IntVec in _pyaqcv:
_pyaqcv.IntVec_swigregister(IntVec)
class UintVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.UintVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.UintVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.UintVec___bool__(self)

    def __len__(self):
        return _pyaqcv.UintVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.UintVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.UintVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.UintVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.UintVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.UintVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.UintVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.UintVec_pop(self)

    def append(self, x):
        return _pyaqcv.UintVec_append(self, x)

    def empty(self):
        return _pyaqcv.UintVec_empty(self)

    def size(self):
        return _pyaqcv.UintVec_size(self)

    def swap(self, v):
        return _pyaqcv.UintVec_swap(self, v)

    def begin(self):
        return _pyaqcv.UintVec_begin(self)

    def end(self):
        return _pyaqcv.UintVec_end(self)

    def rbegin(self):
        return _pyaqcv.UintVec_rbegin(self)

    def rend(self):
        return _pyaqcv.UintVec_rend(self)

    def clear(self):
        return _pyaqcv.UintVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.UintVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.UintVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.UintVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.UintVec_swiginit(self, _pyaqcv.new_UintVec(*args))

    def push_back(self, x):
        return _pyaqcv.UintVec_push_back(self, x)

    def front(self):
        return _pyaqcv.UintVec_front(self)

    def back(self):
        return _pyaqcv.UintVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.UintVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.UintVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.UintVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.UintVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.UintVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_UintVec

# Register UintVec in _pyaqcv:
_pyaqcv.UintVec_swigregister(UintVec)
class BoolVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.BoolVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.BoolVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.BoolVec___bool__(self)

    def __len__(self):
        return _pyaqcv.BoolVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.BoolVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.BoolVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.BoolVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.BoolVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.BoolVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.BoolVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.BoolVec_pop(self)

    def append(self, x):
        return _pyaqcv.BoolVec_append(self, x)

    def empty(self):
        return _pyaqcv.BoolVec_empty(self)

    def size(self):
        return _pyaqcv.BoolVec_size(self)

    def swap(self, v):
        return _pyaqcv.BoolVec_swap(self, v)

    def begin(self):
        return _pyaqcv.BoolVec_begin(self)

    def end(self):
        return _pyaqcv.BoolVec_end(self)

    def rbegin(self):
        return _pyaqcv.BoolVec_rbegin(self)

    def rend(self):
        return _pyaqcv.BoolVec_rend(self)

    def clear(self):
        return _pyaqcv.BoolVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.BoolVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.BoolVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.BoolVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.BoolVec_swiginit(self, _pyaqcv.new_BoolVec(*args))

    def push_back(self, x):
        return _pyaqcv.BoolVec_push_back(self, x)

    def front(self):
        return _pyaqcv.BoolVec_front(self)

    def back(self):
        return _pyaqcv.BoolVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.BoolVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.BoolVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.BoolVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.BoolVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.BoolVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_BoolVec

# Register BoolVec in _pyaqcv:
_pyaqcv.BoolVec_swigregister(BoolVec)
class StringVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.StringVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.StringVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.StringVec___bool__(self)

    def __len__(self):
        return _pyaqcv.StringVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.StringVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.StringVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.StringVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.StringVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.StringVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.StringVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.StringVec_pop(self)

    def append(self, x):
        return _pyaqcv.StringVec_append(self, x)

    def empty(self):
        return _pyaqcv.StringVec_empty(self)

    def size(self):
        return _pyaqcv.StringVec_size(self)

    def swap(self, v):
        return _pyaqcv.StringVec_swap(self, v)

    def begin(self):
        return _pyaqcv.StringVec_begin(self)

    def end(self):
        return _pyaqcv.StringVec_end(self)

    def rbegin(self):
        return _pyaqcv.StringVec_rbegin(self)

    def rend(self):
        return _pyaqcv.StringVec_rend(self)

    def clear(self):
        return _pyaqcv.StringVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.StringVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.StringVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.StringVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.StringVec_swiginit(self, _pyaqcv.new_StringVec(*args))

    def push_back(self, x):
        return _pyaqcv.StringVec_push_back(self, x)

    def front(self):
        return _pyaqcv.StringVec_front(self)

    def back(self):
        return _pyaqcv.StringVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.StringVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.StringVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.StringVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.StringVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.StringVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_StringVec

# Register StringVec in _pyaqcv:
_pyaqcv.StringVec_swigregister(StringVec)
class FloatVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.FloatVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.FloatVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.FloatVec___bool__(self)

    def __len__(self):
        return _pyaqcv.FloatVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.FloatVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.FloatVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.FloatVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.FloatVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.FloatVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.FloatVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.FloatVec_pop(self)

    def append(self, x):
        return _pyaqcv.FloatVec_append(self, x)

    def empty(self):
        return _pyaqcv.FloatVec_empty(self)

    def size(self):
        return _pyaqcv.FloatVec_size(self)

    def swap(self, v):
        return _pyaqcv.FloatVec_swap(self, v)

    def begin(self):
        return _pyaqcv.FloatVec_begin(self)

    def end(self):
        return _pyaqcv.FloatVec_end(self)

    def rbegin(self):
        return _pyaqcv.FloatVec_rbegin(self)

    def rend(self):
        return _pyaqcv.FloatVec_rend(self)

    def clear(self):
        return _pyaqcv.FloatVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.FloatVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.FloatVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.FloatVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.FloatVec_swiginit(self, _pyaqcv.new_FloatVec(*args))

    def push_back(self, x):
        return _pyaqcv.FloatVec_push_back(self, x)

    def front(self):
        return _pyaqcv.FloatVec_front(self)

    def back(self):
        return _pyaqcv.FloatVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.FloatVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.FloatVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.FloatVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.FloatVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.FloatVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_FloatVec

# Register FloatVec in _pyaqcv:
_pyaqcv.FloatVec_swigregister(FloatVec)
class DoubleVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.DoubleVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.DoubleVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.DoubleVec___bool__(self)

    def __len__(self):
        return _pyaqcv.DoubleVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.DoubleVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.DoubleVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.DoubleVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.DoubleVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.DoubleVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.DoubleVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.DoubleVec_pop(self)

    def append(self, x):
        return _pyaqcv.DoubleVec_append(self, x)

    def empty(self):
        return _pyaqcv.DoubleVec_empty(self)

    def size(self):
        return _pyaqcv.DoubleVec_size(self)

    def swap(self, v):
        return _pyaqcv.DoubleVec_swap(self, v)

    def begin(self):
        return _pyaqcv.DoubleVec_begin(self)

    def end(self):
        return _pyaqcv.DoubleVec_end(self)

    def rbegin(self):
        return _pyaqcv.DoubleVec_rbegin(self)

    def rend(self):
        return _pyaqcv.DoubleVec_rend(self)

    def clear(self):
        return _pyaqcv.DoubleVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.DoubleVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.DoubleVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.DoubleVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.DoubleVec_swiginit(self, _pyaqcv.new_DoubleVec(*args))

    def push_back(self, x):
        return _pyaqcv.DoubleVec_push_back(self, x)

    def front(self):
        return _pyaqcv.DoubleVec_front(self)

    def back(self):
        return _pyaqcv.DoubleVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.DoubleVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.DoubleVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.DoubleVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.DoubleVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.DoubleVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_DoubleVec

# Register DoubleVec in _pyaqcv:
_pyaqcv.DoubleVec_swigregister(DoubleVec)
class StringStringMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.StringStringMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.StringStringMap___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.StringStringMap___bool__(self)

    def __len__(self):
        return _pyaqcv.StringStringMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _pyaqcv.StringStringMap___getitem__(self, key)

    def __delitem__(self, key):
        return _pyaqcv.StringStringMap___delitem__(self, key)

    def has_key(self, key):
        return _pyaqcv.StringStringMap_has_key(self, key)

    def keys(self):
        return _pyaqcv.StringStringMap_keys(self)

    def values(self):
        return _pyaqcv.StringStringMap_values(self)

    def items(self):
        return _pyaqcv.StringStringMap_items(self)

    def __contains__(self, key):
        return _pyaqcv.StringStringMap___contains__(self, key)

    def key_iterator(self):
        return _pyaqcv.StringStringMap_key_iterator(self)

    def value_iterator(self):
        return _pyaqcv.StringStringMap_value_iterator(self)

    def __setitem__(self, *args):
        return _pyaqcv.StringStringMap___setitem__(self, *args)

    def asdict(self):
        return _pyaqcv.StringStringMap_asdict(self)

    def __init__(self, *args):
        _pyaqcv.StringStringMap_swiginit(self, _pyaqcv.new_StringStringMap(*args))

    def empty(self):
        return _pyaqcv.StringStringMap_empty(self)

    def size(self):
        return _pyaqcv.StringStringMap_size(self)

    def swap(self, v):
        return _pyaqcv.StringStringMap_swap(self, v)

    def begin(self):
        return _pyaqcv.StringStringMap_begin(self)

    def end(self):
        return _pyaqcv.StringStringMap_end(self)

    def rbegin(self):
        return _pyaqcv.StringStringMap_rbegin(self)

    def rend(self):
        return _pyaqcv.StringStringMap_rend(self)

    def clear(self):
        return _pyaqcv.StringStringMap_clear(self)

    def get_allocator(self):
        return _pyaqcv.StringStringMap_get_allocator(self)

    def count(self, x):
        return _pyaqcv.StringStringMap_count(self, x)

    def erase(self, *args):
        return _pyaqcv.StringStringMap_erase(self, *args)

    def find(self, x):
        return _pyaqcv.StringStringMap_find(self, x)

    def lower_bound(self, x):
        return _pyaqcv.StringStringMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _pyaqcv.StringStringMap_upper_bound(self, x)
    __swig_destroy__ = _pyaqcv.delete_StringStringMap

# Register StringStringMap in _pyaqcv:
_pyaqcv.StringStringMap_swigregister(StringStringMap)
class BufferPoolController(object):
    r"""--addtogroup core"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_reserved_size(self):
        return _pyaqcv.BufferPoolController_get_reserved_size(self)

    def get_max_reserved_size(self):
        return _pyaqcv.BufferPoolController_get_max_reserved_size(self)

    def set_max_reserved_size(self, size):
        return _pyaqcv.BufferPoolController_set_max_reserved_size(self, size)

    def free_all_reserved_buffers(self):
        return _pyaqcv.BufferPoolController_free_all_reserved_buffers(self)

# Register BufferPoolController in _pyaqcv:
_pyaqcv.BufferPoolController_swigregister(BufferPoolController)
kUsageDefault = _pyaqcv.kUsageDefault
class MatSize(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.MatSize_swiginit(self, _pyaqcv.new_MatSize(*args))

    def dims(self):
        return _pyaqcv.MatSize_dims(self)

    def __call__(self):
        return _pyaqcv.MatSize___call__(self)

    def __eq__(self, sz):
        return _pyaqcv.MatSize___eq__(self, sz)

    def __ne__(self, sz):
        return _pyaqcv.MatSize___ne__(self, sz)
    __swig_destroy__ = _pyaqcv.delete_MatSize

# Register MatSize in _pyaqcv:
_pyaqcv.MatSize_swigregister(MatSize)
AQ_CN_MAX = _pyaqcv.AQ_CN_MAX
AQ_CN_SHIFT = _pyaqcv.AQ_CN_SHIFT
AQ_DEPTH_MAX = _pyaqcv.AQ_DEPTH_MAX
AQ_8U = _pyaqcv.AQ_8U
AQ_8S = _pyaqcv.AQ_8S
AQ_16U = _pyaqcv.AQ_16U
AQ_16S = _pyaqcv.AQ_16S
AQ_32S = _pyaqcv.AQ_32S
AQ_32F = _pyaqcv.AQ_32F
AQ_64F = _pyaqcv.AQ_64F
AQ_16F = _pyaqcv.AQ_16F
AQ_MAT_DEPTH_MASK = _pyaqcv.AQ_MAT_DEPTH_MASK
AQ_8UC1 = _pyaqcv.AQ_8UC1
AQ_8UC2 = _pyaqcv.AQ_8UC2
AQ_8UC3 = _pyaqcv.AQ_8UC3
AQ_8UC4 = _pyaqcv.AQ_8UC4
AQ_8SC1 = _pyaqcv.AQ_8SC1
AQ_8SC2 = _pyaqcv.AQ_8SC2
AQ_8SC3 = _pyaqcv.AQ_8SC3
AQ_8SC4 = _pyaqcv.AQ_8SC4
AQ_16UC1 = _pyaqcv.AQ_16UC1
AQ_16UC2 = _pyaqcv.AQ_16UC2
AQ_16UC3 = _pyaqcv.AQ_16UC3
AQ_16UC4 = _pyaqcv.AQ_16UC4
AQ_16SC1 = _pyaqcv.AQ_16SC1
AQ_16SC2 = _pyaqcv.AQ_16SC2
AQ_16SC3 = _pyaqcv.AQ_16SC3
AQ_16SC4 = _pyaqcv.AQ_16SC4
AQ_32SC1 = _pyaqcv.AQ_32SC1
AQ_32SC2 = _pyaqcv.AQ_32SC2
AQ_32SC3 = _pyaqcv.AQ_32SC3
AQ_32SC4 = _pyaqcv.AQ_32SC4
AQ_32FC1 = _pyaqcv.AQ_32FC1
AQ_32FC2 = _pyaqcv.AQ_32FC2
AQ_32FC3 = _pyaqcv.AQ_32FC3
AQ_32FC4 = _pyaqcv.AQ_32FC4
AQ_64FC1 = _pyaqcv.AQ_64FC1
AQ_64FC2 = _pyaqcv.AQ_64FC2
AQ_64FC3 = _pyaqcv.AQ_64FC3
AQ_64FC4 = _pyaqcv.AQ_64FC4
AQ_16FC1 = _pyaqcv.AQ_16FC1
AQ_16FC2 = _pyaqcv.AQ_16FC2
AQ_16FC3 = _pyaqcv.AQ_16FC3
AQ_16FC4 = _pyaqcv.AQ_16FC4
kDecompLU = _pyaqcv.kDecompLU
r"""Gaussian elimination with the optimal pivot element chosen."""
kDecompSVD = _pyaqcv.kDecompSVD
r"""
    singular value decomposition (SVD) method; the system can be over-defined and/or the matrix
       src1 can be singular
    """
kDecompEIG = _pyaqcv.kDecompEIG
r"""eigenvalue decomposition; the matrix src1 must be symmetrical"""
kDecompCholeshy = _pyaqcv.kDecompCholeshy
r"""
    Cholesky  :math:`LL^T`  factorization; the matrix src1 must be symmetrical and positively
       defined
    """
kDecompQR = _pyaqcv.kDecompQR
r"""QR factorization; the system can be over-defined and/or the matrix src1 can be singular"""
kDecompNormal = _pyaqcv.kDecompNormal
r"""
    while all the previous flags are mutually exclusive, this flag can be used together with
       any of the previous; it means that the normal equations
        :math:`\texttt{src1}^T\cdot\texttt{src1}\cdot\texttt{dst}=\texttt{src1}^T\texttt{src2}`  are
       solved instead of the original system
        :math:`\texttt{src1}\cdot\texttt{dst}=\texttt{src2}`
    """
kNormInf = _pyaqcv.kNormInf
r"""
    .. math::

        norm =
        \begin{cases}
        {\|\texttt{src1}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I)|}&{if \;  \texttt{norm_type} = \texttt{kNormInf} }\\
        {\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}} =  \max _I | \texttt{src1} (I) -  \texttt{src2} (I)|}&{if\;  \texttt{norm_type} = \texttt{kNormInf}}\\
        {\frac{\|\texttt{src1}-\texttt{src2}\|_{L_{\infty}} }{\|\texttt{src2}\|_{L_{\infty}} }}&{if \;  \texttt{norm_type} = \texttt{kNormRelative | kNormInf} }
          \end{cases}
    """
kNormL1 = _pyaqcv.kNormL1
r"""
    .. math::

        norm =
           \begin{cases}
           {\| \texttt{src1} \| _{L_1} =  \sum _I | \texttt{src1} (I)|}&{if  \;\texttt{norm_type} = \texttt{kNormL1}}\\
           { \| \texttt{src1} - \texttt{src2} \| _{L_1} =  \sum _I | \texttt{src1} (I) -  \texttt{src2} (I)|}&{if\;\texttt{norm_type} = \texttt{kNormL1} }\\
           { \frac{\|\texttt{src1}-\texttt{src2}\|_{L_1} }{\|\texttt{src2}\|_{L_1}} }&{if  \;\texttt{norm_type} = \texttt{kNormRelative | kNormL1} }
           \end{cases}
    """
kNormL2 = _pyaqcv.kNormL2
r"""
    .. math::

        norm =
        \begin{cases}
        { \| \texttt{src1} \| _{L_2} =  \sqrt{\sum_I \texttt{src1}(I)^2} }&{if  \;\texttt{norm_type} = \texttt{kNormL2} }\\
        { \| \texttt{src1} - \texttt{src2} \| _{L_2} =  \sqrt{\sum_I (\texttt{src1}(I) - \texttt{src2}(I))^2} }&{if\;\texttt{norm_type} = \texttt{kNormL2} }\\
        { \frac{\|\texttt{src1}-\texttt{src2}\|_{L_2} }{\|\texttt{src2}\|_{L_2}} }&{if  \;\texttt{norm_type} = \texttt{kNormRelative | kNormL2} }
        \end{cases}
    """
kNormL2Sqr = _pyaqcv.kNormL2Sqr
r"""
    .. math::

        norm = \begin{cases}
        { \| \texttt{src1} \| _{L_2} ^{2} = \sum_I \texttt{src1}(I)^2} &{if\;\texttt{norm_type} = \texttt{kNormL2Sqr}}\\
         { \| \texttt{src1} - \texttt{src2} \| _{L_2} ^{2} =  \sum_I (\texttt{src1}(I) - \texttt{src2}(I))^2 }&{if\; \texttt{norm_type} = \texttt{kNormL2Sqr}}\\
        { \left(\frac{\|\texttt{src1}-\texttt{src2}\|_{L_2} } {\|\texttt{src2}\|_{L_2}}\right)^2 }&{if\;\texttt{norm_type} = \texttt{kNormRelative | kNormL2Sqr} }
        \end{cases}
    """
kNormHamming = _pyaqcv.kNormHamming
r"""
    In the case of one input array, calculates the Hamming distance of the array from zero,
    In the case of two input arrays, calculates the Hamming distance between the arrays.
    """
kNormHamming2 = _pyaqcv.kNormHamming2
r"""
    Similar to kNormHamming, but in the calculation, each two bits of the input sequence will
    be added and treated as a single bit to be used in the same calculation as kNormHamming.
    """
kNormTypeMask = _pyaqcv.kNormTypeMask
r"""bit-mask which can be used to separate norm type from norm flags"""
kNormRelative = _pyaqcv.kNormRelative
r"""flag"""
kNormMinMax = _pyaqcv.kNormMinMax
r"""flag"""

def norm_l2_sqr(a, b, n):
    return _pyaqcv.norm_l2_sqr(a, b, n)

def norm_l1(*args):
    return _pyaqcv.norm_l1(*args)

def cube_root(*args):
    r"""
     Computes the cube root of an argument.

    The function cube_root computes  :math:`\sqrt[3]{\texttt{val}}` . Negative arguments are handled correctly.
    NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for
    single-precision data.
    :type val: float
    :param val: A function argument.
    """
    return _pyaqcv.cube_root(*args)

def fast_atan2(y, x):
    r"""
     Calculates the angle of a 2D vector in degrees.

    The function fast_atan2 calculates the full-range angle of an input 2D vector. The angle is measured
    in degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees.
    :type x: float
    :param x: x-coordinate of the vector.
    :type y: float
    :param y: y-coordinate of the vector.
    """
    return _pyaqcv.fast_atan2(y, x)

def LU(*args):
    r"""
    *Overload 1:*
    proxy for hal::LU

    |

    *Overload 2:*
    proxy for hal::LU
    """
    return _pyaqcv.LU(*args)

def Cholesky(*args):
    r"""
    *Overload 1:*
    proxy for hal::Cholesky

    |

    *Overload 2:*
    proxy for hal::Cholesky
    """
    return _pyaqcv.Cholesky(*args)

def fast_malloc(bufSize):
    r"""
     --addtogroup core_utils Allocates an aligned memory buffer.

    The function allocates the buffer of the specified size and returns it. When the buffer size is 16
    bytes or more, the returned buffer is aligned to 16 bytes.
    :type bufSize: int
    :param bufSize: Allocated buffer size.
    """
    return _pyaqcv.fast_malloc(bufSize)

def fast_free(ptr):
    r"""
     Deallocates a memory buffer.

    The function deallocates the buffer allocated with fast_malloc . If NULL pointer is passed, the
    function does nothing.
    :type ptr: void
    :param ptr: Pointer to the allocated buffer.
    """
    return _pyaqcv.fast_free(ptr)

def char_tolower(ch):
    r"""Conditional comment: IGNORED"""
    return _pyaqcv.char_tolower(ch)

def char_toupper(ch):
    return _pyaqcv.char_toupper(ch)
class RotatedRect(object):
    r"""
     The class represents rotated (i.e. not up-right) rectangles on a plane.

    Each rectangle is specified by the center point (mass center), length of each side (represented by
    #Size2f structure) and the rotation angle in degrees.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        full constructor
           :type center: :py:class:`Point2f`
           :param center: The rectangle mass center.
           :type size: :py:class:`Size2f`
           :param size: Width and height of the rectangle.
           :type angle: float
           :param angle: The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc.,
               the rectangle becomes an up-right rectangle.

        |

        *Overload 3:*

           Any 3 end points of the RotatedRect. They must be given in order (either clockwise or
           anticlockwise).
        """
        _pyaqcv.RotatedRect_swiginit(self, _pyaqcv.new_RotatedRect(*args))
    __swig_destroy__ = _pyaqcv.delete_RotatedRect

    def points(self, pts):
        r"""
        returns 4 vertices of the rectangle
           :type pts: :py:class:`Point2f`
           :param pts: The points array for storing rectangle vertices. The order is bottomLeft, topLeft, topRight, bottomRight.
        """
        return _pyaqcv.RotatedRect_points(self, pts)

    def bounding_rect(self):
        r"""returns the minimal up-right integer rectangle containing the rotated rectangle"""
        return _pyaqcv.RotatedRect_bounding_rect(self)
    center = property(_pyaqcv.RotatedRect_center_get, _pyaqcv.RotatedRect_center_set, doc=r"""returns the rectangle mass center""")
    size = property(_pyaqcv.RotatedRect_size_get, _pyaqcv.RotatedRect_size_set, doc=r"""returns width and height of the rectangle""")
    angle = property(_pyaqcv.RotatedRect_angle_get, _pyaqcv.RotatedRect_angle_set, doc=r"""returns the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.""")

# Register RotatedRect in _pyaqcv:
_pyaqcv.RotatedRect_swigregister(RotatedRect)
class Range(object):
    r"""
     Template class specifying a continuous subsequence (slice) of a sequence.

    The class is used to specify a row or a column span in a matrix ( Mat ) and for many other purposes.
    Range(a,b) is basically the same as a:b in Matlab or a..b in Python. As in Python, start is an
    inclusive left boundary of the range and end is an exclusive right boundary of the range. Such a
    half-opened interval is usually denoted as  :math:`[start,end)`  .

    The static method Range::all() returns a special variable that means "the whole sequence" or "the
    whole range", just like " : " in Matlab or " ... " in Python. All the methods and functions in
    aqcv that take Range support this special Range::all() value. But, of course, in case of your own
    custom processing, you will probably have to check and handle it explicitly:

    .. code-block:: c++

            void my_function(..., const Range& r, ....)
            {
                if(r == Range::all()) {
        process all the data
                }
                else {
        process [r.start, r.end)
                }
            }
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Range_swiginit(self, _pyaqcv.new_Range(*args))

    def size(self):
        return _pyaqcv.Range_size(self)

    def empty(self):
        return _pyaqcv.Range_empty(self)

    @staticmethod
    def all():
        return _pyaqcv.Range_all()
    __swig_destroy__ = _pyaqcv.delete_Range
    start = property(_pyaqcv.Range_start_get, _pyaqcv.Range_start_set)
    end = property(_pyaqcv.Range_end_get, _pyaqcv.Range_end_set)

# Register Range in _pyaqcv:
_pyaqcv.Range_swigregister(Range)
class TermCriteria(object):
    r"""
     The class defining termination criteria for iterative algorithms.

    You can initialize it by default constructor and then override any parameters, or the structure may
    be fully initialized using the advanced variant of the constructor.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kCount = _pyaqcv.TermCriteria_kCount
    r"""the maximum number of iterations or elements to compute"""
    kMaxIter = _pyaqcv.TermCriteria_kMaxIter
    r"""ditto"""
    kEps = _pyaqcv.TermCriteria_kEps
    r"""the desired accuracy or change in parameters at which the iterative algorithm stops"""

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*

           :type type: int
           :param type: The type of termination criteria, one of TermCriteria::Type
           :type max_count: int
           :param max_count: The maximum number of iterations or elements to compute.
           :type epsilon: float
           :param epsilon: The desired accuracy or change in parameters at which the iterative algorithm stops.
        """
        _pyaqcv.TermCriteria_swiginit(self, _pyaqcv.new_TermCriteria(*args))
    __swig_destroy__ = _pyaqcv.delete_TermCriteria

    def is_valid(self):
        return _pyaqcv.TermCriteria_is_valid(self)
    type = property(_pyaqcv.TermCriteria_type_get, _pyaqcv.TermCriteria_type_set, doc=r"""the type of termination criteria: kCount, kEps or kCount + kEps""")
    max_count = property(_pyaqcv.TermCriteria_max_count_get, _pyaqcv.TermCriteria_max_count_set, doc=r"""the maximum number of iterations/elements""")
    epsilon = property(_pyaqcv.TermCriteria_epsilon_get, _pyaqcv.TermCriteria_epsilon_set, doc=r"""the desired accuracy""")

# Register TermCriteria in _pyaqcv:
_pyaqcv.TermCriteria_swigregister(TermCriteria)
class Moments(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        the default constructor

        |

        *Overload 2:*
        the full constructor
        """
        _pyaqcv.Moments_swiginit(self, _pyaqcv.new_Moments(*args))
    __swig_destroy__ = _pyaqcv.delete_Moments
    m00 = property(_pyaqcv.Moments_m00_get, _pyaqcv.Moments_m00_set)
    m10 = property(_pyaqcv.Moments_m10_get, _pyaqcv.Moments_m10_set)
    m01 = property(_pyaqcv.Moments_m01_get, _pyaqcv.Moments_m01_set)
    m20 = property(_pyaqcv.Moments_m20_get, _pyaqcv.Moments_m20_set)
    m11 = property(_pyaqcv.Moments_m11_get, _pyaqcv.Moments_m11_set)
    m02 = property(_pyaqcv.Moments_m02_get, _pyaqcv.Moments_m02_set)
    m30 = property(_pyaqcv.Moments_m30_get, _pyaqcv.Moments_m30_set)
    m21 = property(_pyaqcv.Moments_m21_get, _pyaqcv.Moments_m21_set)
    m12 = property(_pyaqcv.Moments_m12_get, _pyaqcv.Moments_m12_set)
    m03 = property(_pyaqcv.Moments_m03_get, _pyaqcv.Moments_m03_set)
    mu20 = property(_pyaqcv.Moments_mu20_get, _pyaqcv.Moments_mu20_set)
    mu11 = property(_pyaqcv.Moments_mu11_get, _pyaqcv.Moments_mu11_set)
    mu02 = property(_pyaqcv.Moments_mu02_get, _pyaqcv.Moments_mu02_set)
    mu30 = property(_pyaqcv.Moments_mu30_get, _pyaqcv.Moments_mu30_set)
    mu21 = property(_pyaqcv.Moments_mu21_get, _pyaqcv.Moments_mu21_set)
    mu12 = property(_pyaqcv.Moments_mu12_get, _pyaqcv.Moments_mu12_set)
    mu03 = property(_pyaqcv.Moments_mu03_get, _pyaqcv.Moments_mu03_set)
    nu20 = property(_pyaqcv.Moments_nu20_get, _pyaqcv.Moments_nu20_set)
    nu11 = property(_pyaqcv.Moments_nu11_get, _pyaqcv.Moments_nu11_set)
    nu02 = property(_pyaqcv.Moments_nu02_get, _pyaqcv.Moments_nu02_set)
    nu30 = property(_pyaqcv.Moments_nu30_get, _pyaqcv.Moments_nu30_set)
    nu21 = property(_pyaqcv.Moments_nu21_get, _pyaqcv.Moments_nu21_set)
    nu12 = property(_pyaqcv.Moments_nu12_get, _pyaqcv.Moments_nu12_set)
    nu03 = property(_pyaqcv.Moments_nu03_get, _pyaqcv.Moments_nu03_set)

# Register Moments in _pyaqcv:
_pyaqcv.Moments_swigregister(Moments)
AQCV_PI = _pyaqcv.AQCV_PI
AQCV_2PI = _pyaqcv.AQCV_2PI
AQCV_LOG2 = _pyaqcv.AQCV_LOG2
AQCV_PI_2 = _pyaqcv.AQCV_PI_2
AQCV_PI_4 = _pyaqcv.AQCV_PI_4
class aq16suf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    i = property(_pyaqcv.aq16suf_i_get, _pyaqcv.aq16suf_i_set)
    u = property(_pyaqcv.aq16suf_u_get, _pyaqcv.aq16suf_u_set)

    def __init__(self):
        _pyaqcv.aq16suf_swiginit(self, _pyaqcv.new_aq16suf())
    __swig_destroy__ = _pyaqcv.delete_aq16suf

# Register aq16suf in _pyaqcv:
_pyaqcv.aq16suf_swigregister(aq16suf)
class aq32suf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    i = property(_pyaqcv.aq32suf_i_get, _pyaqcv.aq32suf_i_set)
    u = property(_pyaqcv.aq32suf_u_get, _pyaqcv.aq32suf_u_set)
    f = property(_pyaqcv.aq32suf_f_get, _pyaqcv.aq32suf_f_set)

    def __init__(self):
        _pyaqcv.aq32suf_swiginit(self, _pyaqcv.new_aq32suf())
    __swig_destroy__ = _pyaqcv.delete_aq32suf

# Register aq32suf in _pyaqcv:
_pyaqcv.aq32suf_swigregister(aq32suf)
class aq64suf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    i = property(_pyaqcv.aq64suf_i_get, _pyaqcv.aq64suf_i_set)
    u = property(_pyaqcv.aq64suf_u_get, _pyaqcv.aq64suf_u_set)
    f = property(_pyaqcv.aq64suf_f_get, _pyaqcv.aq64suf_f_set)

    def __init__(self):
        _pyaqcv.aq64suf_swiginit(self, _pyaqcv.new_aq64suf())
    __swig_destroy__ = _pyaqcv.delete_aq64suf

# Register aq64suf in _pyaqcv:
_pyaqcv.aq64suf_swigregister(aq64suf)

def is_nan(value):
    r"""
    Determines if the argument is Not A Number.

    :type value: float
    :param value: The input floating-point value

    The function returns 1 if the argument is Not A Number (as defined by IEEE754 standard), 0
    otherwise.
    """
    return _pyaqcv.is_nan(value)

def is_inf(value):
    r"""
    Determines if the argument is Infinity.

    :type value: float
    :param value: The input floating-point value

    The function returns 1 if the argument is a plus or minus infinity (as defined by IEEE754 standard)
    and 0 otherwise.
    """
    return _pyaqcv.is_inf(value)
AQ_ENABLE_UNROLLED = _pyaqcv.AQ_ENABLE_UNROLLED
AQ_CPU_NONE = _pyaqcv.AQ_CPU_NONE
AQ_CPU_MMX = _pyaqcv.AQ_CPU_MMX
AQ_CPU_SSE = _pyaqcv.AQ_CPU_SSE
AQ_CPU_SSE2 = _pyaqcv.AQ_CPU_SSE2
AQ_CPU_SSE3 = _pyaqcv.AQ_CPU_SSE3
AQ_CPU_SSSE3 = _pyaqcv.AQ_CPU_SSSE3
AQ_CPU_SSE4_1 = _pyaqcv.AQ_CPU_SSE4_1
AQ_CPU_SSE4_2 = _pyaqcv.AQ_CPU_SSE4_2
AQ_CPU_POPCNT = _pyaqcv.AQ_CPU_POPCNT
AQ_CPU_FP16 = _pyaqcv.AQ_CPU_FP16
AQ_CPU_AVX = _pyaqcv.AQ_CPU_AVX
AQ_CPU_AVX2 = _pyaqcv.AQ_CPU_AVX2
AQ_CPU_FMA3 = _pyaqcv.AQ_CPU_FMA3
AQ_CPU_AVX_512F = _pyaqcv.AQ_CPU_AVX_512F
AQ_CPU_AVX_512BW = _pyaqcv.AQ_CPU_AVX_512BW
AQ_CPU_AVX_512CD = _pyaqcv.AQ_CPU_AVX_512CD
AQ_CPU_AVX_512DQ = _pyaqcv.AQ_CPU_AVX_512DQ
AQ_CPU_AVX_512ER = _pyaqcv.AQ_CPU_AVX_512ER
AQ_CPU_AVX_512IFMA512 = _pyaqcv.AQ_CPU_AVX_512IFMA512
AQ_CPU_AVX_512IFMA = _pyaqcv.AQ_CPU_AVX_512IFMA
AQ_CPU_AVX_512PF = _pyaqcv.AQ_CPU_AVX_512PF
AQ_CPU_AVX_512VBMI = _pyaqcv.AQ_CPU_AVX_512VBMI
AQ_CPU_AVX_512VL = _pyaqcv.AQ_CPU_AVX_512VL
AQ_CPU_AVX_512VBMI2 = _pyaqcv.AQ_CPU_AVX_512VBMI2
AQ_CPU_AVX_512VNNI = _pyaqcv.AQ_CPU_AVX_512VNNI
AQ_CPU_AVX_512BITALG = _pyaqcv.AQ_CPU_AVX_512BITALG
AQ_CPU_AVX_512VPOPCNTDQ = _pyaqcv.AQ_CPU_AVX_512VPOPCNTDQ
AQ_CPU_AVX_5124VNNIW = _pyaqcv.AQ_CPU_AVX_5124VNNIW
AQ_CPU_AVX_5124FMAPS = _pyaqcv.AQ_CPU_AVX_5124FMAPS
AQ_CPU_NEON = _pyaqcv.AQ_CPU_NEON
AQ_CPU_MSA = _pyaqcv.AQ_CPU_MSA
AQ_CPU_VSX = _pyaqcv.AQ_CPU_VSX
AQ_CPU_VSX3 = _pyaqcv.AQ_CPU_VSX3
AQ_CPU_RVV = _pyaqcv.AQ_CPU_RVV
AQ_HAL_ERROR_OK = _pyaqcv.AQ_HAL_ERROR_OK
AQ_HAL_ERROR_NOT_IMPLEMENTED = _pyaqcv.AQ_HAL_ERROR_NOT_IMPLEMENTED
AQ_HAL_ERROR_UNKNOWN = _pyaqcv.AQ_HAL_ERROR_UNKNOWN
AQ_HARDWARE_MAX_FEATURE = _pyaqcv.AQ_HARDWARE_MAX_FEATURE
AQ_STRONG_ALIGNMENT = _pyaqcv.AQ_STRONG_ALIGNMENT
AQ_FP16_TYPE = _pyaqcv.AQ_FP16_TYPE
AQ_MAX_DIM = _pyaqcv.AQ_MAX_DIM
AQ_AUTOSTEP = _pyaqcv.AQ_AUTOSTEP
AQ_MALLOC_ALIGN = _pyaqcv.AQ_MALLOC_ALIGN
AQ_MAT_CN_MASK = _pyaqcv.AQ_MAT_CN_MASK
AQ_MAT_CONT_FLAG_SHIFT = _pyaqcv.AQ_MAT_CONT_FLAG_SHIFT
AQ_MAT_CONT_FLAG = _pyaqcv.AQ_MAT_CONT_FLAG
AQ_SUBMAT_FLAG_SHIFT = _pyaqcv.AQ_SUBMAT_FLAG_SHIFT
AQ_SUBMAT_FLAG = _pyaqcv.AQ_SUBMAT_FLAG
AQ_CXX11 = _pyaqcv.AQ_CXX11
r"""
    Size of each channel item,
      0x28442211 = 0010 1000 0100 0100 0010 0010 0001 0001 ~ array of sizeof(arr_type_elem)
    """
AQ_CXX_MOVE_SEMANTICS = _pyaqcv.AQ_CXX_MOVE_SEMANTICS
AQ_CXX_STD_ARRAY = _pyaqcv.AQ_CXX_STD_ARRAY
class float16_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.float16_t_swiginit(self, _pyaqcv.new_float16_t(*args))

    @staticmethod
    def fromBits(b):
        return _pyaqcv.float16_t_fromBits(b)

    @staticmethod
    def zero():
        return _pyaqcv.float16_t_zero()

    def bits(self):
        return _pyaqcv.float16_t_bits(self)
    __swig_destroy__ = _pyaqcv.delete_float16_t

# Register float16_t in _pyaqcv:
_pyaqcv.float16_t_swigregister(float16_t)
kAccessRead = _pyaqcv.kAccessRead
kAccessWrite = _pyaqcv.kAccessWrite
kAccessRW = _pyaqcv.kAccessRW
kAccessMask = _pyaqcv.kAccessMask
kAccessFast = _pyaqcv.kAccessFast
class _InputArray(object):
    r"""
     This is the proxy class for passing read-only input arrays into aqcv functions.

    It is defined as:

    .. code-block:: c++

            typedef const _InputArray& InputArray;
    where _InputArray is a class that can be constructed from `Mat`, `Mat_<T>`, `Matx<T, m, n>`,
    `std::vector<T>`, `std::vector<std::vector<T> >`, `std::vector<Mat>`, `std::vector<Mat_<T> >`
    or `double`. It can also be constructed from a matrix expression.

    Since this is mostly implementation-level class, and its interface may change in future versions, we
    do not describe it in details. There are a few key things, though, that should be kept in mind:

    -   When you see in the reference manual or in aqcv source code a function that takes
        InputArray, it means that you can actually pass `Mat`, `Matx`, `vector<T>` etc. (see above the
        complete list).
    -   Optional input arguments: If some of the input arrays may be empty, pass aqcv::no_array() (or
        simply aqcv::Mat() as you probably did before).
    -   The class is designed solely for passing parameters. That is, normally you *should not*
        declare class members, local and global variables of this type.
    -   If you want to design your own function or a class method that can operate of arrays of
        multiple types, you can use InputArray (or OutputArray) for the respective parameters. Inside
        a function you should use _InputArray::get_mat() method to construct a matrix header for the
        array (without copying data). _InputArray::kind() can be used to distinguish Mat from
        `vector<>` etc., but normally it is not needed.

    There is another related type, InputArrayOfArrays, which is currently defined as a synonym for
    InputArray:

    .. code-block:: c++

            typedef InputArray InputArrayOfArrays;
    It denotes function arguments that are either vectors of vectors or vectors of matrices. A separate
    synonym is needed to generate Python/Java etc. wrappers properly. At the function implementation
    level their use is similar, but _InputArray::get_mat(idx) should be used to get header for the
    idx-th component of the outer vector and _InputArray::size().area() should be used to find the
    number of components (vectors/matrices) of the outer vector.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kKindShift = _pyaqcv._InputArray_kKindShift
    kFixedType = _pyaqcv._InputArray_kFixedType
    kFixedSize = _pyaqcv._InputArray_kFixedSize
    kKindMask = _pyaqcv._InputArray_kKindMask
    kNone = _pyaqcv._InputArray_kNone
    kMat = _pyaqcv._InputArray_kMat
    kMatx = _pyaqcv._InputArray_kMatx
    kStdVector = _pyaqcv._InputArray_kStdVector
    kStdVectorVector = _pyaqcv._InputArray_kStdVectorVector
    kStdVectorMat = _pyaqcv._InputArray_kStdVectorMat
    kExpr = _pyaqcv._InputArray_kExpr
    kStdBoolVector = _pyaqcv._InputArray_kStdBoolVector
    kStdArray = _pyaqcv._InputArray_kStdArray
    kStdArrayMat = _pyaqcv._InputArray_kStdArrayMat

    def __init__(self, *args):
        _pyaqcv._InputArray_swiginit(self, _pyaqcv.new__InputArray(*args))

    def get_mat(self, idx=-1):
        return _pyaqcv._InputArray_get_mat(self, idx)

    def get_mat_(self, idx=-1):
        return _pyaqcv._InputArray_get_mat_(self, idx)

    def get_mat_vector(self, mv):
        return _pyaqcv._InputArray_get_mat_vector(self, mv)

    def get_flags(self):
        return _pyaqcv._InputArray_get_flags(self)

    def get_obj(self):
        return _pyaqcv._InputArray_get_obj(self)

    def get_size(self):
        return _pyaqcv._InputArray_get_size(self)

    def kind(self):
        return _pyaqcv._InputArray_kind(self)

    def dims(self, i=-1):
        return _pyaqcv._InputArray_dims(self, i)

    def cols(self, i=-1):
        return _pyaqcv._InputArray_cols(self, i)

    def rows(self, i=-1):
        return _pyaqcv._InputArray_rows(self, i)

    def size(self, i=-1):
        return _pyaqcv._InputArray_size(self, i)

    def sizend(self, sz, i=-1):
        return _pyaqcv._InputArray_sizend(self, sz, i)

    def same_size(self, arr):
        return _pyaqcv._InputArray_same_size(self, arr)

    def total(self, i=-1):
        return _pyaqcv._InputArray_total(self, i)

    def type(self, i=-1):
        return _pyaqcv._InputArray_type(self, i)

    def depth(self, i=-1):
        return _pyaqcv._InputArray_depth(self, i)

    def channels(self, i=-1):
        return _pyaqcv._InputArray_channels(self, i)

    def is_continuous(self, i=-1):
        return _pyaqcv._InputArray_is_continuous(self, i)

    def is_submatrix(self, i=-1):
        return _pyaqcv._InputArray_is_submatrix(self, i)

    def empty(self):
        return _pyaqcv._InputArray_empty(self)

    def copy_to(self, *args):
        return _pyaqcv._InputArray_copy_to(self, *args)

    def offset(self, i=-1):
        return _pyaqcv._InputArray_offset(self, i)

    def step(self, i=-1):
        return _pyaqcv._InputArray_step(self, i)

    def is_mat(self):
        return _pyaqcv._InputArray_is_mat(self)

    def is_mat_vector(self):
        return _pyaqcv._InputArray_is_mat_vector(self)

    def is_matx(self):
        return _pyaqcv._InputArray_is_matx(self)

    def is_vector(self):
        return _pyaqcv._InputArray_is_vector(self)
    __swig_destroy__ = _pyaqcv.delete__InputArray

# Register _InputArray in _pyaqcv:
_pyaqcv._InputArray_swigregister(_InputArray)
class _OutputArray(_InputArray):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kDepthMask8U = _pyaqcv._OutputArray_kDepthMask8U
    kDepthMask8S = _pyaqcv._OutputArray_kDepthMask8S
    kDepthMask16U = _pyaqcv._OutputArray_kDepthMask16U
    kDepthMask16S = _pyaqcv._OutputArray_kDepthMask16S
    kDepthMask32S = _pyaqcv._OutputArray_kDepthMask32S
    kDepthMask32F = _pyaqcv._OutputArray_kDepthMask32F
    kDepthMask64F = _pyaqcv._OutputArray_kDepthMask64F
    kDepthMask16F = _pyaqcv._OutputArray_kDepthMask16F
    kDepthMaskAll = _pyaqcv._OutputArray_kDepthMaskAll
    kDepthMaskAllBut8S = _pyaqcv._OutputArray_kDepthMaskAllBut8S
    kDepthMaskAll16F = _pyaqcv._OutputArray_kDepthMaskAll16F
    kDepthMaskFlt = _pyaqcv._OutputArray_kDepthMaskFlt

    def __init__(self, *args):
        _pyaqcv._OutputArray_swiginit(self, _pyaqcv.new__OutputArray(*args))

    def fixed_size(self):
        return _pyaqcv._OutputArray_fixed_size(self)

    def fixed_type(self):
        return _pyaqcv._OutputArray_fixed_type(self)

    def needed(self):
        return _pyaqcv._OutputArray_needed(self)

    def get_mat_ref(self, i=-1):
        return _pyaqcv._OutputArray_get_mat_ref(self, i)

    def create(self, *args):
        return _pyaqcv._OutputArray_create(self, *args)

    def create_same_size(self, arr, mtype):
        return _pyaqcv._OutputArray_create_same_size(self, arr, mtype)

    def release(self):
        return _pyaqcv._OutputArray_release(self)

    def clear(self):
        return _pyaqcv._OutputArray_clear(self)

    def set_to(self, *args):
        return _pyaqcv._OutputArray_set_to(self, *args)

    def assign(self, *args):
        return _pyaqcv._OutputArray_assign(self, *args)

    def move(self, m):
        return _pyaqcv._OutputArray_move(self, m)
    __swig_destroy__ = _pyaqcv.delete__OutputArray

# Register _OutputArray in _pyaqcv:
_pyaqcv._OutputArray_swigregister(_OutputArray)
class _InputOutputArray(_OutputArray):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv._InputOutputArray_swiginit(self, _pyaqcv.new__InputOutputArray(*args))
    __swig_destroy__ = _pyaqcv.delete__InputOutputArray

# Register _InputOutputArray in _pyaqcv:
_pyaqcv._InputOutputArray_swigregister(_InputOutputArray)

def no_array():
    return _pyaqcv.no_array()
class MatOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_MatOp

    def element_wise(self, expr):
        return _pyaqcv.MatOp_element_wise(self, expr)

    def assign(self, expr, m, type=-1):
        return _pyaqcv.MatOp_assign(self, expr, m, type)

    def roi(self, expr, row_range, col_range, res):
        return _pyaqcv.MatOp_roi(self, expr, row_range, col_range, res)

    def diag(self, expr, d, res):
        return _pyaqcv.MatOp_diag(self, expr, d, res)

    def aug_assign_add(self, expr, m):
        return _pyaqcv.MatOp_aug_assign_add(self, expr, m)

    def aug_assign_subtract(self, expr, m):
        return _pyaqcv.MatOp_aug_assign_subtract(self, expr, m)

    def aug_assign_multiply(self, expr, m):
        return _pyaqcv.MatOp_aug_assign_multiply(self, expr, m)

    def aug_assign_divide(self, expr, m):
        return _pyaqcv.MatOp_aug_assign_divide(self, expr, m)

    def aug_assign_and(self, expr, m):
        return _pyaqcv.MatOp_aug_assign_and(self, expr, m)

    def aug_assign_or(self, expr, m):
        return _pyaqcv.MatOp_aug_assign_or(self, expr, m)

    def aug_assign_xor(self, expr, m):
        return _pyaqcv.MatOp_aug_assign_xor(self, expr, m)

    def add(self, *args):
        return _pyaqcv.MatOp_add(self, *args)

    def subtract(self, *args):
        return _pyaqcv.MatOp_subtract(self, *args)

    def multiply(self, *args):
        return _pyaqcv.MatOp_multiply(self, *args)

    def divide(self, *args):
        return _pyaqcv.MatOp_divide(self, *args)

    def abs(self, expr, res):
        return _pyaqcv.MatOp_abs(self, expr, res)

    def transpose(self, expr, res):
        return _pyaqcv.MatOp_transpose(self, expr, res)

    def matmul(self, expr1, expr2, res):
        return _pyaqcv.MatOp_matmul(self, expr1, expr2, res)

    def invert(self, expr, method, res):
        return _pyaqcv.MatOp_invert(self, expr, method, res)

    def size(self, expr):
        return _pyaqcv.MatOp_size(self, expr)

    def type(self, expr):
        return _pyaqcv.MatOp_type(self, expr)

# Register MatOp in _pyaqcv:
_pyaqcv.MatOp_swigregister(MatOp)
class MatExpr(object):
    r"""
     Matrix expression representation

    This is a list of implemented matrix operations that can be combined in arbitrary complex
    expressions (here A, B stand for matrices ( Mat ), s for a scalar ( Scalar ), alpha for a
    real-valued scalar ( double )):
    -   Addition, subtraction, negation: `A+B`, `A-B`, `A+s`, `A-s`, `s+A`, `s-A`, `-A`
    -   Scaling: `A*alpha`
    -   Per-element multiplication and division: `A.mul(B)`, `A/B`, `alpha/A`
    -   Matrix multiplication: `A*B`
    -   Transposition: `A.t()` (means A T)
    -   Matrix inversion and pseudo-inversion, solving linear systems and least-squares problems:
        `A.inv([method]) (~ A -1)`,   `A.inv([method])*B (~ X: AX=B)`
    -   Comparison: `A cmpop B`, `A cmpop alpha`, `alpha cmpop A`, where *cmpop* is one of
      `>`, `>=`, `==`, `!=`, `<=`, `<`. The result of comparison is an 8-bit single channel mask whose
        elements are set to 255 (if the particular element or pair of elements satisfy the condition) or
        0.
    -   Bitwise logical operations: `A logicop B`, `A logicop s`, `s logicop A`, `~A`, where *logicop* is one of
      `&`, `|`, `^`.
    -   Element-wise minimum and maximum: `min(A, B)`, `min(A, alpha)`, `max(A, B)`, `max(A, alpha)`
    -   Element-wise absolute value: `abs(A)`
    -   Cross-product, dot-product: `A.cross(B)`, `A.dot(B)`
    -   Any function of matrix or matrices and scalars that returns a matrix or a scalar, such as norm,
        mean, sum, count_non_zero, trace, determinant, repeat, and others.
    -   Matrix initializers ( Mat::eye(), Mat::zeros(), Mat::ones() ), matrix comma-separated
        initializers, matrix constructors and operators that extract sub-matrices (see Mat description).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.MatExpr_swiginit(self, _pyaqcv.new_MatExpr(*args))
    __swig_destroy__ = _pyaqcv.delete_MatExpr

    def size(self):
        return _pyaqcv.MatExpr_size(self)

    def type(self):
        return _pyaqcv.MatExpr_type(self)

    def row(self, y):
        return _pyaqcv.MatExpr_row(self, y)

    def col(self, x):
        return _pyaqcv.MatExpr_col(self, x)

    def diag(self, d=0):
        return _pyaqcv.MatExpr_diag(self, d)

    def __call__(self, *args):
        return _pyaqcv.MatExpr___call__(self, *args)

    def t(self):
        return _pyaqcv.MatExpr_t(self)

    def inv(self, method=0):
        return _pyaqcv.MatExpr_inv(self, method)

    def mul(self, *args):
        return _pyaqcv.MatExpr_mul(self, *args)

    def cross(self, m):
        return _pyaqcv.MatExpr_cross(self, m)

    def dot(self, m):
        return _pyaqcv.MatExpr_dot(self, m)

    def swap(self, b):
        return _pyaqcv.MatExpr_swap(self, b)
    op = property(_pyaqcv.MatExpr_op_get, _pyaqcv.MatExpr_op_set)
    flags = property(_pyaqcv.MatExpr_flags_get, _pyaqcv.MatExpr_flags_set)
    a = property(_pyaqcv.MatExpr_a_get, _pyaqcv.MatExpr_a_set)
    b = property(_pyaqcv.MatExpr_b_get, _pyaqcv.MatExpr_b_set)
    c = property(_pyaqcv.MatExpr_c_get, _pyaqcv.MatExpr_c_set)
    alpha = property(_pyaqcv.MatExpr_alpha_get, _pyaqcv.MatExpr_alpha_set)
    beta = property(_pyaqcv.MatExpr_beta_get, _pyaqcv.MatExpr_beta_set)
    s = property(_pyaqcv.MatExpr_s_get, _pyaqcv.MatExpr_s_set)

# Register MatExpr in _pyaqcv:
_pyaqcv.MatExpr_swigregister(MatExpr)

def __mul__(*args):
    return _pyaqcv.__mul__(*args)

def __truediv__(*args):
    return _pyaqcv.__truediv__(*args)

def __and__(*args):
    return _pyaqcv.__and__(*args)

def __or__(*args):
    return _pyaqcv.__or__(*args)

def __xor__(*args):
    return _pyaqcv.__xor__(*args)

def __invert__(*args):
    return _pyaqcv.__invert__(*args)

def abs(*args):
    r"""
     Calculates an absolute value of each matrix element.

    abs is a meta-function that is expanded to one of absdiff or convert_scale_abs forms:
    - C = abs(A-B) is equivalent to `absdiff(A, B, C)`
    - C = abs(A) is equivalent to `absdiff(A, Scalar::all(0), C)`

    The output matrix has the same size and the same type as the input one except for the last case,
    where C is depth=AQ_8U .
    :type m: :py:class:`Mat`
    :param m: matrix.
    See also: 'MatrixExpressions', absdiff, convert_scale_abs
    """
    return _pyaqcv.abs(*args)
class MatDataAutoLock(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.MatDataAutoLock_swiginit(self, _pyaqcv.new_MatDataAutoLock(*args))
    __swig_destroy__ = _pyaqcv.delete_MatDataAutoLock
    u1 = property(_pyaqcv.MatDataAutoLock_u1_get, _pyaqcv.MatDataAutoLock_u1_set)
    u2 = property(_pyaqcv.MatDataAutoLock_u2_get, _pyaqcv.MatDataAutoLock_u2_set)

# Register MatDataAutoLock in _pyaqcv:
_pyaqcv.MatDataAutoLock_swigregister(MatDataAutoLock)
class MatStep(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.MatStep_swiginit(self, _pyaqcv.new_MatStep(*args))
    buf = property(_pyaqcv.MatStep_buf_get, _pyaqcv.MatStep_buf_set)
    __swig_destroy__ = _pyaqcv.delete_MatStep

# Register MatStep in _pyaqcv:
_pyaqcv.MatStep_swigregister(MatStep)
DepthTypes_kDepth_Original = _pyaqcv.DepthTypes_kDepth_Original
DepthTypes_kDepth_U8 = _pyaqcv.DepthTypes_kDepth_U8
r"""unsigned char AQ_8U"""
DepthTypes_kDepth_S8 = _pyaqcv.DepthTypes_kDepth_S8
r"""AQ_8S"""
DepthTypes_kDepth_U16 = _pyaqcv.DepthTypes_kDepth_U16
r"""unsigned short AQ_16U"""
DepthTypes_kDepth_S16 = _pyaqcv.DepthTypes_kDepth_S16
r"""AQ_16S"""
DepthTypes_kDepth_S32 = _pyaqcv.DepthTypes_kDepth_S32
r"""32-bit float AQ_32S"""
DepthTypes_kDepth_F32 = _pyaqcv.DepthTypes_kDepth_F32
r"""AQ_32F"""
DepthTypes_kDepth_F64 = _pyaqcv.DepthTypes_kDepth_F64
r"""AQ_64F"""
class Mat(object):
    r"""
     n-dimensional dense array class

    The class Mat represents an n-dimensional dense numerical single-channel or multi-channel array. It
    can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel
    volumes, vector fields, point clouds, tensors. The data layout of the array `M` is defined by the array
    `M.step[]`, so that the address of element  :math:`(i_0,...,i_{M.dims-1})` , where  :math:`0\leq i_k<M.size[k]` , is
    computed as:

     .. math::

         addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}
    In case of a 2-dimensional array, the above formula is reduced to:

     .. math::

         addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j
    Note that `M.step[i] >= M.step[i+1]` (in fact, `M.step[i] >= M.step[i+1]*M.size[i+1]` ). This means
    that 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane,
    and so on. M.step[M.dims-1] is minimal and always equal to the element size M.elem_size() .

    So, the data layout in Mat is compatible with the majority of dense array types from the standard
    toolkits and SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others,
    that is, with any array that uses *steps* (or *strides*) to compute the position of a pixel.
    Due to this compatibility, it is possible to make a Mat header for user-allocated data and process
    it in-place using aqcv functions.

    There are many different ways to create a Mat object. The most popular options are listed below:

    - Use the create(nrows, ncols, type) method or the similar Mat(nrows, ncols, type[, fillValue])
    constructor. A new array of the specified size and type is allocated. For example, AQ_8UC1 means
    a 8-bit single-channel array, AQ_32FC2
    means a 2-channel (complex) floating-point array, and so on.

    .. code-block:: c++

        make a 7x7 complex matrix filled with 1+3j.
            Mat M(7,7,AQ_32FC2,Scalar(1,3));
        and now turn M to a 100x60 15-channel 8-bit matrix.
        The old content will be deallocated
            M.create(100,60,AQ_8UC(15));
    As noted in the introduction to this chapter, create() allocates only a new array when the shape
    or type of the current array are different from the specified ones.

    - Create a multi-dimensional array:

    .. code-block:: c++

        create a 100x100x100 8-bit array
            int sz[] = {100, 100, 100};
            Mat bigCube(3, sz, AQ_8U, Scalar::all(0));
    It passes the number of dimensions =1 to the Mat constructor but the created array will be
    2-dimensional with the number of columns set to 1. So, Mat::dims is always >= 2 (can also be 0
    when the array is empty).

    - Use a copy constructor or assignment operator where there can be an array or expression on the
    right side (see below). As noted in the introduction, the array assignment is an O(1) operation
    because it only copies the header and increases the reference counter. The Mat::clone() method can
    be used to get a full (deep) copy of the array when you need it.

    - Construct a header for a part of another array. It can be a single row, single column, several
    rows, several columns, rectangular region in the array (called a *minor* in algebra) or a
    diagonal. Such operations are also O(1) because the new header references the same data. You can
    actually modify a part of the array using this feature, for example:

    .. code-block:: c++

        add the 5-th row, multiplied by 3 to the 3rd row
            M.row(3) = M.row(3) + M.row(5)*3;
        now copy the 7-th column to the 1-st column
        M.col(1) = M.col(7); // this will not work
            Mat M1 = M.col(1);
            M.col(7).copy_to(M1);
        create a new 320x240 image
            Mat img(Size(320,240),AQ_8UC3);
        select a ROI
            Mat roi(img, Rect(10,10,100,100));
        fill the ROI with (0,255,0) (which is green in RGB space);
        the original 320x240 image will be modified
            roi = Scalar(0,255,0);
    Due to the additional datastart and dataend members, it is possible to compute a relative
    sub-array position in the main *container* array using locate_roi():

    .. code-block:: c++

            Mat A = Mat::eye(10, 10, AQ_32S);
        extracts A columns, 1 (inclusive) to 3 (exclusive).
            Mat B = A(Range::all(), Range(1, 3));
        extracts B rows, 5 (inclusive) to 9 (exclusive).
        that is, C \~ A(Range(5, 9), Range(1, 3))
            Mat C = B(Range(5, 9), Range::all());
            Size size; Point ofs;
            C.locate_roi(size, ofs);
        size will be (width=10,height=10) and the ofs will be (x=1, y=5)
    As in case of whole matrices, if you need a deep copy, use the `clone()` method of the extracted
    sub-matrices.

    - Make a header for user-allocated data. It can be useful to do the following:
        -# Process "foreign" data using aqcv (for example, when you implement a DirectShow* filter or
        a processing module for gstreamer, and so on). For example:

        .. code-block:: c++

                Mat process_video_frame(const unsigned char* pixels,
                                        int width, int height, int step)
                {
        wrap input buffer
                    Mat img(height, width, AQ_8UC3, (unsigned char*)pixels, step);

                    Mat result;
                    gaussian_blur(img, result, Size(7, 7), 1.5, 1.5);

                    return result;
                }
        -# Quickly initialize small matrices and/or get a super-fast element access.

        .. code-block:: c++

                double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};
                Mat M = Mat(3, 3, AQ_64F, m).inv();
        .

    - Use MATLAB-style array initializers, zeros(), ones(), eye(), for example:

    .. code-block:: c++

        create a double-precision identity matrix and add it to M.
            M += Mat::eye(M.rows, M.cols, AQ_64F);

    Once the array is created, it is automatically managed via a reference-counting mechanism. If the
    array header is built on top of user-allocated data, you should handle the data by yourself. The
    array data is deallocated when no one points to it. If you want to release the data pointed by a
    array header before the array destructor is called, use Mat::release().

    The next important thing to learn about the array class is element access. This manual already
    described how to compute an address of each array element. Normally, you are not required to use the
    formula directly in the code. If you know the array element type (which can be retrieved using the
    method Mat::type() ), you can access the element  :math:`M_{ij}`  of a 2-dimensional array as:

    .. code-block:: c++

            M.at<double>(i,j) += 1.f;
    assuming that `M` is a double-precision floating-point array. There are several variants of the method
    at for a different number of dimensions.

    If you need to process a whole row of a 2D array, the most efficient way is to get the pointer to
    the row first, and then just use the plain C operator [] :

    .. code-block:: c++

        compute sum of positive matrix elements
        (assuming that M is a double-precision matrix)
            double sum=0;
            for(int i = 0; i < M.rows; i++)
            {
                const double* Mi = M.ptr<double>(i);
                for(int j = 0; j < M.cols; j++)
                    sum += std::max(Mi[j], 0.);
            }
    Some operations, like the one above, do not actually depend on the array shape. They just process
    elements of an array one by one (or elements from multiple arrays that have the same coordinates,
    for example, array addition). Such operations are called *element-wise*. It makes sense to check
    whether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If
    yes, process them as a long single row:

    .. code-block:: c++

        compute the sum of positive matrix elements, optimized variant
            double sum=0;
            int cols = M.cols, rows = M.rows;
            if(M.is_continuous())
            {
                cols *= rows;
                rows = 1;
            }
            for(int i = 0; i < rows; i++)
            {
                const double* Mi = M.ptr<double>(i);
                for(int j = 0; j < cols; j++)
                    sum += std::max(Mi[j], 0.);
            }
    In case of the continuous matrix, the outer loop body is executed just once. So, the overhead is
    smaller, which is especially noticeable in case of small matrices.

    Finally, there are STL-style iterators that are smart enough to skip gaps between successive rows:

    .. code-block:: c++

        compute sum of positive matrix elements, iterator-based variant
            double sum=0;
            MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();
            for(; it != it_end; ++it)
                sum += std::max(*it, 0.);
    The matrix iterators are random-access iterators, so they can be passed to any STL algorithm,
    including std::sort().

    Notes: Matrix Expressions and arithmetic see MatExpr
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_Mat

    def row(self, y):
        r"""
        Creates a matrix header for the specified matrix row.

           The method makes a new header for the specified matrix row and returns it. This is an O(1)
           operation, regardless of the matrix size. The underlying data of the new matrix is shared with the
           original matrix. Here is the example of one of the classical basic matrix processing operations,
           axpy, used by LU and many other algorithms:

           .. code-block:: c++

                   inline void matrix_axpy(Mat& A, int i, int j, double alpha)
                   {
                       A.row(i) += A.row(j)*alpha;
                   }
           Notes: In the current implementation, the following code does not work as expected:

           .. code-block:: c++

                   Mat A;
                   ...
                   A.row(i) = A.row(j); // will not work
           This happens because A.row(i) forms a temporary header that is further assigned to another header.
           Remember that each of these operations is O(1), that is, no data is copied. Thus, the above
           assignment is not true if you may have expected the j-th row to be copied to the i-th row. To
           achieve that, you should either turn this simple assignment into an expression or use the
           Mat::copy_to method:

           .. code-block:: c++

                   Mat A;
                   ...
           works, but looks a bit obscure.
                   A.row(i) = A.row(j) + 0;
           this is a bit longer, but the recommended method.
                   A.row(j).copy_to(A.row(i));
           :type y: int
           :param y: A 0-based row index.
        """
        return _pyaqcv.Mat_row(self, y)

    def col(self, x):
        r"""
        Creates a matrix header for the specified matrix column.

           The method makes a new header for the specified matrix column and returns it. This is an O(1)
           operation, regardless of the matrix size. The underlying data of the new matrix is shared with the
           original matrix. See also the Mat::row description.
           :type x: int
           :param x: A 0-based column index.
        """
        return _pyaqcv.Mat_col(self, x)

    def row_range(self, *args):
        r"""
        Creates a matrix header for the specified row span.

           The method makes a new header for the specified row span of the matrix. Similarly to Mat::row and
           Mat::col , this is an O(1) operation.
           :type startrow: int
           :param startrow: An inclusive 0-based start index of the row span.
           :type endrow: int
           :param endrow: An exclusive 0-based ending index of the row span(not included in the result).
        """
        return _pyaqcv.Mat_row_range(self, *args)

    def col_range(self, *args):
        r"""
        Creates a matrix header for the specified column span.

           The method makes a new header for the specified column span of the matrix. Similarly to Mat::row and
           Mat::col , this is an O(1) operation.
           :type startcol: int
           :param startcol: An inclusive 0-based start index of the column span.
           :type endcol: int
           :param endcol: An exclusive 0-based ending index of the column span.
        """
        return _pyaqcv.Mat_col_range(self, *args)

    @staticmethod
    def diag(*args):
        r"""
        *Overload 1:*
        Extracts a diagonal from a matrix

           The method makes a new header for the specified matrix diagonal. The new matrix is represented as a
           single-column matrix. Similarly to Mat::row and Mat::col, this is an O(1) operation.
           :type d: int, optional
           :param d: index of the diagonal, with the following values:
               - `d=0` is the main diagonal.
               - `d<0` is a diagonal from the lower half. For example, d=-1 means the diagonal is set
                 immediately below the main one.
               - `d>0` is a diagonal from the upper half. For example, d=1 means the diagonal is set
                 immediately above the main one.

        |

        *Overload 2:*
        creates a diagonal matrix

           The method creates a square diagonal matrix from specified main diagonal.
           :type d: :py:class:`Mat`
           :param d: One-dimensional matrix that represents the main diagonal.
        """
        return _pyaqcv.Mat_diag(*args)

    def clone(self):
        r"""
        Creates a full copy of the array and the underlying data.

           The method creates a full copy of the array. The original step[] is not taken into account. So, the
           array copy is a continuous array occupying total()*elem_size() bytes.
        """
        return _pyaqcv.Mat_clone(self)

    def copy_to(self, *args):
        r"""
        *Overload 1:*
         Copies the matrix to another one.

            The method copies the matrix data to another matrix. Before copying the data, the method invokes :

            .. code-block:: c++

                    m.create(this->size(), this->type());
            so that the destination matrix is reallocated if needed. While m.copy_to(m); works flawlessly, the
            function does not handle the case of a partial overlap between the source and the destination
            matrices.

            When the operation mask is specified, if the Mat::create call shown above reallocates the matrix,
            the newly allocated matrix is initialized with all zeros before copying the data.
            :type m: :py:class:`_OutputArray`
            :param m: Destination matrix. If it does not have a proper size or type before the operation, it is
                reallocated.

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
            :type m: :py:class:`_OutputArray`
            :param m: Destination matrix. If it does not have a proper size or type before the operation, it is
                reallocated.
            :type mask: :py:class:`Mat`
            :param mask: Operation mask of the same size as *this. Its non-zero elements indicate which matrix
                elements need to be copied. The mask has to be of type AQ_8U and can have 1 or multiple channels.
        """
        return _pyaqcv.Mat_copy_to(self, *args)

    def convert_to(self, m, rtype, alpha=1, beta=0):
        r"""
        Converts an array to another data type with optional scaling.

           The method converts source pixel values to the target data type. saturate_cast<> is applied at
           the end to avoid possible overflows:

            .. math::

                m(x,y) = saturate \_ cast<rType>( \alpha (*this)(x,y) +  \beta )
           :type m: :py:class:`_OutputArray`
           :param m: output matrix; if it does not have a proper size or type before the operation, it is
               reallocated.
           :type rtype: int
           :param rtype: desired output matrix type or, rather, the depth since the number of channels are the
               same as the input has; if rtype is negative, the output matrix will have the same type as the input.
           :type alpha: float, optional
           :param alpha: optional scale factor.
           :type beta: float, optional
           :param beta: optional delta added to the scaled values.
        """
        return _pyaqcv.Mat_convert_to(self, m, rtype, alpha, beta)

    def assign_to(self, m, type=-1):
        r"""
        Provides a functional form of convert_to.

           This is an internally used method called by the 'MatrixExpressions' engine.
           :type m: :py:class:`Mat`
           :param m: Destination array.
           :type type: int, optional
           :param type: Desired destination array depth (or -1 if it should be the same as the source type).
        """
        return _pyaqcv.Mat_assign_to(self, m, type)

    def set_to(self, *args):
        r"""
        Sets all or some of the array elements to the specified value.

           This is an advanced variant of the Mat::operator=(const Scalar& s) operator.
           :type value: :py:class:`_InputArray`
           :param value: Assigned scalar converted to the actual array type.
           :type mask: :py:class:`Mat`, optional
           :param mask: Operation mask of the same size as *this. Its non-zero elements indicate which matrix
               elements need to be copied. The mask has to be of type AQ_8U and can have 1 or multiple channels
        """
        return _pyaqcv.Mat_set_to(self, *args)

    def reshape(self, *args):
        r"""
        Changes the shape and/or the number of channels of a 2D matrix without copying the data.

           The method makes a new matrix header for *this elements. The new matrix may have a different size
           and/or different number of channels. Any combination is possible if:
           -   No extra elements are included into the new matrix and no elements are excluded. Consequently,
               the product rows*cols*channels() must stay the same after the transformation.
           -   No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of
               rows, or the operation changes the indices of elements row in some other way, the matrix must be
               continuous. See Mat::is_continuous .

           For example, if there is a set of 3D points stored as an STL vector, and you want to represent the
           points as a 3xN matrix, do the following:

           .. code-block:: c++

                   std::vector<Point3f> vec;
                   ...
                   Mat pointMat = Mat(vec). // convert vector to Mat, O(1) operation
                                     reshape(1). // make Nx3 1-channel matrix out of Nx1 3-channel.
           Also, an O(1) operation
                                        t(); // finally, transpose the Nx3 matrix.
           This involves copying all the elements
           :type cn: int
           :param cn: New number of channels. If the parameter is 0, the number of channels remains the same.
           :type rows: int, optional
           :param rows: New number of rows. If the parameter is 0, the number of rows remains the same.
        """
        return _pyaqcv.Mat_reshape(self, *args)

    def t(self):
        r"""
        Transposes a matrix.

           The method performs matrix transposition by means of matrix expressions. It does not perform the
           actual transposition but returns a temporary matrix transposition object that can be further used as
           a part of more complex matrix expressions or can be assigned to a matrix:

           .. code-block:: c++

                   Mat A1 = A + Mat::eye(A.size(), A.type())*lambda;
                   Mat C = A1.t()*A1; // compute (A + lambda*I)^t * (A + lamda*I)
        """
        return _pyaqcv.Mat_t(self)

    def inv(self, *args):
        r"""
        Inverses a matrix.

           The method performs a matrix inversion by means of matrix expressions. This means that a temporary
           matrix inversion object is returned by the method and can be used further as a part of more complex
           matrix expressions or can be assigned to a matrix.
           :type method: int, optional
           :param method: Matrix inversion method. One of aqcv::DecompTypes
        """
        return _pyaqcv.Mat_inv(self, *args)

    def mul(self, m, scale=1):
        r"""
        Performs an element-wise multiplication or division of the two matrices.

           The method returns a temporary object encoding per-element array multiplication, with optional
           scale. Note that this is not a matrix multiplication that corresponds to a simpler "\*" operator.

           Example:

           .. code-block:: c++

                   Mat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)
           :type m: :py:class:`Mat`
           :param m: Another array of the same type and the same size as *this, or a matrix expression.
           :type scale: float, optional
           :param scale: Optional scale factor.
        """
        return _pyaqcv.Mat_mul(self, m, scale)

    def cross(self, m):
        r"""
        Computes a cross-product of two 3-element vectors.

           The method computes a cross-product of two 3-element vectors. The vectors must be 3-element
           floating-point vectors of the same shape and size. The result is another 3-element vector of the
           same shape and type as operands.
           :type m: :py:class:`Mat`
           :param m: Another cross-product operand.
        """
        return _pyaqcv.Mat_cross(self, m)

    def dot(self, m):
        r"""
        Computes a dot-product of two vectors.

           The method computes a dot-product of two matrices. If the matrices are not single-column or
           single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D
           vectors. The vectors must have the same size and type. If the matrices have more than one channel,
           the dot products from all the channels are summed together.
           :type m: :py:class:`Mat`
           :param m: another dot-product operand.
        """
        return _pyaqcv.Mat_dot(self, m)

    @staticmethod
    def zeros(*args):
        r"""
        Returns a zero array of the specified size and type.

           The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant
           array as a function parameter, part of a matrix expression, or as a matrix initializer:

           .. code-block:: c++

                   Mat A;
                   A = Mat::zeros(3, 3, AQ_32F);
           In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix.
           Otherwise, the existing matrix A is filled with zeros.
           :type rows: int
           :param rows: Number of rows.
           :type cols: int
           :param cols: Number of columns.
           :type type: int
           :param type: Created matrix type.
        """
        return _pyaqcv.Mat_zeros(*args)

    @staticmethod
    def ones(*args):
        r"""
        Returns an array of all 1's of the specified size and type.

           The method returns a Matlab-style 1's array initializer, similarly to Mat::zeros. Note that using
           this method you can initialize an array with an arbitrary value, using the following Matlab idiom:

           .. code-block:: c++

                   Mat A = Mat::ones(100, 100, AQ_8U)*3; // make 100x100 matrix filled with 3.
           The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it
           just remembers the scale factor (3 in this case) and use it when actually invoking the matrix
           initializer.
           Notes: In case of multi-channels type, only the first channel will be initialized with 1's, the
           others will be set to 0's.
           :type rows: int
           :param rows: Number of rows.
           :type cols: int
           :param cols: Number of columns.
           :type type: int
           :param type: Created matrix type.
        """
        return _pyaqcv.Mat_ones(*args)

    @staticmethod
    def eye(*args):
        r"""
        Returns an identity matrix of the specified size and type.

           The method returns a Matlab-style identity matrix initializer, similarly to Mat::zeros. Similarly to
           Mat::ones, you can use a scale operation to create a scaled identity matrix efficiently:

           .. code-block:: c++

           make a 4x4 diagonal matrix with 0.1's on the diagonal.
                   Mat A = Mat::eye(4, 4, AQ_32F)*0.1;
           Notes: In case of multi-channels type, identity matrix will be initialized only for the first channel,
           the others will be set to 0's
           :type rows: int
           :param rows: Number of rows.
           :type cols: int
           :param cols: Number of columns.
           :type type: int
           :param type: Created matrix type.
        """
        return _pyaqcv.Mat_eye(*args)

    def create(self, *args):
        r"""
        *Overload 1:*

        only allocate meomery of the mat

        |

        *Overload 2:*
         Allocates new array data if needed.

            This is one of the key Mat methods. Most new-style aqcv functions and methods that produce arrays
            call this method for each output array. The method uses the following algorithm:

            -# If the current array shape and the type match the new ones, return immediately. Otherwise,
               de-reference the previous data by calling Mat::release.
            -# Initialize the new header.
            -# Allocate the new data of total()*elem_size() bytes.
            -# Allocate the new, associated with the data, reference counter and set it to 1.

            Such a scheme makes the memory management robust and efficient at the same time and helps avoid
            extra typing for you. This means that usually there is no need to explicitly allocate output arrays.

            :type rows: int
            :param rows: New number of rows.
            :type cols: int
            :param cols: New number of columns.
            :type type: int
            :param type: New matrix type.
        """
        return _pyaqcv.Mat_create(self, *args)

    def addref(self):
        r"""
        Increments the reference counter.

           The method increments the reference counter associated with the matrix data. If the matrix header
           points to an external data set (see Mat::Mat ), the reference counter is NULL, and the method has no
           effect in this case. Normally, to avoid memory leaks, the method should not be called explicitly. It
           is called implicitly by the matrix assignment operator. The reference counter increment is an atomic
           operation on the platforms that support it. Thus, it is safe to operate on the same matrices
           asynchronously in different threads.
        """
        return _pyaqcv.Mat_addref(self)

    def release(self):
        r"""
        Decrements the reference counter and deallocates the matrix if needed.

           The method decrements the reference counter associated with the matrix data. When the reference
           counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers
           are set to NULL's. If the matrix header points to an external data set (see Mat::Mat ), the
           reference counter is NULL, and the method has no effect in this case.

           This method can be called manually to force the matrix data deallocation. But since this method is
           automatically called in the destructor, or by any other method that changes the data pointer, it is
           usually not needed. The reference counter decrement and check for 0 is an atomic operation on the
           platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in
           different threads.
        """
        return _pyaqcv.Mat_release(self)

    def deallocate(self):
        r"""internal use function, consider to use 'release' method instead; deallocates the matrix data"""
        return _pyaqcv.Mat_deallocate(self)

    def copy_size(self, m):
        r"""internal use function; properly re-allocates _size, _step arrays"""
        return _pyaqcv.Mat_copy_size(self, m)

    def reserve(self, sz):
        r"""
        Reserves space for the certain number of rows.

           The method reserves space for sz rows. If the matrix already has enough space to store sz rows,
           nothing happens. If the matrix is reallocated, the first Mat::rows rows are preserved. The method
           emulates the corresponding method of the STL vector class.
           :type sz: int
           :param sz: Number of rows.
        """
        return _pyaqcv.Mat_reserve(self, sz)

    def reserve_buffer(self, sz):
        r"""
        Reserves space for the certain number of bytes.

           The method reserves space for sz bytes. If the matrix already has enough space to store sz bytes,
           nothing happens. If matrix has to be reallocated its previous content could be lost.
           :type sz: int
           :param sz: Number of bytes.
        """
        return _pyaqcv.Mat_reserve_buffer(self, sz)

    def resize(self, *args):
        r"""
        Changes the number of matrix rows.

           The methods change the number of matrix rows. If the matrix is reallocated, the first
           min(Mat::rows, sz) rows are preserved. The methods emulate the corresponding methods of the STL
           vector class.
           :type sz: int
           :param sz: New number of rows.
        """
        return _pyaqcv.Mat_resize(self, *args)

    def push_back_(self, elem):
        r"""internal function"""
        return _pyaqcv.Mat_push_back_(self, elem)

    def push_back(self, m):
        return _pyaqcv.Mat_push_back(self, m)

    def pop_back(self, nelems=1):
        r"""
        Removes elements from the bottom of the matrix.

           The method removes one or more rows from the bottom of the matrix.
           :type nelems: int, optional
           :param nelems: Number of removed rows. If it is greater than the total number of rows, an exception
               is thrown.
        """
        return _pyaqcv.Mat_pop_back(self, nelems)

    def locate_roi(self, whole_size, ofs):
        r"""
        Locates the matrix header within a parent matrix.

           After you extracted a submatrix from a matrix using Mat::row, Mat::col, Mat::row_range,
           Mat::col_range, and others, the resultant submatrix points just to the part of the original big
           matrix. However, each submatrix contains information (represented by datastart and dataend
           fields) that helps reconstruct the original matrix size and the position of the extracted
           submatrix within the original matrix. The method locate_roi does exactly that.
           :type whole_size: :py:class:`Size`
           :param whole_size: Output parameter that contains the size of the whole matrix containing *this*
               as a part.
           :type ofs: :py:class:`Point`
           :param ofs: Output parameter that contains an offset of *this* inside the whole matrix.
        """
        return _pyaqcv.Mat_locate_roi(self, whole_size, ofs)

    def adjust_roi(self, dtop, dbottom, dleft, dright):
        r"""
        Adjusts a submatrix size and position within the parent matrix.

           The method is complimentary to Mat::locate_roi . The typical use of these functions is to determine
           the submatrix position within the parent matrix and then shift the position somehow. Typically, it
           can be required for filtering operations when pixels outside of the ROI should be taken into
           account. When all the method parameters are positive, the ROI needs to grow in all directions by the
           specified amount, for example:

           .. code-block:: c++

                   A.adjust_roi(2, 2, 2, 2);
           In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted
           by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the
           filtering with the 5x5 kernel.

           adjust_roi forces the adjusted ROI to be inside of the parent matrix that is boundaries of the
           adjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix A is
           located in the first row of a parent matrix and you called A.adjust_roi(2, 2, 2, 2) then A will not
           be increased in the upward direction.

           The function is used internally by the aqcv filtering functions, like filter2d , morphological
           operations, and so on.
           :type dtop: int
           :param dtop: Shift of the top submatrix boundary upwards.
           :type dbottom: int
           :param dbottom: Shift of the bottom submatrix boundary downwards.
           :type dleft: int
           :param dleft: Shift of the left submatrix boundary to the left.
           :type dright: int
           :param dright: Shift of the right submatrix boundary to the right.
           See also: copy_make_border
        """
        return _pyaqcv.Mat_adjust_roi(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        r"""
        *Overload 1:*
         Extracts a rectangular submatrix.

            The operators make a new header for the specified sub-array of *this . They are the most
            generalized forms of Mat::row, Mat::col, Mat::row_range, and Mat::col_range . For example,
            `A(Range(0, 10), Range::all())` is equivalent to `A.row_range(0, 10)`. Similarly to all of the above,
            the operators are O(1) operations, that is, no matrix data is copied.
            :type row_range: :py:class:`Range`
            :param row_range: Start and end row of the extracted submatrix. The upper boundary is not included. To
                select all the rows, use Range::all().
            :type col_range: :py:class:`Range`
            :param col_range: Start and end column of the extracted submatrix. The upper boundary is not included.
                To select all the columns, use Range::all().

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        return _pyaqcv.Mat___call__(self, *args)

    def is_continuous(self):
        r"""
        Reports whether the matrix is continuous or not.

           The method returns true if the matrix elements are stored continuously without gaps at the end of
           each row. Otherwise, it returns false. Obviously, 1x1 or 1xN matrices are always continuous.
           Matrices created with Mat::create are always continuous. But if you extract a part of the matrix
           using Mat::col, Mat::diag, and so on, or constructed a matrix header for externally allocated data,
           such matrices may no longer have this property.

           The continuity flag is stored as a bit in the Mat::flags field and is computed automatically when
           you construct a matrix header. Thus, the continuity check is a very fast operation, though
           theoretically it could be done as follows:

           .. code-block:: c++

           alternative implementation of Mat::is_continuous()
                   bool myCheckMatContinuity(const Mat& m)
                   {
           return (m.flags & Mat::kContinuousFlag) != 0;
                       return m.rows == 1 || m.step == m.cols*m.elem_size();
                   }
           The method is used in quite a few of aqcv functions. The point is that element-wise operations
           (such as arithmetic and logical operations, math functions, alpha blending, color space
           transformations, and others) do not depend on the image geometry. Thus, if all the input and output
           arrays are continuous, the functions can process them as very long single-row vectors.

           This approach, while being very simple, can boost the performance of a simple element-operation by
           10-20 percents, especially if the image is rather small and the operation is quite simple.

           Another aqcv idiom in this function, a call of Mat::create for the destination array, that
           allocates the destination array unless it already has the proper size and type. And while the newly
           allocated arrays are always continuous, you still need to check the destination array because
           Mat::create does not always allocate a new matrix.

           Notes: For large Mat(whose total()>INT_MAX), is_continuous() always return false. You can use
           is_continuous = (mat.step == ((int64_t)mat.elem_size() * mat.cols)) || mat.rows == 1
           to judge if a Mat is continuous.
        """
        return _pyaqcv.Mat_is_continuous(self)

    def is_submatrix(self):
        r"""returns true if the matrix is a submatrix of another matrix"""
        return _pyaqcv.Mat_is_submatrix(self)

    def elem_size(self):
        r"""
        Returns the matrix element size in bytes.

           The method returns the matrix element size in bytes. For example, if the matrix type is AQ_16SC3 ,
           the method returns 3*sizeof(short) or 6.
        """
        return _pyaqcv.Mat_elem_size(self)

    def elem_size1(self):
        r"""
        Returns the size of each matrix element channel in bytes.

           The method returns the matrix element channel size in bytes, that is, it ignores the number of
           channels. For example, if the matrix type is AQ_16SC3 , the method returns sizeof(short) or 2.
        """
        return _pyaqcv.Mat_elem_size1(self)

    def type(self):
        r"""
        Returns the type of a matrix element.

           The method returns a matrix element type. This is a combination of depth and channels. For example,
           AQ_16SC3 is a 16-bit signed 3-channel array, and so on. If you don't specify channel, like AQ_8U,
           it means single channel, which is equal to AQ_8UC1.
        """
        return _pyaqcv.Mat_type(self)

    def depth(self):
        r"""
        Returns the depth of a matrix element.

           The method returns the identifier of the matrix element depth (the type of each individual channel).
           For example, for a 16-bit signed element array, the method returns AQ_16S . A complete list of
           matrix types contains the following values:
           -   AQ_8U - 8-bit unsigned integers ( 0..255 )
           -   AQ_8S - 8-bit signed integers ( -128..127 )
           -   AQ_16U - 16-bit unsigned integers ( 0..65535 )
           -   AQ_16S - 16-bit signed integers ( -32768..32767 )
           -   AQ_32S - 32-bit signed integers ( -2147483648..2147483647 )
           -   AQ_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )
           -   AQ_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )
        """
        return _pyaqcv.Mat_depth(self)

    def depth_type(self):
        r"""
        get depth with DepthTypes

            There are two kind of representations of depth in aqcv, like AQ_8U and kDepth_U8, they have different type (int vs enum)
            but have the same meaning. You can use both of them in most operators.
            -   kDepth_U8 is equal to AQ_8U
            -   kDepth_S8 is equal to AQ_8S
            -   kDepth_U16 is equal to AQ_16U
            -   kDepth_S16 is equal to AQ_16S
            -   kDepth_S32 is equal to AQ_32S
            -   kDepth_F32 is equal to AQ_32F
            -   kDepth_F64 is equal to AQ_64F
        """
        return _pyaqcv.Mat_depth_type(self)

    def channels(self):
        r"""
        Returns the number of matrix channels.

           The method returns the number of matrix channels.
        """
        return _pyaqcv.Mat_channels(self)

    def step1(self, i=0):
        r"""
        Returns a normalized step.

           The method returns a matrix step divided by Mat::elem_size1() . It can be useful to quickly access an
           arbitrary matrix element.
        """
        return _pyaqcv.Mat_step1(self, i)

    def empty(self):
        r"""
        Returns true if the array has no elements.

           The method returns true if Mat::total() is 0 or if Mat::data is NULL. Because of pop_back() and
           resize() methods `M.total() == 0` does not imply that `M.data == NULL`.
        """
        return _pyaqcv.Mat_empty(self)

    def total(self, *args):
        r"""
        *Overload 1:*
        Returns the total number of array elements.

           The method returns the number of array elements (a number of pixels if the array represents an
           image).

        |

        *Overload 2:*
        Returns the total number of array elements.

           The method returns the number of elements within a certain sub-array slice with start_dim <= dim < end_dim

        |

        *Overload 3:*
        Returns the total number of array elements.

           The method returns the number of elements within a certain sub-array slice with start_dim <= dim < end_dim
        """
        return _pyaqcv.Mat_total(self, *args)

    def check_vector(self, elem_channels, depth=-1, require_continuous=True):
        r"""
        :type elem_channels: int
        :param elem_channels: Number of channels or number of columns the matrix should have.
                                For a 2-D matrix, when the matrix has only 1 column, then it should have
                                elem_channels channels; When the matrix has only 1 channel,
                                then it should have elem_channels columns.
                                For a 3-D matrix, it should have only one channel. Furthermore,
                                if the number of planes is not one, then the number of rows
                                within every plane has to be 1; if the number of rows within
                                every plane is not 1, then the number of planes has to be 1.
        :type depth: int, optional
        :param depth: The depth the matrix should have. Set it to -1 when any depth is fine.
        :type require_continuous: boolean, optional
        :param require_continuous: Set it to true to require the matrix to be continuous
        :rtype: int
        :return: -1 if the requirement is not satisfied.
                    Otherwise, it returns the number of elements in the matrix. Note
                    that an element may have multiple channels.
        """
        return _pyaqcv.Mat_check_vector(self, elem_channels, depth, require_continuous)

    def width(self):
        return _pyaqcv.Mat_width(self)

    def height(self):
        return _pyaqcv.Mat_height(self)

    def elem_size_1(self):
        r"""pixel element's byte size, e.g. for kDepth_U16 with three channels element size is 2 (byte of unsigned short)"""
        return _pyaqcv.Mat_elem_size_1(self)

    def roi(self, x, y, width, height):
        r"""get a roi region of the Matrix, matrix data is shared."""
        return _pyaqcv.Mat_roi(self, x, y, width, height)

    def data_byte_size(self):
        r"""
        data_byte_size, equaltTo height * width* element_size. temporary, if
        :rtype: int
        :return: total size of the image
        """
        return _pyaqcv.Mat_data_byte_size(self)

    def ptr(self, *args):
        r"""
        Returns a pointer to the specified matrix row.

           The methods return `uchar*` or typed pointer to the specified matrix row. See the sample in
           Mat::is_continuous to know how to use these methods.
           :type i0: int, optional
           :param i0: A 0-based row index.
        """
        return _pyaqcv.Mat_ptr(self, *args)

    def from_chars(self, buffer, height, width, depth, channel, copy=True):
        r"""
        from_chars parse image from chars pointer which point to a byte image format-as interleaved(H*W*C)

           :type buffer: string
           :param buffer: data pointer
           :type height: int
           :param height: image height
           :type width: int
           :param width: image width
           :type depth: int
           :param depth: depth of the data
           :type channel: int
           :param channel: image channel
           :type copy: boolean, optional
           :param copy: whether deep copy buffer data
           :rtype: boolean
           :return: true if successed.
        """
        return _pyaqcv.Mat_from_chars(self, buffer, height, width, depth, channel, copy)

    def to_chars(self, buffer, buf_size):
        r"""
        to_chars Reverse operation of "from_chars"
           :type buffer: string
           :param buffer: Pre-allocated buffer, you should pre-allocte buffer[data_byte_size()]
           :type buf_size: int
           :param buf_size: byte size of pre-allocated buffer
        """
        return _pyaqcv.Mat_to_chars(self, buffer, buf_size)

    def __init__(self, *args):
        r"""
        *Overload 1:*

           These are various constructors that form a matrix. As noted in the AutomaticAllocation, often
           the default constructor is enough, and the proper matrix will be allocated by an aqcv function.
           The constructed matrix can further be assigned to another matrix or matrix expression or can be
           allocated with Mat::create . In the former case, the old content is de-referenced.

        |

        *Overload 2:*
        Returns the matrix iterator and sets it to the first matrix element.

           The methods return the matrix read-only or read-write iterators. The use of matrix iterators is very
           similar to the use of bi-directional STL iterators. In the example below, the alpha blending
           function is rewritten using the matrix iterators:

           .. code-block:: c++

                   template<typename T>
                   void alphaBlendRGBA(const Mat& src1, const Mat& src2, Mat& dst)
                   {
                       typedef Vec<T, 4> VT;

                       const float alpha_scale = (float)std::numeric_limits<T>::max(),
                                   inv_scale = 1.f/alpha_scale;

                       AQCV_ASSERT( src1.type() == src2.type() &&
                                  src1.type() == traits::Type<VT>::value &&
                                  src1.size() == src2.size());
                       Size size = src1.size();
                       dst.create(size, src1.type());

                       MatConstIterator_<VT> it1 = src1.begin<VT>(), it1_end = src1.end<VT>();
                       MatConstIterator_<VT> it2 = src2.begin<VT>();
                       MatIterator_<VT> dst_it = dst.begin<VT>();

                       for( ; it1 != it1_end; ++it1, ++it2, ++dst_it )
                       {
                           VT pix1 = *it1, pix2 = *it2;
                           float alpha = pix1[3]*inv_scale, beta = pix2[3]*inv_scale;
           dst_it = VT(saturate_cast<T>(pix1[0]*alpha + pix2[0]*beta),
                                        saturate_cast<T>(pix1[1]*alpha + pix2[1]*beta),
                                        saturate_cast<T>(pix1[2]*alpha + pix2[2]*beta),
                                        saturate_cast<T>((1 - (1-alpha)*(1-beta))*alpha_scale));
                       }
                   }
        """
        _pyaqcv.Mat_swiginit(self, _pyaqcv.new_Mat(*args))
    kMagicVal = _pyaqcv.Mat_kMagicVal
    kAutoStep = _pyaqcv.Mat_kAutoStep
    kContinuousFlag = _pyaqcv.Mat_kContinuousFlag
    kSubMatrixFlag = _pyaqcv.Mat_kSubMatrixFlag
    kMagicMask = _pyaqcv.Mat_kMagicMask
    kTypeMask = _pyaqcv.Mat_kTypeMask
    kDepthMask = _pyaqcv.Mat_kDepthMask
    flags = property(_pyaqcv.Mat_flags_get, _pyaqcv.Mat_flags_set, doc=r"""
    includes several bit-fields:
            - the magic signature
            - continuity flag
            - depth
            - number of channels
    """)
    dims = property(_pyaqcv.Mat_dims_get, _pyaqcv.Mat_dims_set, doc=r"""the matrix dimensionality, >= 2""")
    rows = property(_pyaqcv.Mat_rows_get, _pyaqcv.Mat_rows_set, doc=r"""the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions""")
    cols = property(_pyaqcv.Mat_cols_get, _pyaqcv.Mat_cols_set)
    data = property(_pyaqcv.Mat_data_get, _pyaqcv.Mat_data_set, doc=r"""pointer to the data""")
    datastart = property(_pyaqcv.Mat_datastart_get, _pyaqcv.Mat_datastart_set, doc=r"""helper fields used in locate_roi and adjust_roi""")
    dataend = property(_pyaqcv.Mat_dataend_get, _pyaqcv.Mat_dataend_set)
    datalimit = property(_pyaqcv.Mat_datalimit_get, _pyaqcv.Mat_datalimit_set)
    allocator = property(_pyaqcv.Mat_allocator_get, _pyaqcv.Mat_allocator_set, doc=r"""custom allocator""")

    @staticmethod
    def get_std_allocator():
        r"""and the standard allocator"""
        return _pyaqcv.Mat_get_std_allocator()

    @staticmethod
    def get_default_allocator():
        return _pyaqcv.Mat_get_default_allocator()

    @staticmethod
    def set_default_allocator(allocator):
        return _pyaqcv.Mat_set_default_allocator(allocator)

    def update_continuity_flag(self):
        r"""internal use method: updates the continuity flag"""
        return _pyaqcv.Mat_update_continuity_flag(self)
    u = property(_pyaqcv.Mat_u_get, _pyaqcv.Mat_u_set, doc=r"""interaction with MatData""")
    size = property(_pyaqcv.Mat_size_get, _pyaqcv.Mat_size_set)
    step = property(_pyaqcv.Mat_step_get)

    def at_vec1c(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec1c(self, *args)

    def at_vec2c(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec2c(self, *args)

    def at_vec3c(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec3c(self, *args)

    def at_vec4c(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec4c(self, *args)

    def at_vec1b(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec1b(self, *args)

    def at_vec2b(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec2b(self, *args)

    def at_vec3b(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec3b(self, *args)

    def at_vec4b(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec4b(self, *args)

    def at_vec1s(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec1s(self, *args)

    def at_vec2s(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec2s(self, *args)

    def at_vec3s(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec3s(self, *args)

    def at_vec4s(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec4s(self, *args)

    def at_vec1w(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec1w(self, *args)

    def at_vec2w(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec2w(self, *args)

    def at_vec3w(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec3w(self, *args)

    def at_vec4w(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec4w(self, *args)

    def at_vec1i(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec1i(self, *args)

    def at_vec2i(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec2i(self, *args)

    def at_vec3i(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec3i(self, *args)

    def at_vec4i(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec4i(self, *args)

    def at_vec1f(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec1f(self, *args)

    def at_vec2f(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec2f(self, *args)

    def at_vec3f(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec3f(self, *args)

    def at_vec4f(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec4f(self, *args)

    def at_vec1d(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec1d(self, *args)

    def at_vec2d(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec2d(self, *args)

    def at_vec3d(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec3d(self, *args)

    def at_vec4d(self, *args):
        r"""
        Returns a reference to the specified array element.

           The template methods return a reference to the specified array element. For the sake of higher
           performance, the index range checks are only performed in the Debug configuration.

           Note that the variants with a single index (i) can be used to access elements of single-row or
           single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
           B is an M x 1 integer matrix, you can simply write `A.at<float>(k+4)` and `B.at<int>(2*i+1)`
           instead of `A.at<float>(0,k+4)` and `B.at<int>(2*i+1,0)`, respectively.

           The example below initializes a Hilbert matrix:

           .. code-block:: c++

                   Mat H(100, 100, AQ_64F);
                   for(int i = 0; i < H.rows; i++)
                       for(int j = 0; j < H.cols; j++)
                           H.at<double>(i,j)=1./(i+j+1);

           Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
           on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
            - If matrix is of type `AQ_8U` then use `Mat.at<uchar>(y,x)`.
            - If matrix is of type `AQ_8S` then use `Mat.at<schar>(y,x)`.
            - If matrix is of type `AQ_16U` then use `Mat.at<ushort>(y,x)`.
            - If matrix is of type `AQ_16S` then use `Mat.at<short>(y,x)`.
            - If matrix is of type `AQ_32S`  then use `Mat.at<int>(y,x)`.
            - If matrix is of type `AQ_32F`  then use `Mat.at<float>(y,x)`.
            - If matrix is of type `AQ_64F` then use `Mat.at<double>(y,x)`.

           :type i0: int, optional
           :param i0: Index along the dimension 0
        """
        return _pyaqcv.Mat_at_vec4d(self, *args)

# Register Mat in _pyaqcv:
_pyaqcv.Mat_swigregister(Mat)

def __lshift__(os, mat):
    return _pyaqcv.__lshift__(os, mat)

def geometry_matrix3f_to_mat(matrix3f, res_mat, keep_last_row=True):
    r"""
    convert visionflow::geometry::Matrix3f to aqcv::Mat

    :type matrix3f: :py:class:`Matrix3f`
    :param matrix3f: visionflow::geometry::Matrix3f data
    :type res_mat: :py:class:`Mat`
    :param res_mat: converted aqcv::Mat, AQ_64FC1
    :type keep_last_row: boolean, optional
    :param keep_last_row: shape of res_mat will be 3x3 when keep last row is true, otherwise will be 2x3
    :rtype: boolean
    :return: true if successed.
    """
    return _pyaqcv.geometry_matrix3f_to_mat(matrix3f, res_mat, keep_last_row)

def mat_to_geometry_matrix3f(mat, matrix3f):
    r"""
    convert visionflow::geometry::Matrix3f to aqcv::Mat
    :type mat: :py:class:`Mat`
    :param mat: aqcv::Mat, 3x3 or 2x3, single channel, kDepth_F64 or kDepth_F32
    :type matrix3f: :py:class:`Matrix3f`
    :param matrix3f: converted visionflow::geometry::Matrix3f data
    :rtype: boolean
    :return: true if successed.
    """
    return _pyaqcv.mat_to_geometry_matrix3f(mat, matrix3f)
class Matx_AddOp(object):
    r"""Conditional comment: IGNORED"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Matx_AddOp_swiginit(self, _pyaqcv.new_Matx_AddOp(*args))
    __swig_destroy__ = _pyaqcv.delete_Matx_AddOp

# Register Matx_AddOp in _pyaqcv:
_pyaqcv.Matx_AddOp_swigregister(Matx_AddOp)
class Matx_SubOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Matx_SubOp_swiginit(self, _pyaqcv.new_Matx_SubOp(*args))
    __swig_destroy__ = _pyaqcv.delete_Matx_SubOp

# Register Matx_SubOp in _pyaqcv:
_pyaqcv.Matx_SubOp_swigregister(Matx_SubOp)
class Matx_ScaleOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Matx_ScaleOp_swiginit(self, _pyaqcv.new_Matx_ScaleOp(*args))
    __swig_destroy__ = _pyaqcv.delete_Matx_ScaleOp

# Register Matx_ScaleOp in _pyaqcv:
_pyaqcv.Matx_ScaleOp_swigregister(Matx_ScaleOp)
class Matx_MulOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Matx_MulOp_swiginit(self, _pyaqcv.new_Matx_MulOp(*args))
    __swig_destroy__ = _pyaqcv.delete_Matx_MulOp

# Register Matx_MulOp in _pyaqcv:
_pyaqcv.Matx_MulOp_swigregister(Matx_MulOp)
class Matx_DivOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Matx_DivOp_swiginit(self, _pyaqcv.new_Matx_DivOp(*args))
    __swig_destroy__ = _pyaqcv.delete_Matx_DivOp

# Register Matx_DivOp in _pyaqcv:
_pyaqcv.Matx_DivOp_swigregister(Matx_DivOp)
class Matx_MatMulOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Matx_MatMulOp_swiginit(self, _pyaqcv.new_Matx_MatMulOp(*args))
    __swig_destroy__ = _pyaqcv.delete_Matx_MatMulOp

# Register Matx_MatMulOp in _pyaqcv:
_pyaqcv.Matx_MatMulOp_swigregister(Matx_MatMulOp)
class Matx_TOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Matx_TOp_swiginit(self, _pyaqcv.new_Matx_TOp(*args))
    __swig_destroy__ = _pyaqcv.delete_Matx_TOp

# Register Matx_TOp in _pyaqcv:
_pyaqcv.Matx_TOp_swigregister(Matx_TOp)
class MatConstIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        constructor that sets the iterator to the beginning of the matrix

        |

        *Overload 3:*
        constructor that sets the iterator to the specified element of the matrix

        |

        *Overload 4:*
        constructor that sets the iterator to the specified element of the matrix

        |

        *Overload 5:*
        constructor that sets the iterator to the specified element of the matrix

        |

        *Overload 6:*
        constructor that sets the iterator to the specified element of the matrix copy constructor
        """
        _pyaqcv.MatConstIterator_swiginit(self, _pyaqcv.new_MatConstIterator(*args))

    def __ref__(self):
        r"""returns the current matrix element"""
        return _pyaqcv.MatConstIterator___ref__(self)

    def __iadd__(self, ofs):
        r"""shifts the iterator forward by the specified number of elements"""
        return _pyaqcv.MatConstIterator___iadd__(self, ofs)

    def __isub__(self, ofs):
        r"""shifts the iterator backward by the specified number of elements"""
        return _pyaqcv.MatConstIterator___isub__(self, ofs)

    def pos(self, *args):
        r"""
        *Overload 1:*
        returns the current iterator position

        |

        *Overload 2:*
        returns the current iterator position
        """
        return _pyaqcv.MatConstIterator_pos(self, *args)

    def lpos(self):
        return _pyaqcv.MatConstIterator_lpos(self)

    def seek(self, *args):
        return _pyaqcv.MatConstIterator_seek(self, *args)
    __swig_destroy__ = _pyaqcv.delete_MatConstIterator
    m = property(_pyaqcv.MatConstIterator_m_get, _pyaqcv.MatConstIterator_m_set)
    elem_size = property(_pyaqcv.MatConstIterator_elem_size_get, _pyaqcv.MatConstIterator_elem_size_set)
    ptr = property(_pyaqcv.MatConstIterator_ptr_get, _pyaqcv.MatConstIterator_ptr_set)
    slice_start = property(_pyaqcv.MatConstIterator_slice_start_get, _pyaqcv.MatConstIterator_slice_start_set)
    slice_end = property(_pyaqcv.MatConstIterator_slice_end_get, _pyaqcv.MatConstIterator_slice_end_set)

# Register MatConstIterator in _pyaqcv:
_pyaqcv.MatConstIterator_swigregister(MatConstIterator)
class NAryMatIterator(object):
    r"""
     n-ary multi-dimensional array iterator.

    Use the class to implement unary, binary, and, generally, n-ary element-wise operations on
    multi-dimensional arrays. Some of the arguments of an n-ary function may be continuous arrays, some
    may be not. It is possible to use conventional MatIterator 's for each array but incrementing all of
    the iterators after each small operations may be a big overhead. In this case consider using
    NAryMatIterator to iterate through several matrices simultaneously as long as they have the same
    geometry (dimensionality and all the dimension sizes are the same). On each iteration `it.planes[0]`,
    `it.planes[1]`,... will be the slices of the corresponding matrices.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        the default constructor

        |

        *Overload 2:*
        the full constructor taking arbitrary number of n-dim matrices

        |

        *Overload 3:*
        the full constructor taking arbitrary number of n-dim matrices

        |

        *Overload 4:*
        the full constructor taking arbitrary number of n-dim matrices

        |

        *Overload 5:*
        the full constructor taking arbitrary number of n-dim matrices
        """
        _pyaqcv.NAryMatIterator_swiginit(self, _pyaqcv.new_NAryMatIterator(*args))

    def init(self, arrays, planes, ptrs, narrays=-1):
        r"""the separate iterator initialization method"""
        return _pyaqcv.NAryMatIterator_init(self, arrays, planes, ptrs, narrays)
    __swig_destroy__ = _pyaqcv.delete_NAryMatIterator
    arrays = property(_pyaqcv.NAryMatIterator_arrays_get, _pyaqcv.NAryMatIterator_arrays_set, doc=r"""the iterated arrays""")
    planes = property(_pyaqcv.NAryMatIterator_planes_get, _pyaqcv.NAryMatIterator_planes_set, doc=r"""the current planes""")
    ptrs = property(_pyaqcv.NAryMatIterator_ptrs_get, _pyaqcv.NAryMatIterator_ptrs_set, doc=r"""data pointers""")
    narrays = property(_pyaqcv.NAryMatIterator_narrays_get, _pyaqcv.NAryMatIterator_narrays_set, doc=r"""the number of arrays""")
    nplanes = property(_pyaqcv.NAryMatIterator_nplanes_get, _pyaqcv.NAryMatIterator_nplanes_set, doc=r"""the number of hyper-planes that the iterator steps through""")
    size = property(_pyaqcv.NAryMatIterator_size_get, _pyaqcv.NAryMatIterator_size_set, doc=r"""the size of each segment (in elements)""")

# Register NAryMatIterator in _pyaqcv:
_pyaqcv.NAryMatIterator_swigregister(NAryMatIterator)

def __eq__(*args):
    return _pyaqcv.__eq__(*args)

def __ne__(*args):
    return _pyaqcv.__ne__(*args)

def __lt__(*args):
    return _pyaqcv.__lt__(*args)

def __gt__(*args):
    return _pyaqcv.__gt__(*args)

def __le__(*args):
    return _pyaqcv.__le__(*args)

def __ge__(*args):
    return _pyaqcv.__ge__(*args)

def __add__(*args):
    return _pyaqcv.__add__(*args)

def __sub__(*args):
    return _pyaqcv.__sub__(*args)

def swap(*args):
    r"""Swaps two matrices"""
    return _pyaqcv.swap(*args)
kBorderConstant = _pyaqcv.kBorderConstant
r"""`iiiiii|abcdefgh|iiiiiii`  with some specified `i`"""
kBorderReplicate = _pyaqcv.kBorderReplicate
r"""`aaaaaa|abcdefgh|hhhhhhh`"""
kBorderReflect = _pyaqcv.kBorderReflect
r"""`fedcba|abcdefgh|hgfedcb`"""
kBorderWrap = _pyaqcv.kBorderWrap
r"""`cdefgh|abcdefgh|abcdefg`"""
kBorderReflect101 = _pyaqcv.kBorderReflect101
r"""`gfedcb|abcdefgh|gfedcba`"""
kBorderTransparent = _pyaqcv.kBorderTransparent
r"""`uvwxyz|abcdefgh|ijklmno`"""
kBorderReflect_101 = _pyaqcv.kBorderReflect_101
r"""same as kBorderReflect101"""
kBorderDefault = _pyaqcv.kBorderDefault
r"""same as kBorderReflect101"""
kBorderIsolated = _pyaqcv.kBorderIsolated
r"""do not look outside of ROI"""

def border_interpolate(p, len, type):
    r"""
     Computes the source location of an extrapolated pixel.

    The function computes and returns the coordinate of a donor pixel corresponding to the specified
    extrapolated pixel when using the specified extrapolation border mode. For example, if you use
    aqcv::kBorderWrap mode in the horizontal direction, aqcv::kBorderReflect_101 in the vertical direction and
    want to compute value of the "virtual" pixel Point(-5, 100) in a floating-point image img , it
    looks like:

    .. code-block:: c++

            float val = img.at<float>(border_interpolate(100, img.rows, aqcv::kBorderReflect_101),
                                      border_interpolate(-5, img.cols, aqcv::kBorderWrap));
    Normally, the function is not called directly. It is used inside filtering functions and also in
    copy_make_border.
    :type p: int
    :param p: 0-based coordinate of the extrapolated pixel along one of the axes, likely <0 or >= len
    :type len: int
    :param len: Length of the array along the corresponding axis.
    :type type: int
    :param type: Border type, one of the #BorderTypes, except for #kBorderTransparent and
        #kBorderIsolated . When borderType==#kBorderConstant , the function always returns -1, regardless
        of p and len.

    See also: copy_make_border
    """
    return _pyaqcv.border_interpolate(p, len, type)

def copy_make_border(*args):
    r"""
     Forms a border around an image.

    The function copies the source image into the middle of the destination image. The areas to the
    left, to the right, above and below the copied source image will be filled with extrapolated
    pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but
    what other more complex functions, including your own, may do to simplify image boundary handling.

    The function supports the mode when src is already in the middle of dst . In this case, the
    function does not copy src itself but simply constructs the border, for example:

    Notes: When the source image is a part (ROI) of a bigger image, the function will try to use the
    pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as
    if src was not a ROI, use borderType | #kBorderIsolated.

    :type src: :py:class:`Mat`
    :param src: Source image.
    :type dst: :py:class:`Mat`
    :param dst: Destination image of the same type as src and the size Size(src.cols+left+right,
        src.rows+top+bottom) .
    :type top: int
    :param top: the top pixels
    :type bottom: int
    :param bottom: the bottom pixels
    :type left: int
    :param left: the left pixels
    :type right: int
    :param right: Parameter specifying how many pixels in each direction from the source image rectangle
        to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs
        to be built.
    :type type: int
    :param type: Border type. See border_interpolate for details.
    :type value: :py:class:`Scalar`, optional
    :param value: Border value if borderType==kBorderConstant .

    See also: border_interpolate
    """
    return _pyaqcv.copy_make_border(*args)

def add(*args):
    r"""
     Calculates the per-element sum of two arrays or an array and a scalar.

    The function add calculates:
    - Sum of two arrays when both input arrays have the same size and the same number of channels:

     .. math::

         \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0
    - Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
    elements as `src1.channels()`:

     .. math::

         \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0
    - Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
    elements as `src2.channels()`:

     .. math::

         \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0
    where `I` is a multi-dimensional index of array elements. In case of multi-channel arrays, each
    channel is processed independently.

    The first function in the list above can be replaced with matrix expressions:

    .. code-block:: c++

            dst = src1 + src2;
            dst += src1; // equivalent to add(dst, src1, dst);
    The input arrays and the output array can all have the same or different depths. For example, you
    can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
    floating-point array. Depth of the output array is determined by the dtype parameter. In the second
    and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
    be set to the default -1. In this case, the output array will have the same depth as the input
    array, be it src1, src2 or both.
    Notes: Saturation is not applied when the output array has the depth AQ_32S. You may even get
    result of an incorrect sign in the case of overflow.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array or a scalar.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array or a scalar.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array that has the same size and number of channels as the input array(s); the
        depth is defined by dtype or src1/src2.
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask - 8-bit single channel array, that specifies elements of the
        output array to be changed.
    :type dtype: int, optional
    :param dtype: optional depth of the output array (see the discussion below).
    See also: subtract, add_weighted, scale_add, Mat::convert_to
    """
    return _pyaqcv.add(*args)

def subtract(*args):
    r"""
     Calculates the per-element difference between two arrays or array and a scalar.

    The function subtract calculates:
    - Difference between two arrays, when both input arrays have the same size and the same number of
    channels:

         .. math::

             \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0
    - Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
    number of elements as `src1.channels()`:

         .. math::

             \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0
    - Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
    number of elements as `src2.channels()`:

         .. math::

             \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0
    - The reverse difference between a scalar and an array in the case of `SubRS`:

         .. math::

             \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0
    where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
    channel is processed independently.

    The first function in the list above can be replaced with matrix expressions:

    .. code-block:: c++

            dst = src1 - src2;
            dst -= src1; // equivalent to subtract(dst, src1, dst);
    The input arrays and the output array can all have the same or different depths. For example, you
    can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
    the output array is determined by dtype parameter. In the second and third cases above, as well as
    in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
    case the output array will have the same depth as the input array, be it src1, src2 or both.
    Notes: Saturation is not applied when the output array has the depth AQ_32S. You may even get
    result of an incorrect sign in the case of overflow.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array or a scalar.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array or a scalar.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of the same size and the same number of channels as the input array.
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask; this is an 8-bit single channel array that specifies elements
        of the output array to be changed.
    :type dtype: int, optional
    :param dtype: optional depth of the output array
    See also: add, add_weighted, scale_add, Mat::convert_to
    """
    return _pyaqcv.subtract(*args)

def multiply(src1, src2, dst, scale=1, dtype=-1):
    r"""
     Calculates the per-element scaled product of two arrays.

    The function multiply calculates the per-element product of two arrays:

     .. math::

         \texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))

    There is also a 'MatrixExpressions' -friendly variant of the first function. See Mat::mul .

    For a not-per-element matrix product, see gemm .

    Notes: Saturation is not applied when the output array has the depth
    AQ_32S. You may even get result of an incorrect sign in the case of
    overflow.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array of the same size and the same type as src1.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of the same size and type as src1.
    :type scale: float, optional
    :param scale: optional scale factor.
    :type dtype: int, optional
    :param dtype: optional depth of the output array
    See also: add, subtract, divide, scale_add, add_weighted, accumulate, accumulateProduct, accumulateSquare,
    Mat::convert_to
    """
    return _pyaqcv.multiply(src1, src2, dst, scale, dtype)

def divide(*args):
    r"""
     Performs per-element division of two arrays or a scalar by an array.

    The function aqcv::divide divides one array by another:

     .. math::

         \texttt{dst(I) = saturate(src1(I)*scale/src2(I))}
    or a scalar by an array when there is no src1 :

     .. math::

         \texttt{dst(I) = saturate(scale/src2(I))}

    Different channels of multi-channel arrays are processed independently.

    For integer types when src2(I) is zero, dst(I) will also be zero.

    Notes: In case of floating point data there is no special defined behavior for zero src2(I) values.
    Regular floating-point division is used.
    Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).

    Saturation is not applied when the output array has the depth AQ_32S. You may even get
    result of an incorrect sign in the case of overflow.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array of the same size and type as src1.
    :type scale: float, optional
    :param scale: scalar factor.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of the same size and type as src2.
    :type dtype: int, optional
    :param dtype: optional depth of the output array; if -1, dst will have depth src2.depth(), but in
        case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().
    See also: multiply, add, subtract
    """
    return _pyaqcv.divide(*args)

def add_weighted(src1, alpha, src2, beta, gamma, dst, dtype=-1):
    r"""
     Calculates the weighted sum of two arrays.

    The function add_weighted calculates the weighted sum of two arrays as follows:

     .. math::

         \texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )
    where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
    channel is processed independently.
    The function can be replaced with a matrix expression:

    .. code-block:: c++

            dst = src1*alpha + src2*beta + gamma;
    Notes: Saturation is not applied when the output array has the depth AQ_32S. You may even get
    result of an incorrect sign in the case of overflow.
    :type src1: :py:class:`Mat`
    :param src1: first input array.
    :type alpha: float
    :param alpha: weight of the first array elements.
    :type src2: :py:class:`Mat`
    :param src2: second input array of the same size and channel number as src1.
    :type beta: float
    :param beta: weight of the second array elements.
    :type gamma: float
    :param gamma: scalar added to each sum.
    :type dst: :py:class:`Mat`
    :param dst: output array that has the same size and number of channels as the input arrays.
    :type dtype: int, optional
    :param dtype: optional depth of the output array; when both input arrays have the same depth, dtype
        can be set to -1, which will be equivalent to src1.depth().
    See also: add, subtract, scale_add, Mat::convert_to
    """
    return _pyaqcv.add_weighted(src1, alpha, src2, beta, gamma, dst, dtype)

def scale_add(src1, alpha, src2, dst):
    r"""
     Calculates the sum of a scaled array and another array.

    The function scale_add is one of the classical primitive linear algebra operations, known as DAXPY
    or SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates
    the sum of a scaled array and another array:

     .. math::

         \texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) +  \texttt{src2} (I)
    The function can also be emulated with a matrix expression, for example:

    .. code-block:: c++

            Mat A(3, 3, AQ_64F);
            ...
            A.row(0) = A.row(1)*2 + A.row(2);
    :type src1: :py:class:`Mat`
    :param src1: first input array.
    :type alpha: float
    :param alpha: scale factor for the first array.
    :type src2: :py:class:`Mat`
    :param src2: second input array of the same size and type as src1.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src1.
    See also: add, add_weighted, subtract, Mat::dot, Mat::convert_to
    """
    return _pyaqcv.scale_add(src1, alpha, src2, dst)

def convert_scale_abs(src, dst, alpha=1, beta=0):
    r"""
     Scales, calculates absolute values, and converts the result to 8-bit. dst = abs(src * alpha + beta)

    On each element of the input array, the function convert_scale_abs
    performs three operations sequentially: scaling, taking an absolute
    value, conversion to an unsigned 8-bit type:

     .. math::

         \texttt{dst} (I)= \texttt{saturate\_cast<uchar>} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)
    In case of multi-channel arrays, the function processes each channel
    independently. When the output is not 8-bit, the operation can be
    emulated by calling the Mat::convert_to method (or by using matrix
    expressions) and then by calculating an absolute value of the result.
    For example:

    .. code-block:: c++

            Mat_<float> A(30,30);
            randu(A, Scalar(-100), Scalar(100));
            Mat_<float> B = A*5 + 3;
            B = abs(B);
        Mat_<float> B = abs(A*5+3) will also do the job,
        but it will allocate a temporary matrix
        Same as convert_scale_abs(A,B,5,3);
    :type src: :py:class:`Mat`
    :param src: input array.
    :type dst: :py:class:`Mat`
    :param dst: output array.
    :type alpha: float, optional
    :param alpha: optional scale factor.
    :type beta: float, optional
    :param beta: optional delta added to the scaled values.
    See also: Mat::convert_to, aqcv::abs(const Mat&)
    """
    return _pyaqcv.convert_scale_abs(src, dst, alpha, beta)

def lut(src, lut, dst):
    r"""
     Performs a look-up table transform of an array.

    The function lut fills the output array with values from the look-up table. Indices of the entries
    are taken from the input array. That is, the function processes each element of src as follows:

     .. math::

         \texttt{dst} (I)  \leftarrow \texttt{lut(src(I) + d)}
    where

     .. math::

         \texttt{d} =\begin{cases}\texttt{0}&{ \texttt{if src has depth AQ_8U}}\\\texttt{128}&{ \texttt{if src has depth AQ_8S}  }\end{cases}
    :type src: :py:class:`Mat`
    :param src: input array of 8-bit elements.
    :type lut: :py:class:`Mat`
    :param lut: look-up table of 256 elements; in case of multi-channel input array, the table should
        either have a single channel (in this case the same table is used for all channels) or the same
        number of channels as in the input array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and number of channels as src, and the same depth as lut.
    See also: convert_scale_abs, Mat::convert_to
    """
    return _pyaqcv.lut(src, lut, dst)

def count_non_zero(src):
    r"""
     Counts non-zero array elements.

    The function returns the number of non-zero elements in src :

     .. math::

         \sum _{I: \; \texttt{src} (I) \ne0 } 1
    :type src: :py:class:`Mat`
    :param src: single-channel array.
    See also: mean, mean_std_dev, norm, min_max_loc, calc_covar_matrix
    """
    return _pyaqcv.count_non_zero(src)

def find_non_zero(src, idx):
    r"""
     Returns the list of locations of non-zero pixels

    Given a binary matrix (likely returned from an operation such
    as threshold(), compare(), >, ==, etc, return all of the non-zero
    indices as a aqcv::Mat.
    For example:

    .. code-block:: c++

            aqcv::Mat binaryImage; // input, binary image
            aqcv::Mat locations;   // output, locations of non-zero pixels
            aqcv::find_non_zero(binaryImage, locations);

        access pixel coordinates
            Point pnt = locations.at<Point>(i);
    :type src: :py:class:`Mat`
    :param src: single-channel array
    :type idx: :py:class:`Mat`
    :param idx: the output array, type of aqcv::Mat corresponding to non-zero indices in the input
    """
    return _pyaqcv.find_non_zero(src, idx)

def sum(*args):
    r"""
    *Overload 1:*
     Calculates the sum of array elements.

    The function aqcv::sum calculates and returns the sum of array elements,
    independently for each channel.
    :type src: :py:class:`Mat`
    :param src: input array that must have from 1 to 4 channels.
    :type mask: :py:class:`Mat`, optional
    :param mask: optional operation mask.
    See also: count_non_zero, mean, mean_std_dev, norm, min_max_loc, reduce


    |

    *Overload 2:*
     overload See also: sum.
    :type src: :py:class:`Mat`
    :param src: input image to compute sum. Only AQ_8UC1, AQ_8UC3, AQ_8UC4, AQ_16UC1 are supported now
    :type regions: :py:class:`MultiPolygon2i`
    :param regions: regions to compute sum, regions should be the boundary of pixels(only pixels in the regions will be considered).
        only regions in the image area will be considered.
    """
    return _pyaqcv.sum(*args)

def mean(*args):
    r"""
    *Overload 1:*
     Calculates an average (mean) of array elements.

    The function aqcv::mean calculates the mean value M of array elements,
    independently for each channel, and return it:

     .. math::

         \begin{array}{l} N =  \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \\ M_c =  \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}
    When all the mask elements are 0's, the function returns Scalar::all(0)
    :type src: :py:class:`Mat`
    :param src: input array that should have from 1 to 4 channels so that the result can be stored in
        Scalar_ .
    :type mask: :py:class:`Mat`, optional
    :param mask: optional operation mask.
    See also: count_non_zero, mean_std_dev, norm, min_max_loc


    |

    *Overload 2:*
     overload See also: mean.
    :type src: :py:class:`Mat`
    :param src: input image to compute mean. Only AQ_8UC1, AQ_8UC3, AQ_8UC4, AQ_16UC1 are supported now
    :type regions: :py:class:`MultiPolygon2i`
    :param regions: regions to compute mean, regions should be the boundary of pixels(only pixels in the regions will be considered).
        only regions in the image area will be considered.
    """
    return _pyaqcv.mean(*args)

def mean_std_dev(*args):
    r"""
    *Overload 1:*
     Calculates a mean and standard deviation of array elements.

    The function aqcv::mean_std_dev calculates the mean and the standard deviation M
    of array elements independently for each channel and returns it via the
    output parameters:

     .. math::

         \begin{array}{l} N =  \sum _{I, \texttt{mask} (I)  \ne 0} 1 \\ \texttt{mean} _c =  \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \\ \texttt{stddev} _c =  \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array}
    When all the mask elements are 0's, the function returns
    mean and stddev with all zeros.
    Notes: The calculated standard deviation is only the diagonal of the
    complete normalized covariance matrix. If the full matrix is needed, you
    can reshape the multi-channel array M x N to the single-channel array
    M*N x mtx.channels() (only possible when the matrix is continuous) and
    then pass the matrix to calc_covar_matrix .
    :type src: :py:class:`Mat`
    :param src: input array.
    :type mean: :py:class:`Mat`
    :param mean: output parameter: calculated mean value in AQ_64F, n x 1 continuous matrix (n=channels of src).
    :type stddev: :py:class:`Mat`
    :param stddev: output parameter: calculated standard deviation in AQ_64F, n x 1 continuous matrix (n=channels of src).
    :type mask: :py:class:`Mat`, optional
    :param mask: optional operation mask.
    See also: count_non_zero, mean, norm, min_max_loc, calc_covar_matrix


    |

    *Overload 2:*
     overload See also: mean_std_dev.
    :type src: :py:class:`Mat`
    :param src: input image to compute mean and standard deviation. Only AQ_8UC1, AQ_8UC3, AQ_8UC4, AQ_16UC1 are supported now
    :type mean: :py:class:`Scalar`
    :param mean: output mean of each channel.
    :type stddev: :py:class:`Scalar`
    :param stddev: output standard deviation of each channel.
    :type regions: :py:class:`MultiPolygon2i`
    :param regions: regions to compute, regions should be the boundary of pixels(only pixels in the regions will be considered).
        only regions in the image area will be considered.
    """
    return _pyaqcv.mean_std_dev(*args)

def norm(*args):
    r"""
    *Overload 1:*
     Calculates the absolute norm of an array.

    This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.

    As example for one array consider the function  :math:`r(x)= \begin{pmatrix} x \\ 1-x \end{pmatrix}, x \in [-1;1]` .
    The  :math:`L_{1}, L_{2}`  and  :math:`L_{\infty}`  norm for the sample value  :math:`r(-1) = \begin{pmatrix} -1 \\ 2 \end{pmatrix}`
    is calculated as follows
    *}
        | r(-1) |_{L_1} &= |-1| + |2| = 3 \
        | r(-1) |_{L_2} &= (-1)^{2} + (2)^{2}} = \
        | r(-1) |_{L_&= (|-1|,|2|) = 2

    and for  :math:`r(0.5) = \begin{pmatrix} 0.5 \\ 0.5 \end{pmatrix}`  the calculation is
    *}
        | r(0.5) |_{L_1} &= |0.5| + |0.5| = 1 \
        | r(0.5) |_{L_2} &= (0.5)^{2} + (0.5)^{2}} = .5} \
        | r(0.5) |_{L_&= (|0.5|,|0.5|) = 0.5.

    The following graphic shows all values for the three norm functions  :math:`\| r(x) \|_{L_1}, \| r(x) \|_{L_2}`  and  :math:`\| r(x) \|_{L_\infty}` .
    It is notable that the  :math:`L_{1}`  norm forms the upper and the  :math:`L_{\infty}`  norm forms the lower border for the example function  :math:`r(x)` .
    [Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)

    When the mask parameter is specified and it is not empty, the norm is

    If norm_type is not specified, #kNormL2 is used.
    calculated only over the region specified by the mask.

    Multi-channel input arrays are treated as single-channel arrays, that is,
    the results for all channels are combined.

    Hamming norms can only be calculated with AQ_8U depth arrays.

    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type norm_type: int, optional
    :param norm_type: type of the norm (see #NormTypes).
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask; it must have the same size as src1 and AQ_8UC1 type.


    |

    *Overload 2:*
     Calculates an absolute difference norm or a relative difference norm.

    This version of aqcv::norm calculates the absolute difference norm
    or the relative difference norm of arrays src1 and src2.
    The type of norm to calculate is specified using #NormTypes.

    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array of the same size and the same type as src1.
    :type norm_type: int, optional
    :param norm_type: type of the norm (see #NormTypes).
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask; it must have the same size as src1 and AQ_8UC1 type.


    |

    *Overload 3:*
     Calculates an absolute difference norm or a relative difference norm.

    This version of aqcv::norm calculates the absolute difference norm
    or the relative difference norm of arrays src1 and src2.
    The type of norm to calculate is specified using #NormTypes.

    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array of the same size and the same type as src1.
    :type norm_type: int, optional
    :param norm_type: type of the norm (see #NormTypes).
    :param mask: optional operation mask; it must have the same size as src1 and AQ_8UC1 type.


    |

    *Overload 4:*
     Calculates an absolute difference norm or a relative difference norm.

    This version of aqcv::norm calculates the absolute difference norm
    or the relative difference norm of arrays src1 and src2.
    The type of norm to calculate is specified using #NormTypes.

    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array of the same size and the same type as src1.
    :param norm_type: type of the norm (see #NormTypes).
    :param mask: optional operation mask; it must have the same size as src1 and AQ_8UC1 type.
    """
    return _pyaqcv.norm(*args)

def normalize(*args):
    r"""
     Normalizes the norm or value range of an array.

    The function aqcv::normalize normalizes scale and shift the input array elements so that

     .. math::

         \| \texttt{dst} \| _{L_p}= \texttt{alpha}
    (where p=Inf, 1 or 2) when norm_type=kNormInf, kNormL1, or kNormL2, respectively; or so that

     .. math::

         \min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}

    when norm_type=kNormMinMax (for dense arrays only). The optional mask specifies a sub-array to be
    normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
    sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
    min-max but modify the whole array, you can use norm and Mat::convert_to.

    In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
    the range transformation for sparse matrices is not allowed since it can shift the zero level.

    Possible usage with some positive example data:

    .. code-block:: c++

            vector<double> positiveData = { 2.0, 8.0, 10.0 };
            vector<double> normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

        Norm to probability (total count)
        sum(numbers) = 20.0
        2.0      0.1     (2.0/20.0)
        8.0      0.4     (8.0/20.0)
        10.0     0.5     (10.0/20.0)
            normalize(positiveData, normalizedData_l1, 1.0, 0.0, kNormL1);

        Norm to unit vector: ||positiveData|| = 1.0
        2.0      0.15
        8.0      0.62
        10.0     0.77
            normalize(positiveData, normalizedData_l2, 1.0, 0.0, kNormL2);

        Norm to max element
        2.0      0.2     (2.0/10.0)
        8.0      0.8     (8.0/10.0)
        10.0     1.0     (10.0/10.0)
            normalize(positiveData, normalizedData_inf, 1.0, 0.0, kNormInf);

        Norm to range [0.0;1.0]
        2.0      0.0     (shift to left border)
        8.0      0.75    (6.0/8.0)
        10.0     1.0     (shift to right border)
            normalize(positiveData, normalizedData_minmax, 1.0, 0.0, kNormMinMax);

    :type src: :py:class:`_InputArray`
    :param src: input array.
    :type dst: :py:class:`_InputOutputArray`
    :param dst: output array of the same size as src .
    :type alpha: float, optional
    :param alpha: norm value to normalize to or the lower range boundary in case of the range
        normalization.
    :type beta: float, optional
    :param beta: upper range boundary in case of the range normalization; it is not used for the norm
        normalization.
    :type norm_type: int, optional
    :param norm_type: normalization type (see aqcv::NormTypes).
    :type dtype: int, optional
    :param dtype: when negative, the output array has the same type as src; otherwise, it has the same
        number of channels as src and the depth =AQ_MAT_DEPTH(dtype).
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask.
    See also: norm, Mat::convert_to
    """
    return _pyaqcv.normalize(*args)

def psnr(src1, src2, R=255.):
    r"""
     Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.

    This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB),
    between two input arrays src1 and src2. The arrays must have the same type.

    The PSNR is calculated as follows:

     .. math::

         \texttt{PSNR} = 10 \cdot \log_{10}{\left( \frac{R^2}{MSE} \right) }

    where R is the maximum integer value of depth (e.g. 255 in the case of AQ_8U data)
    and MSE is the mean squared error between the two arrays.

    :type src1: :py:class:`Mat`
    :param src1: first input array.
    :type src2: :py:class:`Mat`
    :param src2: second input array of the same size as src1.
    :type R: float, optional
    :param R: the maximum pixel value (255 by default)

    """
    return _pyaqcv.psnr(src1, src2, R)

def batch_distance(*args):
    r"""
     naive nearest neighbor finder

    The function aqcv::batch_distance calculates norm between query descriptors and template
    descriptors.

    :type src1: :py:class:`Mat`
    :param src1: query descriptors with type AQ_8U or AQ_32F, rows mean the number of query
        descriptors and cols mean the number of features.
    :type src2: :py:class:`Mat`
    :param src2: template descriptors, it must have the same type and cols as src1, rows mean
        the number of template descriptors.
    :type dist: :py:class:`Mat`
    :param dist: output matrix of distance between query descriptors and template descriptors, dist(i, j)
        means the norm of i th query descriptor and j th template descriptor.
    :type dtype: int
    :param dtype: depth of the output array, should be AQ_32S when src is AQ_8U, and AQ_32F when src is AQ_32F.
        when -1, it's AQ_32S when you use hamming norm, otherwise it's AQ_32F.
    :type nidx: :py:class:`_OutputArray`
    :param nidx: output matrix of index, when K > 0, it has the same size with dist and in AQ_32S, indicates
        the index of nearest K neighbors for each query descriptor. if K = 0, use aqcv::no_array().
    :type norm_type: int, optional
    :param norm_type: normalization type (see aqcv::NormTypes).
    :type K: int, optional
    :param K: the number of nearest neighbors to calculate. when 0 < K < src2.rows, dist is a src1.rows x K
        matrix, otherwise it calculate all neighbors of query descriptors.
    :type mask: :py:class:`Mat`, optional
    :param mask: optional operation mask, 8-bit single channel array, only non-zero pixel of mask is considered.
    :type update: int, optional
    :param update: use update = 0 for now.
    :type crosscheck: boolean, optional
    :param crosscheck: if do crosscheck. if an idx-th element from src1 appeared to be the nearest to i-th element
        of src2, we update the minimum mutual distance between idx-th element of src1 and the whole src2 set.
        As a result, if nidx[idx] = i*, it means that idx-th element of src1 is the nearest to i*-th element of src2
        and i*-th element of src2 is the closest to idx-th element of src1. If nidx[idx] = -1, it means that there
        is no such ideal couple for it in src2. This O(2N) procedure is called cross-check and it helps to eliminate
        some false matches.
    """
    return _pyaqcv.batch_distance(*args)

def min_max_loc(*args):
    r"""
     Finds the global minimum and maximum in an array.

    The function aqcv::min_max_loc finds the minimum and maximum element values and their positions. The
    extremums are searched across the whole array or, if mask is not an empty array, in the specified
    array region.

    The function do not work with multi-channel arrays. If you need to find minimum or maximum
    elements across all the channels, use Mat::reshape first to reinterpret the array as
    single-channel. Or you may extract the particular channel using either extract_channel, or
    mix_channels, or split.
    :type src: :py:class:`Mat`
    :param src: input single-channel array.
    :type min_val: float
    :param min_val: pointer to the returned minimum value; NULL is used if not required.
    :type max_val: float, optional
    :param max_val: pointer to the returned maximum value; NULL is used if not required.
    :type min_loc: :py:class:`Point`, optional
    :param min_loc: pointer to the returned minimum location (in 2D case); NULL is used if not required.
    :type max_loc: :py:class:`Point`, optional
    :param max_loc: pointer to the returned maximum location (in 2D case); NULL is used if not required.
    :type mask: :py:class:`Mat`, optional
    :param mask: optional mask used to select a sub-array.
    See also: max, min, compare, in_range, extract_channel, mix_channels, split, Mat::reshape
    """
    return _pyaqcv.min_max_loc(*args)

def min_max_idx(*args):
    r"""
     Finds the global minimum and maximum in an array

    The function aqcv::min_max_idx finds the minimum and maximum element values and their positions. The
    extremums are searched across the whole array or, if mask is not an empty array, in the specified
    array region. The function does not work with multi-channel arrays. If you need to find minimum or
    maximum elements across all the channels, use Mat::reshape first to reinterpret the array as
    single-channel. Or you may extract the particular channel using either extract_channel , or
    mix_channels , or split . In case of a sparse matrix, the minimum is found among non-zero elements
    only.
    Notes: When min_idx is not NULL, it must have at least 2 elements (as well as max_idx), even if src is
    a single-row or single-column matrix. In aqcv (following MATLAB) each array has at least 2
    dimensions, i.e. single-column matrix is Mx1 matrix (and therefore min_idx/max_idx will be
    (i1,0)/(i2,0)) and single-row matrix is 1xN matrix (and therefore min_idx/max_idx will be
    (0,j1)/(0,j2)).
    :type src: :py:class:`Mat`
    :param src: input single-channel array.
    :type min_val: float
    :param min_val: pointer to the returned minimum value; NULL is used if not required.
    :type max_val: float, optional
    :param max_val: pointer to the returned maximum value; NULL is used if not required.
    :type min_idx: int, optional
    :param min_idx: pointer to the returned minimum location (in nD case); NULL is used if not required;
        Otherwise, it must point to an array of src.dims elements, the coordinates of the minimum element
        in each dimension are stored there sequentially.
    :type max_idx: int, optional
    :param max_idx: pointer to the returned maximum location (in nD case). NULL is used if not required.
    :type mask: :py:class:`Mat`, optional
    :param mask: specified array region
    """
    return _pyaqcv.min_max_idx(*args)
kReduceSum = _pyaqcv.kReduceSum
r"""the output is the sum of all rows/columns of the matrix."""
kReduceAvg = _pyaqcv.kReduceAvg
r"""the output is the mean vector of all rows/columns of the matrix."""
kReduceMax = _pyaqcv.kReduceMax
r"""the output is the maximum (column/row-wise) of all rows/columns of the matrix."""
kReduceMin = _pyaqcv.kReduceMin
r"""the output is the minimum (column/row-wise) of all rows/columns of the matrix."""

def reduce(src, dst, dim, rtype, dtype=-1):
    r"""
     Reduces a matrix to a vector.

    The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of
    1D vectors and performing the specified operation on the vectors until a single row/column is
    obtained. For example, the function can be used to compute horizontal and vertical projections of a
    raster image. In case of #kReduceMax and #kReduceMin , the output image should have the same type as the source one.
    In case of #kReduceSum and #kReduceAvg, the output may have a larger element bit-depth to preserve accuracy.
    And multi-channel arrays are also supported in these two reduction modes.

    :type src: :py:class:`Mat`
    :param src: input 2D matrix.
    :type dst: :py:class:`Mat`
    :param dst: output vector. Its size and type is defined by dim and dtype parameters.
    :type dim: int
    :param dim: dimension index along which the matrix is reduced. 0 means that the matrix is reduced to
        a single row. 1 means that the matrix is reduced to a single column.
    :type rtype: int
    :param rtype: reduction operation that could be one of #ReduceTypes
    :type dtype: int, optional
    :param dtype: when negative, the output vector will have the same type as the input matrix,
        otherwise, its type will be AQ_MAKE_TYPE(AQ_MAT_DEPTH(dtype), src.channels()).
    See also: repeat
    """
    return _pyaqcv.reduce(src, dst, dim, rtype, dtype)

def merge(mv, dst):
    r"""
     Creates one multi-channel array out of several single-channel ones.

    The function aqcv::merge merges several arrays to make a single multi-channel array. That is, each
    element of the output array will be a concatenation of the elements of the input arrays, where
    elements of i-th input array are treated as mv[i].channels()-element vectors.

    The function aqcv::split does the reverse operation. If you need to shuffle channels in some other
    advanced way, use aqcv::mix_channels.

    :type mv: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
    :param mv: input vector of matrices to be merged; all the matrices in mv must have the same
        size and the same depth.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and the same depth as mv[0]; The number of channels will
        be the total number of channels in the matrix array.
    See also: mix_channels, split, Mat::reshape
    """
    return _pyaqcv.merge(mv, dst)

def split(src, mv):
    r"""
     Divides a multi-channel array into several single-channel arrays.

    The function aqcv::split splits a multi-channel array into separate single-channel arrays:

     .. math::

         \texttt{mv} [c](I) =  \texttt{src} (I)_c
    If you need to extract a single channel or do some other sophisticated channel permutation, use
    aqcv::mix_channels.

    :type src: :py:class:`Mat`
    :param src: input multi-channel array.
    :type mv: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
    :param mv: output vector of arrays; the arrays themselves are reallocated, if needed.
    See also: merge, mix_channels, cvt_color
    """
    return _pyaqcv.split(src, mv)

def mix_channels(*args):
    r"""
    *Overload 1:*
     Copies specified channels from input arrays to the specified channels of
    output arrays.

    The function aqcv::mix_channels provides an advanced mechanism for shuffling image channels.

    aqcv::split,aqcv::merge,aqcv::extract_channel,aqcv::insert_channel and some forms of aqcv::cvt_color
    are partial cases of aqcv::mix_channels.

    In the example below, the code splits a 4-channel BGRA image into a 3-channel BGR (with B and R
    channels swapped) and a separate alpha-channel image:

    .. code-block:: c++

            Mat bgra( 100, 100, AQ_8UC4, Scalar(255,0,0,255) );
            Mat bgr( bgra.rows, bgra.cols, AQ_8UC3 );
            Mat alpha( bgra.rows, bgra.cols, AQ_8UC1 );

        forming an array of matrices is a quite efficient operation,
        because the matrix data is not copied, only the headers
            Mat out[] = { bgr, alpha };
        bgra[0] -> bgr[2], bgra[1] -> bgr[1],
        bgra[2] -> bgr[0], bgra[3] -> alpha[0]
            int from_to[] = { 0,2, 1,1, 2,0, 3,3 };
            mix_channels( &bgra, 1, out, 2, from_to, 4 );
    Notes: Unlike many other new-style C++ functions in aqcv (see the introduction section and
    Mat::create), aqcv::mix_channels requires the output arrays to be pre-allocated before calling the
    function.
    :type src: :py:class:`Mat`
    :param src: input array or vector of matrices; all of the matrices must have the same size and the
        same depth.
    :type nsrcs: int
    :param nsrcs: number of matrices in `src`.
    :type dst: :py:class:`Mat`
    :param dst: output array or vector of matrices; all the matrices **must be allocated**; their size and
        depth must be the same as in `src[0]`.
    :type ndsts: int
    :param ndsts: number of matrices in `dst`.
    :type from_to: int
    :param from_to: array of index pairs specifying which channels are copied and where; from_to[k*2] is
        a 0-based index of the input channel in src, from_to[k*2+1] is an index of the output channel in
        dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to
        src[0].channels()-1, the second input image channels are indexed from src[0].channels() to
        src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image
        channels; as a special case, when from_to[k*2] is negative, the corresponding output channel is
        filled with zero.
    :type npairs: int
    :param npairs: number of index pairs in `from_to`.
    See also: split, merge, extract_channel, insert_channel, cvt_color


    |

    *Overload 2:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.
    :type src: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
    :param src: input vector of matrices; all of the matrices must have the same size and the
        same depth.
    :type dst: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
    :param dst: output vector of matrices; all the matrices **must be allocated**; their size and
        depth must be the same as in src[0].
    :type from_to: std::vector< int,std::allocator< int > >
    :param from_to: vector of index pairs specifying which channels are copied and where; from_to[k*2] is
        a 0-based index of the input channel in src, from_to[k*2+1] is an index of the output channel in
        dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to
        src[0].channels()-1, the second input image channels are indexed from src[0].channels() to
        src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image
        channels; as a special case, when from_to[k*2] is negative, the corresponding output channel is
        filled with zero.
    """
    return _pyaqcv.mix_channels(*args)

def extract_channel(src, dst, coi):
    r"""
     Extracts a single channel from src (coi is 0-based index)
    :type src: :py:class:`Mat`
    :param src: input array
    :type dst: :py:class:`Mat`
    :param dst: output array
    :type coi: int
    :param coi: index of channel to extract
    See also: mix_channels, split
    """
    return _pyaqcv.extract_channel(src, dst, coi)

def insert_channel(src, dst, coi):
    r"""
     Inserts a single channel to dst (coi is 0-based index) (rewrite dst channel, don't add channel)
    :type src: :py:class:`Mat`
    :param src: input array
    :type dst: :py:class:`Mat`
    :param dst: output array
    :type coi: int
    :param coi: index of channel for insertion
    See also: mix_channels, merge
    """
    return _pyaqcv.insert_channel(src, dst, coi)
kVertical = _pyaqcv.kVertical
r"""up down flip"""
kHorizontal = _pyaqcv.kHorizontal
r"""left right"""
kBoth = _pyaqcv.kBoth
r"""left right and up down"""
kFlip45 = _pyaqcv.kFlip45
r"""flip around 45 degree diagonal (same as transpose)"""
kFlip135 = _pyaqcv.kFlip135
r"""flip around 135 degree diagonal (same as kBoth + kFlip45)"""

def flip(src, dst, flip_code):
    r"""
     Flips a 2D array around vertical, horizontal, both axes or diagonal.

    The function aqcv::flip flips the array in one of five different ways (row
    and column indices are 0-based):

     .. math::

         \texttt{dst} _{ij} =
         \left\{
         \begin{array}{l l}
         \texttt{src} _{\texttt{src.rows}-i-1,j} & if\;  \texttt{flip_code} = kVertical \\
         \texttt{src} _{i, \texttt{src.cols}-j-1} & if\;  \texttt{flip_code} = kHorizontal \\
         \texttt{src} _{\texttt{src.rows}-i-1, \texttt{src.cols}-j-1} & if\; \texttt{flip_code} = kBoth \\
         \texttt{src} _{j, i} & if\; \texttt{flip_code} = kFlip45 \\
         \texttt{src} _{\texttt{src.cols}-j-1, \texttt{src.rows}-i-1} & if\; \texttt{flip_code} = kFlip135 \\
         \end{array}
         \right.
    The example scenarios of using the function are the following:
      Vertical flipping of the image (flip_code == kVertical) to switch between
        top-left and bottom-left image origin. This is a typical operation
        in video processing on Microsoft Windows* OS.
      Horizontal flipping of the image with the subsequent horizontal
        shift and absolute difference calculation to check for a
        vertical-axis symmetry (flip_code == kHorizontal).
      Simultaneous horizontal and vertical flipping of the image with
        the subsequent shift and absolute difference calculation to check
        for a central symmetry (flip_code == kBoth).
      Reversing the order of point arrays (flip_code == kHorizontal or flip_code == kBoth).
    :type src: :py:class:`Mat`
    :param src: input array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src.
    :type flip_code: int
    :param flip_code: a flag to specify how to flip the array; kVertical means flipping around
        the x-axis and kHorizontal means flipping around y-axis. kBoth means flipping around both axes.
        kFlip45 and kFlip135 means flipping around 45 or 135 degree diagonal.
    Notes: For now, kFlip135 only supports Mat with elem_size <= 4.
    See also: transpose, repeat, complete_symm
    """
    return _pyaqcv.flip(src, dst, flip_code)

def repeat(*args):
    r"""
     Fills the output array with repeated copies of the input array.

    The function aqcv::repeat duplicates the input array one or more times along each of the two axes:

     .. math::

         \texttt{dst} _{ij}= \texttt{src} _{i\mod src.rows, \; j\mod src.cols }
    The second variant of the function is more convenient to use with 'MatrixExpressions'.
    :type src: :py:class:`Mat`
    :param src: input array to replicate.
    :type ny: int
    :param ny: Flag to specify how many times the `src` is repeated along the
        vertical axis.
    :type nx: int
    :param nx: Flag to specify how many times the `src` is repeated along the
        horizontal axis.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same type as `src`.
    See also: aqcv::reduce
    """
    return _pyaqcv.repeat(*args)

def hconcat(*args):
    r"""
     Applies horizontal concatenation to given matrices.

    The function horizontally concatenates two or more aqcv::Mat matrices (with the same number of rows).

    .. code-block:: c++

            aqcv::Mat matArray[] = { aqcv::Mat(4, 1, AQ_8UC1, aqcv::Scalar(1)),
                                     aqcv::Mat(4, 1, AQ_8UC1, aqcv::Scalar(2)),
                                     aqcv::Mat(4, 1, AQ_8UC1, aqcv::Scalar(3)),};

            aqcv::Mat out;
            aqcv::hconcat( matArray, 3, out );
        out:
        [1, 2, 3;
        1, 2, 3;
        1, 2, 3;
        1, 2, 3]
    :type src: :py:class:`Mat`
    :param src: input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.
    :type nsrc: int
    :param nsrc: number of matrices in src.
    :type dst: :py:class:`Mat`
    :param dst: output array. It has the same number of rows and depth as the src, and the sum of cols of the src.
    """
    return _pyaqcv.hconcat(*args)

def vconcat(*args):
    r"""
     Applies vertical concatenation to given matrices.

    The function vertically concatenates two or more aqcv::Mat matrices (with the same number of cols).

    .. code-block:: c++

            aqcv::Mat matArray[] = { aqcv::Mat(1, 4, AQ_8UC1, aqcv::Scalar(1)),
                                     aqcv::Mat(1, 4, AQ_8UC1, aqcv::Scalar(2)),
                                     aqcv::Mat(1, 4, AQ_8UC1, aqcv::Scalar(3)),};

            aqcv::Mat out;
            aqcv::vconcat( matArray, 3, out );
        out:
        [1,   1,   1,   1;
        2,   2,   2,   2;
        3,   3,   3,   3]
    :type src: :py:class:`Mat`
    :param src: input array or vector of matrices. all of the matrices must have the same number of cols and the same depth.
    :type nsrc: int
    :param nsrc: number of matrices in src.
    :type dst: :py:class:`Mat`
    :param dst: output array. It has the same number of cols and depth as the src, and the sum of rows of the src.
    """
    return _pyaqcv.vconcat(*args)

def bitwise_and(*args):
    r"""
     computes bitwise conjunction of the two arrays (dst = src1 & src2)
    Calculates the per-element bit-wise conjunction of two arrays or an
    array and a scalar.

    The function aqcv::bitwise_and calculates the per-element bit-wise logical conjunction for:
      Two arrays when src1 and src2 have the same size:

         .. math::

             \texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0
      An array and a scalar when src2 is constructed from Scalar or has
        the same number of elements as `src1.channels()`:

         .. math::

             \texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0
      A scalar and an array when src1 is constructed from Scalar or has
        the same number of elements as `src2.channels()`:

         .. math::

             \texttt{dst} (I) =  \texttt{src1}  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0
    In case of floating-point arrays, their machine-specific bit
    representations (usually IEEE754-compliant) are used for the operation.
    In case of multi-channel arrays, each channel is processed
    independently. In the second and third cases above, the scalar is first
    converted to the array type.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array or a scalar.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array or a scalar.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array that has the same size and type as the input
        arrays.
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask, 8-bit single channel array, that
        specifies elements of the output array to be changed.
    """
    return _pyaqcv.bitwise_and(*args)

def bitwise_or(*args):
    r"""
     Calculates the per-element bit-wise disjunction of two arrays or an
    array and a scalar.

    The function aqcv::bitwise_or calculates the per-element bit-wise logical disjunction for:
      Two arrays when src1 and src2 have the same size:

         .. math::

             \texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0
      An array and a scalar when src2 is constructed from Scalar or has
        the same number of elements as `src1.channels()`:

         .. math::

             \texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0
      A scalar and an array when src1 is constructed from Scalar or has
        the same number of elements as `src2.channels()`:

         .. math::

             \texttt{dst} (I) =  \texttt{src1}  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0
    In case of floating-point arrays, their machine-specific bit
    representations (usually IEEE754-compliant) are used for the operation.
    In case of multi-channel arrays, each channel is processed
    independently. In the second and third cases above, the scalar is first
    converted to the array type.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array or a scalar.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array or a scalar.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array that has the same size and type as the input
        arrays.
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask, 8-bit single channel array, that
        specifies elements of the output array to be changed.
    """
    return _pyaqcv.bitwise_or(*args)

def bitwise_xor(*args):
    r"""
     Calculates the per-element bit-wise "exclusive or" operation on two
    arrays or an array and a scalar.

    The function aqcv::bitwise_xor calculates the per-element bit-wise logical "exclusive-or"
    operation for:
      Two arrays when src1 and src2 have the same size:

         .. math::

             \texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0
      An array and a scalar when src2 is constructed from Scalar or has
        the same number of elements as `src1.channels()`:

         .. math::

             \texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0
      A scalar and an array when src1 is constructed from Scalar or has
        the same number of elements as `src2.channels()`:

         .. math::

             \texttt{dst} (I) =  \texttt{src1}  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0
    In case of floating-point arrays, their machine-specific bit
    representations (usually IEEE754-compliant) are used for the operation.
    In case of multi-channel arrays, each channel is processed
    independently. In the 2nd and 3rd cases above, the scalar is first
    converted to the array type.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array or a scalar.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array or a scalar.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array that has the same size and type as the input
        arrays.
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask, 8-bit single channel array, that
        specifies elements of the output array to be changed.
    """
    return _pyaqcv.bitwise_xor(*args)

def bitwise_not(*args):
    r"""
     Inverts every bit of an array.

    The function aqcv::bitwise_not calculates per-element bit-wise inversion of the input
    array:

     .. math::

         \texttt{dst} (I) =  \neg \texttt{src} (I)
    In case of a floating-point input array, its machine-specific bit
    representation (usually IEEE754-compliant) is used for the operation. In
    case of multi-channel arrays, each channel is processed independently.
    :type src: :py:class:`_InputArray`
    :param src: input array.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array that has the same size and type as the input
        array.
    :type mask: :py:class:`_InputArray`, optional
    :param mask: optional operation mask, 8-bit single channel array, that
        specifies elements of the output array to be changed.
    """
    return _pyaqcv.bitwise_not(*args)

def absdiff(src1, src2, dst):
    r"""
     Calculates the per-element absolute difference between two arrays or between an array and a scalar.

    The function aqcv::absdiff calculates:
      Absolute difference between two arrays when they have the same
        size and type:

         .. math::

             \texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2}(I)|)
      Absolute difference between an array and a scalar when the second
        array is constructed from Scalar or has as many elements as the
        number of channels in `src1`:

         .. math::

             \texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2} |)
      Absolute difference between a scalar and an array when the first
        array is constructed from Scalar or has as many elements as the
        number of channels in `src2`:

         .. math::

             \texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1} -  \texttt{src2}(I) |)
        where I is a multi-dimensional index of array elements. In case of
        multi-channel arrays, each channel is processed independently.
    Notes: Saturation is not applied when the arrays have the depth AQ_32S.
    You may even get a negative value in the case of overflow.
    :type src1: :py:class:`_InputArray`
    :param src1: first input array or a scalar.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array or a scalar.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array that has the same size and type as input arrays.
    See also: aqcv::abs(const Mat&)
    """
    return _pyaqcv.absdiff(src1, src2, dst)

def copy_to(*args):
    r"""
     This is an overloaded member function, provided for convenience (python)
    Copies the matrix to another one.
    When the operation mask is specified, if the Mat::create call shown above reallocates the matrix,
    the newly allocated matrix is initialized with all zeros before copying the data.
    :type src: :py:class:`_InputArray`
    :param src: source matrix.
    :type dst: :py:class:`_OutputArray`
    :param dst: Destination matrix. If it does not have a proper size or type before the operation, it is
        reallocated.
    :type mask: :py:class:`Mat`, optional
    :param mask: Operation mask of the same size as *this. Its non-zero elements indicate which matrix
        elements need to be copied. The mask has to be of type AQ_8U and can have 1 or multiple channels.
    """
    return _pyaqcv.copy_to(*args)

def in_range(src, lowerb, upperb, dst):
    r"""
     Checks if array elements lie between the elements of two other arrays.

    The function checks the range as follows:
    -   For every element of a single-channel input array:

         .. math::

             \texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0
    -   For two-channel arrays:

         .. math::

             \texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0  \land \texttt{lowerb} (I)_1  \leq \texttt{src} (I)_1 \leq  \texttt{upperb} (I)_1
    -   and so forth.

    That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the
    specified 1D, 2D, 3D, ... box and 0 otherwise.

    When the lower and/or upper boundary parameters are scalars, the indexes
    (I) at lowerb and upperb in the above formulas should be omitted.
    :type src: :py:class:`_InputArray`
    :param src: first input array.
    :type lowerb: :py:class:`_InputArray`
    :param lowerb: inclusive lower boundary array or a scalar.
    :type upperb: :py:class:`_InputArray`
    :param upperb: inclusive upper boundary array or a scalar.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of the same size as src and AQ_8U type.
    """
    return _pyaqcv.in_range(src, lowerb, upperb, dst)
kCmpEQ = _pyaqcv.kCmpEQ
r"""src1 is equal to src2."""
kCmpGT = _pyaqcv.kCmpGT
r"""src1 is greater than src2."""
kCmpGE = _pyaqcv.kCmpGE
r"""src1 is greater than or equal to src2."""
kCmpLT = _pyaqcv.kCmpLT
r"""src1 is less than src2."""
kCmpLE = _pyaqcv.kCmpLE
r"""src1 is less than or equal to src2."""
kCmpNE = _pyaqcv.kCmpNE
r"""src1 is unequal to src2."""

def compare(src1, src2, dst, cmp_type):
    r"""
     Performs the per-element comparison of two arrays or an array and scalar value.

    The function compares:
      Elements of two arrays when src1 and src2 have the same size:

         .. math::

             \texttt{dst} (I) =  \texttt{src1} (I)  \,\texttt{cmp_type}\, \texttt{src2} (I)
      Elements of src1 with a scalar src2 when src2 is constructed from
        Scalar or has a single element:

         .. math::

             \texttt{dst} (I) =  \texttt{src1}(I) \,\texttt{cmp_type}\,  \texttt{src2}
      src1 with elements of src2 when src1 is constructed from Scalar or
        has a single element:

         .. math::

             \texttt{dst} (I) =  \texttt{src1}  \,\texttt{cmp_type}\, \texttt{src2} (I)
    When the comparison result is true, the corresponding element of output
    array is set to 255. The comparison operations can be replaced with the
    equivalent matrix expressions:

    .. code-block:: c++

            Mat dst1 = src1 >= src2;
            Mat dst2 = src1 < 8;
            ...
    :type src1: :py:class:`_InputArray`
    :param src1: first input array or a scalar; when it is an array, it must have a single channel.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array or a scalar; when it is an array, it must have a single channel.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of type ref AQ_8U that has the same size and the same number of channels as
            the input arrays.
    :type cmp_type: int
    :param cmp_type: a flag, that specifies correspondence between the arrays (aqcv::CmpTypes)
    See also: check_range, min, max, threshold
    """
    return _pyaqcv.compare(src1, src2, dst, cmp_type)

def min(*args):
    r"""
     Calculates per-element minimum of two arrays or an array and a scalar.

    The function aqcv::min calculates the per-element minimum of two arrays:

     .. math::

         \texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I))
    or array and a scalar:

     .. math::

         \texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} )
    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array of the same size and type as src1.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of the same size and type as src1.
    See also: max, compare, in_range, min_max_loc
    """
    return _pyaqcv.min(*args)

def max(*args):
    r"""
     Calculates per-element maximum of two arrays or an array and a scalar.

    The function aqcv::max calculates the per-element maximum of two arrays:

     .. math::

         \texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I))
    or array and a scalar:

     .. math::

         \texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} )
    :type src1: :py:class:`_InputArray`
    :param src1: first input array.
    :type src2: :py:class:`_InputArray`
    :param src2: second input array of the same size and type as src1 .
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of the same size and type as src1.
    See also: min, compare, in_range, min_max_loc, 'MatrixExpressions'
    """
    return _pyaqcv.max(*args)

def sqrt(*args):
    r"""
     Calculates a square root of array elements.

    The function aqcv::sqrt calculates a square root of each input array element.
    In case of multi-channel arrays, each channel is processed
    independently. The accuracy is approximately the same as of the built-in
    std::sqrt.
    :type src: :py:class:`Mat`
    :param src: input floating-point array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src.
    """
    return _pyaqcv.sqrt(*args)

def pow(*args):
    r"""
     Raises every array element to a power.

    The function aqcv::pow raises every element of the input array to power :

     .. math::

         \texttt{dst} (I) =\begin{cases}{\texttt{src}(I)^{power}}&if\;\texttt{power is integer}\\{|\texttt{src}(I)|^{power}}&\texttt{otherwise}\end{cases}

    So, for a non-integer power exponent, the absolute values of input array
    elements are used. However, it is possible to get true values for
    negative values using some extra operations. In the example below,
    computing the 5th root of array src shows:

    .. code-block:: c++

            Mat mask = src < 0;
            pow(src, 1./5, dst);
            subtract(Scalar::all(0), dst, dst, mask);
    For some values of power, such as integer values, 0.5 and -0.5,
    specialized faster algorithms are used.

    Special values (NaN, Inf) are not handled.
    :type src: :py:class:`Mat`
    :param src: input array.
    :type power: float
    :param power: exponent of power.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src.
    See also: sqrt, exp, log, cart_to_polar, polar_to_cart
    """
    return _pyaqcv.pow(*args)

def exp(*args):
    r"""
     Calculates the exponent of every array element.

    The function aqcv::exp calculates the exponent of every element of the input
    array:

     .. math::

         \texttt{dst} [I] = e^{ src(I) }

    The maximum relative error is about 7e-6 for single-precision input and
    less than 1e-10 for double-precision input. Currently, the function
    converts denormalized values to zeros on output. Special values (NaN,
    Inf) are not handled.
    :type src: :py:class:`Mat`
    :param src: input array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src.
    See also: log , cart_to_polar , polar_to_cart , phase , pow , sqrt , magnitude
    """
    return _pyaqcv.exp(*args)

def log(*args):
    r"""
     Calculates the natural logarithm of every array element.

    The function aqcv::log calculates the natural logarithm of every element of the input array:

     .. math::

         \texttt{dst} (I) =  \log (\texttt{src}(I))

    Output on zero, negative and special (NaN, Inf) values is undefined.

    :type src: :py:class:`Mat`
    :param src: input array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src .
    See also: exp, cart_to_polar, polar_to_cart, phase, pow, sqrt, magnitude
    """
    return _pyaqcv.log(*args)

def polar_to_cart(magnitude, angle, x, y, angle_in_degrees=False):
    r"""
     Calculates x and y coordinates of 2D vectors from their magnitude and angle.

    The function aqcv::polar_to_cart calculates the Cartesian coordinates of each 2D
    vector represented by the corresponding elements of magnitude and angle:

     .. math::

         \begin{array}{l} \texttt{x} (I) =  \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \\ \texttt{y} (I) =  \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \\ \end{array}

    The relative accuracy of the estimated coordinates is about 1e-6.
    :type magnitude: :py:class:`Mat`
    :param magnitude: input floating-point array of magnitudes of 2D vectors;
        it can be an empty matrix (=Mat()), in this case, the function assumes
        that all the magnitudes are =1; if it is not empty, it must have the
        same size and type as angle.
    :type angle: :py:class:`Mat`
    :param angle: input floating-point array of angles of 2D vectors.
    :type x: :py:class:`Mat`
    :param x: output array of x-coordinates of 2D vectors; it has the same
        size and type as angle.
    :type y: :py:class:`Mat`
    :param y: output array of y-coordinates of 2D vectors; it has the same
        size and type as angle.
    :type angle_in_degrees: boolean, optional
    :param angle_in_degrees: when true, the input angles are measured in
        degrees, otherwise, they are measured in radians.
    See also: cart_to_polar, magnitude, phase, exp, log, pow, sqrt
    """
    return _pyaqcv.polar_to_cart(magnitude, angle, x, y, angle_in_degrees)

def cart_to_polar(x, y, magnitude, angle, angle_in_degrees=False):
    r"""
     Calculates the magnitude and angle of 2D vectors.

    The function aqcv::cart_to_polar calculates either the magnitude, angle, or both
    for every 2D vector (x(I),y(I)):

     .. math::

         \begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \\ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array}

    The angles are calculated with accuracy about 0.3 degrees. For the point
    (0,0), the angle is set to 0.
    :type x: :py:class:`Mat`
    :param x: array of x-coordinates; this must be a single-precision or
        double-precision floating-point array.
    :type y: :py:class:`Mat`
    :param y: array of y-coordinates, that must have the same size and same type as x.
    :type magnitude: :py:class:`Mat`
    :param magnitude: output array of magnitudes of the same size and type as x.
    :type angle: :py:class:`Mat`
    :param angle: output array of angles that has the same size and type as
        x; the angles are measured in radians (from 0 to 2*Pi) or in degrees (0 to 360 degrees).
    :type angle_in_degrees: boolean, optional
    :param angle_in_degrees: a flag, indicating whether the angles are measured
        in radians (which is by default), or in degrees.
    See also: sobel, scharr
    """
    return _pyaqcv.cart_to_polar(x, y, magnitude, angle, angle_in_degrees)

def phase(x, y, angle, angle_in_degrees=False):
    r"""
     Calculates the rotation angle of 2D vectors.

    The function aqcv::phase calculates the rotation angle of each 2D vector that
    is formed from the corresponding elements of x and y :

     .. math::

         \texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))

    The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,
    the corresponding angle(I) is set to 0.
    :type x: :py:class:`Mat`
    :param x: input floating-point array of x-coordinates of 2D vectors.
    :type y: :py:class:`Mat`
    :param y: input array of y-coordinates of 2D vectors; it must have the
        same size and the same type as x.
    :type angle: :py:class:`Mat`
    :param angle: output array of vector angles; it has the same size and
        same type as x .
    :type angle_in_degrees: boolean, optional
    :param angle_in_degrees: when true, the function calculates the angle in
        degrees, otherwise, they are measured in radians.
    """
    return _pyaqcv.phase(x, y, angle, angle_in_degrees)

def magnitude(x, y, magnitude):
    r"""
     Calculates the magnitude of 2D vectors.

    The function aqcv::magnitude calculates the magnitude of 2D vectors formed
    from the corresponding elements of x and y arrays:

     .. math::

         \texttt{dst} (I) =  \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2}
    :type x: :py:class:`Mat`
    :param x: floating-point array of x-coordinates of the vectors.
    :type y: :py:class:`Mat`
    :param y: floating-point array of y-coordinates of the vectors; it must
        have the same size as x.
    :type magnitude: :py:class:`Mat`
    :param magnitude: output array of the same size and type as x.
    See also: cart_to_polar, polar_to_cart, phase, sqrt
    """
    return _pyaqcv.magnitude(x, y, magnitude)

def check_range(*args):
    r"""
     Checks every element of an input array for invalid values.

    The function aqcv::check_range checks that every array element is neither NaN nor infinite. When min_val >
    -DBL_MAX and max_val < DBL_MAX, the function also checks that each value is between min_val and
    max_val. In case of multi-channel arrays, each channel is processed independently. If some values
    are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
    function either returns false (when quiet=true) or throws an exception.
    :type a: :py:class:`Mat`
    :param a: input array.
    :type quiet: boolean, optional
    :param quiet: a flag, indicating whether the functions quietly return false when the array elements
        are out of range or they throw an exception.
    :type pos: :py:class:`Point`, optional
    :param pos: optional output parameter, when not NULL, must be a pointer to array of src.dims
        elements.
    :type min_val: float, optional
    :param min_val: inclusive lower boundary of valid values range.
    :type max_val: float, optional
    :param max_val: exclusive upper boundary of valid values range.
    """
    return _pyaqcv.check_range(*args)

def patch_nans(a, val=0):
    r"""
     converts NaNs to the given number
    :type a: :py:class:`Mat`
    :param a: input/output matrix (AQ_32F type).
    :type val: float, optional
    :param val: value to convert the NaNs
    """
    return _pyaqcv.patch_nans(a, val)
kGemmDefault = _pyaqcv.kGemmDefault
r"""no transposes"""
kGemm1T = _pyaqcv.kGemm1T
r"""transposes src1"""
kGemm2T = _pyaqcv.kGemm2T
r"""transposes src2"""
kGemm3T = _pyaqcv.kGemm3T
r"""transposes src3"""

def gemm(*args):
    r"""
     Performs generalized matrix multiplication.

    The function aqcv::gemm performs generalized matrix multiplication similar to the
    gemm functions in BLAS level 3. For example,
    `gemm(src1, src2, alpha, src3, beta, dst, kGemm1T + kGemm3T)`
    corresponds to

     .. math::

         \texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T

    In case of complex (two-channel) data, performed a complex matrix
    multiplication.

    The function can be replaced with a matrix expression. For example, the
    above call can be replaced with:

    .. code-block:: c++

            dst = alpha*src1.t()*src2 + beta*src3.t();
    :type src1: :py:class:`_InputArray`
    :param src1: first multiplied input matrix that could be real(AQ_32FC1,
        AQ_64FC1) or complex(AQ_32FC2, AQ_64FC2).
    :type src2: :py:class:`_InputArray`
    :param src2: second multiplied input matrix of the same type as src1.
    :type alpha: float
    :param alpha: weight of the matrix product.
    :type src3: :py:class:`_InputArray`
    :param src3: third optional delta matrix added to the matrix product; it
        should have the same type as src1 and src2.
    :type beta: float
    :param beta: weight of src3.
    :type dst: :py:class:`_OutputArray`
    :param dst: output matrix; it has the proper size and the same type as
        input matrices.
    :type flags: int, optional
    :param flags: operation flags (aqcv::GemmFlags)
    See also: mul_transposed , transform
    """
    return _pyaqcv.gemm(*args)

def mul_transposed(*args):
    r"""
     Calculates the product of a matrix and its transposition.

    The function aqcv::mul_transposed calculates the product of src and its
    transposition:

     .. math::

         \texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )
    if aTa=true , and

     .. math::

         \texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T
    otherwise. The function is used to calculate the covariance matrix. With
    zero delta, it can be used as a faster substitute for general matrix
    product A*B when B=A'
    :type src: :py:class:`Mat`
    :param src: input single-channel matrix. Note that unlike gemm, the
        function can multiply not only floating-point matrices.
    :type dst: :py:class:`Mat`
    :param dst: output square matrix.
    :type aTa: boolean
    :param aTa: Flag specifying the multiplication ordering. See the
        description below.
    :type delta: :py:class:`Mat`, optional
    :param delta: Optional delta matrix subtracted from src before the
        multiplication. When the matrix is empty ( delta=no_array() ), it is
        assumed to be zero, that is, nothing is subtracted. If it has the same
        size as src , it is simply subtracted. Otherwise, it is "repeated" (see
        repeat ) to cover the full src and then subtracted. Type of the delta
        matrix, when it is not empty, must be the same as the type of created
        output matrix. See the dtype parameter description below.
    :type scale: float, optional
    :param scale: Optional scale factor for the matrix product.
    :type dtype: int, optional
    :param dtype: Optional type of the output matrix. When it is negative,
        the output matrix will have the same type as src . Otherwise, it will be
        type=AQ_MAT_DEPTH(dtype) that should be either AQ_32F or AQ_64F .
    See also: calc_covar_matrix, gemm, repeat, reduce
    """
    return _pyaqcv.mul_transposed(*args)

def transpose(src, dst):
    r"""
     Transposes a matrix.

    The function aqcv::transpose transposes the matrix src :

     .. math::

         \texttt{dst} (i,j) =  \texttt{src} (j,i)
    Notes: No complex conjugation is done in case of a complex matrix. It
    should be done separately if needed.
    :type src: :py:class:`Mat`
    :param src: input array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same type as src.
    """
    return _pyaqcv.transpose(src, dst)

def transform(src, dst, m):
    r"""
     Performs the matrix transformation of every array element.

    The function aqcv::transform performs the matrix transformation of every
    element of the array src and stores the results in dst :

     .. math::

         \texttt{dst} (I) =  \texttt{m} \cdot \texttt{src} (I)
    (when m.cols=src.channels() ), or

     .. math::

         \texttt{dst} (I) =  \texttt{m} \cdot [ \texttt{src} (I); 1]
    (when m.cols=src.channels()+1 )

    Every element of the N -channel array src is interpreted as N -element
    vector that is transformed using the M x N or M x (N+1) matrix m to
    M-element vector - the corresponding element of the output array dst .

    The function may be used for geometrical transformation of
    N -dimensional points, arbitrary linear color space transformation (such
    as various kinds of RGB to YUV transforms), shuffling the image
    channels, and so forth.
    :type src: :py:class:`Mat`
    :param src: input array that must have as many channels (1 to 4) as
        m.cols or m.cols-1.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and depth as src; it has as
        many channels as m.rows.
    :type m: :py:class:`Mat`
    :param m: transformation 2x2 or 2x3 floating-point matrix.
    See also: perspective_transform
    """
    return _pyaqcv.transform(src, dst, m)

def perspective_transform(src, dst, m):
    r"""
     Performs the perspective matrix transformation of vectors.

    The function aqcv::perspective_transform transforms every element of src by
    treating it as a 2D or 3D vector, in the following way:

     .. math::

         (x, y, z)  \rightarrow (x'/w, y'/w, z'/w)
    where

     .. math::

         (x', y', z', w') =  \texttt{mat} \cdot \begin{bmatrix} x & y & z & 1  \end{bmatrix}
    and

     .. math::

         w =\begin{cases}{w'}&{if \;w' \ne 0}\\{\infty}&{otherwise}\end{cases}

    Here a 3D vector transformation is shown. In case of a 2D vector
    transformation, the z component is omitted.

    Notes: The function transforms a sparse set of 2D or 3D vectors. If you
    want to transform an image using perspective transformation, use
    warp_perspective. If you have an inverse problem, that is, you want to
    compute the most probable perspective transformation out of several
    pairs of corresponding points, you can use get_perspective_mat.

    :type src: :py:class:`Mat`
    :param src: input two-channel or three-channel floating-point array; each
        element is a 2D/3D vector to be transformed.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src.
    :type m: :py:class:`Mat`
    :param m: 3x3 or 4x4 floating-point transformation matrix.
    See also: transform
    """
    return _pyaqcv.perspective_transform(src, dst, m)

def complete_symm(m, lower_to_upper=False):
    r"""
     Copies the lower or the upper half of a square matrix to its another half.

    The function aqcv::complete_symm copies the lower or the upper half of a square matrix to
    its another half. The matrix diagonal remains unchanged:
     -  :math:`\texttt{m}_{ij}=\texttt{m}_{ji}`  for  :math:`i > j`  if
        lower_to_upper=false
     -  :math:`\texttt{m}_{ij}=\texttt{m}_{ji}`  for  :math:`i < j`  if
        lower_to_upper=true

    :type m: :py:class:`Mat`
    :param m: input-output floating-point square matrix.
    :type lower_to_upper: boolean, optional
    :param lower_to_upper: operation flag; if true, the lower half is copied to
        the upper half. Otherwise, the upper half is copied to the lower half.
    See also: flip, transpose
    """
    return _pyaqcv.complete_symm(m, lower_to_upper)

def set_identity(*args):
    r"""
     Initializes a scaled identity matrix.

    The function aqcv::set_identity initializes a scaled identity matrix:

     .. math::

         \texttt{mtx} (i,j)=\begin{cases}{\texttt{value}} & if \texttt{i=j}\\{0} & \texttt{otherwise}\end{cases}

    The function can also be emulated using the matrix initializers and the
    matrix expressions:

    .. code-block:: c++

            Mat A = Mat::eye(4, 3, AQ_32F)*5;
        A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]
    :type mtx: :py:class:`Mat`
    :param mtx: matrix to initialize (not necessarily square).
    :type s: :py:class:`Scalar`, optional
    :param s: value to assign to diagonal elements.
    See also: Mat::zeros, Mat::ones, Mat::set_to, Mat::operator=
    """
    return _pyaqcv.set_identity(*args)

def determinant(mtx):
    r"""
     Returns the determinant of a square floating-point matrix.

    The function aqcv::determinant calculates and returns the determinant of the
    specified matrix. For small matrices ( mtx.cols=mtx.rows<=3 ), the
    direct method is used. For larger matrices, the function uses LU
    factorization with partial pivoting.

    For symmetric positively-determined matrices, it is also possible to use
    eigen decomposition to calculate the determinant.
    :type mtx: :py:class:`Mat`
    :param mtx: input matrix that must have AQ_32FC1 or AQ_64FC1 type and
        square size.
    See also: trace, invert, solve, eigen, 'MatrixExpressions'
    """
    return _pyaqcv.determinant(mtx)

def trace(m):
    r"""
     Returns the trace of a matrix.

    The function aqcv::trace returns the sum of the diagonal elements of the
    matrix mtx .

     .. math::

         \mathrm{m} ( \texttt{m} ) =  \sum _i  \texttt{m} (i,i)
    :type m: :py:class:`Mat`
    :param m: input matrix.
    """
    return _pyaqcv.trace(m)

def invert(*args):
    r"""
     Finds the inverse or pseudo-inverse of a matrix.

    The function aqcv::invert inverts the matrix src and stores the result in dst
    . When the matrix src is singular or non-square, the function calculates
    the pseudo-inverse matrix (the dst matrix) so that norm(src*dst - I) is
    minimal, where I is an identity matrix.

    In case of the #kDecompLU method, the function returns non-zero value if
    the inverse has been successfully calculated and 0 if src is singular.

    In case of the #kDecompSVD method, the function returns the inverse
    condition number of src (the ratio of the smallest singular value to the
    largest singular value) and 0 if src is singular. The SVD method
    calculates a pseudo-inverse matrix if src is singular.

    Similarly to #kDecompLU, the method #kDecompCholeshy works only with
    non-singular square matrices that should also be symmetrical and
    positively defined. In this case, the function stores the inverted
    matrix in dst and returns non-zero. Otherwise, it returns 0.

    :type src: :py:class:`Mat`
    :param src: input floating-point M x N matrix.
    :type dst: :py:class:`Mat`
    :param dst: output matrix of N x M size and the same type as src.
    :type flags: int, optional
    :param flags: inversion method (aqcv::DecompTypes)
    See also: solve, SVD
    """
    return _pyaqcv.invert(*args)

def solve(*args):
    r"""
     Solves one or more linear systems or least-squares problems.

    The function aqcv::solve solves a linear system or least-squares problem (the
    latter is possible with SVD or QR methods, or by specifying the flag
    #kDecompNormal ):

     .. math::

         \texttt{dst} =  \arg \min _X \| \texttt{src1} \cdot \texttt{X} -  \texttt{src2} \|

    If #kDecompLU or #kDecompCholeshy method is used, the function returns 1
    if src1 (or  :math:`\texttt{src1}^T\texttt{src1}`  ) is non-singular. Otherwise,
    it returns 0. In the latter case, dst is not valid. Other methods find a
    pseudo-solution in case of a singular left-hand side part.

    Notes: If you want to find a unity-norm solution of an under-defined
    singular system  :math:`\texttt{src1}\cdot\texttt{dst}=0`  , the function solve
    will not do the work. Use SVD::solve_z instead.

    :type src1: :py:class:`Mat`
    :param src1: input matrix on the left-hand side of the system.
    :type src2: :py:class:`Mat`
    :param src2: input matrix on the right-hand side of the system.
    :type dst: :py:class:`Mat`
    :param dst: output solution.
    :type flags: int, optional
    :param flags: solution (matrix inversion) method (#DecompTypes)
    See also: invert, SVD, eigen
    """
    return _pyaqcv.solve(*args)
kSortEveryRow = _pyaqcv.kSortEveryRow
r"""each matrix row is sorted independently"""
kSortEveryColumn = _pyaqcv.kSortEveryColumn
r"""each matrix column is sorted independently; this flag and the previous one are mutually exclusive."""
kSortAscending = _pyaqcv.kSortAscending
r"""each matrix row is sorted in the ascending order."""
kSortDescending = _pyaqcv.kSortDescending
r"""each matrix row is sorted in the descending order; this flag and the previous one are also mutually exclusive."""

def sort(src, dst, flags):
    r"""
     Sorts each row or each column of a matrix.

    The function aqcv::sort sorts each matrix row or each matrix column in
    ascending or descending order. So you should pass two operation flags to
    get desired behaviour. If you want to sort matrix rows or columns
    lexicographically, you can use STL std::sort generic function with the
    proper comparison predicate.
    return sorted Mat.

    :type src: :py:class:`_InputArray`
    :param src: input single-channel array.
    :type dst: :py:class:`_OutputArray`
    :param dst: output array of the same size and type as src.
    :type flags: int
    :param flags: operation flags, a combination of #SortFlags
    See also: sort_idx, rand_shuffle
    """
    return _pyaqcv.sort(src, dst, flags)

def sort_idx(src, dst, flags):
    r"""
     Sorts each row or each column of a matrix.

    The function aqcv::sort_idx sorts each matrix row or each matrix column in the
    ascending or descending order. So you should pass two operation flags to
    get desired behaviour. Instead of reordering the elements themselves, it
    stores the indices of sorted elements in the output array.
    return an index Mat.
    For example:

    .. code-block:: c++

            Mat A = Mat::eye(3,3,AQ_32F), B;
            sort_idx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);
        B will probably contain
        (because of equal elements in A some permutations are possible):
        [[1, 2, 0], [0, 2, 1], [0, 1, 2]]
    :type src: :py:class:`_InputArray`
    :param src: input single-channel array.
    :type dst: :py:class:`_OutputArray`
    :param dst: output integer array of the same size as src.
    :type flags: int
    :param flags: operation flags that could be a combination of aqcv::SortFlags
    See also: sort, rand_shuffle
    """
    return _pyaqcv.sort_idx(src, dst, flags)

def solve_cubic(coeffs, roots):
    r"""
     Finds the real roots of a cubic equation.

    The function solve_cubic finds the real roots of a cubic equation:
    -   if coeffs is a 4-element vector:

     .. math::

         \texttt{coeffs} [0] x^3 +  \texttt{coeffs} [1] x^2 +  \texttt{coeffs} [2] x +  \texttt{coeffs} [3] = 0
    -   if coeffs is a 3-element vector:

     .. math::

         x^3 +  \texttt{coeffs} [0] x^2 +  \texttt{coeffs} [1] x +  \texttt{coeffs} [2] = 0

    The roots are stored in the roots array.
    :type coeffs: :py:class:`_InputArray`
    :param coeffs: equation coefficients, an array of 3 or 4 elements.
    :type roots: :py:class:`_OutputArray`
    :param roots: output array of real roots that has 1 or 3 elements.
    :rtype: int
    :return: number of real roots. It can be 0, 1 or 2.
    """
    return _pyaqcv.solve_cubic(coeffs, roots)

def solve_poly(coeffs, roots, max_iters=300):
    r"""
     Finds the real or complex roots of a polynomial equation.

    The function aqcv::solve_poly finds real and complex roots of a polynomial equation:

     .. math::

         \texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + ... +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0
    :type coeffs: :py:class:`_InputArray`
    :param coeffs: array of polynomial coefficients.
    :type roots: :py:class:`_OutputArray`
    :param roots: output (complex) array of roots.
    :type max_iters: int, optional
    :param max_iters: maximum number of iterations the algorithm does.
    """
    return _pyaqcv.solve_poly(coeffs, roots, max_iters)

def eigen(*args):
    r"""
     Calculates eigenvalues and eigenvectors of a symmetric matrix.

    The function aqcv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric
    matrix src:

    .. code-block:: c++

            src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()

    Notes: Use aqcv::eigen_non_symmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.

    :type src: :py:class:`Mat`
    :param src: input matrix that must have AQ_32FC1 or AQ_64FC1 type, square size and be symmetrical
        (src ^T^ == src).
    :type eigenvalues: :py:class:`Mat`
    :param eigenvalues: output vector of eigenvalues of the same type as src; the eigenvalues are stored
        in the descending order.
    :type eigenvectors: :py:class:`_OutputArray`, optional
    :param eigenvectors: output matrix of eigenvectors; it has the same size and type as src; the
        eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding
        eigenvalues.
    See also: eigen_non_symmetric, complete_symm , PCA
    """
    return _pyaqcv.eigen(*args)

def eigen_non_symmetric(src, eigenvalues, eigenvectors):
    r"""
     Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).

    Notes: Assumes real eigenvalues.

    The function calculates eigenvalues and eigenvectors (optional) of the square matrix src:

    .. code-block:: c++

            src*eigenvectors.row(i).t() = eigenvalues.at<srcType>(i)*eigenvectors.row(i).t()

    :type src: :py:class:`Mat`
    :param src: input matrix (AQ_32FC1 or AQ_64FC1 type).
    :type eigenvalues: :py:class:`Mat`
    :param eigenvalues: output vector of eigenvalues (type is the same type as src).
    :type eigenvectors: :py:class:`_OutputArray`
    :param eigenvectors: output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.
    See also: eigen
    """
    return _pyaqcv.eigen_non_symmetric(src, eigenvalues, eigenvectors)
kCovarScrambled = _pyaqcv.kCovarScrambled
r"""
    The output covariance matrix is calculated as:

           .. math::

               \texttt{scale}   \cdot  [  \texttt{vects}  [0]-  \texttt{mean}  , \texttt{vects}  [1]-  \texttt{mean}  ,...]^T  \cdot  [ \texttt{vects}  [0]- \texttt{mean}  , \texttt{vects}  [1]- \texttt{mean}  ,...],
          The covariance matrix will be nsamples x nsamples. Such an unusual covariance matrix is used
          for fast PCA of a set of very large vectors (see, for example, the EigenFaces technique for
          face recognition). Eigenvalues of this "scrambled" matrix match the eigenvalues of the true
          covariance matrix. The "true" eigenvectors can be easily calculated from the eigenvectors of
          the "scrambled" covariance matrix.
    """
kCovarNormal = _pyaqcv.kCovarNormal
r"""
    The output covariance matrix is calculated as:

             .. math::

                 \texttt{scale}   \cdot  [  \texttt{vects}  [0]-  \texttt{mean}  , \texttt{vects}  [1]-  \texttt{mean}  ,...]  \cdot  [ \texttt{vects}  [0]- \texttt{mean}  , \texttt{vects}  [1]- \texttt{mean}  ,...]^T,
            covar will be a square matrix of the same size as the total number of elements in each input
            vector. One and only one of #COVAR_SCRAMBLED and #COVAR_kNormal must be specified.
    """
kCovarUseAvg = _pyaqcv.kCovarUseAvg
r"""
    If the flag is specified, the function does not calculate mean from
           the input vectors but, instead, uses the passed mean vector. This is useful if mean has been
           pre-calculated or known in advance, or if the covariance matrix is calculated by parts. In
           this case, mean is not a mean vector of the input sub-set of vectors but rather the mean
           vector of the whole set.
    """
kCovarScale = _pyaqcv.kCovarScale
r"""
    If the flag is specified, the covariance matrix is scaled. In the
           "normal" mode, scale is 1./nsamples . In the "scrambled" mode, scale is the reciprocal of the
           total number of elements in each input vector. By default (if the flag is not specified), the
           covariance matrix is not scaled ( scale=1 ).
    """
kCovarRows = _pyaqcv.kCovarRows
r"""
    If the flag is
           specified, all the input vectors are stored as rows of the samples matrix. mean should be a
           single-row vector in this case.
    """
kCovarCols = _pyaqcv.kCovarCols
r"""
    If the flag is
           specified, all the input vectors are stored as columns of the samples matrix. mean should be a
           single-column vector in this case.
    """

def calc_covar_matrix(samples, covar, mean, flags, ctype=6):
    r"""
     Calculates the covariance matrix of a set of vectors.

    The function aqcv::calc_covar_matrix calculates the covariance matrix and, optionally, the mean vector of
    the set of input vectors.
    Notes: use #kCovarRows or #kCovarCols flag
    :type samples: :py:class:`Mat`
    :param samples: samples stored as rows/columns of a single matrix.  (mxn)
    :type covar: :py:class:`Mat`
    :param covar: output covariance matrix of the type ctype and square size.
    :type mean: :py:class:`Mat`
    :param mean: input or output (depending on the flags) array as the average value of the input vectors.
    :type flags: int
    :param flags: operation flags as a combination of #CovarFlags
    :type ctype: int, optional
    :param ctype: type of the matrixl; it equals 'AQ_64F' by default.
    """
    return _pyaqcv.calc_covar_matrix(samples, covar, mean, flags, ctype)

def mahalanobis(v1, v2, icovar):
    r"""
     Calculates the mahalanobis distance between two vectors.

    The function aqcv::mahalanobis calculates and returns the weighted distance between two vectors:

     .. math::

         d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} }
    The covariance matrix may be calculated using the #calc_covar_matrix function and then inverted using
    the invert function (preferably using the #kDecompSVD method, as the most accurate).
    :type v1: :py:class:`_InputArray`
    :param v1: first 1D input vector.
    :type v2: :py:class:`_InputArray`
    :param v2: second 1D input vector.
    :type icovar: :py:class:`_InputArray`
    :param icovar: inverse covariance matrix.
    """
    return _pyaqcv.mahalanobis(v1, v2, icovar)
kDftDefault = _pyaqcv.kDftDefault
r"""build in, can not use."""
kDftInverse = _pyaqcv.kDftInverse
r"""
    performs an inverse 1D or 2D transform instead of the default forward
           transform.
    """
kDftScale = _pyaqcv.kDftScale
r"""
    scales the result: divide it by the number of array elements. Normally, it is
           combined with kDftInverse.
    """
kDftRows = _pyaqcv.kDftRows
r"""
    performs a forward or inverse transform of every individual row of the input
           matrix; this flag enables you to transform multiple vectors simultaneously and can be used to
           decrease the overhead (which is sometimes several times larger than the processing itself) to
           perform 3D and higher-dimensional transformations and so forth.
    """
kDftComplexOutput = _pyaqcv.kDftComplexOutput
r"""
    performs a forward transformation of 1D or 2D real array; the result,
           though being a complex array, has complex-conjugate symmetry (*CCS*, see the function
           description below for details), and such an array can be packed into a real array of the same
           size as input, which is the fastest option and which is what the function does by default;
           however, you may wish to get a full complex array (for simpler spectrum analysis, and so on) -
           pass the flag to enable the function to produce a full-size complex output array.
    """
kDftRealOutput = _pyaqcv.kDftRealOutput
r"""
    performs an inverse transformation of a 1D or 2D complex array; the
           result is normally a complex array of the same size, however, if the input array has
           conjugate-complex symmetry (for example, it is a result of forward transformation with
           kDftComplexOutput flag), the output is a real array; while the function itself does not
           check whether the input is symmetrical or not, you can pass the flag and then the function
           will assume the symmetry and produce the real output array (note that when the input is packed
           into a real array and inverse transformation is executed, the function treats the input as a
           packed complex-conjugate symmetrical array, and the output will also be a real array).
    """
kDftComplexInput = _pyaqcv.kDftComplexInput
r"""
    specifies that input is complex input. If this flag is set, the input must have 2 channels.
           On the other hand, for backwards compatibility reason, if input has 2 channels, input is
           already considered complex.
    """
kDctInverse = _pyaqcv.kDctInverse
r"""performs an inverse 1D or 2D transform instead of the default forward transform."""
kDctRows = _pyaqcv.kDctRows
r"""
    performs a forward or inverse transform of every individual row of the input
           matrix. This flag enables you to transform multiple vectors simultaneously and can be used to
           decrease the overhead (which is sometimes several times larger than the processing itself) to
           perform 3D and higher-dimensional transforms and so forth.
    """

def dft(*args):
    r"""
     Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.

    The function aqcv::dft performs one of the following:
    -   Forward the Fourier transform of a 1D vector of N elements:

         .. math::

             Y = F^{(N)}  \cdot X,
        where  :math:`F^{(N)}_{jk}=\exp(-2\pi i j k/N)`  and  :math:`i=\sqrt{-1}`
    -   Inverse the Fourier transform of a 1D vector of N elements:

         .. math::

             \begin{array}{l} X'=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array}
        where  :math:`F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T`
    -   Forward the 2D Fourier transform of a M x N matrix:

         .. math::

             Y = F^{(M)}  \cdot X  \cdot F^{(N)}
    -   Inverse the 2D Fourier transform of a M x N matrix:

         .. math::

             \begin{array}{l} X'=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X' \end{array}

    In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input
    spectrum of the inverse Fourier transform can be represented in a packed format called *CCS*
    (complex-conjugate-symmetrical). It was borrowed from IPL (Intel* Image Processing Library). Here
    is how 2D *CCS* spectrum looks:

     .. math::

         \begin{bmatrix} Re Y_{0,0} & Re Y_{0,1} & Im Y_{0,1} & Re Y_{0,2} & Im Y_{0,2} &  \cdots & Re Y_{0,N/2-1} & Im Y_{0,N/2-1} & Re Y_{0,N/2}
         \\ Re Y_{1,0} & Re Y_{1,1} & Im Y_{1,1} & Re Y_{1,2} & Im Y_{1,2} &  \cdots & Re Y_{1,N/2-1} & Im Y_{1,N/2-1} & Re Y_{1,N/2}
         \\ Im Y_{1,0} & Re Y_{2,1} & Im Y_{2,1} & Re Y_{2,2} & Im Y_{2,2} &  \cdots & Re Y_{2,N/2-1} & Im Y_{2,N/2-1} & Im Y_{1,N/2}
         \\ \texttt{.......}
         \\ Re Y_{M/2-1,0} &  Re Y_{M-3,1}  & Im Y_{M-3,1} &  \cdots & Re Y_{M-3,N/2-1} & Im Y_{M-3,N/2-1}& Re Y_{M/2-1,N/2}
         \\ Im Y_{M/2-1,0} &  Re Y_{M-2,1}  & Im Y_{M-2,1} & \cdots & Re Y_{M-2,N/2-1} & Im Y_{M-2,N/2-1}& Im Y_{M/2-1,N/2}
         \\ Re Y_{M/2,0}  &  Re Y_{M-1,1} &  Im Y_{M-1,1} &  \cdots & Re Y_{M-1,N/2-1} & Im Y_{M-1,N/2-1}& Re Y_{M/2,N/2} \end{bmatrix}

    In case of 1D transform of a real vector, the output looks like the first row of the matrix above.

    So, the function chooses an operation mode depending on the flags and size of the input array:
    -   If #kDftRows is set or the input array has a single row or single column, the function
        performs a 1D forward or inverse transform of each row of a matrix when #kDftRows is set.
        Otherwise, it performs a 2D transform.
    -   If the input array is real and #kDftInverse is not set, the function performs a forward 1D or
        2D transform:
        -   When #kDftComplexOutput is set, the output is a complex matrix of the same size as
            input.
        -   When #kDftComplexOutput is not set, the output is a real matrix of the same size as
            input. In case of 2D transform, it uses the packed format as shown above. In case of a
            single 1D transform, it looks like the first row of the matrix above. In case of
            multiple 1D transforms (when using the #kDftRows flag), each row of the output matrix
            looks like the first row of the matrix above.
    -   If the input array is complex and either #kDftInverse or #kDftRealOutput are not set, the
        output is a complex array of the same size as input. The function performs a forward or
        inverse 1D or 2D transform of the whole input array or each row of the input array
        independently, depending on the flags kDftInverse and kDftRows.
    -   When #kDftInverse is set and the input array is real, or it is complex but #kDftRealOutput
        is set, the output is a real array of the same size as input. The function performs a 1D or 2D
        inverse transformation of the whole input array or each individual row, depending on the flags
        #kDftInverse and #kDftRows.

    If #kDftScale is set, the scaling is done after the transformation.

    Unlike dct, the function supports arrays of arbitrary size. But only those arrays are processed
    efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the
    current implementation). Such an efficient DFT size can be calculated using the get_optimal_dft_size
    method.

    The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:

    .. code-block:: c++

            void convolveDFT(InputArray A, InputArray B, OutputArray C)
            {
        reallocate the output array if needed
                C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
                Size dftSize;
        calculate the size of DFT transform
                dftSize.width = get_optimal_dft_size(A.cols + B.cols - 1);
                dftSize.height = get_optimal_dft_size(A.rows + B.rows - 1);

        allocate temporary buffers and initialize them with 0's
                Mat tempA(dftSize, A.type(), Scalar::all(0));
                Mat tempB(dftSize, B.type(), Scalar::all(0));

        copy A and B to the top-left corners of tempA and tempB, respectively
                Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
                A.copy_to(roiA);
                Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
                B.copy_to(roiB);

        now transform the padded A & B in-place;
        use "non_zero_rows" hint for faster processing
                dft(tempA, tempA, 0, A.rows);
                dft(tempB, tempB, 0, B.rows);

        multiply the spectrums;
        the function handles packed spectrum representations well
                mul_spectrums(tempA, tempB, tempA);

        transform the product back from the frequency domain.
        Even though all the result rows will be non-zero,
        you need only the first C.rows of them, and thus you
        pass non_zero_rows == C.rows
                dft(tempA, tempA, kDftInverse + kDftScale, C.rows);

        now copy the result back to C.
                tempA(Rect(0, 0, C.cols, C.rows)).copy_to(C);

        all the temporary buffers will be deallocated automatically
            }
    To optimize this sample, consider the following approaches:
    -   Since non_zero_rows != 0 is passed to the forward transform calls and since A and B are copied to
        the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole
        tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)
        rightmost columns of the matrices.
    -   This DFT-based convolution does not have to be applied to the whole big arrays, especially if B
        is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.
        To do this, you need to split the output array C into multiple tiles. For each tile, estimate
        which parts of A and B are required to calculate convolution in this tile. If the tiles in C are
        too small, the speed will decrease a lot because of repeated work. In the ultimate case, when
        each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution
        algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and
        there is also a slowdown because of bad cache locality. So, there is an optimal tile size
        somewhere in the middle.
    -   If different tiles in C can be calculated in parallel and, thus, the convolution is done by
        parts, the loop can be threaded.

    All of the above improvements have been implemented in #match_template and #filter2d . Therefore, by
    using them, you can get the performance even better than with the above theoretically optimal
    implementation. Though, those two functions actually calculate cross-correlation, not convolution,
    so you need to "flip" the second convolution operand B vertically and horizontally using flip .

    :type src: :py:class:`Mat`
    :param src: input array that could be real or complex.
    :type dst: :py:class:`Mat`
    :param dst: output array whose size and type depends on the flags .
    :type flags: int, optional
    :param flags: transformation flags, representing a combination of the #DftFlags
    :type non_zero_rows: int, optional
    :param non_zero_rows: when the parameter is not zero, the function assumes that only the first
        non_zero_rows rows of the input array (#kDftInverse is not set) or only the first non_zero_rows of the
        output array (#kDftInverse is set) contain non-zeros, thus, the function can handle the rest of the
        rows more efficiently and save some time; this technique is very useful for calculating array
        cross-correlation or convolution using DFT.
    See also: dct , get_optimal_dft_size , mul_spectrums, filter2d , match_template , flip , cart_to_polar ,
    magnitude , phase
    """
    return _pyaqcv.dft(*args)

def idft(*args):
    r"""
     Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

    idft(src, dst, flags) is equivalent to dft(src, dst, flags | #kDftInverse) .
    Notes: None of dft and idft scales the result by default. So, you should pass #kDftScale to one of
    dft or idft explicitly to make these transforms mutually inverse.
    See also: dft, dct, idct, mul_spectrums, get_optimal_dft_size
    :type src: :py:class:`Mat`
    :param src: input floating-point real or complex array.
    :type dst: :py:class:`Mat`
    :param dst: output array whose size and type depend on the flags.
    :type flags: int, optional
    :param flags: operation flags (see dft and #DftFlags).
    :type non_zero_rows: int, optional
    :param non_zero_rows: number of dst rows to process; the rest of the rows have undefined content (see
        the convolution sample in dft description.
    """
    return _pyaqcv.idft(*args)

def dct(*args):
    r"""
     Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

    The function aqcv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D
    floating-point array:
    -   Forward Cosine transform of a 1D vector of N elements:

         .. math::

             Y = C^{(N)}  \cdot X
        where

         .. math::

             C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )
        and
         :math:`\alpha_0=1` ,  :math:`\alpha_j=2`  for *j > 0*.
    -   Inverse Cosine transform of a 1D vector of N elements:

         .. math::

             X =  \left (C^{(N)} \right )^{-1}  \cdot Y =  \left (C^{(N)} \right )^T  \cdot Y
        (since  :math:`C^{(N)}`  is an orthogonal matrix,  :math:`C^{(N)} \cdot \left(C^{(N)}\right)^T = I`  )
    -   Forward 2D Cosine transform of M x N matrix:

         .. math::

             Y = C^{(N)}  \cdot X  \cdot \left (C^{(N)} \right )^T
    -   Inverse 2D Cosine transform of M x N matrix:

         .. math::

             X =  \left (C^{(N)} \right )^T  \cdot X  \cdot C^{(N)}

    The function chooses the mode of operation by looking at the flags and size of the input array:
    -   If (flags & #kDctInverse) == 0 , the function does a forward 1D or 2D transform. Otherwise, it
        is an inverse 1D or 2D transform.
    -   If (flags & #kDctRows) != 0 , the function performs a 1D transform of each row.
    -   If the array is a single column or a single row, the function performs a 1D transform.
    -   If none of the above is true, the function performs a 2D transform.

    Notes: Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you
    can pad the array when necessary.
    Also, the function performance depends very much, and not monotonically, on the array size (see
    get_optimal_dft_size ). In the current implementation DCT of a vector of size N is calculated via DFT
    of a vector of size N/2 . Thus, the optimal DCT size N1 >= N can be calculated as:

    .. code-block:: c++

            size_t get_optimal_dft_size(size_t N) { return 2*get_optimal_dft_size((N+1)/2); }
            N1 = get_optimal_dft_size(N);
    :type src: :py:class:`Mat`
    :param src: input floating-point array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src .
    :type flags: int, optional
    :param flags: transformation flags as a combination of aqcv::DftFlags
    See also: dft , get_optimal_dft_size , idct
    """
    return _pyaqcv.dct(*args)

def idct(*args):
    r"""
     Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

    idct(src, dst, flags) is equivalent to dct(src, dst, flags | kDftInverse).
    :type src: :py:class:`Mat`
    :param src: input floating-point single-channel array.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type as src.
    :type flags: int, optional
    :param flags: operation flags.
    See also: dct, dft, idft, get_optimal_dft_size
    """
    return _pyaqcv.idct(*args)

def mul_spectrums(a, b, c, flags, conj_b=False):
    r"""
     Performs the per-element multiplication of two Fourier spectrums.

    The function aqcv::mul_spectrums performs the per-element multiplication of the two CCS-packed or complex
    matrices that are results of a real or complex Fourier transform.

    The function, together with dft and idft , may be used to calculate convolution (pass conj_b=false )
    or correlation (pass conj_b=true ) of two arrays rapidly. When the arrays are complex, they are
    simply multiplied (per element) with an optional conjugation of the second-array elements. When the
    arrays are real, they are assumed to be CCS-packed (see dft for details).
    :type a: :py:class:`Mat`
    :param a: first input array.
    :type b: :py:class:`Mat`
    :param b: second input array of the same size and type as src1 .
    :type c: :py:class:`Mat`
    :param c: output array of the same size and type as src1 .
    :type flags: int
    :param flags: operation flags; currently, the only supported flag is aqcv::kDftRows, which indicates that
        each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a `0` as value.
    :type conj_b: boolean, optional
    :param conj_b: optional flag that conjugates the second input array before the multiplication (true)
        or not (false).
    """
    return _pyaqcv.mul_spectrums(a, b, c, flags, conj_b)

def get_optimal_dft_size(vecsize):
    r"""
     Returns the optimal DFT size for a given vector size.

    DFT performance is not a monotonic function of a vector size. Therefore, when you calculate
    convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to
    pad the input data with zeros to get a bit larger array that can be transformed much faster than the
    original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process.
    Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5*5*3*2*2)
    are also processed quite efficiently.

    The function aqcv::get_optimal_dft_size returns the minimum number N that is greater than or equal to vecsize
    so that the DFT of a vector of size N can be processed efficiently. In the current implementation N
    = 2 ^p^ * 3 ^q^ * 5 ^r^ for some integer p, q, r.

    The function returns a negative number if vecsize is too large (very close to INT_MAX ).

    While the function cannot be used directly to estimate the optimal vector size for DCT transform
    (since the current DCT implementation supports only even-size vectors), it can be easily processed
    as get_optimal_dft_size((vecsize+1)/2)*2.
    :type vecsize: int
    :param vecsize: vector size.
    See also: dft , dct , idft , idct , mul_spectrums
    """
    return _pyaqcv.get_optimal_dft_size(vecsize)
class PCA(object):
    r"""
     Principal Component Analysis

    The class is used to calculate a special basis for a set of vectors. The
    basis will consist of eigenvectors of the covariance matrix calculated
    from the input set of vectors. The class %PCA can also transform
    vectors to/from the new coordinate space defined by the basis. Usually,
    in this new coordinate system, each vector from the original set (and
    any linear combination of such vectors) can be quite accurately
    approximated by taking its first few components, corresponding to the
    eigenvectors of the largest eigenvalues of the covariance matrix.
    Geometrically it means that you calculate a projection of the vector to
    a subspace formed by a few eigenvectors corresponding to the dominant
    eigenvalues of the covariance matrix. And usually such a projection is
    very close to the original vector. So, you can represent the original
    vector from a high-dimensional space with a much shorter vector
    consisting of the projected vector's coordinates in the subspace. Such a
    transformation is also known as Karhunen-Loeve Transform, or KLT.
    See http://en.wikipedia.org/wiki/Principal_component_analysis

    The sample below is the function that takes two matrices. The first
    function stores a set of vectors (a row per vector) that is used to
    calculate PCA. The second function stores another "test" set of vectors
    (a row per vector). First, these vectors are compressed with PCA, then
    reconstructed back, and then the reconstruction error norm is computed
    and printed for each vector. :

    .. code-block:: c++

        using namespace aqcv;

        PCA compressPCA(const Mat& pcaset, int max_components,
                        const Mat& testset, Mat& compressed)
        {
            PCA pca(pcaset, // pass the data
                    Mat(), // we do not have a pre-computed mean vector,
        so let the PCA engine to compute it
                    PCA::kDataAsRow, // indicate that the vectors
        are stored as matrix rows
        (use PCA::kDataAsCol if the vectors are
        the matrix columns)
                    max_components // specify, how many principal components to retain
                    );
        if there is no test data, just return the computed basis, ready-to-use
            if( !testset.data )
                return pca;
            AQCV_ASSERT( testset.cols == pcaset.cols );

            compressed.create(testset.rows, max_components, testset.type());

            Mat reconstructed;
            for( int i = 0; i < testset.rows; i++ )
            {
                Mat vec = testset.row(i), coeffs = compressed.row(i), reconstructed;
        compress the vector, the result will be stored
        in the i-th row of the output matrix
                pca.project(vec, coeffs);
        and then reconstruct it
                pca.back_project(coeffs, reconstructed);
        and measure the error
                printf("%d. diff = %g\n", i, norm(vec, reconstructed, kNormL2));
            }
            return pca;
        }
    See also: calc_covar_matrix, mul_transposed, SVD, dft, dct
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kDataAsRow = _pyaqcv.PCA_kDataAsRow
    r"""indicates that the input samples are stored as matrix rows"""
    kDataAsCol = _pyaqcv.PCA_kDataAsCol
    r"""indicates that the input samples are stored as matrix columns"""
    kUseAge = _pyaqcv.PCA_kUseAge

    def __init__(self, *args):
        r"""
        default constructor

           The default constructor initializes an empty %PCA structure. The other
           constructors initialize the structure and call PCA::operator()().
        """
        _pyaqcv.PCA_swiginit(self, _pyaqcv.new_PCA(*args))

    def __call__(self, *args):
        r"""
        performs %PCA

           The operator performs %PCA of the supplied dataset. It is safe to reuse
           the same PCA structure for multiple datasets. That is, if the structure
           has been previously used with another dataset, the existing internal
           data is reclaimed and the new 'eigenvalues', 'eigenvectors' and
           mean are allocated and computed.

           The computed 'eigenvalues' are sorted from the largest to the smallest and
           the corresponding 'eigenvectors' are stored as eigenvectors rows.

           :type data: :py:class:`Mat`
           :param data: input samples stored as the matrix rows or as the matrix
               columns.
           :type mean: :py:class:`Mat`
           :param mean: optional mean value; if the matrix is empty (no_array()),
               the mean is computed from the data.
           :type flags: int
           :param flags: operation flags; currently the parameter is only used to
               specify the data layout. (Flags)
           :type max_components: int, optional
           :param max_components: maximum number of components that PCA should
               retain; by default, all the components are retained.
        """
        return _pyaqcv.PCA___call__(self, *args)

    def project(self, *args):
        r"""
        Projects vector(s) to the principal component subspace.

           The methods project one or more vectors to the principal component
           subspace, where each vector projection is represented by coefficients in
           the principal component basis. The first form of the method returns the
           matrix that the second form writes to the result. So the first form can
           be used as a part of expression while the second form can be more
           efficient in a processing loop.
           :type vec: :py:class:`Mat`
           :param vec: input vector(s); must have the same dimensionality and the
               same layout as the input data used at %PCA phase, that is, if
               kDataAsRow are specified, then `vec.cols==data.cols`
               (vector dimensionality) and `vec.rows` is the number of vectors to
               project, and the same is true for the PCA::kDataAsCol case.
        """
        return _pyaqcv.PCA_project(self, *args)

    def back_project(self, *args):
        r"""
        Reconstructs vectors from their PC projections.

           The methods are inverse operations to PCA::project. They take PC
           coordinates of projected vectors and reconstruct the original vectors.
           Unless all the principal components have been retained, the
           reconstructed vectors are different from the originals. But typically,
           the difference is small if the number of components is large enough (but
           still much smaller than the original vector dimensionality). As a
           result, PCA is used.
           :type vec: :py:class:`Mat`
           :param vec: coordinates of the vectors in the principal component
               subspace, the layout and size are the same as of PCA::project output
               vectors.
        """
        return _pyaqcv.PCA_back_project(self, *args)
    __swig_destroy__ = _pyaqcv.delete_PCA
    eigenvectors = property(_pyaqcv.PCA_eigenvectors_get, _pyaqcv.PCA_eigenvectors_set, doc=r"""eigenvectors of the covariation matrix""")
    eigenvalues = property(_pyaqcv.PCA_eigenvalues_get, _pyaqcv.PCA_eigenvalues_set, doc=r"""eigenvalues of the covariation matrix""")
    mean = property(_pyaqcv.PCA_mean_get, _pyaqcv.PCA_mean_set, doc=r"""mean value subtracted before the projection and added after the back projection""")

# Register PCA in _pyaqcv:
_pyaqcv.PCA_swigregister(PCA)

def pca_compute(*args):
    r"""
    *Overload 1:*
    wrap PCA::operator()

    |

    *Overload 2:*
    wrap PCA::operator() and add eigenvalues output parameter

    |

    *Overload 3:*
    wrap PCA::operator() and add eigenvalues output parameter

    |

    *Overload 4:*
    wrap PCA::operator()

    |

    *Overload 5:*
    wrap PCA::operator() and add eigenvalues output parameter
    """
    return _pyaqcv.pca_compute(*args)

def pca_project(data, mean, eigenvectors, result):
    r"""wrap PCA::project"""
    return _pyaqcv.pca_project(data, mean, eigenvectors, result)

def pca_back_project(data, mean, eigenvectors, result):
    r"""wrap PCA::back_project"""
    return _pyaqcv.pca_back_project(data, mean, eigenvectors, result)
class LDA(object):
    r"""
     Linear Discriminant Analysis

    Linear discriminant analysis (LDA) is the induction of Fisher's linear discrimination method.
    This method uses statistics, pattern recognition and machine learning methods to try to find
    a linear combination of the characteristics of two types of objects or events, so as to
    characterize or distinguish them. The resulting combination can be used as a linear classifier,
    or, more commonly, to reduce the dimension for subsequent classification.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        constructor
           Initializes a LDA with num_components (default 0).

        |

        *Overload 2:*
        Initializes and performs a Discriminant Analysis with Fisher's
            Optimization Criterion on given data in src and corresponding labels
            in labels. If 0 (or less) number of components are given, they are
            automatically determined for given data in computation.

        |

        *Overload 3:*
        Initializes and performs a Discriminant Analysis with Fisher's
            Optimization Criterion on given data in src and corresponding labels
            in labels. If 0 (or less) number of components are given, they are
            automatically determined for given data in computation.
        """
        _pyaqcv.LDA_swiginit(self, _pyaqcv.new_LDA(*args))
    __swig_destroy__ = _pyaqcv.delete_LDA

    def compute(self, *args):
        r"""Compute the discriminants for data in src (row aligned) and labels."""
        return _pyaqcv.LDA_compute(self, *args)

    def project(self, *args):
        r"""
        Projects samples into the LDA subspace.
               src may be one or more row aligned samples.
        """
        return _pyaqcv.LDA_project(self, *args)

    def reconstruct(self, *args):
        r"""
        Reconstructs projections from the LDA subspace.
               src may be one or more row aligned projections.
        """
        return _pyaqcv.LDA_reconstruct(self, *args)

    def eigenvectors(self):
        r"""Returns the eigenvectors of this LDA."""
        return _pyaqcv.LDA_eigenvectors(self)

    def eigenvalues(self):
        r"""Returns the eigenvalues of this LDA."""
        return _pyaqcv.LDA_eigenvalues(self)

    @staticmethod
    def subspace_project(*args):
        return _pyaqcv.LDA_subspace_project(*args)

    @staticmethod
    def subspace_reconstruct(*args):
        return _pyaqcv.LDA_subspace_reconstruct(*args)

# Register LDA in _pyaqcv:
_pyaqcv.LDA_swigregister(LDA)
class SVD(object):
    r"""
     Singular Value Decomposition

    Class for computing Singular Value Decomposition of a floating-point
    matrix. The Singular Value Decomposition is used to solve least-square
    problems, under-determined linear systems, invert matrices, compute
    condition numbers, and so on.

    If you want to compute a condition number of a matrix or an absolute value of
    its determinant, you do not need `u` and `vt`. You can pass
    flags=SVD::kNoUV|... . Another flag SVD::kFullUV indicates that full-size u
    and vt must be computed, which is not necessary most of the time.

    See also: invert, solve, eigen, determinant
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kDefault = _pyaqcv.SVD_kDefault
    r"""build in, can not use."""
    kModifyA = _pyaqcv.SVD_kModifyA
    r"""
    allow the algorithm to modify the decomposed matrix; it can save space and speed up
               processing. currently ignored.
    """
    kNoUV = _pyaqcv.SVD_kNoUV
    r"""
    indicates that only a vector of singular values `w` is to be processed, while u and vt
               will be set to empty matrices
    """
    kFullUV = _pyaqcv.SVD_kFullUV
    r"""
    when the matrix is not square, by default the algorithm produces u and vt matrices of
               sufficiently large size for the further A reconstruction; if, however, kFullUV flag is
               specified, u and vt will be full-size square orthogonal matrices.
    """

    def __init__(self, *args):
        r"""
        the default constructor

           initializes an empty SVD structure
        """
        _pyaqcv.SVD_swiginit(self, _pyaqcv.new_SVD(*args))

    def __call__(self, *args):
        r"""
        the operator that performs SVD. The previously allocated u, w and vt are released.

           The operator performs the singular value decomposition of the supplied
           matrix. The u,`vt` , and the vector of singular values w are stored in
           the structure. The same SVD structure can be reused many times with
           different matrices. Each time, if needed, the previous u,`vt` , and w
           are reclaimed and the new matrices are created, which is all handled by
           Mat::create.
           :type src: :py:class:`Mat`
           :param src: decomposed matrix. The depth has to be AQ_32F or AQ_64F.
           :type flags: int, optional
           :param flags: operation flags (SVD::Flags)
        """
        return _pyaqcv.SVD___call__(self, *args)

    @staticmethod
    def compute(*args):
        r"""
        decomposes matrix and stores the results to user-provided matrices

           The methods/functions perform SVD of matrix. Unlike SVD::SVD constructor
           and SVD::operator(), they store the results to the user-provided
           matrices:

           .. code-block:: c++

               Mat A, w, u, vt;
               SVD::compute(A, w, u, vt);

           :type src: :py:class:`Mat`
           :param src: decomposed matrix. The depth has to be AQ_32F or AQ_64F.
           :type w: :py:class:`Mat`
           :param w: calculated singular values
           :type u: :py:class:`Mat`
           :param u: calculated left singular vectors
           :type vt: :py:class:`Mat`
           :param vt: transposed matrix of right singular vectors
           :type flags: int, optional
           :param flags: operation flags - see SVD::Flags.
        """
        return _pyaqcv.SVD_compute(*args)

    @staticmethod
    def solve_z(src, dst):
        r"""
        solves an under-determined singular linear system

           The method finds a unit-length solution x of a singular linear system
           A*x = 0. Depending on the rank of A, there can be no solutions, a
           single solution or an infinite number of solutions. In general, the
           algorithm solves the following problem:

            .. math::

                dst =  \arg \min _{x:  \| x \| =1}  \| src  \cdot x  \|
           :type src: :py:class:`Mat`
           :param src: left-hand-side matrix.
           :type dst: :py:class:`Mat`
           :param dst: found solution.
        """
        return _pyaqcv.SVD_solve_z(src, dst)

    def back_subst(self, *args):
        r"""
        *Overload 1:*
        performs back substitution

        |

        *Overload 2:*
        performs a singular value back substitution.

           The method calculates a back substitution for the specified right-hand
           side:

            .. math::

                \texttt{x} =  \texttt{vt} ^T  \cdot diag( \texttt{w} )^{-1}  \cdot \texttt{u} ^T  \cdot \texttt{rhs} \sim \texttt{A} ^{-1}  \cdot \texttt{rhs}

           Using this technique you can either get a very accurate solution of the
           convenient linear system, or the best (in the least-squares terms)
           pseudo-solution of an overdetermined linear system.

           :type rhs: :py:class:`Mat`
           :param rhs: right-hand side of a linear system (u*w*v')*dst = rhs to
               be solved, where A has been previously decomposed.

           :type dst: :py:class:`Mat`
           :param dst: found solution of the system.

           Notes: Explicit SVD with the further back substitution only makes sense
           if you need to solve many linear systems with the same left-hand side
           (for example, src ). If all you need is to solve a single system
           (possibly with multiple rhs immediately available), simply call solve
           add pass #kDecompSVD there. It does absolutely the same thing.
        """
        return _pyaqcv.SVD_back_subst(self, *args)
    __swig_destroy__ = _pyaqcv.delete_SVD
    u = property(_pyaqcv.SVD_u_get, _pyaqcv.SVD_u_set)
    w = property(_pyaqcv.SVD_w_get, _pyaqcv.SVD_w_set)
    vt = property(_pyaqcv.SVD_vt_get, _pyaqcv.SVD_vt_set)

# Register SVD in _pyaqcv:
_pyaqcv.SVD_swigregister(SVD)

def svd_decomp(*args):
    r"""wrap SVD::compute"""
    return _pyaqcv.svd_decomp(*args)

def svd_back_subst(w, u, vt, rhs, dst):
    r"""wrap SVD::back_subst"""
    return _pyaqcv.svd_back_subst(w, u, vt, rhs, dst)
class RNG(object):
    r"""
     Random Number Generator

    Random number generator. It encapsulates the state (currently, a 64-bit
    integer) and has methods to return scalar random values and to fill
    arrays with random values. Currently it supports uniform and Gaussian
    (normal) distributions. The generator uses Multiply-With-Carry
    algorithm, introduced by G. Marsaglia (
    <http://en.wikipedia.org/wiki/Multiply-with-carry> ).
    Gaussian-distribution random numbers are generated using the Ziggurat
    algorithm ( <http://en.wikipedia.org/wiki/Ziggurat_algorithm> ),
    introduced by G. Marsaglia and W. W. Tsang.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kUniform = _pyaqcv.RNG_kUniform
    kNormal = _pyaqcv.RNG_kNormal

    def __init__(self, *args):
        r"""
        constructor

           These are the RNG constructors. The first form sets the state to some
           pre-defined value, equal to 2**32-1 in the current implementation. The
           second form sets the state to the specified value. If you passed state=0
           , the constructor uses the above default value instead to avoid the
           singular random number sequence, consisting of all zeros.
        """
        _pyaqcv.RNG_swiginit(self, _pyaqcv.new_RNG(*args))

    def next(self):
        r"""
        The method updates the state using the MWC algorithm and returns the
            next 32-bit random number.
        """
        return _pyaqcv.RNG_next(self)

    def __call__(self, *args):
        r"""
        returns a random integer sampled uniformly from [0, N).

           The methods transform the state using the MWC algorithm and return the
           next random number. The first form is equivalent to RNG::next . The
           second form returns the random number modulo N , which means that the
           result is in the range [0, N) .
        """
        return _pyaqcv.RNG___call__(self, *args)

    def uniform(self, *args):
        r"""
        returns uniformly distributed integer random number from [a,b) range

           The methods transform the state using the MWC algorithm and return the
           next uniformly-distributed random number of the specified type, deduced
           from the input parameter type, from the range [a, b) . There is a nuance
           illustrated by the following sample:

           .. code-block:: c++

               RNG rng;

           always produces 0
               double a = rng.uniform(0, 1);

           produces double from [0, 1)
               double a1 = rng.uniform((double)0, (double)1);

           produces float from [0, 1)
               float b = rng.uniform(0.f, 1.f);

           produces double from [0, 1)
               double c = rng.uniform(0., 1.);

           may cause compiler error because of ambiguity:
            RNG::uniform(0, (int)0.999999)? or RNG::uniform((double)0, 0.99999)?
               double d = rng.uniform(0, 0.999999);

           The compiler does not take into account the type of the variable to
           which you assign the result of RNG::uniform . The only thing that
           matters to the compiler is the type of a and b parameters. So, if you
           want a floating-point random number, but the range boundaries are
           integer numbers, either put dots in the end, if they are constants, or
           use explicit type cast operators, as in the a1 initialization above.
           :type a: int
           :param a: lower inclusive boundary of the returned random number.
           :type b: int
           :param b: upper non-inclusive boundary of the returned random number.
        """
        return _pyaqcv.RNG_uniform(self, *args)

    def fill(self, *args):
        r"""
        Fills arrays with random numbers.

           :type mat: :py:class:`_InputOutputArray`
           :param mat: 2D or N-dimensional matrix; currently matrices with more than
               4 channels are not supported by the methods, use Mat::reshape as a
               possible workaround.
           :type dist_type: int
           :param dist_type: distribution type, RNG::kUniform or RNG::kNormal.
           :type a: :py:class:`_InputArray`
           :param a: first distribution parameter; in case of the uniform
               distribution, this is an inclusive lower boundary, in case of the normal
               distribution, this is a mean value.
           :type b: :py:class:`_InputArray`
           :param b: second distribution parameter; in case of the uniform
               distribution, this is a non-inclusive upper boundary, in case of the
               normal distribution, this is a standard deviation (diagonal of the
               standard deviation matrix or the full standard deviation matrix).
           :type saturate_range: boolean, optional
           :param saturate_range: pre-saturation flag; for uniform distribution only;
               if true, the method will first convert a and b to the acceptable value
               range (according to the mat datatype) and then will generate uniformly
               distributed random numbers within the range [saturate(a), saturate(b)),
               if saturate_range=false, the method will generate uniformly distributed
               random numbers in the original range [a, b) and then will saturate them,
               it means, for example, that
               the_rng().fill(mat_8u, RNG::kUniform, -DBL_MAX, DBL_MAX) will likely
               produce array mostly filled with 0's and 255's, since the range (0, 255)
               is significantly smaller than [-DBL_MAX, DBL_MAX).

           Each of the methods fills the matrix with the random values from the
           specified distribution. As the new numbers are generated, the RNG state
           is updated accordingly. In case of multiple-channel images, every
           channel is filled independently, which means that RNG cannot generate
           samples from the multi-dimensional Gaussian distribution with
           non-diagonal covariance matrix directly. To do that, the method
           generates samples from multi-dimensional standard Gaussian distribution
           with zero mean and identity covariation matrix, and then transforms them
           using transform to get samples from the specified Gaussian distribution.
        """
        return _pyaqcv.RNG_fill(self, *args)

    def gaussian(self, sigma):
        r"""
        Returns the next random number sampled from the Gaussian distribution
           :type sigma: float
           :param sigma: standard deviation of the distribution.

           The method transforms the state using the MWC algorithm and returns the
           next random number from the Gaussian distribution N(0,sigma) . That is,
           the mean value of the returned random numbers is zero and the standard
           deviation is the specified sigma .
        """
        return _pyaqcv.RNG_gaussian(self, sigma)
    state = property(_pyaqcv.RNG_state_get, _pyaqcv.RNG_state_set)

    def __eq__(self, other):
        return _pyaqcv.RNG___eq__(self, other)
    __swig_destroy__ = _pyaqcv.delete_RNG

# Register RNG in _pyaqcv:
_pyaqcv.RNG_swigregister(RNG)

def the_rng():
    r"""
     Returns the default random number generator.

    The function aqcv::the_rng returns the default random number generator. For each thread, there is a
    separate random number generator, so you can use the function safely in multi-thread environments.
    If you just need to get a single random number using this generator or initialize an array, you can
    use randu or randn instead. But if you are going to generate many random numbers inside a loop, it
    is much faster to use this function to retrieve the generator and then use RNG::operator _Tp() .
    See also: RNG, randu, randn
    """
    return _pyaqcv.the_rng()

def set_rng_seed(seed):
    r"""
     Sets state of default random number generator.

    The function aqcv::set_rng_seed sets state of default random number generator to custom value.
    :type seed: int
    :param seed: new state for default random number generator
    See also: RNG, randu, randn
    """
    return _pyaqcv.set_rng_seed(seed)

def randu(dst, low, high):
    r"""
     Generates a single uniformly-distributed random number or an array of random numbers.

    Non-template variant of the function fills the matrix dst with uniformly-distributed
    random numbers from the specified range:

     .. math::

         \texttt{low} _c  \leq \texttt{dst} (I)_c <  \texttt{high} _c
    :type dst: :py:class:`_InputOutputArray`
    :param dst: output array of random numbers; the array must be pre-allocated.
    :type low: :py:class:`_InputArray`
    :param low: inclusive lower boundary of the generated random numbers.
    :type high: :py:class:`_InputArray`
    :param high: exclusive upper boundary of the generated random numbers.
    See also: RNG, randn, the_rng
    """
    return _pyaqcv.randu(dst, low, high)

def randn(dst, mean, stddev):
    r"""
     Fills the array with normally distributed random numbers.

    The function aqcv::randn fills the matrix dst with normally distributed random numbers with the specified
    mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the
    value range of the output array data type.
    :type dst: :py:class:`_InputOutputArray`
    :param dst: output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.
    :type mean: :py:class:`_InputArray`
    :param mean: mean value (expectation) of the generated random numbers.
    :type stddev: :py:class:`_InputArray`
    :param stddev: standard deviation of the generated random numbers; it can be either a vector (in
        which case a diagonal standard deviation matrix is assumed) or a square matrix.
    See also: RNG, randu
    """
    return _pyaqcv.randn(dst, mean, stddev)

def rand_shuffle(dst, iter_factor=1., rng=None):
    r"""
     Shuffles the array elements randomly.

    The function aqcv::rand_shuffle shuffles the specified 1D array by randomly choosing pairs of elements and
    swapping them. The number of such swap operations will be dst.rows*dst.cols*iterFactor .
    :type dst: :py:class:`_InputOutputArray`
    :param dst: input/output numerical 1D array.
    :param iterFactor: scale factor that determines the number of random swap operations (see the details
        below).
    :type rng: :py:class:`RNG`, optional
    :param rng: optional random number generator used for shuffling; if it is zero, the_rng () is used
        instead.
    See also: RNG, sort
    """
    return _pyaqcv.rand_shuffle(dst, iter_factor, rng)
kKmeansRandomCenters = _pyaqcv.kKmeansRandomCenters
r"""Select random initial centers in each attempt."""
kKmeansPPCenters = _pyaqcv.kKmeansPPCenters
r"""Use kmeans++ center initialization by Arthur and Vassilvitskii [Arthur2007]."""
kKmeansUseInitialLabels = _pyaqcv.kKmeansUseInitialLabels
r"""
    During the first (and possibly the only) attempt, use the
           user-supplied labels instead of computing them from the initial centers. For the second and
           further attempts, use the random or semi-random centers. Use one of kKmeans_*_Centers flag
           to specify the exact method.
    """

def kmeans(*args):
    r"""
     Finds centers of clusters and groups input samples around the clusters.

    The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters
    and groups the input samples around the clusters. As an output,  :math:`\texttt{bestLabels}_i`  contains a
    0-based cluster index for the sample stored in the  :math:`i^{th}`  row of the samples matrix.

    :type data: :py:class:`_InputArray`
    :param data: Data for clustering. An array of N-Dimensional points with float coordinates is needed.
        Examples of this array can be:
        -   Mat points(count, 2, AQ_32F);
        -   Mat points(count, 1, AQ_32FC2);
        -   Mat points(1, count, AQ_32FC2);
        -   std::vector<aqcv::Point2f> points(sample_count);
    :type K: int
    :param K: Number of clusters to split the set by.
    :type bestLabels: :py:class:`_InputOutputArray`
    :param bestLabels: Input/output integer array that stores the cluster indices for every sample.
    :type criteria: :py:class:`TermCriteria`
    :param criteria: The algorithm termination criteria, that is, the maximum number of iterations and/or
        the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster
        centers moves by less than criteria.epsilon on some iteration, the algorithm stops.
    :type attempts: int
    :param attempts: Flag to specify the number of times the algorithm is executed using different
        initial labellings. The algorithm returns the labels that yield the best compactness (see the last
        function parameter).
    :type flags: int
    :param flags: Flag that can take values of aqcv::KmeansFlags
    :type centers: :py:class:`_OutputArray`, optional
    :param centers: Output matrix of the cluster centers, one row per each cluster center.
    :rtype: float
    :return: The function returns the compactness measure that is computed as

         .. math::

             \sum _i  \| \texttt{samples} _i -  \texttt{centers} _{ \texttt{labels} _i} \| ^2
    after every attempt. The best (minimum) value is chosen and the corresponding labels and the
    compactness value are returned by the function. Basically, you can use only the core of the
    function, set the number of attempts to 1, initialize labels each time using a custom algorithm,
    pass them with the ( flags = #kKmeansUseInitialLabels ) flag, and then choose the best
    (most-compact) clustering.
    """
    return _pyaqcv.kmeans(*args)

def __iadd__(*args):
    return _pyaqcv.__iadd__(*args)

def __isub__(*args):
    return _pyaqcv.__isub__(*args)

def __imul__(*args):
    return _pyaqcv.__imul__(*args)

def __itruediv__(*args):
    return _pyaqcv.__itruediv__(*args)

def __iand__(*args):
    return _pyaqcv.__iand__(*args)

def __ior__(*args):
    return _pyaqcv.__ior__(*args)

def __ixor__(*args):
    return _pyaqcv.__ixor__(*args)

def get_version_string():
    r"""
     Returns library version string
    For example "1.0.11_alpha".
    See also: get_version_major, get_version_minor, get_version_revision
    """
    return _pyaqcv.get_version_string()

def get_version_major():
    r"""returns major library version"""
    return _pyaqcv.get_version_major()

def get_version_minor():
    r"""returns minor library version"""
    return _pyaqcv.get_version_minor()

def get_version_revision():
    r"""returns revision field of the library version"""
    return _pyaqcv.get_version_revision()

def set_thread_num(nthreads):
    r"""
     aqcv will try to set the number of threads for the next parallel region.

    If threads == 0, aqcv will disable threading optimizations and run all it's functions
    sequentially. Passing threads < 0 will reset threads number to system default. This function must
    be called outside of parallel region.

    :type nthreads: int
    :param nthreads: Number of threads used by aqcv.
    See also: get_thread_num, get_thread_id
    """
    return _pyaqcv.set_thread_num(nthreads)

def get_thread_num():
    r"""
     Returns the number of threads used by aqcv for parallel regions.

    Always returns 1 if aqcv is built without threading support.

    See also: set_thread_num, get_thread_id
    """
    return _pyaqcv.get_thread_num()

def get_thread_maximum_num():
    r"""
     Returns the maximum threads number(equal to cpu's core count.).
    See also: set_thread_num, get_thread_num
    """
    return _pyaqcv.get_thread_maximum_num()

def get_thread_id():
    r"""
     Returns the index of the currently executed thread within the current parallel region. Always
    returns 0 if called outside of parallel region.

    See also: set_thread_num, get_thread_num
    """
    return _pyaqcv.get_thread_id()

def set_cpu_affinity(core_ids):
    r"""
     set cpu affinity to threads in thread pool.
    :type core_ids: std::vector< int,std::allocator< int > >
    :param core_ids: cpu kernel ids[0-min(cpu_core_num-1,63)] allowed thread to run on.
    :raises: std::exception
    Notes: Only have effect on threads using aqcv_threadpool currently.
    """
    return _pyaqcv.set_cpu_affinity(core_ids)

def get_cpu_affinity():
    r"""
     set cpu affinity to threads in thread pool. See also: set_cpu_affinity
    :rtype: std::vector< int,std::allocator< int > >
    :return: core_ids cpu kernel ids(0-63) allowed thread to run on.
    """
    return _pyaqcv.get_cpu_affinity()

def set_allow_nested_threads(allow_nested):
    r"""
    set allow nested thread parallel or not. Alow nested is useful
    for operators with nested threads call. It is useful for operator using less thread than given kernel
    but have nested thread implementation. However may induce dead lock.
    Warning: It is disenabled by default for safety and only have effect on threads using aqcv_threadpool
    """
    return _pyaqcv.set_allow_nested_threads(allow_nested)

def get_allow_nested_threads():
    r"""get nested thread is allowed or not. See also: set_allow_nested_threads"""
    return _pyaqcv.get_allow_nested_threads()

def current_parallel_framework():
    r"""get parallel framework name"""
    return _pyaqcv.current_parallel_framework()

def get_tick_count():
    r"""
     Returns the number of ticks.
    The function returns the number of ticks after the certain event (for example, when the machine was
    turned on). It can be used to initialize RNG or to measure a function execution time by reading the
    tick count before and after the function call.
    See also: get_tick_frequency
    """
    return _pyaqcv.get_tick_count()

def get_tick_frequency():
    r"""
     Returns the number of ticks per second.

    The function returns the number of ticks per second. That is, the following code computes the
    execution time in seconds:

    .. code-block:: c++

            double t = (double)get_tick_count();
        do something ...
            t = ((double)get_tick_count() - t)/get_tick_frequency();
    See also: get_tick_count
    """
    return _pyaqcv.get_tick_frequency()

def check_cpu_intrins():
    r"""
     Check if the CPU intrinsics satisfy the minimum requirement of aqcv

    The function returns if your CPU intrinsics support internal acceleration used by aqcv.
    If not, it maybe spend more time to run an operator.
    """
    return _pyaqcv.check_cpu_intrins()

def get_elem_size(type):
    return _pyaqcv.get_elem_size(type)
class ParallelLoopBody(object):
    r"""Base class for parallel data processors"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_ParallelLoopBody

    def __call__(self, range):
        return _pyaqcv.ParallelLoopBody___call__(self, range)

# Register ParallelLoopBody in _pyaqcv:
_pyaqcv.ParallelLoopBody_swigregister(ParallelLoopBody)

def parallel_for_(range, body, nstripes=-1.):
    r"""Parallel data processor"""
    return _pyaqcv.parallel_for_(range, body, nstripes)

def align_size(sz, n):
    r"""
     Aligns a buffer size to the specified number of bytes.

    The function returns the minimum number that is greater than or equal to sz and is divisible by n :

     .. math::

         \texttt{(sz + n-1) & -n}
    :type sz: int
    :param sz: Buffer size to align.
    :type n: int
    :param n: Alignment size that must be a power of two.
    """
    return _pyaqcv.align_size(sz, n)

def div_up(*args):
    r"""
     Integer division with result round up.

    Use this function instead of `ceil((float)a / b)` expressions.

    See also: align_size
    """
    return _pyaqcv.div_up(*args)

def round_up(*args):
    r"""
     Round first value up to the nearest multiple of second value.

    Use this function instead of `ceil((float)a / b) * b` expressions.

    See also: div_up
    """
    return _pyaqcv.round_up(*args)

def scalar_to_raw_data(s, buf, type, unroll_to=0):
    return _pyaqcv.scalar_to_raw_data(s, buf, type, unroll_to)

def alloc_singleton_buffer(size):
    r"""Allocate memory buffers which will not be freed, ease filtering memcheck issues. Uses fast_malloc() call."""
    return _pyaqcv.alloc_singleton_buffer(size)

def alloc_singleton_new_buffer(size):
    r"""Allocate memory buffers which will not be freed, ease filtering memcheck issues. Uses generic malloc() call."""
    return _pyaqcv.alloc_singleton_new_buffer(size)
class StopWatch(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.StopWatch_swiginit(self, _pyaqcv.new_StopWatch())
    __swig_destroy__ = _pyaqcv.delete_StopWatch

    def reset(self):
        r"""stop Stop the time interval measurement and reset the running time to zero."""
        return _pyaqcv.StopWatch_reset(self)

    def restart(self):
        r"""Stop the time interval measurement, reset the running time to zero, and then start measuring the running time."""
        return _pyaqcv.StopWatch_restart(self)

    def start(self):
        r"""Start or continue measuring the running time for a certain time interval."""
        return _pyaqcv.StopWatch_start(self)

    def stop(self):
        r"""Stop measuring the running time for a certain time interval."""
        return _pyaqcv.StopWatch_stop(self)

    def is_runing(self):
        r"""Whether the timer is running."""
        return _pyaqcv.StopWatch_is_runing(self)

    def elapsed_miliseconds(self):
        r"""Get the total run time (in milliseconds) measured for the current instance."""
        return _pyaqcv.StopWatch_elapsed_miliseconds(self)

    def elapsed_microseconds(self):
        r"""Get the total run time (in microseconds) measured for the current instance."""
        return _pyaqcv.StopWatch_elapsed_microseconds(self)

# Register StopWatch in _pyaqcv:
_pyaqcv.StopWatch_swigregister(StopWatch)

def floor(value):
    r"""convert value to integer to negative direction"""
    return _pyaqcv.floor(value)

def ceil(value):
    r"""convert value to integer to positive direction"""
    return _pyaqcv.ceil(value)

def round(value):
    r"""
    convert value to it's nearest integer.when there are two
      integer with same distances to value, the result will depeden on odevity of value's integet part.
      if the value is odd, it will convert to nearest integer which far from origin.
     e.g... code-block:: c++

             round(-3.5) = -4; round(3.5) = 4;
             round(-2.5) = -2; round(2.5) = 2;
             round(-1.5) = -2; round(1.5) = 2;
             round(-0.5) = 0; round(0.5) = 0;
    """
    return _pyaqcv.round(value)
class PointFeat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pt = property(_pyaqcv.PointFeat_pt_get, _pyaqcv.PointFeat_pt_set, doc=r"""position""")
    angle = property(_pyaqcv.PointFeat_angle_get, _pyaqcv.PointFeat_angle_set, doc=r"""angle feature""")
    magnitude = property(_pyaqcv.PointFeat_magnitude_get, _pyaqcv.PointFeat_magnitude_set, doc=r"""gradientt magnitude""")
    weight = property(_pyaqcv.PointFeat_weight_get, _pyaqcv.PointFeat_weight_set, doc=r"""weightness""")
    score = property(_pyaqcv.PointFeat_score_get, _pyaqcv.PointFeat_score_set, doc=r"""confidence of feature""")
    is_mod_180 = property(_pyaqcv.PointFeat_is_mod_180_get, _pyaqcv.PointFeat_is_mod_180_set)
    size = property(_pyaqcv.PointFeat_size_get, _pyaqcv.PointFeat_size_set, doc=r"""feature's size""")
    pyr_level = property(_pyaqcv.PointFeat_pyr_level_get, _pyaqcv.PointFeat_pyr_level_set, doc=r"""feature level for pyrmid""")

    def __init__(self):
        _pyaqcv.PointFeat_swiginit(self, _pyaqcv.new_PointFeat())
    __swig_destroy__ = _pyaqcv.delete_PointFeat

# Register PointFeat in _pyaqcv:
_pyaqcv.PointFeat_swigregister(PointFeat)
class PointFeatArraySet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    point_features = property(_pyaqcv.PointFeatArraySet_point_features_get, _pyaqcv.PointFeatArraySet_point_features_set)
    chains_info = property(_pyaqcv.PointFeatArraySet_chains_info_get, _pyaqcv.PointFeatArraySet_chains_info_set)

    def __init__(self):
        _pyaqcv.PointFeatArraySet_swiginit(self, _pyaqcv.new_PointFeatArraySet())
    __swig_destroy__ = _pyaqcv.delete_PointFeatArraySet

# Register PointFeatArraySet in _pyaqcv:
_pyaqcv.PointFeatArraySet_swigregister(PointFeatArraySet)
class AqChainInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_closed = property(_pyaqcv.AqChainInfo_is_closed_get, _pyaqcv.AqChainInfo_is_closed_set)

    def __init__(self):
        _pyaqcv.AqChainInfo_swiginit(self, _pyaqcv.new_AqChainInfo())
    __swig_destroy__ = _pyaqcv.delete_AqChainInfo

# Register AqChainInfo in _pyaqcv:
_pyaqcv.AqChainInfo_swigregister(AqChainInfo)

def enable_exception(enable=True):
    r"""
    global setting, exception is disable by default.
    exception can carry more error information than return value.
    you should catch exception if exception is enabled See also: exception_enabled
    :type enable: boolean, optional
    :param enable: enable flag
    """
    return _pyaqcv.enable_exception(enable)

def exception_enabled():
    r"""
    check whether exception is enabled.
    :rtype: boolean
    :return: bool true indicating exception is enabled.
    """
    return _pyaqcv.exception_enabled()
class Exception(object):
    r"""base exception, all Exception should derived from this class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Exception_swiginit(self, _pyaqcv.new_Exception(*args))
    __swig_destroy__ = _pyaqcv.delete_Exception

    def what(self):
        r"""
        get error message
        :rtype: string
        :return: error message.
        """
        return _pyaqcv.Exception_what(self)

    def name(self):
        r"""get current exception type name"""
        return _pyaqcv.Exception_name(self)

    def err_code(self):
        r"""get err_code, you can also determine the exception type by error code"""
        return _pyaqcv.Exception_err_code(self)

    def get_info(self):
        r"""get original exception info See also: ExceptionInfo"""
        return _pyaqcv.Exception_get_info(self)

# Register Exception in _pyaqcv:
_pyaqcv.Exception_swigregister(Exception)
class AqExceptionInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    msg = property(_pyaqcv.AqExceptionInfo_msg_get, _pyaqcv.AqExceptionInfo_msg_set, doc=r"""error message""")
    func = property(_pyaqcv.AqExceptionInfo_func_get, _pyaqcv.AqExceptionInfo_func_set, doc=r"""exception was throw in which function""")
    file = property(_pyaqcv.AqExceptionInfo_file_get, _pyaqcv.AqExceptionInfo_file_set, doc=r"""file path that throw exception""")
    line = property(_pyaqcv.AqExceptionInfo_line_get, _pyaqcv.AqExceptionInfo_line_set, doc=r"""exception was throw in which line""")
    err_code = property(_pyaqcv.AqExceptionInfo_err_code_get, _pyaqcv.AqExceptionInfo_err_code_set, doc=r"""error code,every Exception has a specific error code""")

    def __init__(self):
        _pyaqcv.AqExceptionInfo_swiginit(self, _pyaqcv.new_AqExceptionInfo())
    __swig_destroy__ = _pyaqcv.delete_AqExceptionInfo

# Register AqExceptionInfo in _pyaqcv:
_pyaqcv.AqExceptionInfo_swigregister(AqExceptionInfo)

def handle_error(e):
    return _pyaqcv.handle_error(e)
class UnknownError(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.UnknownError_swiginit(self, _pyaqcv.new_UnknownError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_UnknownError

# Register UnknownError in _pyaqcv:
_pyaqcv.UnknownError_swigregister(UnknownError)
class MemoryError(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.MemoryError_swiginit(self, _pyaqcv.new_MemoryError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_MemoryError

# Register MemoryError in _pyaqcv:
_pyaqcv.MemoryError_swigregister(MemoryError)
class IOError(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.IOError_swiginit(self, _pyaqcv.new_IOError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_IOError

# Register IOError in _pyaqcv:
_pyaqcv.IOError_swigregister(IOError)
class ArgumentsError(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.ArgumentsError_swiginit(self, _pyaqcv.new_ArgumentsError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_ArgumentsError

# Register ArgumentsError in _pyaqcv:
_pyaqcv.ArgumentsError_swigregister(ArgumentsError)
class LogicError(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.LogicError_swiginit(self, _pyaqcv.new_LogicError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_LogicError

# Register LogicError in _pyaqcv:
_pyaqcv.LogicError_swigregister(LogicError)
class MathError(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.MathError_swiginit(self, _pyaqcv.new_MathError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_MathError

# Register MathError in _pyaqcv:
_pyaqcv.MathError_swigregister(MathError)
class UnimplementedERROR(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.UnimplementedERROR_swiginit(self, _pyaqcv.new_UnimplementedERROR(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_UnimplementedERROR

# Register UnimplementedERROR in _pyaqcv:
_pyaqcv.UnimplementedERROR_swigregister(UnimplementedERROR)
class GeneralAqcvAssertException(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.GeneralAqcvAssertException_swiginit(self, _pyaqcv.new_GeneralAqcvAssertException(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_GeneralAqcvAssertException

# Register GeneralAqcvAssertException in _pyaqcv:
_pyaqcv.GeneralAqcvAssertException_swigregister(GeneralAqcvAssertException)
class GeneralAqcvErrorException(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.GeneralAqcvErrorException_swiginit(self, _pyaqcv.new_GeneralAqcvErrorException(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_GeneralAqcvErrorException

# Register GeneralAqcvErrorException in _pyaqcv:
_pyaqcv.GeneralAqcvErrorException_swigregister(GeneralAqcvErrorException)
class PlatformEnvironmentError(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.PlatformEnvironmentError_swiginit(self, _pyaqcv.new_PlatformEnvironmentError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_PlatformEnvironmentError

# Register PlatformEnvironmentError in _pyaqcv:
_pyaqcv.PlatformEnvironmentError_swigregister(PlatformEnvironmentError)
class FitModelBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_FitModelBase

    def get_min_sample_num(self):
        r"""Get the minimum samples number of build fitmodel."""
        return _pyaqcv.FitModelBase_get_min_sample_num(self)

    def init_model(self, pts_mat, idxs):
        r"""
        Build the fitmodel by using minimum samples.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  the channel is one. the depth is AQ_64F. the cols indicate dimension of samples. the rows indicate numbers of samples.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participated in the build.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.FitModelBase_init_model(self, pts_mat, idxs)

    def fit(self, pts_mat, idxs):
        r"""
        Fit.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participate in fitting, defaultly all points paticipate.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.FitModelBase_fit(self, pts_mat, idxs)

    def distance(self, pts_mat, distance_mat, idxs):
        r"""
        Calculate the distance between samples and fitmodel
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type distance_mat: :py:class:`Mat`
        :param distance_mat:  each row indicate one distance along idxs.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participate in calculating distance, defaultly all points paticipate.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.FitModelBase_distance(self, pts_mat, distance_mat, idxs)

# Register FitModelBase in _pyaqcv:
_pyaqcv.FitModelBase_swigregister(FitModelBase)
class AuthStatus(object):
    r"""authorization status"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _code, msg):
        _pyaqcv.AuthStatus_swiginit(self, _pyaqcv.new_AuthStatus(_code, msg))

    def __nonzero__(self):
        return _pyaqcv.AuthStatus___nonzero__(self)
    __bool__ = __nonzero__


    code = property(_pyaqcv.AuthStatus_code_get, _pyaqcv.AuthStatus_code_set, doc=r"""status code. 0 indicates OK""")
    error_msg = property(_pyaqcv.AuthStatus_error_msg_get, _pyaqcv.AuthStatus_error_msg_set, doc=r"""error message""")
    __swig_destroy__ = _pyaqcv.delete_AuthStatus

# Register AuthStatus in _pyaqcv:
_pyaqcv.AuthStatus_swigregister(AuthStatus)
class AuthCallBack(object):
    r"""
     AuthCallBack base class.(we define a class instead of a std::function is only for convenience multilanguage wrapping)
    A callback function to deal with authorization error by Authorization::set_authorize_callback function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_AuthCallBack

    def handle(self, remain_chance, error_msg):
        r"""callback function, you should implementing the method."""
        return _pyaqcv.AuthCallBack_handle(self, remain_chance, error_msg)

# Register AuthCallBack in _pyaqcv:
_pyaqcv.AuthCallBack_swigregister(AuthCallBack)
class Authorization(object):
    r"""
     Authorization class.
    aqcv only supports hardware dongle authorization currently. An authorization detection cycle will start in 5 minutes after the program started,
    if the authorization verify failed during the first check time, the program will automatically quit after 5 minutes!
    (please complete the saving of your current project within this time, otherwise all losses will be responsible for by you!)
    the subsequent check will be performed every 5 minutes. If 2 consecutive checks fail in the subsequent checking loops,
    the program will exit within 5 minutes after the last failed checking.

    you can set up a callback handler to deal with authorization error by set_authorize_callback function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.Authorization_swiginit(self, _pyaqcv.new_Authorization())
    __swig_destroy__ = _pyaqcv.delete_Authorization

    @staticmethod
    def set_authorize_callback(auth_cb):
        r"""
        set a callback function. The parameters of the callback function are remaing_chance and error msg.
        The authorization only keep a pointer to you callback class, so you must ensure the lifetime of callback
        class(valid during the program running before program quit or disable callback by remove_authorize_callback)
        :type auth_cb: :py:class:`AuthCallBack`
        :param auth_cb: callback when authorization failed.
        """
        return _pyaqcv.Authorization_set_authorize_callback(auth_cb)

    @staticmethod
    def remove_authorize_callback():
        r"""
        remove callback function.
        :param auth_cb: callback when authorization failed.
        """
        return _pyaqcv.Authorization_remove_authorize_callback()

    @staticmethod
    def authorize_status(*args):
        r"""
        checking authorization valid or not(including local and remote(only for sense shield)).
        :param server_addres: only for sense dongle. remote authrozation service ip address, e.g. 192.168.2.130, keep empty to verify local dongle.
        :type dongle_id: string, optional
        :param dongle_id: only for sense dongle. dongle serial number(id), if set, only the dongle with the specified sn will be checked. keep empty to auto detect any valid dongle.
        :rtype: :py:class:`AuthStatus`
        :return: checking status: code == 0 indicates successed. otherwise means some error happened(in status's error_msg).
        Notes: parameters(server_addres and dongle_id) only useful for sense authorization. no effect for sentinel authorization.
        """
        return _pyaqcv.Authorization_authorize_status(*args)

    @staticmethod
    def get_dongle_features():
        r"""
        get dongle feature information(in xml format),only support sentinel dongle.
        :rtype: string
        :return: feat_info checking inforation.
        """
        return _pyaqcv.Authorization_get_dongle_features()

    @staticmethod
    def set_authorize_info(*args):
        r"""
         set automatically loop checking's configuration. set remote authorizaiton or specific dongle(sn serial num)
        :param server_addres: only for sense dongle. remote authrozation service ip address, e.g. 192.168.2.130, keep empty to use local dongle. default empty.
        :type dongle_id: string, optional
        :param dongle_id: only for sense dongle.dongle serial number, if set, only the dongle with the specified sn will be checked. keep empty to auto detect any valid dongle. default empty.
        Notes: only use for sense shield dongle. you must set this informations in five minutes after you program started. server_address and dongle_id
        can not be changed after the first checking(after five minutes running)
        """
        return _pyaqcv.Authorization_set_authorize_info(*args)

    @staticmethod
    def set_remote_authorize_code(auth_code):
        return _pyaqcv.Authorization_set_remote_authorize_code(auth_code)

# Register Authorization in _pyaqcv:
_pyaqcv.Authorization_swigregister(Authorization)
class MD5(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.MD5_swiginit(self, _pyaqcv.new_MD5())
    __swig_destroy__ = _pyaqcv.delete_MD5

    def __call__(self, *args):
        r"""
        *Overload 1:*
        brief compute MD5 of a memory block

        |

        *Overload 2:*
        brief compute MD5 of a string, excluding final zero
        """
        return _pyaqcv.MD5___call__(self, *args)

    def add(self, buffer, num_bytes):
        r"""brief add arbitrary number of bytes (process immediately, none copy)"""
        return _pyaqcv.MD5_add(self, buffer, num_bytes)

    def get_hash(self):
        r"""brief return latest hash as 32 hex characters"""
        return _pyaqcv.MD5_get_hash(self)

    def reset(self):
        r"""brief restart"""
        return _pyaqcv.MD5_reset(self)

# Register MD5 in _pyaqcv:
_pyaqcv.MD5_swigregister(MD5)
class SHA1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.SHA1_swiginit(self, _pyaqcv.new_SHA1())
    __swig_destroy__ = _pyaqcv.delete_SHA1

    def __call__(self, *args):
        r"""
        *Overload 1:*
        compute SHA1 of a memory block

        |

        *Overload 2:*
        brief compute SHA1 of a string, excluding final zero
        """
        return _pyaqcv.SHA1___call__(self, *args)

    def add(self, buffer, num_bytes):
        r"""add arbitrary number of bytes"""
        return _pyaqcv.SHA1_add(self, buffer, num_bytes)

    def get_hash(self):
        r"""
        :rtype: string
        :return: latest hash as 40 hex characters
        """
        return _pyaqcv.SHA1_get_hash(self)

    def reset(self):
        r"""restart"""
        return _pyaqcv.SHA1_reset(self)

# Register SHA1 in _pyaqcv:
_pyaqcv.SHA1_swigregister(SHA1)
class SHA256(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.SHA256_swiginit(self, _pyaqcv.new_SHA256())
    __swig_destroy__ = _pyaqcv.delete_SHA256

    def __call__(self, *args):
        r"""
        *Overload 1:*
        compute SHA256 of a memory block

        |

        *Overload 2:*
        compute SHA256 of a string, excluding final zero
        """
        return _pyaqcv.SHA256___call__(self, *args)

    def add(self, buffer, num_bytes):
        r"""add arbitrary number of bytes"""
        return _pyaqcv.SHA256_add(self, buffer, num_bytes)

    def get_hash(self):
        r"""
        :rtype: string
        :return: latest hash as 64 hex characters
        """
        return _pyaqcv.SHA256_get_hash(self)

    def reset(self):
        r"""restart"""
        return _pyaqcv.SHA256_reset(self)

# Register SHA256 in _pyaqcv:
_pyaqcv.SHA256_swigregister(SHA256)
class SHA3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kBits224 = _pyaqcv.SHA3_kBits224
    kBits256 = _pyaqcv.SHA3_kBits256
    kBits384 = _pyaqcv.SHA3_kBits384
    kBits512 = _pyaqcv.SHA3_kBits512

    def __init__(self, *args):
        _pyaqcv.SHA3_swiginit(self, _pyaqcv.new_SHA3(*args))
    __swig_destroy__ = _pyaqcv.delete_SHA3

    def __call__(self, *args):
        r"""
        *Overload 1:*
        compute hash of a memory block

        |

        *Overload 2:*
        compute hash of a string, excluding final zero
        """
        return _pyaqcv.SHA3___call__(self, *args)

    def add(self, buffer, num_bytes):
        r"""add arbitrary number of bytes"""
        return _pyaqcv.SHA3_add(self, buffer, num_bytes)

    def get_hash(self):
        r"""
        :rtype: string
        :return: latest hash as hex characters
        """
        return _pyaqcv.SHA3_get_hash(self)

    def reset(self):
        r"""restart"""
        return _pyaqcv.SHA3_reset(self)

# Register SHA3 in _pyaqcv:
_pyaqcv.SHA3_swigregister(SHA3)
kImreadUnchanged = _pyaqcv.kImreadUnchanged
r"""If set, return the loaded image as is (with alpha channel, otherwise it gets cropped). Ignore EXIF orientation."""
kImreadGrayscale = _pyaqcv.kImreadGrayscale
r"""If set, always convert image to the single channel grayscale image (codec internal conversion)."""
kImreadColor = _pyaqcv.kImreadColor
r"""If set, always convert image to the 3 channel BGR color image."""
kImreadAnyDepth = _pyaqcv.kImreadAnyDepth
r"""If set, return 16-bit/32-bit image when the input has the corresponding depth, otherwise convert it to 8-bit."""
kImreadAnyColor = _pyaqcv.kImreadAnyColor
r"""If set, the image is read in any possible color format."""
kImreadLoadGdal = _pyaqcv.kImreadLoadGdal
r"""If set, use the gdal driver for loading the image."""
kImreadIgnoreOrientation = _pyaqcv.kImreadIgnoreOrientation
r"""If set, do not rotate the image according to EXIF's orientation flag."""
kImwriteJpegQuality = _pyaqcv.kImwriteJpegQuality
r"""For JPEG, it can be a quality from 0 to 100 (the higher is the better). Default value is 95."""
kImwriteJpegProgressive = _pyaqcv.kImwriteJpegProgressive
r"""Enable JPEG features, 0 or 1, default is False."""
kImwriteJpegOptimize = _pyaqcv.kImwriteJpegOptimize
r"""Enable JPEG features, 0 or 1, default is False."""
kImwriteJpegRstInterval = _pyaqcv.kImwriteJpegRstInterval
r"""JPEG restart interval, 0 - 65535, default is 0 - no restart."""
kImwriteJpegLumaQuality = _pyaqcv.kImwriteJpegLumaQuality
r"""Separate luma quality level, 0 - 100, default is 0 - don't use."""
kImwriteJpegChromaQuality = _pyaqcv.kImwriteJpegChromaQuality
r"""Separate chroma quality level, 0 - 100, default is 0 - don't use."""
kImwritePngCompression = _pyaqcv.kImwritePngCompression
r"""For PNG, it can be the compression level from 0 to 9. A higher value means a smaller size and longer compression time. If specified, strategy is changed to kImwritePngStrategyDefault (Z_DEFAULT_STRATEGY). Default value is 1 (best speed setting)."""
kImwritePngStrategy = _pyaqcv.kImwritePngStrategy
r"""One of aqcv::ImwritePNGFlags, default is kImwritePngStrategyRle."""
kImwritePngBilevel = _pyaqcv.kImwritePngBilevel
r"""Binary level PNG, 0 or 1, default is 0."""
kImwriteTiffResunit = _pyaqcv.kImwriteTiffResunit
r"""For TIFF, use to specify which DPI resolution unit to set; see libtiff documentation for valid values"""
kImwriteTiffXdpi = _pyaqcv.kImwriteTiffXdpi
r"""For TIFF, use to specify the X direction DPI"""
kImwriteTiffYdpi = _pyaqcv.kImwriteTiffYdpi
r"""For TIFF, use to specify the Y direction DPI"""
kImwriteTiffCompression = _pyaqcv.kImwriteTiffCompression
r"""For TIFF, use to specify the image compression scheme. See libtiff for integer constants corresponding to compression formats. Note, for images whose depth is AQ_32F, only libtiff's SGILOG compression scheme is used. For other supported depths, the compression scheme can be specified by this flag; LZW compression is the default."""
kImwritePngStrategyDefault = _pyaqcv.kImwritePngStrategyDefault
r"""Use this value for normal data."""
kImwritePngStrategyFiltered = _pyaqcv.kImwritePngStrategyFiltered
r"""Use this value for data produced by a filter (or predictor).Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better."""
kImwritePngStrategyHuffmanOnly = _pyaqcv.kImwritePngStrategyHuffmanOnly
r"""Use this value to force Huffman encoding only (no string match)."""
kImwritePngStrategyRle = _pyaqcv.kImwritePngStrategyRle
r"""Use this value to limit match distances to one (run-length encoding)."""
kImwritePngStrategyFixed = _pyaqcv.kImwritePngStrategyFixed
r"""Using this value prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications."""

def imread_ascii(*args):
    r"""
     Loads an image from a file.



    The function imread loads an image from the specified file and returns it. If the image cannot be
    read (because of missing file, improper permissions, unsupported or invalid format), the function
    returns an empty matrix ( Mat::data==NULL ).

    Currently, the following file formats are supported:

    -   Windows bitmaps - *.bmp, *.dib (always supported)
    -   JPEG files - *.jpeg, *.jpg, *.jpe (see the *Note* section)
    -   Portable Network Graphics - *.png (see the *Note* section)
    -   TIFF files - *.tiff, *.tif (see the *Note* section)

    Notes: 
    -   The function determines the type of an image by the content, not by the file extension.
    -   In the case of color images, the decoded images will have the channels stored in **B G R** order.
    -   When using kImreadGrayscale, the codec's internal grayscale conversion will be used, if available.
        Results may differ to the output of cvt_color()
    -   On Microsoft Windows* OS and MacOSX*, the codecs shipped with an aqcv image (libjpeg,
        libpng, libtiff) are used by default. So, aqcv can always read JPEGs, PNGs,
        and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware
        that currently these native image loaders give images with different pixel values because of
        the color management embedded into MacOSX.
    -   By default number of pixels must be less than 2^30.

    :type filename: string
    :param filename: Name of file to be loaded.
    :type flags: int, optional
    :param flags: Flag that can take values of aqcv::ImreadModes
    """
    return _pyaqcv.imread_ascii(*args)

def imread(*args):
    return _pyaqcv.imread(*args)

def imwrite_ascii(*args):
    r"""
     Saves an image to a specified file.

    The function imwrite saves the image to the specified file. The image format is chosen based on the
    filename extension (see aqcv::imread for the list of extensions). In general, only 8-bit
    single-channel or 3-channel (with 'BGR' channel order) images
    can be saved using this function, with these exceptions:

    - 16-bit unsigned (AQ_16U) images can be saved in the case of PNG, and TIFF formats
    - 32-bit float (AQ_32F) images can be saved in TIFF formats;
      3-channel (AQ_32FC3) TIFF images will be saved using the LogLuv high dynamic range encoding
      (4 bytes per pixel)
    - PNG images with an alpha channel can be saved using this function. To do this, create
    8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels
    should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535.
    - Multiple images (vector of Mat) can be saved in TIFF format.

    If the format, depth or channel order is different, use
    Mat::convert_to and aqcv::cvt_color to convert it before saving.

    :type filename: string
    :param filename: Name of the file.
    :type img: :py:class:`_InputArray`
    :param img: (Mat or vector of Mat) Image or Images to be saved.
    :type params: std::vector< int,std::allocator< int > >, optional
    :param params: Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see aqcv::ImwriteFlags
    """
    return _pyaqcv.imwrite_ascii(*args)

def imwrite(*args):
    return _pyaqcv.imwrite(*args)

def imdecode(*args):
    r"""
     Reads an image from a buffer in memory.

    The function imdecode reads an image from the specified buffer in the memory. If the buffer is too short or
    contains invalid data, the function returns an empty matrix ( Mat::data==NULL ).

    See aqcv::imread for the list of supported formats and flags description.

    Notes: In the case of color images, the decoded images will have the channels stored in **B G R** order.
    :type buf: :py:class:`_InputArray`
    :param buf: Input array or vector of bytes.
    :type flags: int
    :param flags: The same flags as in aqcv::imread, see aqcv::ImreadModes.
    """
    return _pyaqcv.imdecode(*args)

def imencode(*args):
    r"""
     Encodes an image into a memory buffer.

    The function imencode compresses the image and stores it in the memory buffer that is resized to fit the
    result. See aqcv::imwrite for the list of supported formats and flags description.

    :type ext: string
    :param ext: File extension that defines the output format.
    :type img: :py:class:`_InputArray`
    :param img: Image to be written.
    :type buf: std::vector< uchar,std::allocator< uchar > >
    :param buf: Output buffer resized to fit the compressed image.
    :type params: std::vector< int,std::allocator< int > >, optional
    :param params: Format-specific parameters. See aqcv::imwrite and aqcv::ImwriteFlags.
    """
    return _pyaqcv.imencode(*args)

def have_image_reader(*args):
    r"""
    *Overload 1:*
     Returns true if the specified image can be decoded by aqcv

    :type filename: string
    :param filename: File name of the image


    |

    *Overload 2:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.
    """
    return _pyaqcv.have_image_reader(*args)

def have_image_writer(*args):
    r"""
    *Overload 1:*
     Returns true if an image with the specified filename can be encoded by aqcv

    :type filename: string
    :param filename: File name of the image


    |

    *Overload 2:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.
    """
    return _pyaqcv.have_image_writer(*args)
class ImageViewer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kWindowNormal = _pyaqcv.ImageViewer_kWindowNormal
    r"""the user can resize the window (no constraint) / also use to switch a fullscreen window to a normal size."""
    kWindowAutoSize = _pyaqcv.ImageViewer_kWindowAutoSize
    r"""the user cannot resize the window, the size is constrainted by the image displayed (default)."""

    def __init__(self):
        _pyaqcv.ImageViewer_swiginit(self, _pyaqcv.new_ImageViewer())
    __swig_destroy__ = _pyaqcv.delete_ImageViewer

    def set_win_mode(self, mode):
        r"""
         set window mode
        :type mode: int
        :param mode: window mode, please reference WindowMode
        Notes: : the window mode set to object is only used by show_single_image() and show_frames(), not imshow().
        """
        return _pyaqcv.ImageViewer_set_win_mode(self, mode)

    def show_single_image(self, win_name, img, during_time=0, destory=False):
        r"""
         show image
        :type win_name: string
        :param win_name: window name
        :type img: :py:class:`Mat`
        :param img: the image to show
        :type during_time: int, optional
        :param during_time: window will be destroied after the during_time (in miliseconds),
                  0 means keep the window unitl any key was pressed
        :type destory: boolean, optional
        :param destory: if true, destory the img window after the during_time.
        """
        return _pyaqcv.ImageViewer_show_single_image(self, win_name, img, during_time, destory)

    def add_frame(self, frame):
        r"""
         add image to be shown
        frame the frame to be added
        """
        return _pyaqcv.ImageViewer_add_frame(self, frame)

    def pop_frame(self):
        r"""
         pop the back frame
        :rtype: :py:class:`Mat`
        :return: the poped frame
        """
        return _pyaqcv.ImageViewer_pop_frame(self)

    def frame_count(self):
        r"""get current frame count"""
        return _pyaqcv.ImageViewer_frame_count(self)

    def show_frames(self, *args):
        r"""
         show the added frames,press ESC to exit.
        :type win_name: string
        :param win_name:    window name
        :type frame_rate: float, optional
        :param frame_rate:  show frequency(num/second)
        :type loop: boolean, optional
        :param loop:        whether to loop
        :type start_idx: int, optional
        :param start_idx:   the begin index to show
        :type end_idx: int, optional
        :param end_idx:     the last frame to show(not contain)
        :type destory: boolean, optional
        :param destory:     if true, destory the img window after all images are shown.
        """
        return _pyaqcv.ImageViewer_show_frames(self, *args)

    @staticmethod
    def destory_all_windows():
        r"""close all windows"""
        return _pyaqcv.ImageViewer_destory_all_windows()

    @staticmethod
    def imshow(*args):
        r"""
        show image in windows with title win_name
        :type win_name: string
        :param win_name: windows name
        :type img: :py:class:`Mat`
        :param img: image to be shown
        :type mode: int, optional
        :param mode: window mode, see #WindowMode
        Notes: : if the window `win_name` is already exist, use the window mode of `win_name` instead of the input mode.
        """
        return _pyaqcv.ImageViewer_imshow(*args)

    @staticmethod
    def wait_key(delay=0):
        r"""

        The function waitKey waits for a key event infinitely(when  :math:`\texttt {delay}\leq 0` ) or for delay
           milliseconds, when it is positive.Since the OS has a minimum time between switching threads, the
           function will not wait exactly delay ms, it will wait at least delay ms, depending on what else is
           running on your computer at that time.It returns the code of the pressed key or -1 if no key was
           pressed before the specified time had elapsed.
        """
        return _pyaqcv.ImageViewer_wait_key(delay)

# Register ImageViewer in _pyaqcv:
_pyaqcv.ImageViewer_swigregister(ImageViewer)
kFilterscharr = _pyaqcv.kFilterscharr
kCannyL2Gradient = _pyaqcv.kCannyL2Gradient
kTextAnchorBottomLeft = _pyaqcv.kTextAnchorBottomLeft
r"""Anchor point is in bottom-left of the text"""
kTextAnchorTopLeft = _pyaqcv.kTextAnchorTopLeft
r"""Anchor point is in top-left of the text"""

def get_gaussian_kernel(ksize, sigma, ktype=6):
    r"""
     Returns Gaussian filter coefficients.

    The function computes and returns the  :math:`\texttt{ksize} \times 1`  matrix of Gaussian filter
    coefficients:

     .. math::

         G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},

    where  :math:`i=0..\texttt{ksize}-1`  and  :math:`\alpha`  is the scale factor chosen so that  :math:`\sum_i G_i=1` .

    Two of such generated kernels can be passed to separable_filter2d. Those functions automatically recognize
    smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly.
    You may also use the higher-level gaussian_blur.
    :type ksize: int
    :param ksize: Aperture size. It should be odd (  :math:`\texttt{ksize} \mod 2 = 1`  ) and positive.
    :type sigma: float
    :param sigma: Gaussian standard deviation. If it is non-positive, it is computed from ksize as
        `sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8`.
    :type ktype: int, optional
    :param ktype: Type of filter coefficients. It can be AQ_32F or AQ_64F.
    See also: separable_filter2d, get_derivatives_kernels, getStructuringElement, gaussian_blur
    """
    return _pyaqcv.get_gaussian_kernel(ksize, sigma, ktype)

def get_derivatives_kernels(kx, ky, dx, dy, ksize, normalize=False, ktype=5):
    r"""
     Returns filter coefficients for computing spatial image derivatives.

    The function computes and returns the filter coefficients for spatial image derivatives. When
    `ksize=kFilterscharr`, the scharr  :math:`3 \times 3`  kernels are generated (see #scharr). Otherwise, sobel
    kernels are generated (see #sobel). The filters are normally passed to #separable_filter2d or to

    :type kx: :py:class:`Mat`
    :param kx: Output matrix of row filter coefficients. It has the type ktype.
    :type ky: :py:class:`Mat`
    :param ky: Output matrix of column filter coefficients. It has the type ktype.
    :type dx: int
    :param dx: Derivative order in respect of x.
    :type dy: int
    :param dy: Derivative order in respect of y.
    :type ksize: int
    :param ksize: Aperture size. It can be kFilterscharr, 1, 3, 5, or 7.
    :type normalize: boolean, optional
    :param normalize: Flag indicating whether to normalize (scale down) the filter coefficients or not.
        Theoretically, the coefficients should have the denominator  :math:`=2^{ksize*2-dx-dy-2}` . If you are
        going to filter floating-point images, you are likely to use the normalized kernels. But if you
        compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve
        all the fractional bits, you may want to set normalize=false.
    :type ktype: int, optional
    :param ktype: Type of filter coefficients. It can be AQ_32f or AQ_64F.
    """
    return _pyaqcv.get_derivatives_kernels(kx, ky, dx, dy, ksize, normalize, ktype)

def get_gabor_kernel(*args):
    r"""
     Returns Gabor filter coefficients.

    For more details about gabor filter equations and parameters, see: [Gabor
    Filter](http://en.wikipedia.org/wiki/Gabor_filter).

    :type ksize: :py:class:`Size`
    :param ksize: Size of the filter returned.
    :type sigma: float
    :param sigma: Standard deviation of the gaussian envelope.
    :type theta: float
    :param theta: Orientation of the normal to the parallel stripes of a Gabor function.
    :type lambd: float
    :param lambd: Wavelength of the sinusoidal factor.
    :type gamma: float
    :param gamma: Spatial aspect ratio.
    :type psi: float, optional
    :param psi: Phase offset.
    :type ktype: int, optional
    :param ktype: Type of filter coefficients. It can be AQ_32F or AQ_64F.
    """
    return _pyaqcv.get_gabor_kernel(*args)

def median_blur(src, dst, ksize):
    r"""
     Blurs an image using the median filter.

    The function smoothes an image using the median filter with the  :math:`\texttt{ksize} \times\texttt{ksize}`  aperture. Each channel of a multi-channel image is processed independently.
    In-place operation is supported.

    Notes: The median filter uses #kBorderReplicate internally to cope with border pixels, see #BorderTypes

    :type src: :py:class:`Mat`
    :param src: input 1-, 3-, or 4-channel image; when ksize <= 9, the image depth should be
        AQ_8U, AQ_16U, or AQ_32F, for larger aperture sizes, it can only be AQ_8U.
    :type dst: :py:class:`Mat`
    :param dst: destination array of the same size and type as src.
    :type ksize: int
    :param ksize: aperture linear size; it must be odd and greater than 1. The maximum ksize is 255.
    See also: bilateral_filter, box_filter, gaussian_blur
    """
    return _pyaqcv.median_blur(src, dst, ksize)

def gaussian_blur(*args):
    r"""
     Blurs an image using a Gaussian filter.

    The function convolves the source image with the specified Gaussian kernel. In-place filtering is
    supported. For large kernel size, it's suggest to use stack_blur to accelerate.

    :type src: :py:class:`Mat`
    :param src: input image; the image can have any number of channels, which are processed
        independently, but the depth should be AQ_8U, AQ_16U, AQ_16S, AQ_32F or AQ_64F.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and type as src.
    :type ksize: :py:class:`Size`
    :param ksize: Gaussian kernel size. ksize.width and ksize.height can differ but they both must be
        positive and odd. Or, they can be zero's and then they are computed from sigma.
    :type sigmaX: float
    :param sigmaX: Gaussian kernel standard deviation in X direction.
    :type sigmaY: float, optional
    :param sigmaY: Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
        equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
        respectively (see #get_gaussian_kernel for details); to fully control the result regardless of
        possible future modifications of all this semantics, it is recommended to specify all of ksize,
        sigmaX, and sigmaY.
    :type border_type: int, optional
    :param border_type: pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.

    See also: separable_filter2d, filter2d, box_filter, bilateral_filter, median_blur, stack_blur
    """
    return _pyaqcv.gaussian_blur(*args)

def stack_blur(src, dst, ksize):
    r"""
     Blurs an image using the stack_blur.

    stack_blur can generate similar results as gaussian blur, and the time consumption does not increase with the increase of kernel size.
    It creates a kind of moving stack of colors whilst scanning through the image. Thereby it just has to add one new block of color to the right side
    of the stack and remove the leftmost color. The remaining colors on the topmost layer of the stack are either added on or reduced by one,
    depending on if they are on the right or on the left side of the stack. The only supported BorderTypes is kBorderReplicate.
    Original paper was proposed by Mario Klingemann, which can be found http://underdestruction.com/2004/02/25/stackblur-2004.

    :type src: :py:class:`Mat`
    :param src: input image. The number of channels can be arbitrary, but the depth should be one of
        AQ_8U, AQ_16U, AQ_16S or AQ_32F.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and type as src.
    :type ksize: :py:class:`Size`
    :param ksize: stack-blurring kernel size. The ksize.width and ksize.height can differ but they both must be
        positive and odd.
    Notes: From aqcv 1.1.14, stack_blur is always faster than gaussian_blur.
    """
    return _pyaqcv.stack_blur(src, dst, ksize)

def bilateral_filter(*args):
    r"""
     Applies the bilateral filter to an image.

    The function applies bilateral filtering to the input image, as described in
    http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html
    bilateral_filter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
    very slow compared to most filters.

    _Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (<
    10), the filter will not have much effect, whereas if they are large (> 150), they will have a very
    strong effect, making the image look "cartoonish".

    _Filter size_: Large filters (d > 5) are very slow, so it is recommended to use d=5 for real-time
    applications, and perhaps d=9 for offline applications that need heavy noise filtering.

    :type src: :py:class:`Mat`
    :param src: Source 8-bit or floating-point, 1-channel or 3-channel image.
    :type dst: :py:class:`Mat`
    :param dst: Destination image of the same size and type as src .
    :type d: int
    :param d: Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
        it is computed from sigma_space.
    :type sigma_color: float
    :param sigma_color: Filter sigma in the color space. A larger value of the parameter means that
        farther colors within the pixel neighborhood (see sigma_space) will be mixed together, resulting
        in larger areas of semi-equal color.
    :type sigma_space: float
    :param sigma_space: Filter sigma in the coordinate space. A larger value of the parameter means that
        farther pixels will influence each other as long as their colors are close enough (see sigma_color
        ). When d>0, it specifies the neighborhood size regardless of sigma_space. Otherwise, d is
        proportional to sigma_space.
    :type border_type: int, optional
    :param border_type: border mode used to extrapolate pixels outside of the image, see #BorderTypes
    """
    return _pyaqcv.bilateral_filter(*args)

def box_filter(*args):
    r"""
     Blurs an image using the box filter.(mean filter)

    The function smooths an image using the kernel:

     .. math::

         \texttt{K} = \alpha \begin{bmatrix} 1 & 1 & 1 &  \cdots & 1 & 1 \\ .&.&.&.&.&.  \\ 1 & 1 & 1 &  \cdots & 1 & 1  \\ 1 & 1 & 1 &  \cdots & 1 & 1 \end{bmatrix}

    where

     .. math::

         \alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} & \texttt{when } \texttt{normalize=true}  \\1 & \texttt{otherwise}\end{cases}

    Unnormalized box filter is useful for computing various integral characteristics over each pixel
    neighborhood, such as covariance matrices of image derivatives (used in dense optical flow
    algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.

    :type src: :py:class:`Mat`
    :param src: input image.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and type as src.
    :type ddepth: int
    :param ddepth: the output image depth (-1 to use src.depth()).
    :type ksize: :py:class:`Size`
    :param ksize: blurring kernel size.
    :type anchor: :py:class:`Point`, optional
    :param anchor: anchor point; default value Point(-1,-1) means that the anchor is at the kernel
        center.
    :type normalize: boolean, optional
    :param normalize: flag, specifying whether the kernel is normalized by its area or not.
    :type border_type: int, optional
    :param border_type: border mode used to extrapolate pixels outside of the image, see #BorderTypes. #kBorderWrap is not supported.
    See also: bilateral_filter, gaussian_blur, median_blur, integral
    """
    return _pyaqcv.box_filter(*args)

def sqr_box_filter(*args):
    r"""
     Calculates the normalized sum of squares of the pixel values overlapping the filter.

    For every pixel  :math:`(x, y)`  in the source image, the function calculates the sum of squares of those neighboring
    pixel values which overlap the filter placed over the pixel  :math:`(x, y)` .

    The unnormalized square box filter can be useful in computing local image statistics such as the local
    variance and standard deviation around the neighborhood of a pixel.

    :type src: :py:class:`Mat`
    :param src: input image
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and type as src
    :type ddepth: int
    :param ddepth: the output image depth (-1 to use src.depth())
    :type ksize: :py:class:`Size`
    :param ksize: kernel size
    :type anchor: :py:class:`Point`, optional
    :param anchor: kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel
        center.
    :type normalize: boolean, optional
    :param normalize: flag, specifying whether the kernel is to be normalized by it's area or not.
    :type border_type: int, optional
    :param border_type: border mode used to extrapolate pixels outside of the image, see #BorderTypes. #kBorderWrap is not supported.
    See also: box_filter
    """
    return _pyaqcv.sqr_box_filter(*args)

def filter2d(*args):
    r"""
     Convolves an image with the kernel.

    The function applies an arbitrary linear filter to an image. In-place operation is supported. When
    the aperture is partially outside the image, the function interpolates outlier pixel values
    according to the specified border mode.

    The function does actually compute correlation, not the convolution:

     .. math::

         \texttt{dst} (x,y) =  \sum _{{0\leq x' < \texttt{kernel.cols}\\{0\leq y' < \texttt{kernel.rows}}}}  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )

    That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip
    the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows -
    anchor.y - 1)`.

    The function uses the DFT-based algorithm in case of sufficiently large kernels (~`11 x 11` or
    larger) and the direct algorithm for small kernels.

    :type src: :py:class:`Mat`
    :param src: input image.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and the same number of channels as src.
    :type ddepth: int
    :param ddepth: desired depth of the destination image, see 'combinations'
    :type kernel: :py:class:`Mat`
    :param kernel: convolution kernel (or rather a correlation kernel), a single-channel floating point
        matrix; if you want to apply different kernels to different channels, split the image into
        separate color planes using split and process them individually.
    :type anchor: :py:class:`Point`, optional
    :param anchor: anchor of the kernel that indicates the relative position of a filtered point within
        the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor
        is at the kernel center.
    :type delta: float, optional
    :param delta: optional value added to the filtered pixels before storing them in dst.
    :type border_type: int, optional
    :param border_type: pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.
    See also: separable_filter2d, dft
    """
    return _pyaqcv.filter2d(*args)

def separable_filter2d(*args):
    r"""
     Applies a separable linear filter to an image.

    The function applies a separable linear filter to the image. That is, first, every row of src is
    filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D
    kernel kernelY. The final result shifted by delta is stored in dst .

    :type src: :py:class:`Mat`
    :param src: Source image.
    :type dst: :py:class:`Mat`
    :param dst: Destination image of the same size and the same number of channels as src .
    :type ddepth: int
    :param ddepth: Destination image depth, see 'combinations'
    :type kernelX: :py:class:`Mat`
    :param kernelX: Coefficients for filtering each row.
    :type kernelY: :py:class:`Mat`
    :param kernelY: Coefficients for filtering each column.
    :type anchor: :py:class:`Point`, optional
    :param anchor: Anchor position within the kernel. The default value  :math:`(-1,-1)`  means that the anchor
        is at the kernel center.
    :type delta: float, optional
    :param delta: Value added to the filtered results before storing them.
    :type border_type: int, optional
    :param border_type: Pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.
    See also: filter2d, sobel, gaussian_blur, box_filter, blur
    """
    return _pyaqcv.separable_filter2d(*args)

def sobel(*args):
    r"""
     Calculates the first, second, third, or mixed image derivatives using an extended sobel operator.

    In all cases except one, the  :math:`\texttt{ksize} \times \texttt{ksize}`  separable kernel is used to
    calculate the derivative. When  :math:`\texttt{ksize = 1}` , the  :math:`3 \times 1`  or  :math:`1 \times 3`
    kernel is used (that is, no Gaussian smoothing is done). `ksize = 1` can only be used for the first
    or the second x- or y- derivatives.

    There is also the special value `ksize = #kFilterscharr (-1)` that corresponds to the  :math:`3\times3`  scharr
    filter that may give more accurate results than the  :math:`3\times3`  sobel. The scharr aperture is

     .. math::

         \begin{bmatrix} -3 & 0 & 3 \\ -10 & 0 & 10  \\ -3 & 0 & 3  \end{bmatrix}

    for the x-derivative, or transposed for the y-derivative.

    The function calculates an image derivative by convolving the image with the appropriate kernel:

     .. math::

         \texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}

    The sobel operators combine Gaussian smoothing and differentiation, so the result is more or less
    resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3)
    or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first
    case corresponds to a kernel of:

     .. math::

         \begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2  \\ -1 & 0 & 1  \end{bmatrix}

    The second case corresponds to a kernel of:

     .. math::

         \begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0  \\ 1 & 2 & 1  \end{bmatrix}

    :type src: :py:class:`Mat`
    :param src: input image.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and the same number of channels as src .
    :type ddepth: int
    :param ddepth: output image depth, see 'combinations'; in the case of
            8-bit input images it will result in truncated derivatives.
    :type dx: int
    :param dx: order of the derivative x.
    :type dy: int
    :param dy: order of the derivative y.
    :type ksize: int, optional
    :param ksize: size of the extended sobel kernel; it must be 1, 3, 5, or 7.
    :type scale: float, optional
    :param scale: optional scale factor for the computed derivative values; by default, no scaling is
        applied (see #get_derivatives_kernels for details).
    :type delta: float, optional
    :param delta: optional delta value that is added to the results prior to storing them in dst.
    :type border_type: int, optional
    :param border_type: pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.
    See also: scharr, laplacian, separable_filter2d, filter2d, gaussian_blur
    """
    return _pyaqcv.sobel(*args)

def spatial_gradient(*args):
    r"""
     Calculates the first order image derivative in both x and y using a sobel operator

    Equivalent to calling:

    .. code-block:: c++

        sobel( src, dx, AQ_16SC1, 1, 0, 3 );
        sobel( src, dy, AQ_16SC1, 0, 1, 3 );

    :type src: :py:class:`Mat`
    :param src: input image, only support 8UC1.
    :type dx: :py:class:`Mat`
    :param dx: output image with first-order derivative in x in AQ_16SC1.
    :type dy: :py:class:`Mat`
    :param dy: output image with first-order derivative in y in AQ_16SC1.
    :type border_type: int, optional
    :param border_type: pixel extrapolation method, see #BorderTypes.
        Only #kBorderDefault=#kBorderReflect_101 and #kBorderReplicate are supported.

    See also: sobel
    """
    return _pyaqcv.spatial_gradient(*args)

def scharr(*args):
    r"""
     Calculates the first x- or y- image derivative using scharr operator.

    The function computes the first x- or y- spatial image derivative using the scharr operator. The
    call

     .. math::

         \texttt{scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}

    is equivalent to

     .. math::

         \texttt{sobel(src, dst, ddepth, dx, dy, kFilterscharr, scale, delta, borderType)} .

    :type src: :py:class:`Mat`
    :param src: input image.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and the same number of channels as src.
    :type ddepth: int
    :param ddepth: output image depth, see 'combinations'
    :type dx: int
    :param dx: order of the derivative x.
    :type dy: int
    :param dy: order of the derivative y (dx+dy must equal to 1).
    :type scale: float, optional
    :param scale: optional scale factor for the computed derivative values; by default, no scaling is
        applied (see #get_derivatives_kernels for details).
    :type delta: float, optional
    :param delta: optional delta value that is added to the results prior to storing them in dst.
    :type border_type: int, optional
    :param border_type: pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.
    See also: cart_to_polar
    """
    return _pyaqcv.scharr(*args)

def laplacian(*args):
    r"""
     Calculates the laplacian of an image.

    The function calculates the laplacian of the source image by adding up the second x and y
    derivatives calculated using the sobel operator:

     .. math::

         \texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2}

    This is done when `ksize > 1`. When `ksize == 1`, the laplacian is computed by filtering the image
    with the following  :math:`3 \times 3`  aperture:

     .. math::

         \begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1  \\ 0 & 1 & 0  \end{bmatrix}

    :type src: :py:class:`Mat`
    :param src: Source image.
    :type dst: :py:class:`Mat`
    :param dst: Destination image of the same size and the same number of channels as src .
    :type ddepth: int
    :param ddepth: Desired depth of the destination image.
    :type ksize: int, optional
    :param ksize: Aperture size used to compute the second-derivative filters. See #get_derivatives_kernels for
        details. The size must be positive and odd.
    :type scale: float, optional
    :param scale: Optional scale factor for the computed laplacian values. By default, no scaling is
        applied. See #get_derivatives_kernels for details.
    :type delta: float, optional
    :param delta: Optional delta value that is added to the results prior to storing them in dst .
    :type border_type: int, optional
    :param border_type: Pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.
    See also: sobel, scharr
    """
    return _pyaqcv.laplacian(*args)

def canny(image, edges, threshold1, threshold2, ksize=3, L2gradient=False):
    r"""
     Finds edges in an image using the canny algorithm 'canny86' .

    The function finds edges in the input image and marks them in the output map edges using the
    canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The
    largest value is used to find initial segments of strong edges. See
    <http://en.wikipedia.org/wiki/canny_edge_detector>

    :type image: :py:class:`Mat`
    :param image: 8-bit input image.
    :type edges: :py:class:`Mat`
    :param edges: output edge map; single channels 8-bit image, which has the same size as image .
    :type threshold1: float
    :param threshold1: first threshold for the hysteresis procedure.
    :type threshold2: float
    :param threshold2: second threshold for the hysteresis procedure.
    :type ksize: int, optional
    :param ksize: aperture size for the sobel operator, only 3, 5, 7 is support.
    :type L2gradient: boolean, optional
    :param L2gradient: a flag, indicating whether a more accurate  :math:`L_2`  norm
         :math:`=\sqrt{(dI/dx)^2 + (dI/dy)^2}`  should be used to calculate the image gradient magnitude (
        L2gradient=true ), or whether the default  :math:`L_1`  norm  :math:`=|dI/dx|+|dI/dy|`  is enough (
        L2gradient=false ).
    """
    return _pyaqcv.canny(image, edges, threshold1, threshold2, ksize, L2gradient)

def morphology_default_border_value():
    r"""returns "magic" border value for erosion and dilation. It is automatically transformed to Scalar::all(-DBL_MAX) for dilation."""
    return _pyaqcv.morphology_default_border_value()
kMorphologyErode = _pyaqcv.kMorphologyErode
r"""erode"""
kMorphologyDilate = _pyaqcv.kMorphologyDilate
r"""dilate"""
kMorphologyOpen = _pyaqcv.kMorphologyOpen
r"""opening operation(erode+dilate)"""
kMorphologyClose = _pyaqcv.kMorphologyClose
r"""closing operation(dilate+erode)"""
kMorphologyGradient = _pyaqcv.kMorphologyGradient
r"""morphological gradient(dilate-erode)"""
kMorphologyTopHat = _pyaqcv.kMorphologyTopHat
r"""top hat(src-opening)"""
kMorphologyBlackHat = _pyaqcv.kMorphologyBlackHat
r"""black hat(closing-src)"""
kMorphologyHitMiss = _pyaqcv.kMorphologyHitMiss
r"""hit or miss(only supported for AQ_8UC1 binary images)"""
kMorphologyRect = _pyaqcv.kMorphologyRect
r"""
    a rectangular structuring element:.. math::

       E_{ij}=1
    """
kMorphologyCross = _pyaqcv.kMorphologyCross
r"""
    a cross-shaped structuring element:.. math::

       E_{ij} = \begin{cases} 1 & \texttt{if } {i=\texttt{anchor.y } {or } {j=\texttt{anchor.x}}} \\0 & \texttt{otherwise} \end{cases}
    """
kMorphologyCircle = _pyaqcv.kMorphologyCircle
r"""a circular structuring element"""
kMorphologyEllipse = _pyaqcv.kMorphologyEllipse
r"""an elliptic structuring element, that is, a filled ellipse inscribed into the rectangle Rect(0, 0, ellipse_size.width, ellipse_size.height)"""

def get_structuring_element(*args):
    r"""
     Returns a structuring element of the specified size and shape for morphological operations.

    The function constructs and returns the structuring element that can be further passed to #erode,
    #dilate or #morphology. But you can also construct an arbitrary binary mask yourself and use it as
    the structuring element.

    :type shape: int
    :param shape: Element shape that could be one of #MorphShapes
    :type ksize: :py:class:`Size`
    :param ksize: Size of the structuring element.
    :type anchor: :py:class:`Point`, optional
    :param anchor: Anchor position within the element. The default value  :math:`(-1, -1)`  means that the
        anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor
        position. In other cases the anchor just regulates how much the result of the morphological
        operation is shifted.
    """
    return _pyaqcv.get_structuring_element(*args)

def erode(*args):
    r"""
     Erodes an image by using a specific structuring element.

    The function erodes the source image using the specified structuring element that determines the
    shape of a pixel neighborhood over which the minimum is taken:

     .. math::

         \texttt{dst} (x,y) =  \min _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')

    The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In
    case of multi-channel images, each channel is processed independently.

    :type src: :py:class:`Mat`
    :param src: input image; the number of channels can be arbitrary, but the depth should be one of
        AQ_8U, AQ_16U, AQ_16S, AQ_32F or AQ_64F.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and type as src.
    :type kernel: :py:class:`Mat`
    :param kernel: structuring element used for erosion; if `element=Mat()`, a `3 x 3` rectangular
        structuring element is used. Kernel can be created using #get_structuring_element.
    :type anchor: :py:class:`Point`, optional
    :param anchor: position of the anchor within the element; default value (-1, -1) means that the
        anchor is at the element center.
    :type iterations: int, optional
    :param iterations: number of times erosion is applied.
    :type border_type: int, optional
    :param border_type: pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.
    :type border_value: :py:class:`Scalar`, optional
    :param border_value: border value in case of a constant border
    See also: dilate, morphology, get_structuring_element
    """
    return _pyaqcv.erode(*args)

def dilate(*args):
    r"""
     Dilates an image by using a specific structuring element.

    The function dilates the source image using the specified structuring element that determines the
    shape of a pixel neighborhood over which the maximum is taken:

     .. math::

         \texttt{dst} (x,y) =  \max _{(x',y'):  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')

    The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
    case of multi-channel images, each channel is processed independently.

    :type src: :py:class:`Mat`
    :param src: input image; the number of channels can be arbitrary, but the depth should be one of
        AQ_8U, AQ_16U, AQ_16S, AQ_32F or AQ_64F.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and type as src.
    :type kernel: :py:class:`Mat`
    :param kernel: structuring element used for dilation; if `element=Mat()`, a `3 x 3` rectangular
        structuring element is used. Kernel can be created using #get_structuring_element
    :type anchor: :py:class:`Point`, optional
    :param anchor: position of the anchor within the element; default value (-1, -1) means that the
        anchor is at the element center.
    :type iterations: int, optional
    :param iterations: number of times dilation is applied.
    :type border_type: int, optional
    :param border_type: pixel extrapolation method, see #BorderTypes. #kBorderWrap is not suported.
    :type border_value: :py:class:`Scalar`, optional
    :param border_value: border value in case of a constant border
    See also: erode, morphology, get_structuring_element
    """
    return _pyaqcv.dilate(*args)

def morphology(*args):
    r"""
    *Overload 1:*
     Performs advanced morphological transformations.

    The function aqcv::morphology can perform advanced morphological transformations using an erosion and dilation as
    basic operations.

    Any of the operations can be done in-place. In case of multi-channel images, each channel is
    processed independently.

    :type src: :py:class:`Mat`
    :param src: Source image. The number of channels can be arbitrary. The depth should be one of
        AQ_8U, AQ_16U, AQ_16S, AQ_32F or AQ_64F.
    :type dst: :py:class:`Mat`
    :param dst: Destination image of the same size and type as source image.
    :type op: int
    :param op: Type of a morphological operation, see #MorphologyTypes
    :type kernel: :py:class:`Mat`
    :param kernel: Structuring element. It can be created using #get_structuring_element.
    :type anchor: :py:class:`Point`, optional
    :param anchor: Anchor position with the kernel. Negative values mean that the anchor is at the
        kernel center.
    :type iterations: int, optional
    :param iterations: Number of times erosion and dilation are applied.
    :type border_type: int, optional
    :param border_type: Pixel extrapolation method, see #BorderTypes. #kBorderWrap is not supported.
    :type border_value: :py:class:`Scalar`, optional
    :param border_value: Border value in case of a constant border. The default value has a special
        meaning.
    See also: dilate, erode, get_structuring_element
    Notes: The number of iterations is the number of times erosion or dilatation operation will be applied.
    For instance, an opening operation (#kMorphologyOpen) with two iterations is equivalent to apply
    successively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).


    |

    *Overload 2:*
     Performs morphological transformations for multipolygon.

    :type src: :py:class:`MultiPolygon2i`
    :param src: Original multipolygon.
    :type res: :py:class:`MultiPolygon2i`
    :param res: Multipolygon after morphological transformations.
    :type op: int
    :param op: Type of a morphological operation, see #MorphologyTypes, only support kMorphologyErode, kMorphologyDilate,
        kMorphologyOpen and kMorphologyClose.
    :type ksize: :py:class:`Size`
    :param ksize: Size of the structuring element, it must be positive and odd.
    :type shape: int, optional
    :param shape: Element shape, see #MorphShapes, only support kMorphologyRect and kMorphologyCircle.


    |

    *Overload 3:*
     Performs morphological transformations for multipolygon.

    :type src: :py:class:`MultiPolygon2i`
    :param src: Original multipolygon.
    :type res: :py:class:`MultiPolygon2i`
    :param res: Multipolygon after morphological transformations.
    :type op: int
    :param op: Type of a morphological operation, see #MorphologyTypes, only support kMorphologyErode, kMorphologyDilate,
        kMorphologyOpen and kMorphologyClose.
    :type ksize: :py:class:`Size`
    :param ksize: Size of the structuring element, it must be positive and odd.
    :param shape: Element shape, see #MorphShapes, only support kMorphologyRect and kMorphologyCircle.
    """
    return _pyaqcv.morphology(*args)

def skeleton(src, dst):
    r"""
     Compute the skeleton of a binary image.

    :type src: :py:class:`Mat`
    :param src: binary image with single channel in AQ_8U data type
    :type dst: :py:class:`Mat`
    :param dst: result skeleton image
    :rtype: boolean
    :return: true if ok.
    """
    return _pyaqcv.skeleton(src, dst)
kRotate90Clockwise = _pyaqcv.kRotate90Clockwise
r"""rotate 90 degrees clockwise."""
kRotate180 = _pyaqcv.kRotate180
r"""rotate 180 degrees clockwise."""
kRotate90CounterClockwise = _pyaqcv.kRotate90CounterClockwise
r"""rotate 270 degrees clockwise."""
kShearHorizontal = _pyaqcv.kShearHorizontal
r"""left right shear"""
kShearVertical = _pyaqcv.kShearVertical
r"""up down shear"""
kInterNearest = _pyaqcv.kInterNearest
r"""nearest neighbor interpolation"""
kInterLinear = _pyaqcv.kInterLinear
r"""bilinear interpolation"""
kInterCubic = _pyaqcv.kInterCubic
r"""bicubic interpolation"""
kInterArea = _pyaqcv.kInterArea
r"""
    resampling using pixel area relation. It may be a preferred method for image decimation, as
       it gives moire'-free results. But when the image is zoomed, it is similar to the kInterNearest
       method.
    """
kInterMax = _pyaqcv.kInterMax
r"""mask for interpolation codes"""

def translate(*args):
    r"""
     translate image by x or y or both

    :type src: :py:class:`Mat`
    :param src: input image
    :type dst: :py:class:`Mat`
    :param dst: output image that has the same type as src but the size is related with keep_src_size
    :type dx: float
    :param dx: displacement in x direction
    :type dy: float
    :param dy: displacement in y direction
    :type inter_method: int, optional
    :param inter_method: please see 'InterMethod'
    :type keep_src_size: boolean, optional
    :param keep_src_size: true indicate output image size equal to input image size, false indicate output image size follow up dx and dy.
    :type border_val: :py:class:`Scalar`, optional
    :param border_val: border filling value
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.translate(*args)

def get_rotation_mat2d(center, angle, scale):
    r"""
     Get an affine matrix of 2D rotation

    :type center: :py:class:`Point2f`
    :param center: center of the rotation in the source image
    :type angle: :py:class:`Radian`
    :param angle: rotation angle, please see 'Radian.(the' coordinate origin is assumed to be the top-left corner, the coordinate x is col, the coordinate y is row)
    :type scale: float
    :param scale: isotropic scale factor
    :rtype: :py:class:`Mat`
    :return: matrix_2X3
    """
    return _pyaqcv.get_rotation_mat2d(center, angle, scale)

def rotate(*args):
    r"""
     rotate image

    :type src: :py:class:`Mat`
    :param src: input image
    :type dst: :py:class:`Mat`
    :param dst: output image that has the same type as src but the size is related with keep_src_size
    :type angle: :py:class:`Radian`
    :param angle: rotation angle(positive angle indicating rotate clockwise), see 'Radian' please.(the coordinate origin is top-left corner, x axes is from left to right, y axes from top to bottom)
    :type inter_method: int, optional
    :param inter_method: please see 'InterMethod'
    :type keep_src_size: boolean, optional
    :param keep_src_size: true indicate output image size equal to input image size, false indicate output image size follow up angle
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.rotate(*args)

def vertical_rotate(src, dst, flag):
    r"""
     Rotate image 90 degrees,180 degrees,270 degrees in clockwise

    :type src: :py:class:`Mat`
    :param src: input image
    :type dst: :py:class:`Mat`
    :param dst: output image that has the same type as src. The size is the same with kRotate180, and the rows and cols are switched for kRotate90Clockwise and kRotate90CounterClockwise.
    :type flag: int
    :param flag: an enum to specify how to rotate the array, see 'RotateFlags'.
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.vertical_rotate(src, dst, flag)

def shear(*args):
    r"""
     shear image by horizontal or vertical

    :type src: :py:class:`Mat`
    :param src: input image
    :type dst: :py:class:`Mat`
    :param dst: output image that has the same type as src but the size is related with angle
    :type dsize: :py:class:`Size`
    :param dsize: destination size of dst
    :type shear_mode: int
    :param shear_mode: please see 'ShearMode'
    :type angle: :py:class:`Radian`
    :param angle:  shear angle(-90,90), please see 'Radian.(the' coordinate origin is assumed to be the top-left corner, the coordinate x is col, the coordinate y is row)
    :type inter_method: int, optional
    :param inter_method: please see 'InterMethod'
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.shear(*args)

def get_affine_mat(*args):
    r"""
    *Overload 1:*
     get affine transform matrix by three pair points

    :type src_points: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param src_points: input src points
    :type dst_points: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param dst_points: input dst points
    :type trans_matrix: :py:class:`Mat`
    :param trans_matrix: output  :math:`2 \times 3`  matrix of an affine transform (AQ_64FC1)
    :rtype: boolean
    :return: true if ok


    |

    *Overload 2:*
     get affine transform matrix with to point pari and angle
    :type src_pt: :py:class:`Point2f`
    :param src_pt: input source point
    :type src_radian: :py:class:`Radian`
    :param src_radian: source angle
    :type dst_pt: :py:class:`Point2f`
    :param dst_pt: destination point
    :type dst_radian: :py:class:`Radian`
    :param dst_radian: dstination angle
    :type trans_matrix: :py:class:`Mat`
    :param trans_matrix: output  :math:`2 \times 3`  matrix of an affine transform (AQ_64FC1)
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.get_affine_mat(*args)

def warp_affine(*args):
    r"""
     wrap affine image

    :type src: :py:class:`Mat`
    :param src: input image
    :type dst: :py:class:`Mat`
    :param dst: output image that has the size dst_image_size and the same type as src
    :type trans_matrix: :py:class:`Mat`
    :param trans_matrix: input  :math:`2 \times 3`  matrix of an affine transform
    :type dst_image_size: :py:class:`Size`
    :param dst_image_size: size of the output image
    :type inter_method: int, optional
    :param inter_method: please see 'InterMethod'
    :type border_type: int, optional
    :param border_type: please see 'BorderTypes'
    :type border_value: :py:class:`Scalar`, optional
    :param border_value: value used in case of a constant border; by default, it is 0
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.warp_affine(*args)

def get_perspective_mat(src_points, dst_points, trans_matrix):
    r"""
     get perspective transform matrix by four pair points

    :type src_points: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param src_points:  input src points
    :type dst_points: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param dst_points:  input dst points
    :type trans_matrix: :py:class:`Mat`
    :param trans_matrix:  output  :math:`3 \times 3`  matrix of an perspective transform
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.get_perspective_mat(src_points, dst_points, trans_matrix)

def warp_perspective(*args):
    r"""
     wrap perspective image

    :type src: :py:class:`Mat`
    :param src: input image
    :type dst: :py:class:`Mat`
    :param dst: output image that has the size dst_image_size and the same type as src
    :type trans_matrix: :py:class:`Mat`
    :param trans_matrix: input perspective transform matrix
    :type dst_image_size: :py:class:`Size`
    :param dst_image_size: size of the output image
    :type inter_method: int, optional
    :param inter_method: please see 'InterMethod'
    :type border_type: int, optional
    :param border_type: please see 'BorderTypes'
    :type border_value: :py:class:`Scalar`, optional
    :param border_value: value used in case of a constant border; by default, it is 0
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.warp_perspective(*args)

def remap(*args):
    r"""
     Applies a generic geometrical transformation to an image.

    The function remap transforms the source image using the specified map:

     .. math::

         \texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y))

    where values of pixels with non-integer coordinates are computed using one of available
    interpolation methods.  :math:`map_x`  and  :math:`map_y`  can be encoded as separate floating-point maps
    in  :math:`map_1`  and  :math:`map_2`  respectively, or interleaved floating-point maps of  :math:`(x,y)`  in
     :math:`map_1` .

    This function cannot operate in-place.

    :type src: :py:class:`Mat`
    :param src: Source image.
    :type dst: :py:class:`Mat`
    :param dst: Destination image. It has the same size as map1 and the same type as src .
    :type map1: :py:class:`Mat`
    :param map1: The first map of either (x,y) points or just x values having the type AQ_32FC1 or AQ_32FC2.
    :type map2: :py:class:`Mat`
    :param map2: The second map of y values having the type AQ_32FC1, or none (empty map
        if map1 is (x,y) points).
    :param interpolation: Interpolation method (see #InterMethod). The methods #kInterArea
        is not supported by this function.
    :param borderMode: Pixel extrapolation method (see #BorderTypes). When
        borderMode=#kBorderTransparent, it means that the pixels in the destination image that
        corresponds to the "outliers" in the source image are not modified by the function.
    :param borderValue: Value used in case of a constant border. By default, it is 0.
    """
    return _pyaqcv.remap(*args)

def resize(*args):
    r"""
     resize image
    AQCV internally calculates floating-point rounding for all image types, using banker's rounding rule.
    Other image libraries in part type such as 8UC1 May use other rules for speed up,
    and it is normal to have inconsistent results.

    :type src: :py:class:`Mat`
    :param src:  input image
    :type dst: :py:class:`Mat`
    :param dst:  output image that has the size dst_size and the same type as src
    :type dst_size: :py:class:`Size`
    :param dst_size:  size of the output image
    :type x_scale: float, optional
    :param x_scale:  scale factor in x direction
    :type y_scale: float, optional
    :param y_scale:  scale factor in y direction
    :type inter_method: int, optional
    :param inter_method:  please see 'InterMethod'
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.resize(*args)

def warp_circle_spread(*args):
    r"""
     wrap circle spread(cart to polar)

    :type src: :py:class:`Mat`
    :param src: src image wantted to be warpped
    :type dst: :py:class:`Mat`
    :param dst: warpped result image
    :type center: :py:class:`Point2f`
    :param center: center of ploar origin
    :type r_start: float
    :param r_start: the start radius of annulus, should be none negative
    :type r_end: float
    :param r_end: the end radius of annulus, should be none negative
    :type start_angle: :py:class:`Radian`
    :param start_angle: from where begin to warp
    :type span_angle: :py:class:`Radian`
    :param span_angle: total angle span of the annulus, can be positive or negative
    :type dsize: :py:class:`Size`
    :param dsize: the size of result image, dsize will be set adaptively with given annulus when given dsize is empty
    :type inter_method: int, optional
    :param inter_method: 'InterMethod'
    :type border_mode: int, optional
    :param border_mode: 'BorderTypes'
    :param Scalar: value to be filled when out of boundaries
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.warp_circle_spread(*args)

def warp_circle_spread_inv(*args):
    r"""
     wrap image from polar back to cart

    :type src: :py:class:`Mat`
    :param src: src image wantted to be warpped
    :type dst: :py:class:`Mat`
    :param dst: warpped result image
    :type cart_size: :py:class:`Size`
    :param cart_size: the size of result image
    :type center: :py:class:`Point2f`
    :param center: center of ploar origin
    :type r_start: float
    :param r_start: the first radius of annulus, should be none negative
    :type r_end: float
    :param r_end: the second radius of annulus, should be none negative
    :type start_angle: :py:class:`Radian`
    :param start_angle: from where begin to warp
    :type span_angle: :py:class:`Radian`
    :param span_angle: total angle span of the annulus, can be positive or nefative
    :type inter_method: int, optional
    :param inter_method: 'InterMethod'
    :type border_mode: int, optional
    :param border_mode: 'BorderTypes'
    :param Scalar: value to be filled when out of boundaries
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.warp_circle_spread_inv(*args)
kThresholdBinary = _pyaqcv.kThresholdBinary
r"""if x>=thre, x=maxval, otherwise x=0"""
kThresholdBinaryInverse = _pyaqcv.kThresholdBinaryInverse
r"""if x>=thre, x=0, otherwise x=maxval"""
kThresholdTruncate = _pyaqcv.kThresholdTruncate
r"""if x>=thre, x=thre, otherwise x=x"""
kThresholdToZero = _pyaqcv.kThresholdToZero
r"""if x>=thre, x=x, otherwise x=0"""
kThresholdToZeroInverse = _pyaqcv.kThresholdToZeroInverse
r"""if x>=thre, x=0, otherwise x=x"""
kThresholdMask = _pyaqcv.kThresholdMask
r"""interal use"""
kThresholdOtsu = _pyaqcv.kThresholdOtsu
r"""use Otsu algorithm to choose the optimal threshold value"""
kThresholdTriangle = _pyaqcv.kThresholdTriangle
r"""use Triangle algorithm to choose the optimal threshold value"""

def threshold(src, dst, thresh, maxval, type):
    r"""
     use a global fixed threshold to binarize an image.
    The function applies fixed-level thresholding to a multiple-channel array. The function is typically
    used to get a bi-level (binary) image out of a grayscale image or for removing a noise, that is,
    filtering out pixels with too small or too large values. There are several types of thresholding
    supported by the function. They are determined by type parameter.

    Also, the special values #kThresholdOtsu or #kThresholdTriangle may be combined with one of the
    above values. In these cases, the function determines the optimal threshold value using the Otsu's
    or Triangle algorithm and uses it instead of the specified thresh.

    Notes: Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.

    :type src: :py:class:`Mat`
    :param src: input array in AQ_8U, AQ_16U, AQ_16S, AQ_32F or AQ_64F, one or multiple channel.
    :type dst: :py:class:`Mat`
    :param dst: output array of the same size and type and the same number of channels as src.
    :type thresh: float
    :param thresh: threshold value.
    :type maxval: float
    :param maxval: maximum value to use with the #kThresholdBinary and #kThresholdBinaryInverse thresholding types.
    :type type: int
    :param type: thresholding type (see #ThresholdTypes).
    :rtype: float
    :return: the computed threshold value if Otsu's or Triangle methods used.
    """
    return _pyaqcv.threshold(src, dst, thresh, maxval, type)
kAdaptiveThresholdMeanC = _pyaqcv.kAdaptiveThresholdMeanC
r"""the threshold value  :math:`T(x,y)`  is a mean of the  :math:`\texttt{block_size} \times    \texttt{block_size}`  neighborhood of  :math:`(x, y)`  minus C"""
kAdaptiveThresholdGaussianC = _pyaqcv.kAdaptiveThresholdGaussianC
r"""
    the threshold value  :math:`T(x, y)`  is a weighted sum (cross-correlation with a Gaussian
       window) of the  :math:`\texttt{block_size} \times \texttt{block_size}`  neighborhood of  :math:`(x, y)`
       minus C . The default sigma (standard deviation) is used for the specified block_size . See
       #get_gaussian_kernel
    """
kAdaptiveThresholdForegroundLight = _pyaqcv.kAdaptiveThresholdForegroundLight
r"""if x>=mean+offset, x=maxval, otherwise x=0"""
kAdaptiveThresholdForegroundDark = _pyaqcv.kAdaptiveThresholdForegroundDark
r"""if x<=mean-offset, x=maxval, otherwise x=0"""
kAdaptiveThresholdForegroundEqual = _pyaqcv.kAdaptiveThresholdForegroundEqual
r"""if x>=mean-offset and x<=mean+offset, x=maxval, otherwise x=0"""
kAdaptiveThresholdForegroundNotEqual = _pyaqcv.kAdaptiveThresholdForegroundNotEqual
r"""if x<mean-offset or x>mean+offset, x=maxval, otherwise x=0"""

def adaptive_threshold(*args):
    r"""
     use a local adaptive threshold to binarize an image.

    The function transforms a grayscale image to a binary image according to the formulae:
    -   **kThresholdBinary**

         .. math::

             dst(x,y) =
                     \left\{
                         \begin{array}
                             \texttt{maxValue} & if (src(x,y) > T(x,y)) \\
                             \texttt{0} & otherwise
                         \end{array}
                     \right.
    -   **kThresholdBinaryInverse**

         .. math::

             dst(x,y) =
                     \left\{
                         \begin{array}
                             \texttt{0} & if (src(x,y) > T(x,y)) \\
                             \texttt{maxValue} & otherwise
                     \end{array}
                     \right.
    where  :math:`T(x,y)`  is a threshold calculated individually for each pixel (see adaptive_method parameter).

    :type src: :py:class:`Mat`
    :param src: Source 8-bit single-channel image.
    :type dst: :py:class:`Mat`
    :param dst: Destination image of the same size and the same type as src.
    :type maxval: float
    :param maxval: Non-zero value assigned to the pixels for which the condition is satisfied
    :type adaptive_method: int
    :param adaptive_method: Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes.
    :type type: int
    :param type: Thresholding type that must be either #kThresholdBinary and #kThresholdBinaryInverse,
        see #ThresholdTypes.
    :type block_size: int
    :param block_size: Size of a pixel neighborhood that is used to calculate a threshold value for the
        pixel: 3, 5, 7, and so on.
    :type c: float, optional
    :param c: Constant subtracted from the mean or weighted mean. Normally, it is positive but may be
        zero or negative as well.
    """
    return _pyaqcv.adaptive_threshold(*args)

def auto_threshold(src, dst, sigma):
    r"""
     auto_threshold segments a single-channel image using multiple thresholding.

    First, the absolute histogram of the gray values is determined. Then, relevant minima
    are extracted from the histogram, which are used successively as parameters for a
    thresholding operation. The larger the value of Sigma is chosen, the fewer regions
    will be extracted. This operator is useful if the regions to be extracted exhibit
    similar gray values (homogeneous regions).

    :type src: :py:class:`Mat`
    :param src: input single-channel image in AQ_8U.
    :type dst: :py:class:`Mat`
    :param dst: output label image, pixels have the same value belong to the same region,
        pixel value starts from 0,1,2...
    :type sigma: float
    :param sigma: the histogram is smoothed with a Gaussian filter with standard deviation sigma.
    """
    return _pyaqcv.auto_threshold(src, dst, sigma)
class Histogram(object):
    r"""class of histogram"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    bin_num = property(_pyaqcv.Histogram_bin_num_get, _pyaqcv.Histogram_bin_num_set, doc=r"""bin nums in the hist""")
    hist_min = property(_pyaqcv.Histogram_hist_min_get, _pyaqcv.Histogram_hist_min_set, doc=r"""min value, max value and range of the hist""")
    hist_max = property(_pyaqcv.Histogram_hist_max_get, _pyaqcv.Histogram_hist_max_set)
    hist_range = property(_pyaqcv.Histogram_hist_range_get, _pyaqcv.Histogram_hist_range_set)
    mean = property(_pyaqcv.Histogram_mean_get, _pyaqcv.Histogram_mean_set, doc=r"""mean and standard deviation""")
    std_dev = property(_pyaqcv.Histogram_std_dev_get, _pyaqcv.Histogram_std_dev_set)
    total = property(_pyaqcv.Histogram_total_get, _pyaqcv.Histogram_total_set, doc=r"""total pixels in the hist""")
    bin_min = property(_pyaqcv.Histogram_bin_min_get, _pyaqcv.Histogram_bin_min_set, doc=r"""min value, max value, mid value(represent this bin) and pixel nums of each bin""")
    bin_max = property(_pyaqcv.Histogram_bin_max_get, _pyaqcv.Histogram_bin_max_set)
    bin_mid = property(_pyaqcv.Histogram_bin_mid_get, _pyaqcv.Histogram_bin_mid_set)
    bin_count = property(_pyaqcv.Histogram_bin_count_get, _pyaqcv.Histogram_bin_count_set)

    def __init__(self):
        _pyaqcv.Histogram_swiginit(self, _pyaqcv.new_Histogram())

    def init(self, _bins, _hist_min, _hist_max):
        r"""
        hist init with range[_hist_min,_hist_max).
           :type _bins: int
           :param _bins: bin nums
           :type _hist_min: int
           :param _hist_min: min value of the hist(include)
           :type _hist_max: int
           :param _hist_max: max value of the hist(exclude)
        """
        return _pyaqcv.Histogram_init(self, _bins, _hist_min, _hist_max)
    __swig_destroy__ = _pyaqcv.delete_Histogram

# Register Histogram in _pyaqcv:
_pyaqcv.Histogram_swigregister(Histogram)

def histogram(*args):
    r"""
     calculate histogram of images.

    :type images: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
    :param images: input images with the same type(only AQ_8UC1/AQ_8UC3/AQ_16UC1)
    :type hist: :py:class:`Histogram`
    :param hist: output hist
    :type bins: int
    :param bins: bin nums
    :type hist_min: int
    :param hist_min: min value of the hist(include)
    :type hist_max: int
    :param hist_max: max value of the hist(exclude)
    :type mask: :py:class:`Mat`, optional
    :param mask: optional mask. If the matrix is not empty, it must be an 8-bit array of the same size
               as images. The non-zero mask elements mark the array elements counted in the histogram.
    :type cal_mean_std_dev: boolean, optional
    :param cal_mean_std_dev: if calculate mean and standard deviation(rather slow for multiple images)
    """
    return _pyaqcv.histogram(*args)

def histogram_equalization(*args):
    r"""
     histogram equalization.

    :type src: :py:class:`Mat`
    :param src: input image(only AQ_8UC1/AQ_8UC3/AQ_16UC1)
    :type dst: :py:class:`Mat`
    :param dst: output image
    :type mask: :py:class:`Mat`, optional
    :param mask: optional mask. If the matrix is not empty, it must be an 8-bit array of the same size
        as images. The non-zero mask elements mark the array elements counted in the histogram.
    :rtype: boolean
    :return: true if successed
    """
    return _pyaqcv.histogram_equalization(*args)

def histogram_specification(*args):
    r"""
     specify hist to src.

    :type src: :py:class:`Mat`
    :param src: input image(only AQ_8UC1/AQ_8UC3/AQ_16UC1)
    :type dst: :py:class:`Mat`
    :param dst: output image
    :type hist: :py:class:`Histogram`
    :param hist: target hist
    :type mask: :py:class:`Mat`, optional
    :param mask: optional mask. If the matrix is not empty, it must be an 8-bit array of the same size
        as images. The non-zero mask elements mark the array elements counted in the histogram.
    :rtype: boolean
    :return: true if successed
    """
    return _pyaqcv.histogram_specification(*args)

def magic_wand_select(*args):
    r"""
    *Overload 1:*
    magic wand using to selection a region in an image
    :type image: :py:class:`Mat`
    :param image: soure image, in which to select a region
    :type seed_point: :py:class:`Point2i`
    :param seed_point: start point
    :type torlerance: int
    :param torlerance: torlerance of gray value difference between seed_point and it's adjoint points
    :type res_mask: :py:class:`Mat`
    :param res_mask: binary of selected region(255 inicates foreground)
    :rtype: boolean
    :return: ture if ok


    |

    *Overload 2:*
    magic wand using to selection a region in an image
    :type image: :py:class:`Mat`
    :param image: soure image, in which to select a region
    :type seed_point: :py:class:`Point2i`
    :param seed_point: start point
    :type torlerance: int
    :param torlerance: torlerance of gray value difference between seed_point and it's adjoint points
    :type selected_region: :py:class:`MultiPolygon2i`
    :param selected_region: foreground regions
    :type roi: :py:class:`MultiPolygon2i`, optional
    :param roi: optional, region of interest to select, region outof roi will be ignore. nullptr indicates the whole image area
    :rtype: boolean
    :return: ture if ok


    |

    *Overload 3:*
    magic wand using to selection a region in an image
    :type image: :py:class:`Mat`
    :param image: soure image, in which to select a region
    :type seed_point: :py:class:`Point2i`
    :param seed_point: start point
    :type torlerance: int
    :param torlerance: torlerance of gray value difference between seed_point and it's adjoint points
    :type selected_region: :py:class:`MultiPolygon2i`
    :param selected_region: foreground regions
    :param roi: optional, region of interest to select, region outof roi will be ignore. nullptr indicates the whole image area
    :rtype: boolean
    :return: ture if ok
    """
    return _pyaqcv.magic_wand_select(*args)

def scribble_selection(*args):
    r"""
    *Overload 1:*
    select regions with scribble points
    :type image: :py:class:`Mat`
    :param image: soure image, in which to select regions
    :type fg_pts: std::vector< visionflow::geometry::Point2i,std::allocator< visionflow::geometry::Point2i > >
    :param fg_pts: foreground region points, regions similary to this points will be 255 in the result binary mask image
    :type bg_pts: std::vector< visionflow::geometry::Point2i,std::allocator< visionflow::geometry::Point2i > >
    :param bg_pts: background region points regions similary to this points will be 0 in the result binary mask image
    :type res: :py:class:`Mat`
    :param res: binary of selected region(255 inicates foreground)
    :rtype: boolean
    :return: ture if ok


    |

    *Overload 2:*
    select regions with scribble points
    :type image: :py:class:`Mat`
    :param image: soure image, in which to select regions
    :type fg_pts: std::vector< visionflow::geometry::Point2i,std::allocator< visionflow::geometry::Point2i > >
    :param fg_pts: foreground region points, regions similary to this points will be 255 in the result binary mask image
    :type bg_pts: std::vector< visionflow::geometry::Point2i,std::allocator< visionflow::geometry::Point2i > >
    :param bg_pts: background region points regions similary to this points will be 0 in the result binary mask image
    :type selected_region: :py:class:`MultiPolygon2i`
    :param selected_region: foreground regions
    :type roi: :py:class:`MultiPolygon2i`, optional
    :param roi: optional, region of interest to select, region outof roi will be ignore. nullptr indicates the whole image area
    :rtype: boolean
    :return: ture if ok


    |

    *Overload 3:*
    select regions with scribble points
    :type image: :py:class:`Mat`
    :param image: soure image, in which to select regions
    :type fg_pts: std::vector< visionflow::geometry::Point2i,std::allocator< visionflow::geometry::Point2i > >
    :param fg_pts: foreground region points, regions similary to this points will be 255 in the result binary mask image
    :type bg_pts: std::vector< visionflow::geometry::Point2i,std::allocator< visionflow::geometry::Point2i > >
    :param bg_pts: background region points regions similary to this points will be 0 in the result binary mask image
    :type selected_region: :py:class:`MultiPolygon2i`
    :param selected_region: foreground regions
    :param roi: optional, region of interest to select, region outof roi will be ignore. nullptr indicates the whole image area
    :rtype: boolean
    :return: ture if ok
    """
    return _pyaqcv.scribble_selection(*args)
kColorBGR2BGRA = _pyaqcv.kColorBGR2BGRA
r"""add alpha channel to RGB or BGR image"""
kColorRGB2RGBA = _pyaqcv.kColorRGB2RGBA
kColorBGRA2BGR = _pyaqcv.kColorBGRA2BGR
r"""remove alpha channel from RGB or BGR image"""
kColorRGBA2RGB = _pyaqcv.kColorRGBA2RGB
kColorBGR2RGBA = _pyaqcv.kColorBGR2RGBA
r"""convert between RGB and BGR color spaces (with or without alpha channel)"""
kColorRGB2BGRA = _pyaqcv.kColorRGB2BGRA
kColorRGBA2BGR = _pyaqcv.kColorRGBA2BGR
kColorBGRA2RGB = _pyaqcv.kColorBGRA2RGB
kColorBGR2RGB = _pyaqcv.kColorBGR2RGB
kColorRGB2BGR = _pyaqcv.kColorRGB2BGR
kColorBGRA2RGBA = _pyaqcv.kColorBGRA2RGBA
kColorRGBA2BGRA = _pyaqcv.kColorRGBA2BGRA
kColorBGR2Gray = _pyaqcv.kColorBGR2Gray
r"""convert between RGB/BGR and grayscale, 'color conversions'"""
kColorRGB2Gray = _pyaqcv.kColorRGB2Gray
kColorGray2BGR = _pyaqcv.kColorGray2BGR
kColorGray2RGB = _pyaqcv.kColorGray2RGB
kColorGray2BGRA = _pyaqcv.kColorGray2BGRA
kColorGray2RGBA = _pyaqcv.kColorGray2RGBA
kColorBGRA2Gray = _pyaqcv.kColorBGRA2Gray
kColorRGBA2Gray = _pyaqcv.kColorRGBA2Gray
kColorBGR2BGR565 = _pyaqcv.kColorBGR2BGR565
r"""convert between RGB/BGR and BGR565 (16-bit images)"""
kColorRGB2BGR565 = _pyaqcv.kColorRGB2BGR565
kColorBGR5652BGR = _pyaqcv.kColorBGR5652BGR
kColorBGR5652RGB = _pyaqcv.kColorBGR5652RGB
kColorBGRA2BGR565 = _pyaqcv.kColorBGRA2BGR565
kColorRGBA2BGR565 = _pyaqcv.kColorRGBA2BGR565
kColorBGR5652BGRA = _pyaqcv.kColorBGR5652BGRA
kColorBGR5652RGBA = _pyaqcv.kColorBGR5652RGBA
kColorGray2BGR565 = _pyaqcv.kColorGray2BGR565
r"""convert between grayscale to BGR565 (16-bit images)"""
kColorBGR5652Gray = _pyaqcv.kColorBGR5652Gray
kColorBGR2BGR555 = _pyaqcv.kColorBGR2BGR555
r"""convert between RGB/BGR and BGR555 (16-bit images)"""
kColorRGB2BGR555 = _pyaqcv.kColorRGB2BGR555
kColorBGR5552BGR = _pyaqcv.kColorBGR5552BGR
kColorBGR5552RGB = _pyaqcv.kColorBGR5552RGB
kColorBGRA2BGR555 = _pyaqcv.kColorBGRA2BGR555
kColorRGBA2BGR555 = _pyaqcv.kColorRGBA2BGR555
kColorBGR5552BGRA = _pyaqcv.kColorBGR5552BGRA
kColorBGR5552RGBA = _pyaqcv.kColorBGR5552RGBA
kColorGray2BGR555 = _pyaqcv.kColorGray2BGR555
r"""convert between grayscale and BGR555 (16-bit images)"""
kColorBGR5552Gray = _pyaqcv.kColorBGR5552Gray
kColorBGR2XYZ = _pyaqcv.kColorBGR2XYZ
r"""convert RGB/BGR to CIE XYZ, 'color conversions'"""
kColorRGB2XYZ = _pyaqcv.kColorRGB2XYZ
kColorXYZ2BGR = _pyaqcv.kColorXYZ2BGR
kColorXYZ2RGB = _pyaqcv.kColorXYZ2RGB
kColorBGR2YCrCb = _pyaqcv.kColorBGR2YCrCb
r"""convert RGB/BGR to luma-chroma (aka YCC), 'color conversions'"""
kColorRGB2YCrCb = _pyaqcv.kColorRGB2YCrCb
kColorYCrCb2BGR = _pyaqcv.kColorYCrCb2BGR
kColorYCrCb2RGB = _pyaqcv.kColorYCrCb2RGB
kColorBGR2HSV = _pyaqcv.kColorBGR2HSV
r"""convert RGB/BGR to HSV (hue saturation value) with H range 0..180 if 8 bit image, 'color conversions'"""
kColorRGB2HSV = _pyaqcv.kColorRGB2HSV
kColorBGR2Lab = _pyaqcv.kColorBGR2Lab
r"""convert RGB/BGR to CIE Lab, 'color conversions'"""
kColorRGB2Lab = _pyaqcv.kColorRGB2Lab
kColorBGR2Luv = _pyaqcv.kColorBGR2Luv
r"""convert RGB/BGR to CIE Luv, 'color conversions'"""
kColorRGB2Luv = _pyaqcv.kColorRGB2Luv
kColorBGR2HLS = _pyaqcv.kColorBGR2HLS
r"""convert RGB/BGR to HLS (hue lightness saturation) with H range 0..180 if 8 bit image, 'color conversions'"""
kColorRGB2HLS = _pyaqcv.kColorRGB2HLS
kColorHSV2BGR = _pyaqcv.kColorHSV2BGR
r"""backward conversions HSV to RGB/BGR with H range 0..180 if 8 bit image"""
kColorHSV2RGB = _pyaqcv.kColorHSV2RGB
kColorLab2BGR = _pyaqcv.kColorLab2BGR
kColorLab2RGB = _pyaqcv.kColorLab2RGB
kColorLuv2BGR = _pyaqcv.kColorLuv2BGR
kColorLuv2RGB = _pyaqcv.kColorLuv2RGB
kColorHLS2BGR = _pyaqcv.kColorHLS2BGR
r"""backward conversions HLS to RGB/BGR with H range 0..180 if 8 bit image"""
kColorHLS2RGB = _pyaqcv.kColorHLS2RGB
kColorBGR2HSVFull = _pyaqcv.kColorBGR2HSVFull
r"""convert RGB/BGR to HSV (hue saturation value) with H range 0..255 if 8 bit image, 'color conversions'"""
kColorRGB2HSVFull = _pyaqcv.kColorRGB2HSVFull
kColorBGR2HLSFull = _pyaqcv.kColorBGR2HLSFull
r"""convert RGB/BGR to HLS (hue lightness saturation) with H range 0..255 if 8 bit image, 'color conversions'"""
kColorRGB2HLSFull = _pyaqcv.kColorRGB2HLSFull
kColorHSV2BGRFull = _pyaqcv.kColorHSV2BGRFull
r"""backward conversions HSV to RGB/BGR with H range 0..255 if 8 bit image"""
kColorHSV2RGBFull = _pyaqcv.kColorHSV2RGBFull
kColorHLS2BGRFull = _pyaqcv.kColorHLS2BGRFull
r"""backward conversions HLS to RGB/BGR with H range 0..255 if 8 bit image"""
kColorHLS2RGBFull = _pyaqcv.kColorHLS2RGBFull
kColorLBGR2Lab = _pyaqcv.kColorLBGR2Lab
kColorLRGB2Lab = _pyaqcv.kColorLRGB2Lab
kColorLBGR2Luv = _pyaqcv.kColorLBGR2Luv
kColorLRGB2Luv = _pyaqcv.kColorLRGB2Luv
kColorLab2LBGR = _pyaqcv.kColorLab2LBGR
kColorLab2LRGB = _pyaqcv.kColorLab2LRGB
kColorLuv2LBGR = _pyaqcv.kColorLuv2LBGR
kColorLuv2LRGB = _pyaqcv.kColorLuv2LRGB
kColorBGR2YUV = _pyaqcv.kColorBGR2YUV
r"""convert between RGB/BGR and YUV"""
kColorRGB2YUV = _pyaqcv.kColorRGB2YUV
kColorYUV2BGR = _pyaqcv.kColorYUV2BGR
kColorYUV2RGB = _pyaqcv.kColorYUV2RGB
kColorYUV2RGB_NV12 = _pyaqcv.kColorYUV2RGB_NV12
r"""YUV 4:2:0 family to RGB"""
kColorYUV2BGR_NV12 = _pyaqcv.kColorYUV2BGR_NV12
kColorYUV2RGB_NV21 = _pyaqcv.kColorYUV2RGB_NV21
kColorYUV2BGR_NV21 = _pyaqcv.kColorYUV2BGR_NV21
kColorYUV420sp2RGB = _pyaqcv.kColorYUV420sp2RGB
kColorYUV420sp2BGR = _pyaqcv.kColorYUV420sp2BGR
kColorYUV2RGBA_NV12 = _pyaqcv.kColorYUV2RGBA_NV12
kColorYUV2BGRA_NV12 = _pyaqcv.kColorYUV2BGRA_NV12
kColorYUV2RGBA_NV21 = _pyaqcv.kColorYUV2RGBA_NV21
kColorYUV2BGRA_NV21 = _pyaqcv.kColorYUV2BGRA_NV21
kColorYUV420sp2RGBA = _pyaqcv.kColorYUV420sp2RGBA
kColorYUV420sp2BGRA = _pyaqcv.kColorYUV420sp2BGRA
kColorYUV2RGB_YV12 = _pyaqcv.kColorYUV2RGB_YV12
kColorYUV2BGR_YV12 = _pyaqcv.kColorYUV2BGR_YV12
kColorYUV2RGB_IYUV = _pyaqcv.kColorYUV2RGB_IYUV
kColorYUV2BGR_IYUV = _pyaqcv.kColorYUV2BGR_IYUV
kColorYUV2RGB_I420 = _pyaqcv.kColorYUV2RGB_I420
kColorYUV2BGR_I420 = _pyaqcv.kColorYUV2BGR_I420
kColorYUV420p2RGB = _pyaqcv.kColorYUV420p2RGB
kColorYUV420p2BGR = _pyaqcv.kColorYUV420p2BGR
kColorYUV2RGBA_YV12 = _pyaqcv.kColorYUV2RGBA_YV12
kColorYUV2BGRA_YV12 = _pyaqcv.kColorYUV2BGRA_YV12
kColorYUV2RGBA_IYUV = _pyaqcv.kColorYUV2RGBA_IYUV
kColorYUV2BGRA_IYUV = _pyaqcv.kColorYUV2BGRA_IYUV
kColorYUV2RGBA_I420 = _pyaqcv.kColorYUV2RGBA_I420
kColorYUV2BGRA_I420 = _pyaqcv.kColorYUV2BGRA_I420
kColorYUV420p2RGBA = _pyaqcv.kColorYUV420p2RGBA
kColorYUV420p2BGRA = _pyaqcv.kColorYUV420p2BGRA
kColorYUV2Gray420 = _pyaqcv.kColorYUV2Gray420
kColorYUV2GrayNV21 = _pyaqcv.kColorYUV2GrayNV21
kColorYUV2GrayNV12 = _pyaqcv.kColorYUV2GrayNV12
kColorYUV2GrayYV12 = _pyaqcv.kColorYUV2GrayYV12
kColorYUV2GrayIYUV = _pyaqcv.kColorYUV2GrayIYUV
kColorYUV2GrayI420 = _pyaqcv.kColorYUV2GrayI420
kColorYUV420sp2Gray = _pyaqcv.kColorYUV420sp2Gray
kColorYUV420p2Gray = _pyaqcv.kColorYUV420p2Gray
kColorYUV2RGB_UYVY = _pyaqcv.kColorYUV2RGB_UYVY
r"""YUV 4:2:2 family to RGB"""
kColorYUV2BGR_UYVY = _pyaqcv.kColorYUV2BGR_UYVY
kColorYUV2RGB_Y422 = _pyaqcv.kColorYUV2RGB_Y422
kColorYUV2BGR_Y422 = _pyaqcv.kColorYUV2BGR_Y422
kColorYUV2RGB_UYNV = _pyaqcv.kColorYUV2RGB_UYNV
kColorYUV2BGR_UYNV = _pyaqcv.kColorYUV2BGR_UYNV
kColorYUV2RGBA_UYVY = _pyaqcv.kColorYUV2RGBA_UYVY
kColorYUV2BGRA_UYVY = _pyaqcv.kColorYUV2BGRA_UYVY
kColorYUV2RGBA_Y422 = _pyaqcv.kColorYUV2RGBA_Y422
kColorYUV2BGRA_Y422 = _pyaqcv.kColorYUV2BGRA_Y422
kColorYUV2RGBA_UYNV = _pyaqcv.kColorYUV2RGBA_UYNV
kColorYUV2BGRA_UYNV = _pyaqcv.kColorYUV2BGRA_UYNV
kColorYUV2RGB_YUY2 = _pyaqcv.kColorYUV2RGB_YUY2
kColorYUV2BGR_YUY2 = _pyaqcv.kColorYUV2BGR_YUY2
kColorYUV2RGB_YVYU = _pyaqcv.kColorYUV2RGB_YVYU
kColorYUV2BGR_YVYU = _pyaqcv.kColorYUV2BGR_YVYU
kColorYUV2RGB_YUYV = _pyaqcv.kColorYUV2RGB_YUYV
kColorYUV2BGR_YUYV = _pyaqcv.kColorYUV2BGR_YUYV
kColorYUV2RGB_YUNV = _pyaqcv.kColorYUV2RGB_YUNV
kColorYUV2BGR_YUNV = _pyaqcv.kColorYUV2BGR_YUNV
kColorYUV2RGBA_YUY2 = _pyaqcv.kColorYUV2RGBA_YUY2
kColorYUV2BGRA_YUY2 = _pyaqcv.kColorYUV2BGRA_YUY2
kColorYUV2RGBA_YVYU = _pyaqcv.kColorYUV2RGBA_YVYU
kColorYUV2BGRA_YVYU = _pyaqcv.kColorYUV2BGRA_YVYU
kColorYUV2RGBA_YUYV = _pyaqcv.kColorYUV2RGBA_YUYV
kColorYUV2BGRA_YUYV = _pyaqcv.kColorYUV2BGRA_YUYV
kColorYUV2RGBA_YUNV = _pyaqcv.kColorYUV2RGBA_YUNV
kColorYUV2BGRA_YUNV = _pyaqcv.kColorYUV2BGRA_YUNV
kColorYUV2GrayUYVY = _pyaqcv.kColorYUV2GrayUYVY
kColorYUV2GrayYUY2 = _pyaqcv.kColorYUV2GrayYUY2
kColorYUV2GrayY422 = _pyaqcv.kColorYUV2GrayY422
kColorYUV2GrayUYNV = _pyaqcv.kColorYUV2GrayUYNV
kColorYUV2GrayYVYU = _pyaqcv.kColorYUV2GrayYVYU
kColorYUV2GrayYUYV = _pyaqcv.kColorYUV2GrayYUYV
kColorYUV2GrayYUNV = _pyaqcv.kColorYUV2GrayYUNV
kColorRGBA2mRGBA = _pyaqcv.kColorRGBA2mRGBA
r"""alpha premultiplication"""
kColormRGBA2RGBA = _pyaqcv.kColormRGBA2RGBA
kColorRGB2YUV_I420 = _pyaqcv.kColorRGB2YUV_I420
r"""RGB to YUV 4:2:0 family"""
kColorBGR2YUV_I420 = _pyaqcv.kColorBGR2YUV_I420
kColorRGB2YUV_IYUV = _pyaqcv.kColorRGB2YUV_IYUV
kColorBGR2YUV_IYUV = _pyaqcv.kColorBGR2YUV_IYUV
kColorRGBA2YUV_I420 = _pyaqcv.kColorRGBA2YUV_I420
kColorBGRA2YUV_I420 = _pyaqcv.kColorBGRA2YUV_I420
kColorRGBA2YUV_IYUV = _pyaqcv.kColorRGBA2YUV_IYUV
kColorBGRA2YUV_IYUV = _pyaqcv.kColorBGRA2YUV_IYUV
kColorRGB2YUV_YV12 = _pyaqcv.kColorRGB2YUV_YV12
kColorBGR2YUV_YV12 = _pyaqcv.kColorBGR2YUV_YV12
kColorRGBA2YUV_YV12 = _pyaqcv.kColorRGBA2YUV_YV12
kColorBGRA2YUV_YV12 = _pyaqcv.kColorBGRA2YUV_YV12
kColorBayerRG2BGR = _pyaqcv.kColorBayerRG2BGR
r"""Demosaicing first two pixels of first line are RG"""
kColorBayerGR2BGR = _pyaqcv.kColorBayerGR2BGR
r"""first two pixels of first line are GR"""
kColorBayerBG2BGR = _pyaqcv.kColorBayerBG2BGR
r"""first two pixels of first line are BG"""
kColorBayerGB2BGR = _pyaqcv.kColorBayerGB2BGR
r"""first two pixels of first line are GB"""
kColorBayerBG2RGB = _pyaqcv.kColorBayerBG2RGB
kColorBayerGB2RGB = _pyaqcv.kColorBayerGB2RGB
kColorBayerRG2RGB = _pyaqcv.kColorBayerRG2RGB
kColorBayerGR2RGB = _pyaqcv.kColorBayerGR2RGB
kColorBayerRG2Gray = _pyaqcv.kColorBayerRG2Gray
kColorBayerGR2Gray = _pyaqcv.kColorBayerGR2Gray
kColorBayerBG2Gray = _pyaqcv.kColorBayerBG2Gray
kColorBayerGB2Gray = _pyaqcv.kColorBayerGB2Gray
kColorBayerRG2BGR_VNG = _pyaqcv.kColorBayerRG2BGR_VNG
r"""Demosaicing using Variable Number of Gradients"""
kColorBayerGR2BGR_VNG = _pyaqcv.kColorBayerGR2BGR_VNG
kColorBayerBG2BGR_VNG = _pyaqcv.kColorBayerBG2BGR_VNG
kColorBayerGB2BGR_VNG = _pyaqcv.kColorBayerGB2BGR_VNG
kColorBayerBG2RGB_VNG = _pyaqcv.kColorBayerBG2RGB_VNG
kColorBayerGB2RGB_VNG = _pyaqcv.kColorBayerGB2RGB_VNG
kColorBayerRG2RGB_VNG = _pyaqcv.kColorBayerRG2RGB_VNG
kColorBayerGR2RGB_VNG = _pyaqcv.kColorBayerGR2RGB_VNG
kColorBayerRG2BGR_EA = _pyaqcv.kColorBayerRG2BGR_EA
r"""Edge-Aware Demosaicing"""
kColorBayerGR2BGR_EA = _pyaqcv.kColorBayerGR2BGR_EA
kColorBayerBG2BGR_EA = _pyaqcv.kColorBayerBG2BGR_EA
kColorBayerGB2BGR_EA = _pyaqcv.kColorBayerGB2BGR_EA
kColorBayerBG2RGB_EA = _pyaqcv.kColorBayerBG2RGB_EA
kColorBayerGB2RGB_EA = _pyaqcv.kColorBayerGB2RGB_EA
kColorBayerRG2RGB_EA = _pyaqcv.kColorBayerRG2RGB_EA
kColorBayerGR2RGB_EA = _pyaqcv.kColorBayerGR2RGB_EA
kColorBayerRG2BGRA = _pyaqcv.kColorBayerRG2BGRA
r"""Demosaicing with alpha channel"""
kColorBayerGR2BGRA = _pyaqcv.kColorBayerGR2BGRA
kColorBayerBG2BGRA = _pyaqcv.kColorBayerBG2BGRA
kColorBayerGB2BGRA = _pyaqcv.kColorBayerGB2BGRA
kColorBayerBG2RGBA = _pyaqcv.kColorBayerBG2RGBA
kColorBayerGB2RGBA = _pyaqcv.kColorBayerGB2RGBA
kColorBayerRG2RGBA = _pyaqcv.kColorBayerRG2RGBA
kColorBayerGR2RGBA = _pyaqcv.kColorBayerGR2RGBA
kColorColorCvtMax = _pyaqcv.kColorColorCvtMax

def cvt_color(*args):
    r"""
     Converts an image from one color space to another.

    The function converts an input image from one color space to another. In case of a transformation
    to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note
    that the default color format in aqcv is often referred to as RGB but it is actually BGR (the
    bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue
    component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and
    sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.

    The conventional ranges for R, G, and B channel values are:
    -   0 to 255 for kDepth_U8 images
    -   0 to 65535 for kDepth_U16 images
    -   0 to 1 for kDepth_F32 images

    In case of linear transformations, the range does not matter. But in case of a non-linear
    transformation, an input RGB image should be normalized to the proper value range to get the correct
    results. For example, if you have a 32-bit floating-point image directly converted from an 8-bit
    image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the
    function. So, before calling #cvt_color, you need first to scale the image down:

    .. code-block:: c++

            img *= 1./255;
            cvt_color(img, img, kColorBGR2Luv);
    If you use #cvt_color with 8-bit images, the conversion will have some information lost. For many
    applications, this will not be noticeable but it is recommended to use 32-bit images in applications
    that need the full range of colors or that convert an image before an operation and then convert
    back.

    If conversion adds the alpha channel, its value will set to the maximum of corresponding channel
    range: 255 for kDepth_U8, 65535 for kDepth_U16, 1 for kDepth_F32.

    :type src: :py:class:`Mat`
    :param src: input image: 8-bit unsigned, 16-bit unsigned ( kDepth_U16... ), or single-precision
        floating-point.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and depth as src.
    :type code: int
    :param code: color space conversion code (see #ColorConversionCodes).
    :type dstcn: int, optional
    :param dstcn: number of channels in the destination image; if the parameter is 0, the number of the
        channels is derived automatically from src and code.
    :type coeffs: :py:class:`Scalar`, optional
    :param coeffs:  user-defined vector of coefficients for converting color images to grayscale images.
        use only in kColorBGR2Gray,kColorRGB2Gray,kColorBGRA2Gray,kColorRGBA2Gray.
        0 <= coefficients <= 1. the sum of the coefficients should be less than or equal to 1.
        when the coeffs are {0,0,0,0}, the default value {0.114f, 0.587f, 0.299f} will be used.
        The following equation is used to convert an RGB image to gray scale:
        Y = coeffs[0] * B + coeffs[1] * G + coeffs[2] * R;
    """
    return _pyaqcv.cvt_color(*args)

def corner_sub_pix(*args):
    r"""
     Refines the corner locations.

    The function iterates to find the sub-pixel accurate location of corners or radial saddle
    points as described in 'forstner1987fast'.

    Sub-pixel accurate corner locator is based on the observation that every vector from the center  :math:`q`
    to a point  :math:`p`  located within a neighborhood of  :math:`q`  is orthogonal to the image gradient at  :math:`p`
    subject to image and measurement noise. Consider the expression:

     .. math::

         \epsilon _i = {DI_{p_i}}^T  \cdot (q - p_i)

    where  :math:`{DI_{p_i}}`  is an image gradient at one of the points  :math:`p_i`  in a neighborhood of  :math:`q`  . The
    value of  :math:`q`  is to be found so that  :math:`\epsilon_i`  is minimized. A system of equations may be set up
    with  :math:`\epsilon_i`  set to zero:

     .. math::

         \sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T) \cdot q -  \sum _i(DI_{p_i}  \cdot {DI_{p_i}}^T  \cdot p_i)

    where the gradients are summed within a neighborhood ("search window") of  :math:`q`  . Calling the first
    gradient term  :math:`G`  and the second gradient term  :math:`b`  gives:

     .. math::

         q = G^{-1}  \cdot b

    The algorithm sets the center of the neighborhood window at this new center  :math:`q`  and then iterates
    until the center stays within a set threshold.

    :type image: :py:class:`Mat`
    :param image: Input single-channel, 8-bit or float image.
    :type corners: :py:class:`_InputOutputArray`
    :param corners: Initial coordinates of the input corners and refined coordinates provided for
        output.
    :type win_size: :py:class:`Size`
    :param win_size: Half of the side length of the search window. For example, if win_size=Size(5,5) ,
        then a  :math:`(5*2+1) \times (5*2+1) = 11 \times 11`  search window is used.
    :type zero_zone: :py:class:`Size`
    :param zero_zone: Half of the size of the dead region in the middle of the search zone over which
        the summation in the formula below is not done. It is used sometimes to avoid possible
        singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such
        a size.
    :type criteria: :py:class:`TermCriteria`
    :param criteria: Criteria for termination of the iterative process of corner refinement. That is,
        the process of corner position refinement stops either after criteria.max_count iterations or when
        the corner position moves by less than criteria.epsilon on some iteration.
    """
    return _pyaqcv.corner_sub_pix(*args)

def get_rect_sub_pix(image, patch_size, center, patch, patch_type=-1):
    r"""
     Retrieves a pixel rectangle from an image with sub-pixel accuracy.

    The function get_rect_sub_pix extracts pixels from src:

     .. math::

         patch(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5)

    where the values of the pixels at non-integer coordinates are retrieved using bilinear
    interpolation. Every channel of multi-channel images is processed independently. Also
    the image should be a single channel or three channel image. While the center of the
    rectangle must be inside the image, parts of the rectangle may be outside.

    :type image: :py:class:`Mat`
    :param image: Source image.
    :type patch_size: :py:class:`Size`
    :param patch_size: Size of the extracted patch.
    :type center: :py:class:`Point2f`
    :param center: Floating point coordinates of the center of the extracted rectangle within the
        source image. The center must be inside the image.
    :type patch: :py:class:`Mat`
    :param patch: Extracted patch that has the size patch_size and the same number of channels as src.
    :type patch_type: int, optional
    :param patch_type: Depth of the extracted pixels. By default, they have the same depth as src.
    """
    return _pyaqcv.get_rect_sub_pix(image, patch_size, center, patch, patch_type)

def integral(*args):
    r"""
     Calculates the integral of an image.

    The function calculates one or more integral images for the source image as follows:

     .. math::

         \texttt{sum} (X,Y) =  \sum _{x<X,y<Y}  \texttt{image} (x,y)

     .. math::

         \texttt{sqsum} (X,Y) =  \sum _{x<X,y<Y}  \texttt{image} (x,y)^2

     .. math::

         \texttt{tilted} (X,Y) =  \sum _{y<Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y)

    Using these integral images, you can calculate sum, mean, and standard deviation over a specific
    up-right or rotated rectangular region of the image in a constant time, for example:

     .. math::

         \sum _{x_1 \leq x < x_2,  \, y_1  \leq y < y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1)

    It makes possible to do a fast blurring or fast block correlation with a variable window size, for
    example. In case of multi-channel images, sums for each channel are accumulated independently.

    :type src: :py:class:`Mat`
    :param src: input image as  :math:`W \times H` , 8-bit or floating-point (32f or 64f).
    :type sum: :py:class:`Mat`
    :param sum: integral image as  :math:`(W+1)\times (H+1)`  , 32-bit integer or floating-point (32f or 64f).
    :type sqsum: :py:class:`_OutputArray`
    :param sqsum: integral image for squared pixel values; it is  :math:`(W+1)\times (H+1)` , 32f or 64f array.
    :type tilted: :py:class:`_OutputArray`
    :param tilted: integral for the image rotated by 45 degrees; it is  :math:`(W+1)\times (H+1)`  array with
        the same data type as sum.
    :type sdepth: int, optional
    :param sdepth: desired depth of the integral and the tilted integral images, AQ_32S, AQ_32F, or
        AQ_64F.
    :type sqdepth: int, optional
    :param sqdepth: desired depth of the integral image of squared pixel values, AQ_32F or AQ_64F.
    """
    return _pyaqcv.integral(*args)
kFloodfillFixedRange = _pyaqcv.kFloodfillFixedRange
r"""
    If set, the difference between the current pixel and seed pixel is considered. Otherwise,
       the difference between neighbor pixels is considered (that is, the range is floating).
    """
kFloodfillMaskOnly = _pyaqcv.kFloodfillMaskOnly
r"""
    If set, the function does not change the image ( new_val is ignored), and only fills the
       mask with the value specified in bits 8-16 of flags as described above. This option only make
       sense in function variants that have the mask parameter.
    """

def flood_fill(*args):
    r"""
     Fills a connected component with the given color.

    The function aqcv::flood_fill fills a connected component starting from the seed point with the specified
    color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The
    pixel at  :math:`(x,y)`  is considered to belong to the repainted domain if:

    - in case of a grayscale image and floating range

     .. math::

         \texttt{src} (x',y')- \texttt{lo_diff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{up_diff}

    - in case of a grayscale image and fixed range

     .. math::

         \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)- \texttt{lo_diff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)+ \texttt{up_diff}

    - in case of a color image and floating range

     .. math::

         \texttt{src} (x',y')_r- \texttt{lo_diff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{up_diff} _r,

     .. math::

         \texttt{src} (x',y')_g- \texttt{lo_diff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{up_diff} _g
    and

     .. math::

         \texttt{src} (x',y')_b- \texttt{lo_diff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{up_diff} _b

    - in case of a color image and fixed range

     .. math::

         \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)_r- \texttt{lo_diff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)_r+ \texttt{up_diff} _r,

     .. math::

         \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)_g- \texttt{lo_diff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)_g+ \texttt{up_diff} _g
    and

     .. math::

         \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)_b- \texttt{lo_diff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seed_point} .x, \texttt{seed_point} .y)_b+ \texttt{up_diff} _b

    where  :math:`src(x',y')`  is the value of one of pixel neighbors that is already known to belong to the
    component. That is, to be added to the connected component, a color/brightness of the pixel should
    be close enough to:
    - Color/brightness of one of its neighbors that already belong to the connected component in case
    of a floating range.
    - Color/brightness of the seed point in case of a fixed range.

    Use these functions to either mark a connected component with the specified color in-place, or build
    a mask and then extract the contour, or copy the region to another image, and so on.

    :type image: :py:class:`Mat`
    :param image: Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the
        function unless the #kFloodfillMaskOnly flag is set in the second variant of the function. See
        the details below.
    :type mask: :py:class:`Mat`
    :param mask: Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels
        taller than image. Since this is both an input and output parameter, you must take responsibility
        of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example,
        an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the
        mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags
        as described below. Additionally, the function fills the border of the mask with ones to simplify
        internal processing. It is therefore possible to use the same mask in multiple calls to the function
        to make sure the filled areas do not overlap.
    :type seed_point: :py:class:`Point`
    :param seed_point: Starting point.
    :type new_val: :py:class:`Scalar`
    :param new_val: New value of the repainted domain pixels.
    :type lo_diff: :py:class:`Scalar`, optional
    :param lo_diff: Maximal lower brightness/color difference between the currently observed pixel and
        one of its neighbors belonging to the component, or a seed pixel being added to the component.
    :type up_diff: :py:class:`Scalar`, optional
    :param up_diff: Maximal upper brightness/color difference between the currently observed pixel and
        one of its neighbors belonging to the component, or a seed pixel being added to the component.
    :type rect: :py:class:`Rect`, optional
    :param rect: Optional output parameter set by the function to the minimum bounding rectangle of the
        repainted domain.
    :type flags: int, optional
    :param flags: Operation flags. The first 8 bits contain a connectivity value. The default value of
        4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A
        connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner)
        will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill
        the mask (the default value is 1). For example, 4 | ( 255 << 8 ) will consider 4 nearest
        neighbours and fill the mask with a value of 255. The following additional options occupy higher
        bits and therefore may be further combined with the connectivity and mask fill values using
        bit-wise or (|), see #FloodFillFlags.
    :rtype: int
    :return: area of minimum bounding rectangle.

    Notes: Since the mask is larger than the filled image, a pixel  :math:`(x, y)`  in image corresponds to the
    pixel  :math:`(x+1, y+1)`  in the mask.
    """
    return _pyaqcv.flood_fill(*args)

def demosaicing(src, dst, code, dst_cn=0):
    r"""
     main function for all demosaicing processes

    :type src: :py:class:`Mat`
    :param src: input image: 8-bit unsigned or 16-bit unsigned.
    :type dst: :py:class:`Mat`
    :param dst: output image of the same size and depth as src.
    :type code: int
    :param code: Color space conversion code (see the description below).
    :type dst_cn: int, optional
    :param dst_cn: number of channels in the destination image; if the parameter is 0, the number of the
        channels is derived automatically from src and code.

    The function can do the following transformations:

    -   Demosaicing using bilinear interpolation

        #kColorBayerRG2BGR , #kColorBayerGR2BGR , #kColorBayerBG2BGR , #kColorBayerGB2BGR

        #kColorBayerRG2Gray , #kColorBayerGR2Gray , #kColorBayerBG2Gray , #kColorBayerGB2Gray

    -   Demosaicing using Variable Number of Gradients.

        #kColorBayerRG2BGR_VNG , #kColorBayerGR2BGR_VNG , #kColorBayerBG2BGR_VNG , #kColorBayerGB2BGR_VNG

    -   Edge-Aware Demosaicing.

        #kColorBayerRG2BGR_EA , #kColorBayerGR2BGR_EA , #kColorBayerBG2BGR_EA , #kColorBayerGB2BGR_EA

    -   Demosaicing with alpha channel

        #kColorBayerRG2BGRA , #kColorBayerGR2BGRA , #kColorBayerBG2BGRA , #kColorBayerGB2BGRA

    See also: cvt_color
    """
    return _pyaqcv.demosaicing(src, dst, code, dst_cn)
kTMSqDiff = _pyaqcv.kTMSqDiff
r"""
    .. math::

        R(x,y)= \sum _{x',y'} (T(x',y')-I(x+x',y+y'))^2
                                 with mask:

                                  .. math::

                                      R(x,y)= \sum _{x',y'} \left( (T(x',y')-I(x+x',y+y')) \cdot
                                                                        M(x',y') \right)^2
    """
kTMSqDiffNormed = _pyaqcv.kTMSqDiffNormed
r"""
    .. math::

        R(x,y)= \frac{\sum_{x',y'} (T(x',y')-I(x+x',y+y'))^2}{\sqrt{\sum_{
                                          x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}
                                 with mask:

                                  .. math::

                                      R(x,y)= \frac{\sum _{x',y'} \left( (T(x',y')-I(x+x',y+y')) \cdot
                                                                        M(x',y') \right)^2}{\sqrt{\sum_{x',y'} \left( T(x',y') \cdot
                                                                        M(x',y') \right)^2 \cdot \sum_{x',y'} \left( I(x+x',y+y') \cdot
                                                                        M(x',y') \right)^2}}
    """
kTMCCorr = _pyaqcv.kTMCCorr
r"""
    .. math::

        R(x,y)= \sum _{x',y'} (T(x',y') \cdot I(x+x',y+y'))
                                 with mask:

                                  .. math::

                                      R(x,y)= \sum _{x',y'} (T(x',y') \cdot I(x+x',y+y') \cdot M(x',y')
                                                                        ^2)
    """
kTMCCorrNormed = _pyaqcv.kTMCCorrNormed
r"""
    .. math::

        R(x,y)= \frac{\sum_{x',y'} (T(x',y') \cdot I(x+x',y+y'))}{\sqrt{
                                          \sum_{x',y'}T(x',y')^2 \cdot \sum_{x',y'} I(x+x',y+y')^2}}
                                 with mask:

                                  .. math::

                                      R(x,y)= \frac{\sum_{x',y'} (T(x',y') \cdot I(x+x',y+y') \cdot
                                                                        M(x',y')^2)}{\sqrt{\sum_{x',y'} \left( T(x',y') \cdot M(x',y')
                                                                        \right)^2 \cdot \sum_{x',y'} \left( I(x+x',y+y') \cdot M(x',y')
                                                                        \right)^2}}
    """
kTMCCoeff = _pyaqcv.kTMCCoeff
r"""
    .. math::

        R(x,y)= \sum _{x',y'} (T'(x',y') \cdot I'(x+x',y+y'))
                                 where

                                  .. math::

                                      \begin{array}{l} T'(x',y')=T(x',y') - 1/(w \cdot h) \cdot \sum _{
                                                                        x'',y''} T(x'',y'') \\ I'(x+x',y+y')=I(x+x',y+y') - 1/(w \cdot h)
                                                                        \cdot \sum _{x'',y''} I(x+x'',y+y'') \end{array}
                                 with mask:

                                  .. math::

                                      \begin{array}{l} T'(x',y')=M(x',y') \cdot \left( T(x',y') -
                                                                        \frac{1}{\sum _{x'',y''} M(x'',y'')} \cdot \sum _{x'',y''}
                                                                        (T(x'',y'') \cdot M(x'',y'')) \right) \\ I'(x+x',y+y')=M(x',y')
                                                                        \cdot \left( I(x+x',y+y') - \frac{1}{\sum _{x'',y''} M(x'',y'')}
                                                                        \cdot \sum _{x'',y''} (I(x+x'',y+y'') \cdot M(x'',y'')) \right)
                                                                        \end{array}
    """
kTMCCoeffNormed = _pyaqcv.kTMCCoeffNormed
r"""
    .. math::

        R(x,y)= \frac{ \sum_{x',y'} (T'(x',y') \cdot I'(x+x',y+y')) }{
                                          \sqrt{\sum_{x',y'}T'(x',y')^2 \cdot \sum_{x',y'} I'(x+x',y+y')^2}
                                          }
    """

def match_template(*args):
    r"""
     Compares a template against overlapped image regions.

    The function slides through image , compares the overlapped patches of size  :math:`w \times h`  against
    templ using the specified method and stores the comparison results in result . #TemplateMatchModes
    describes the formulae for the available comparison methods (  :math:`I`  denotes image,  :math:`T`
    template,  :math:`R`  result,  :math:`M`  the optional mask ). The summation is done over template and/or
    the image patch:  :math:`x' = 0...w-1, y' = 0...h-1`

    After the function finishes the comparison, the best matches can be found as global minimums (when
    #kTMSqDiff was used) or maximums (when #kTMCCorr or #kTMCCoeff was used) using the
    #min_max_loc function. In case of a color image, template summation in the numerator and each sum in
    the denominator is done over all of the channels and separate mean values are used for each channel.
    That is, the function can take a color template and a color image. The result will still be a
    single-channel image, which is easier to analyze.

    :type image: :py:class:`Mat`
    :param image: Image where the search is running. It must be 8-bit or 32-bit floating-point.
    :type templ: :py:class:`Mat`
    :param templ: Searched template. It must be not greater than the source image and have the same
        data type.
    :type result: :py:class:`Mat`
    :param result: Map of comparison results. It must be single-channel 32-bit floating-point. If image
        is  :math:`W \times H`  and templ is  :math:`w \times h`  , then result is  :math:`(W-w+1) \times (H-h+1)`  .
    :type method: int
    :param method: Parameter specifying the comparison method, see #TemplateMatchModes
    :type mask: :py:class:`Mat`, optional
    :param mask: Optional mask. It must have the same size as templ. It must either have the same number
                    of channels as template or only one channel, which is then used for all template and
                    image channels. If the data type is AQ_8U, the mask is interpreted as a binary mask,
                    meaning only elements where mask is nonzero are used and are kept unchanged independent
                    of the actual mask value (weight equals 1). For data tpye AQ_32F, the mask values are
                    used as weights. The exact formulas are documented in #TemplateMatchModes.
    """
    return _pyaqcv.match_template(*args)
kCCStatLeft = _pyaqcv.kCCStatLeft
r"""The leftmost (x) coordinate which is the inclusive start of the bounding box in the horizontal direction."""
kCCStatTop = _pyaqcv.kCCStatTop
r"""The topmost (y) coordinate which is the inclusive start of the bounding box in the vertical direction."""
kCCStatWidth = _pyaqcv.kCCStatWidth
r"""The horizontal size of the bounding box"""
kCCStatHeight = _pyaqcv.kCCStatHeight
r"""The vertical size of the bounding box"""
kCCStatAera = _pyaqcv.kCCStatAera
r"""The total area (in pixels) of the connected component"""
kCCStatMax = _pyaqcv.kCCStatMax
r"""Max enumeration value. Used internally only for memory allocation"""
kCCLDefault = _pyaqcv.kCCLDefault
r"""BBDT 'Grana2010' algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity. The parallel implementation described in 'Bolelli2017' is available for both BBDT and SAUF."""
kCCLWu = _pyaqcv.kCCLWu
r"""SAUF 'Wu2009' algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity. The parallel implementation described in 'Bolelli2017' is available for SAUF."""
kCCLGrana = _pyaqcv.kCCLGrana
r"""BBDT 'Grana2010' algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity. The parallel implementation described in 'Bolelli2017' is available for both BBDT and SAUF."""
kCCLBolelli = _pyaqcv.kCCLBolelli
r"""Spaghetti 'Bolelli2019' algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity. No parallel implementation supported."""
kCCLSauf = _pyaqcv.kCCLSauf
r"""Same as kCCLWu. It is preferable to use the flag with the name of the algorithm (kCCLSauf) rather than the one with the name of the first author. Support parallel."""
kCCLBbdt = _pyaqcv.kCCLBbdt
r"""Same as kCCLGrana. It is preferable to use the flag with the name of the algorithm (kCCLBbdt) rather than the one with the name of the first author. Support parallel."""
kCCLSpaghetti = _pyaqcv.kCCLSpaghetti
r"""Same as kCCLBolelli. It is preferable to use the flag with the name of the algorithm (kCCLSpaghetti) rather than the one with the name of the first author. No parallel implementation supported."""

def connected_components(*args):
    r"""
     computes the connected components labeled image of boolean image

    image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
    represents the background label. ltype specifies the output label image type, an important
    consideration based on the total number of labels or alternatively the total number of pixels in
    the source image. ccltype specifies the connected components labeling algorithm to use, currently
    Grana (BBDT) and Wu's (SAUF) 'Wu2009' algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes
    for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
    This function uses parallel version of both Grana and Wu's algorithms if at least one allowed
    parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.
    and ltype is AQ_32S

    :param image: the 8-bit single-channel image to be labeled
    :type labels: :py:class:`Mat`
    :param labels: destination labeled image
    :type connectivity: int
    :param connectivity: 8 or 4 for 8-way or 4-way connectivity respectively
    :type ltype: int
    :param ltype: output image label type. Currently AQ_32S and AQ_16U are supported.
    :type ccltype: int
    :param ccltype: connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes).
    :rtype: int
    :return: num of connected components.
    """
    return _pyaqcv.connected_components(*args)

def connected_components_with_stats(*args):
    r"""
     computes the connected components labeled image of boolean image and also produces a statistics output for each label

    image with 4 or 8 way connectivity - returns N, the total number of labels [0, N-1] where 0
    represents the background label. ltype specifies the output label image type, an important
    consideration based on the total number of labels or alternatively the total number of pixels in
    the source image. ccltype specifies the connected components labeling algorithm to use, currently
    Grana's (BBDT) and Wu's (SAUF) 'Wu2009' algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes
    for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not.
    This function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed
    parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.

    :param image: the 8-bit single-channel image to be labeled
    :type labels: :py:class:`Mat`
    :param labels: destination labeled image
    :type stats: :py:class:`_OutputArray`
    :param stats: statistics output for each label, including the background label.
        Statistics are accessed via stats(label, COLUMN) where COLUMN is one of
        #ConnectedComponentsTypes, selecting the statistic. The data type is AQ_32S.
    :type centroids: :py:class:`_OutputArray`
    :param centroids: centroid output for each label, including the background label. Centroids are
        accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type AQ_64F.
    :type connectivity: int
    :param connectivity: 8 or 4 for 8-way or 4-way connectivity respectively
    :type ltype: int
    :param ltype: output image label type. Currently AQ_32S and AQ_16U are supported.
    :type ccltype: int
    :param ccltype: connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes).
    """
    return _pyaqcv.connected_components_with_stats(*args)
kRetrievalExternal = _pyaqcv.kRetrievalExternal
r"""
    retrieves only the extreme outer contours. It sets `hierarchy[i][2]=hierarchy[i][3]=-1` for
       all the contours.
    """
kRetrievalList = _pyaqcv.kRetrievalList
r"""retrieves all of the contours without establishing any hierarchical relationships."""
kRetrievalConnectedComponent = _pyaqcv.kRetrievalConnectedComponent
r"""
    retrieves all of the contours and organizes them into a two-level hierarchy. At the top
       level, there are external boundaries of the components. At the second level, there are
       boundaries of the holes. If there is another contour inside a hole of a connected component, it
       is still put at the top level.
    """
kRetrievalTree = _pyaqcv.kRetrievalTree
r"""retrieves all of the contours and reconstructs a full hierarchy of nested contours."""
kRetrievalFloodfill = _pyaqcv.kRetrievalFloodfill

kChainApproxNone = _pyaqcv.kChainApproxNone
r"""
    stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and
       (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,
       max(abs(x1-x2),abs(y2-y1))==1.
    """
kChainApproxSimple = _pyaqcv.kChainApproxSimple
r"""
    compresses horizontal, vertical, and diagonal segments and leaves only their end points.
       For example, an up-right rectangular contour is encoded with 4 points.
    """
kChainApproxTC89L1 = _pyaqcv.kChainApproxTC89L1
r"""applies one of the flavors of the Teh-Chin chain approximation algorithm 'TehChin89'"""
kChainApproxTC89Kcos = _pyaqcv.kChainApproxTC89Kcos
r"""applies one of the flavors of the Teh-Chin chain approximation algorithm 'TehChin89'"""

def find_contours(*args):
    r"""
     Finds contours in a binary image.

    The function retrieves contours from the binary image using the algorithm 'Suzuki85' . The contours
    are a useful tool for shape analysis and object detection and recognition.

    :type image: :py:class:`Mat`
    :param image: Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero
        pixels remain 0's, so the image is treated as binary . You can use #compare, #in_range, #threshold ,
        #adaptive_threshold, #canny, and others to create a binary image out of a grayscale or color one.
        If mode equals to #kRetrievalConnectedComponent or #kRetrievalFloodfill, the input can also be a 32-bit
        integer image of labels (AQ_32SC1).
    :type contours: :py:class:`_OutputArray`
    :param contours: Detected contours. Each contour is stored as a vector of points (e.g.
        std::vector<std::vector<Point>>).
    :type hierarchy: :py:class:`_OutputArray`
    :param hierarchy: Optional output vector (e.g. std::vector<aqcv::Vec4i>), containing information about
        the image topology. It has as many elements as the number of contours. For each i-th contour contours[i],
        the elements hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based
        indices in contours of the next and previous contours at the same hierarchical level, the first child
        contour and the parent contour, respectively. If for the contour i there are no next, previous,
        parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.
    :type mode: int
    :param mode: Contour retrieval mode, see #RetrievalModes
    :type method: int
    :param method: Contour approximation method, see #ContourApproximationModes
    :type offset: :py:class:`Point`, optional
    :param offset: Optional offset by which every contour point is shifted. This is useful if the
        contours are extracted from the image ROI and then they should be analyzed in the whole image
        context.
    """
    return _pyaqcv.find_contours(*args)

def approx_poly_dp(*args):
    r"""
     Approximates a polygonal curve(s) with the specified precision.

    The function aqcv::approx_poly_dp approximates a curve or a polygon with another curve/polygon with less
    vertices so that the distance between them is less or equal to the specified precision. It uses the
    Douglas-Peucker algorithm <http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm>

    :type curve: :py:class:`_InputArray`
    :param curve: Input vector of a 2D point stored in std::vector or Mat
    :type approx_curve: :py:class:`_OutputArray`
    :param approx_curve: Result of the approximation. The type should match the type of the input curve.
    :type epsilon: float
    :param epsilon: Parameter specifying the approximation accuracy. This is the maximum distance
        between the original curve and its approximation.
    :type closed: boolean
    :param closed: If true, the approximated curve is closed (its first and last vertices are
        connected). Otherwise, it is not closed.
    """
    return _pyaqcv.approx_poly_dp(*args)

def arc_length(*args):
    r"""
     Calculates a contour perimeter or a curve length.

    The function computes a curve length or a closed contour perimeter.

    :type curve: :py:class:`_InputArray`
    :param curve: Input vector of 2D points, stored in std::vector or Mat.
    :type closed: boolean
    :param closed: Flag indicating whether the curve is closed or not.
    """
    return _pyaqcv.arc_length(*args)

def bounding_rect(array):
    r"""
     Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.

    The function calculates and returns the minimal up-right bounding rectangle for the specified point set or
    non-zero pixels of gray-scale image.

    :type array: :py:class:`_InputArray`
    :param array: Input gray-scale image or 2D point set, stored in std::vector or Mat.

    for visionflow::geometry types,please using visionflow::geometry::envelope function
    """
    return _pyaqcv.bounding_rect(array)

def contour_area(contour, oriented=False):
    r"""
     Calculates a contour area.

    The function computes a contour area. Similarly to moments , the area is computed using the Green
    formula. Thus, the returned area and the number of non-zero pixels. Also, the function will most
    certainly give a wrong results for contours with self-intersections.

    :type contour: :py:class:`_InputArray`
    :param contour: Input vector of 2D points (contour vertices), stored in std::vector or Mat.
    :type oriented: boolean, optional
    :param oriented: Oriented area flag. If it is true, the function returns a signed area value,
        depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can
        determine orientation of a contour by taking the sign of an area. By default, the parameter is
        false, which means that the absolute value is returned.
        for visionflow::geometry types, please use visionflow::geometry::area function
    """
    return _pyaqcv.contour_area(contour, oriented)

def min_enclosing_circle(*args):
    r"""
     Finds a circle of the minimum area enclosing a 2D point set.

    The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.

    :type points: :py:class:`_InputArray`
    :param points: Input vector of 2D points, stored in std::vector<> or Mat(AQ_32S or AQ_32F)
    :type center: :py:class:`Point2f`
    :param center: Output center of the circle.
    :type radius: float
    :param radius: Output radius of the circle.
    :rtype: boolean
    :return: true if ok.
    """
    return _pyaqcv.min_enclosing_circle(*args)

def max_inscribed_circle(*args):
    r"""
     Finds maximum inscribed circle of a polygon.

    :type points: :py:class:`_InputArray`
    :param points: Input vector of polygon vertexes, stored in std::vector<> or Mat(AQ_32S or AQ_32F)
    :type center: :py:class:`Point2f`
    :param center: Output center of the circle.
    :type radius: float
    :param radius: Output radius of the circle.
    :rtype: boolean
    :return: true if ok.
    """
    return _pyaqcv.max_inscribed_circle(*args)

def circularity(region):
    r"""
     estimate similarity of a region represented by ring or polygon to a circle.Notes: geom is the pixel edge
    boundary(got from find_contour or blob).holes in Polygon have effect.

     .. math::

         circularity = min(1, \frac{area}{max^2*\pi})
    where area means area of the geometry, and max means the maximum distance from the center to all vertexes
    :type region: :py:class:`IGeometry`
    :param region: supported shapes: Ring2f, Ring2i, Polygon2f, Polygon2i
    :rtype: float
    :return: the similarity will be 0~1, when geom type is accept; -1 will be returned for other types or some error happened.
    """
    return _pyaqcv.circularity(region)

def circularity_geom(geom):
    r"""
     estimate similarity of a ring or polygon to a circle.holes in Polygon have effect.

     .. math::

         circularity = min(1, \frac{area}{max^2*\pi})
    where area means area of the geometry, and max means the maximum distance from the center to all vertexes
    :type geom: :py:class:`IGeometry`
    :param geom: supported shapes: Ring2f, Ring2i, Polygon2f, Polygon2i
    :rtype: float
    :return: the similarity will be 0~1, when geom type is accept; -1 will be returned for other types or some error happened.
    """
    return _pyaqcv.circularity_geom(geom)

def roundness(region, distance, sigma, round, sides):
    r"""
     estimate roundness of a region represented by ring or polygon. roundness indicates the distance between the contour and the center of the area.

     .. math::

         Distance = \frac{1}{N_dense}\Sigma\|p - p_i\| \\
             Sigma^2 = \frac{1}{N_dense}\Sigma(\|p-p_i\| - Distance)^2 \\
             Roundness = 1 - \frac{Sigma}{Distance} \\
             Sides = 1.4111(\frac{Distance}{Sigma})^{0.4724}
    where  :math:`N_dense`  means dense count of given geometry, and  :math:`p`  is the center the area, :math:`p_i`  indicates contour vertexes
    Notes: when there are holes in polygon, the result will be a littel different to halcon roundness(halcon will ignore the same point in inner and outer)
    :type region: :py:class:`IGeometry`
    :param region: supported shapes: Ring2f, Ring2i, Polygon2f, Polygon2i
    :type distance: float
    :param distance: mean distance from the center
    :type sigma: float
    :param sigma: standard deviation of distance
    :type round: float
    :param round: roundness factor of given shape
    :type sides: float
    :param sides: the number of polygon pieces if a regular polygon is concerned
    :rtype: boolean
    :return: true if ok, false for unsupported geometries.
    """
    return _pyaqcv.roundness(region, distance, sigma, round, sides)

def convexity(region):
    r"""
     estimate convexity,  :math:`C = \frac{F_o}{F_c}` ,where  :math:`F_o`  means area of given geom, :math:`F_c`  indicates geom's convex ring's area
    :type region: :py:class:`IGeometry`
    :param region: supported shapes: Ring2f, Ring2i, Polygon2f, Polygon2i
    :rtype: float
    :return: the convexity.-1 will be returned when some error happened(e.g. empty ring or polygon)
    """
    return _pyaqcv.convexity(region)

def compactness(region):
    r"""
     estimate compactness,  :math:`C = max(1, \frac{L^2}{4F\pi}` ,where  :math:`L`  is the length of boundary, :math:`F`  indicates geom's area
    :type region: :py:class:`IGeometry`
    :param region: supported shapes: Ring2f, Ring2i, Polygon2f, Polygon2i
    :rtype: float
    :return: the compactness.-1 will be return when there are some error.
    """
    return _pyaqcv.compactness(region)

def orientation(region, res):
    r"""
     estimate orientation
    :type region: :py:class:`IGeometry`
    :param region: region representated by Ring2f, Ring2i, Polygon2f, Polygon2i
    :type res: :py:class:`Radian`
    :param res: orientation of given region.  :math:`[-\pi,\pi]` ,If, in the rotated coordinate system, the column coordinate of this point
        (on the contour with maximal distance to the center of gravity) is less than the column coordinate of the center of gravity,
        the value of  :math:`\pi`  or  :math:`-\pi`  is added to the angle.
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.orientation(region, res)

def rectangularity(region):
    r"""
     estimate rectangularity of a region
    :type region: :py:class:`IGeometry`
    :param region: region representated by Ring2f, Ring2i, Polygon2f, Polygon2i
    :rtype: float
    :return: return value > 0 represent rectangularity of the region, otherwise it not support the input type.
    Notes: For input regions which orientation cannot be computed by using second order moments (as it is the case for square regions,
    for example), the returned rectangularity is underestimated depending on the orientation of the input region.
    """
    return _pyaqcv.rectangularity(region)

def points_convex_hull(points, hull, clockwise=False, return_points=True):
    r"""
     Finds the convex hull of a point set.
    The function aqcv::points_convex_hull finds the convex hull of a 2D point set using the Sklansky's algorithm 'Sklansky82'
    that has *O(N logN)* complexity in the current implementation.
    :type points: :py:class:`_InputArray`
    :param points: Input 2D point set, stored in std::vector or Mat.
    :type hull: :py:class:`_OutputArray`
    :param hull: Output convex hull. It is either an integer vector of indices or vector of points. In
        the first case, the hull elements are 0-based indices of the convex hull points in the original
        array (since the set of convex hull points is a subset of the original point set). In the second
        case, hull elements are the convex hull points themselves.
    :type clockwise: boolean, optional
    :param clockwise: Orientation flag. If it is true, the output convex hull is oriented clockwise.
        Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing
        to the right, and its Y axis pointing upwards.
    :type return_points: boolean, optional
    :param return_points: Operation flag. In case of a matrix, when the flag is true, the function
        returns convex hull points. Otherwise, it returns indices of the convex hull points. When the
        output array is std::vector, the flag is ignored, and the output depends on the type of the
        vector: std::vector<int> implies return_points=false, std::vector<Point> implies
        return_points=true.

    Notes: `points` and `hull` should be different arrays, inplace processing isn't supported.
    for visionflow::geometry types, please use visionflow::geometry::convex_hull function
    """
    return _pyaqcv.points_convex_hull(points, hull, clockwise, return_points)

def point_polygon_test(contour, pt, measure_dist):
    r"""
     Performs a point-in-contour test.

    The function determines whether the point is inside a contour, outside, or lies on an edge (or
    coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge)
    value, correspondingly. When measure_dist=false , the return value is +1, -1, and 0, respectively.
    Otherwise, the return value is a signed distance between the point and the nearest contour edge.

    :type contour: :py:class:`_InputArray`
    :param contour: Input contour.
    :type pt: :py:class:`Point2f`
    :param pt: Point tested against the contour.
    :type measure_dist: boolean
    :param measure_dist: If true, the function estimates the signed distance from the point to the
        nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.
        for visionflow::geometry types, please use visionflow::geometry::covered_by function
    """
    return _pyaqcv.point_polygon_test(contour, pt, measure_dist)

def moments(*args):
    r"""
     Calculates all of the moments up to the third order of a polygon or rasterized shape.

    The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The
    results are returned in the structure aqcv::Moments.

    :type array: :py:class:`_InputArray`
    :param array: Raster image (single-channel, 8-bit or floating-point 2D array) or an array (
         :math:`1 \times N`  or  :math:`N \times 1`  ) of 2D points (Point or Point2f ).
    :type binary_image: boolean, optional
    :param binary_image: If it is true, all non-zero image pixels are treated as 1's. The parameter is
        used for images only.
    :rtype: :py:class:`Moments`
    :return: moments.

    See also: contour_area, arc_length
    """
    return _pyaqcv.moments(*args)
kLeastSquare = _pyaqcv.kLeastSquare
r"""Simle least square, no weight"""
kHuber = _pyaqcv.kHuber
r"""Huber weight"""
kTukey = _pyaqcv.kTukey
r"""Tukey weight"""

def fit_line(*args):
    r"""
     Fit straight line from multiple points

    :type pts: :py:class:`MultiPoint2f`
    :param pts: input points
    :type res: :py:class:`Line2f`
    :param res: fitted line result
    :type fit_mode: int, optional
    :param fit_mode: fit algorithm, kHuber and kTukey are robust fit algorithms that iteratively fits the line to reduce
        the impact of outliers,but less efficiency
    :type clipping_factor: float, optional
    :param clipping_factor: Clipping factor for the elimination of outliers (typical: 1.0 for kHuber and 2.0 for kTukey).
    :rtype: boolean
    :return: true if fit process succeed
    """
    return _pyaqcv.fit_line(*args)

def fit_circle(*args):
    r"""
     Fit circle from multiple points

    :type pts: :py:class:`MultiPoint2f`
    :param pts: input points
    :type res: :py:class:`Circle2f`
    :param res: fitted circle result
    :type fit_mode: int, optional
    :param fit_mode: fit algorithm, kHuber and kTukey are robust fit algorithms that iteratively fits the circle to reduce
        the impact of outliers
    :type clipping_factor: float, optional
    :param clipping_factor: Clipping factor for the elimination of outliers (typical: 1.0 for kHuber and 2.0 for kTukey).
    :rtype: boolean
    :return: true if fit process succeed
    """
    return _pyaqcv.fit_circle(*args)

def fit_ellipse(*args):
    r"""
     Fit ellipse from multiple points
    :type pts: :py:class:`MultiPoint2f`
    :param pts: input points
    :type res: :py:class:`Ellipse2f`
    :param res: output ellipse result
    :type fit_mode: int, optional
    :param fit_mode: fit algorithm, kHuber and kTukey are robust fit algorithms that iteratively fits the ellipse to reduce
        the impact of outliers
    :type clipping_factor: float, optional
    :param clipping_factor: Clipping factor for the elimination of outliers (typical: 1.0 for kHuber and 2.0 for kTukey).
    :param iterations: number of iterations
    :rtype: boolean
    :return: true if fit process succeed
    """
    return _pyaqcv.fit_ellipse(*args)
class LineFitModel(FitModelBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.LineFitModel_swiginit(self, _pyaqcv.new_LineFitModel())

    def get_min_sample_num(self):
        r"""
        Get the minimum samples number of build line.
        :rtype: int
        :return: value is three.
        """
        return _pyaqcv.LineFitModel_get_min_sample_num(self)

    def set_fit_mode(self, fit_mode):
        r"""
        set fit algorithm, kHuber and kTukey are robust fit algorithms
                that iteratively fits the line to reduce the impact of outliers,but less efficiency
        """
        return _pyaqcv.LineFitModel_set_fit_mode(self, fit_mode)

    def get_fit_mode(self):
        r"""get fit mode"""
        return _pyaqcv.LineFitModel_get_fit_mode(self)

    def set_clip_factor(self, factor):
        r"""
        Clipping factor
        :type factor: float
        :param factor:  used fro kHuber and kTukey for the elimination of outliers (typical: 1.0 for kHuber and 2.0 for kTukey).
        """
        return _pyaqcv.LineFitModel_set_clip_factor(self, factor)

    def get_clip_factor(self):
        r"""get clip factor"""
        return _pyaqcv.LineFitModel_get_clip_factor(self)

    def init_model(self, pts_mat, idxs):
        r"""
        Build line with two samples.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  single channel. the depth is kDepth_F64 'Mat::Depth'. the cols is 2, indicating points' x and y. the rows indicate numbers of samples.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participated to define line.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.LineFitModel_init_model(self, pts_mat, idxs)

    def fit(self, *args):
        r"""
        *Overload 1:*

        Fit line.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in fitting, defaultly all points paticipate.
        :rtype: boolean
        :return: true if successed.

        |

        *Overload 2:*

        Fit plane.
        :type pts: :py:class:`MultiPoint2f`
        :param pts:  points participate in fitting.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.LineFitModel_fit(self, *args)

    def distance(self, *args):
        r"""
        Calculate the distance between points and line
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type distance_mat: :py:class:`Mat`
        :param distance_mat:  each row indicate one distance along idxs.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in calculating distance, defaultly all points paticipate.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.LineFitModel_distance(self, *args)

    def get_result(self):
        r"""Get the line result."""
        return _pyaqcv.LineFitModel_get_result(self)

    def get_line_pt(self):
        r"""Get the line point."""
        return _pyaqcv.LineFitModel_get_line_pt(self)

    def get_line_vector(self):
        r"""Get the line direction vector."""
        return _pyaqcv.LineFitModel_get_line_vector(self)

    def get_clipped_segment(self):
        r"""Get fitted line in segment shape. The endpoints is the most width of the points' foot point to fitted line(include inners and outers)"""
        return _pyaqcv.LineFitModel_get_clipped_segment(self)
    __swig_destroy__ = _pyaqcv.delete_LineFitModel

# Register LineFitModel in _pyaqcv:
_pyaqcv.LineFitModel_swigregister(LineFitModel)
class CircleFitModel(FitModelBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CircleFitModel_swiginit(self, _pyaqcv.new_CircleFitModel())

    def get_min_sample_num(self):
        r"""
        Get the minimum samples number of build circle.
        :rtype: int
        :return: value is three.
        """
        return _pyaqcv.CircleFitModel_get_min_sample_num(self)

    def set_fit_mode(self, fit_mode):
        r"""
        set fit algorithm, kHuber and kTukey are robust fit algorithms
                that iteratively fits the line to reduce the impact of outliers,but less efficiency
        """
        return _pyaqcv.CircleFitModel_set_fit_mode(self, fit_mode)

    def get_fit_mode(self):
        r"""get fit mode"""
        return _pyaqcv.CircleFitModel_get_fit_mode(self)

    def set_clip_factor(self, factor):
        r"""
        Clipping factor
        :type factor: float
        :param factor:  used fro kHuber and kTukey for the elimination of outliers (typical: 1.0 for kHuber and 2.0 for kTukey).
        """
        return _pyaqcv.CircleFitModel_set_clip_factor(self, factor)

    def get_clip_factor(self):
        r"""get clip factor"""
        return _pyaqcv.CircleFitModel_get_clip_factor(self)

    def init_model(self, pts_mat, idxs):
        r"""
        Build circle with 3 samples.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  single channel. the depth is kDepth_F64 'Mat::Depth'. the cols is 2, indicating points' x and y. the rows indicate numbers of samples.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participated to define line.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.CircleFitModel_init_model(self, pts_mat, idxs)

    def fit(self, *args):
        r"""
        *Overload 1:*

        Fit circle.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in fitting, defaultly all points paticipate.
        :rtype: boolean
        :return: true if successed.

        |

        *Overload 2:*

        Fit circle.
        :type pts: :py:class:`MultiPoint2f`
        :param pts:  points participate in fitting.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.CircleFitModel_fit(self, *args)

    def distance(self, *args):
        r"""
        Calculate the distance between points and circle
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type distance_mat: :py:class:`Mat`
        :param distance_mat:  each row indicate one distance along idxs.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in calculating distance, defaultly all points paticipate.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.CircleFitModel_distance(self, *args)

    def get_result(self):
        r"""Get the circle result."""
        return _pyaqcv.CircleFitModel_get_result(self)
    __swig_destroy__ = _pyaqcv.delete_CircleFitModel

# Register CircleFitModel in _pyaqcv:
_pyaqcv.CircleFitModel_swigregister(CircleFitModel)
class EllipseFitModel(FitModelBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.EllipseFitModel_swiginit(self, _pyaqcv.new_EllipseFitModel())

    def get_min_sample_num(self):
        r"""
        Get the minimum samples number of build ellipse.
        :rtype: int
        :return: value is 5.
        """
        return _pyaqcv.EllipseFitModel_get_min_sample_num(self)

    def set_fit_mode(self, fit_mode):
        r"""
        set fit algorithm, kHuber and kTukey are robust fit algorithms
                that iteratively fits the line to reduce the impact of outliers,but less efficiency
        """
        return _pyaqcv.EllipseFitModel_set_fit_mode(self, fit_mode)

    def get_fit_mode(self):
        r"""get fit mode"""
        return _pyaqcv.EllipseFitModel_get_fit_mode(self)

    def set_clip_factor(self, factor):
        r"""
        Clipping factor
        :type factor: float
        :param factor:  used fro kHuber and kTukey for the elimination of outliers (typical: 1.0 for kHuber and 2.0 for kTukey).
        """
        return _pyaqcv.EllipseFitModel_set_clip_factor(self, factor)

    def get_clip_factor(self):
        r"""get clip factor"""
        return _pyaqcv.EllipseFitModel_get_clip_factor(self)

    def init_model(self, pts_mat, idxs):
        r"""
        Build ellipse with 5 samples.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  single channel. the depth is kDepth_F64 'Mat::Depth'. the cols is 2, indicating points' x and y. the rows indicate numbers of samples.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participated to define line.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.EllipseFitModel_init_model(self, pts_mat, idxs)

    def fit(self, *args):
        r"""
        *Overload 1:*

        Fit ellipse.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in fitting, defaultly all points paticipate.
        :rtype: boolean
        :return: true if successed.

        |

        *Overload 2:*

        Fit ellipse.
        :type pts: :py:class:`MultiPoint2f`
        :param pts:  points participate in fitting.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.EllipseFitModel_fit(self, *args)

    def distance(self, *args):
        r"""
        Calculate the distance between points and ellipse
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type distance_mat: :py:class:`Mat`
        :param distance_mat:  each row indicate one distance along idxs.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in calculating distance, defaultly all points paticipate.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.EllipseFitModel_distance(self, *args)

    def get_ellipse(self):
        r"""Get the ellipse result."""
        return _pyaqcv.EllipseFitModel_get_ellipse(self)

    def get_result(self):
        r"""get fitted result as visionflow::geometry::RotateRect2f"""
        return _pyaqcv.EllipseFitModel_get_result(self)
    __swig_destroy__ = _pyaqcv.delete_EllipseFitModel

# Register EllipseFitModel in _pyaqcv:
_pyaqcv.EllipseFitModel_swigregister(EllipseFitModel)
kFilled = _pyaqcv.kFilled
kLine4 = _pyaqcv.kLine4
r"""4-connected line"""
kLine8 = _pyaqcv.kLine8
r"""8-connected line"""
kLineAA = _pyaqcv.kLineAA
r"""antialiased line"""
kMarkerCircle = _pyaqcv.kMarkerCircle
r"""A circular marker shape"""
kMarkerCross = _pyaqcv.kMarkerCross
r"""A crosshair marker shape"""
kMarkerTiltedCross = _pyaqcv.kMarkerTiltedCross
r"""A 45 degree tilted crosshair marker shape"""
kMarkerStar = _pyaqcv.kMarkerStar
r"""A star marker shape, combination of cross and tilted cross"""
kMarkerDiamond = _pyaqcv.kMarkerDiamond
r"""A diamond marker shape"""
kMarkerSquare = _pyaqcv.kMarkerSquare
r"""A square marker shape"""
kMarkerTriangleUp = _pyaqcv.kMarkerTriangleUp
r"""An upwards pointing triangle marker shape"""
kMarkerTriangleDown = _pyaqcv.kMarkerTriangleDown
r"""A downwards pointing triangle marker shape"""
kFontHersheySimplex = _pyaqcv.kFontHersheySimplex
r"""normal size sans-serif font"""
kFontHersheyPlain = _pyaqcv.kFontHersheyPlain
r"""small size sans-serif font"""
kFontHersheyDuplex = _pyaqcv.kFontHersheyDuplex
r"""normal size sans-serif font (more complex than kFontHersheySimplex)"""
kFontHersheyComplex = _pyaqcv.kFontHersheyComplex
r"""normal size serif font"""
kFontHersheyTriplex = _pyaqcv.kFontHersheyTriplex
r"""normal size serif font (more complex than kFontHersheyComplex)"""
kFontHersheyComplexSmall = _pyaqcv.kFontHersheyComplexSmall
r"""smaller version of kFontHersheyComplex"""
kFontHersheyScriptSimplex = _pyaqcv.kFontHersheyScriptSimplex
r"""hand-writing style font"""
kFontHersheyScriptComplex = _pyaqcv.kFontHersheyScriptComplex
r"""more complex variant of kFontHersheyScriptSimplex"""
kFontItalic = _pyaqcv.kFontItalic
r"""flag for italic font"""

def draw(*args):
    r"""
    *Overload 1:*
     Draws point on image.

    :type img: :py:class:`Mat`
    :param img: Image
    :type point: :py:class:`Point2i`
    :param point: Point to draw
    :type color: :py:class:`Scalar`
    :param color: Color of point
    :type marker_type: int, optional
    :param marker_type: The specific type of marker you want to use, see #MarkerTypes
    :type marker_size: int, optional
    :param marker_size: The length of the marker axis
    :type thickness: int, optional
    :param thickness: Line thickness
    :type line_type: int, optional
    :param line_type: Type of the line. See #LineTypes
    :type opacity: float, optional
    :param opacity: Controls the transparency of drawn content.
                - 0: Full transparency, no drawn content is visible.
                - 1: Full opacity, drawn content completely covers the original image on drawn area. (default value)
                - Values between 0 and 1: Blends original image and drawn content based on opacity.
                - When line_type = LineAA, opacity is not supported.
    :rtype: boolean
    :return: true if ok


    |

    *Overload 2:*

    Draws point on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 3:*

    Draws point on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 4:*

    Draws point on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 5:*

    Draws point on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 6:*

    Draws point on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 7:*

    Draws point on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 8:*

    Draws straight line on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 9:*

    Draws straight line on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 10:*

    Draws straight line on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 11:*

    Draws straight line on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 12:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 13:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 14:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 15:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 16:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 17:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 18:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 19:*

    Draws line segment on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 20:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 21:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 22:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 23:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 24:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 25:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 26:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 27:*

    Draws ray on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 28:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 29:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 30:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 31:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 32:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 33:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 34:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 35:*

    Draws line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 36:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 37:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 38:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 39:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 40:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 41:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 42:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 43:*

    Draws ring on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 44:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 45:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 46:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 47:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 48:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 49:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 50:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 51:*

    Draws polygon on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 52:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 53:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 54:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 55:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 56:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 57:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 58:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 59:*

    Draws rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 60:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 61:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 62:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 63:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 64:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 65:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 66:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 67:*

    Draws rotated rectangle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 68:*

    Draws ellipse on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 69:*

    Draws ellipse on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 70:*

    Draws ellipse on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 71:*

    Draws ellipse on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 72:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 73:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 74:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 75:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 76:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 77:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 78:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 79:*

    Draws circle on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 80:*

    Draws arc on image. Notes: fill is not supported. When line_type = LineAA, opacity is not supported.


    |

    *Overload 81:*

    Draws arc on image. Notes: fill is not supported. When line_type = LineAA, opacity is not supported.


    |

    *Overload 82:*

    Draws arc on image. Notes: fill is not supported. When line_type = LineAA, opacity is not supported.


    |

    *Overload 83:*

    Draws arc on image. Notes: fill is not supported. When line_type = LineAA, opacity is not supported.


    |

    *Overload 84:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 85:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 86:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 87:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 88:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 89:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 90:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 91:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 92:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 93:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 94:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 95:*

    Draws multiple points on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 96:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 97:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 98:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 99:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 100:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 101:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 102:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 103:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 104:*

    Draws multiple polygons on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 105:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 106:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 107:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 108:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 109:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 110:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 111:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 112:*

    Draws multiple line string on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 113:*

    Draws contours on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 114:*

    Draws contours on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 115:*

    Draws contours on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 116:*

    Draws contours on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 117:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 118:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 119:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 120:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 121:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 122:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 123:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 124:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 125:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 126:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 127:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 128:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 129:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.


    |

    *Overload 130:*

    Draws text on image. Notes: When line_type = LineAA, opacity is not supported.
    """
    return _pyaqcv.draw(*args)

def draw_utf8(*args):
    r"""
     Draws a UTF8 text string.

    The function aqcv::draw_utf8 renders the specified text string in the image.

    :type img: :py:class:`Mat`
    :param img: Image in AQ_8U with 1, 3 or 4 channels.
    :type text: string
    :param text: Text string to be drawn.
    :type point: :py:class:`Point2i`
    :param point: Bottom-left or Top-left corner of the first character of the printed text.
    :type color: :py:class:`Scalar`
    :param color: Text color.
    :type font_size: int
    :param font_size: Font size in pixels.
    :type text_anchor: int, optional
    :param text_anchor: Place the text in the bottom right or top right corner of the starting point
    """
    return _pyaqcv.draw_utf8(*args)

def draw_utf16(*args):
    r"""Draws a UTF16 text string. The parameters is same as 'draw_utf8'."""
    return _pyaqcv.draw_utf16(*args)

def draw_ellipse(*args):
    r"""
     Draws a simple or thick elliptic arc or fills an ellipse sector.

    The function aqcv::draw_ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic
    arc, or a filled ellipse sector. The drawing code uses general parametric form.
    A piecewise-linear curve is used to approximate the elliptic arc
    boundary. If you use the first variant of the function and want to draw the whole ellipse, not an arc,
    pass `start_angle=0` and `end_angle=360`. If `start_angle` is greater than `end_angle`, they are swapped.

    :type img: :py:class:`Mat`
    :param img: Image.
    :type center: :py:class:`Point`
    :param center: Center of the ellipse.
    :type axes: :py:class:`Size`
    :param axes: Half of the size of the ellipse main axes.
    :type angle: :py:class:`Radian`
    :param angle: Ellipse rotation angle.
    :type start_angle: :py:class:`Radian`
    :param start_angle: Starting angle of the elliptic arc .
    :type end_angle: :py:class:`Radian`
    :param end_angle: Ending angle of the elliptic arc.
    :type color: :py:class:`Scalar`
    :param color: Ellipse color.
    :type thickness: int, optional
    :param thickness: Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that
        a filled ellipse sector is to be drawn.
    :type line_type: int, optional
    :param line_type: Type of the ellipse boundary. See #LineTypes
    :type shift: int, optional
    :param shift: Number of fractional bits in the coordinates of the center and values of axes.
    :type opacity: float, optional
    :param opacity: Controls the transparency of drawn content.
                - 0: Full transparency, no drawn content is visible.
                - 1: Full opacity, drawn content completely covers the original image on drawn area. (default value)
                - Values between 0 and 1: Blends original image and drawn content based on opacity.
                - When line_type = LineAA, opacity is not supported.
    """
    return _pyaqcv.draw_ellipse(*args)

def draw_marker(*args):
    r"""
     Draws a marker on a predefined position in an image.

    The function aqcv::draw_marker draws a marker on a given position in the image. It can highlight positions
    in an image. For the moment several marker types are supported, see #MarkerTypes for more information.

    :type img: :py:class:`Mat`
    :param img: Image.
    :type position: :py:class:`Point`
    :param position: The point where the crosshair is positioned.
    :type color: :py:class:`Scalar`
    :param color: Line color.
    :type marker_type: int, optional
    :param marker_type: The specific type of marker you want to use, see #MarkerTypes
    :type thickness: int, optional
    :param thickness: Line thickness.
    :type line_type: int, optional
    :param line_type: Type of the line, See #LineTypes
    :type marker_size: int, optional
    :param marker_size: The length of the marker axis [default = 20 pixels]
    :type opacity: float, optional
    :param opacity: Controls the transparency of drawn content.
                - 0: Full transparency, no drawn content is visible.
                - 1: Full opacity, drawn content completely covers the original image on drawn area. (default value)
                - Values between 0 and 1: Blends original image and drawn content based on opacity.
                - When line_type = LineAA, opacity is not supported.
    """
    return _pyaqcv.draw_marker(*args)
kDistortionGrid = _pyaqcv.kDistortionGrid
r"""
    image distortion in Augmentor <https://github.com/mdbloice/Augmentor>,
       change grid points randomly(except border points), make parallel lines no longer parallel after distortion.(default)
    """
kDistortionStretch = _pyaqcv.kDistortionStretch
r"""
    image distortion in Albumentation <https://albumentations.readthedocs.io/en/latest>,
       change grid points and resize image in each gird, thus keep rows horizontally and columns vertically.
    """

def get_distortion_grids(*args):
    r"""
     get distortion grid

    :type img_size: :py:class:`Size`
    :param img_size: image size
    :type src_pts: :py:class:`MultiPoint2f`
    :param src_pts: source points
    :type dst_pts: :py:class:`MultiPoint2f`
    :param dst_pts: random points after distortion
    :type dist_magnitude: float, optional
    :param dist_magnitude: distortion magnitude, should in [0,2], negative number means calculated by grid_count.
    :type rand_seed: int, optional
    :param rand_seed: random seed
    :type grid_count: int, optional
    :param grid_count: grid nums for an image, should in [3,10]
    :type type: int, optional
    :param type: distortion type (see #DistortionTypes)
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.get_distortion_grids(*args)

def image_distortion(*args):
    r"""
     image distortion

    :type src: :py:class:`Mat`
    :param src: input image, only support kDepth_U8C1/kDepth_U8C3/kDepth_U16C1
    :type dst: :py:class:`Mat`
    :param dst: output image
    :type src_pts: :py:class:`MultiPoint2f`
    :param src_pts: source points
    :type dst_pts: :py:class:`MultiPoint2f`
    :param dst_pts: distortion points
    :type type: int, optional
    :param type: distortion type (see #DistortionTypes), should be same as get_distortion_grids
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.image_distortion(*args)

def region_distortion(*args):
    r"""
     label distortion(multiple polygon)

    :type input_contours: :py:class:`MultiPolygon2f`
    :param input_contours: input label
    :type output_contours: :py:class:`MultiPolygon2f`
    :param output_contours: output label
    :type src_pts: :py:class:`MultiPoint2f`
    :param src_pts: source points
    :type dst_pts: :py:class:`MultiPoint2f`
    :param dst_pts: distortion points
    :type type: int, optional
    :param type: distortion type (see #DistortionTypes), should be same as image_distortion
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.region_distortion(*args)

def polygon_distortion(*args):
    r"""
     polygon distortion(multiple point)

    :type input_polygon: :py:class:`Polygon2f`
    :param input_polygon: input polygon
    :type output_polygon: :py:class:`Polygon2f`
    :param output_polygon: output polygon
    :type src_pts: :py:class:`MultiPoint2f`
    :param src_pts: source points
    :type dst_pts: :py:class:`MultiPoint2f`
    :param dst_pts: distortion points
    :type type: int, optional
    :param type: distortion type (see #DistortionTypes), should be same as image_distortion
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.polygon_distortion(*args)

def point_distortion(*args):
    r"""
     point distortion

    :type input_point: :py:class:`Point2f`
    :param input_point: input point
    :type output_point: :py:class:`Point2f`
    :param output_point: output point
    :type src_pts: :py:class:`MultiPoint2f`
    :param src_pts: source points
    :type dst_pts: :py:class:`MultiPoint2f`
    :param dst_pts: distortion points
    :type type: int, optional
    :param type: distortion type (see #DistortionTypes), should be same as image_distortion
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.point_distortion(*args)
class ImgEnhancementLEPParam(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kClipByCDFRate = _pyaqcv.ImgEnhancementLEPParam_kClipByCDFRate
    r"""clip part of maximum and minimum pixel value in cumulative distribution function"""
    kClipByFullScaleRate = _pyaqcv.ImgEnhancementLEPParam_kClipByFullScaleRate
    r"""clip part of maximum and minimum pixel value in range (minimum, maximum)"""

    def __init__(self):
        _pyaqcv.ImgEnhancementLEPParam_swiginit(self, _pyaqcv.new_ImgEnhancementLEPParam())

    def set_detail_feat_size(self, val):
        return _pyaqcv.ImgEnhancementLEPParam_set_detail_feat_size(self, val)

    def get_detail_feat_size(self):
        return _pyaqcv.ImgEnhancementLEPParam_get_detail_feat_size(self)

    def set_rough_feat_size(self, val):
        return _pyaqcv.ImgEnhancementLEPParam_set_rough_feat_size(self, val)

    def get_rough_feat_size(self):
        return _pyaqcv.ImgEnhancementLEPParam_get_rough_feat_size(self)

    def set_detail_enhance_scale(self, val):
        return _pyaqcv.ImgEnhancementLEPParam_set_detail_enhance_scale(self, val)

    def get_detail_enhance_scale(self):
        return _pyaqcv.ImgEnhancementLEPParam_get_detail_enhance_scale(self)

    def set_rough_enhance_scale(self, val):
        return _pyaqcv.ImgEnhancementLEPParam_set_rough_enhance_scale(self, val)

    def get_rough_enhance_scale(self):
        return _pyaqcv.ImgEnhancementLEPParam_get_rough_enhance_scale(self)

    def set_base_keep_rate(self, val):
        return _pyaqcv.ImgEnhancementLEPParam_set_base_keep_rate(self, val)

    def get_base_keep_rate(self):
        return _pyaqcv.ImgEnhancementLEPParam_get_base_keep_rate(self)

    def set_clip_type(self, clip_type):
        return _pyaqcv.ImgEnhancementLEPParam_set_clip_type(self, clip_type)

    def get_clip_type(self):
        return _pyaqcv.ImgEnhancementLEPParam_get_clip_type(self)

    def set_cdf_keep_rate(self, lower_bound, upper_bound):
        return _pyaqcv.ImgEnhancementLEPParam_set_cdf_keep_rate(self, lower_bound, upper_bound)

    def get_cdf_keep_rate(self, lower_bound, upper_bound):
        return _pyaqcv.ImgEnhancementLEPParam_get_cdf_keep_rate(self, lower_bound, upper_bound)

    def set_fs_keep_rate(self, lower_bound, upper_bound):
        return _pyaqcv.ImgEnhancementLEPParam_set_fs_keep_rate(self, lower_bound, upper_bound)

    def get_fs_keep_rate(self, lower_bound, upper_bound):
        return _pyaqcv.ImgEnhancementLEPParam_get_fs_keep_rate(self, lower_bound, upper_bound)
    __swig_destroy__ = _pyaqcv.delete_ImgEnhancementLEPParam

# Register ImgEnhancementLEPParam in _pyaqcv:
_pyaqcv.ImgEnhancementLEPParam_swigregister(ImgEnhancementLEPParam)

def img_enhancement_LEP(src, dst, param):
    r"""
     X-ray image or low contrast image enhancement

    This enhancement algorithm uses local edge preserving filter to enhance the image contrast and details.

    :type src: :py:class:`Mat`
    :param src: input image in AQ_8U, AQ_16U, AQ_32F, one or three channel
    :type dst: :py:class:`Mat`
    :param dst: output image
    :type param: :py:class:`ImgEnhancementLEPParam`
    :param param: enhancement parameters, see class ImgEnhancementLEPParam
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.img_enhancement_LEP(src, dst, param)

def illumination_correction(*args):
    r"""
    *Overload 1:*
    corrects an image in low or bright light to an image that is within a normal light range

     .. math::

         \texttt{dst}= \texttt{src}*(base / mean(src))
    :type src: :py:class:`Mat`
    :param src: the source image that needs to be processed
    :type dst: :py:class:`Mat`
    :param dst: if the target image is the same size and type as the source image, the result is stored in the original dst memory, otherwise the dst is recreated
    :type base: float
    :param base: brightness reference value
    :rtype: boolean
    :return: true if ok


    |

    *Overload 2:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.using mean illumination of base_img as base value

     .. math::

         \texttt{dst}= \texttt{src}*(mean(base_img) / mean(src))
    :type src: :py:class:`Mat`
    :param src: the source image that needs to be processed
    :type dst: :py:class:`Mat`
    :param dst: target image，if the target image is the same size and type as the source image, the result is stored in the original dst memory, otherwise the dst is recreated
    :type base_img: :py:class:`Mat`
    :param base_img: luminance base image, from which the baseline value is calculated (only the brightness value is taken for color images)
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.illumination_correction(*args)

def contrast_enhance(src, dst, ratio, threshold):
    r"""
     enhance image contrast

    This enhance algorithm uses a nonlinear stretch algorithm to conversion brightness in a specified range

    :type src: :py:class:`Mat`
    :param src: input entire or sub regions of image in AQ_8U, one and three channels
    :type dst: :py:class:`Mat`
    :param dst: output image
    :type ratio: float
    :param ratio: it is within [0, 30], and it controls the slopes of the transform curves, its values larger, the curves steeper
    :type threshold: float
    :param threshold: it is within [0, 255], gray values less threshold are compressed to a dark range and values greater than  threshold are extended to a brighter range
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.contrast_enhance(src, dst, ratio, threshold)

def gamma_transform(src, dst, gamma, alpha, beta):
    r"""
    Transform the contrast of image,the function use the formula as follow:

     .. math::

         \texttt{dst}=255*alpha(((\texttt{src}+beta)/255)^{gamma})

    :type src: :py:class:`Mat`
    :param src: original image in AQ_8U, one or three channel
    :type dst: :py:class:`Mat`
    :param dst: result image
    :type gamma: float
    :param gamma: transformation coefficient,it is greater than 0. It gets higher output value within (0,1),lower output value within (1,+∞)and linear mapping when equal to 1.
    :type alpha: float
    :param alpha: slope, it is greater than 0, and result image will get the higher luminance with its increasing
    :type beta: float
    :param beta: offset,it is a offset in transforming contrast of image
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.gamma_transform(src, dst, gamma, alpha, beta)

def emphasize(src, dst, filter_size, factor):
    r"""
    The operator emphasize emphasizes high frequency areas of the image (edges and corners). The resulting images appears sharper.
    :type src: :py:class:`Mat`
    :param src: Image to be enhanced
    :type dst: :py:class:`Mat`
    :param dst: Contrast enhanced image
    :type filter_size: :py:class:`Size`
    :param filter_size: Width and Height of low pass filter.The value is an odd number between 3 and 201.
    :type factor: float
    :param factor: Intensity of contrast emphasis.The range is between 0.0 and 20.0
    """
    return _pyaqcv.emphasize(src, dst, filter_size, factor)

def max_area_inner_rect(*args):
    r"""
    *Overload 1:*

    find the largest area of the inscribed rectangle inside the ring.

    :type ring: :py:class:`Ring2i`
    :param ring: input geometry
    :type max_rect: :py:class:`Rect2i`
    :param max_rect: an inscribed rectangle with the largest area inside the geometry

    |

    *Overload 2:*
     find the largest area of the inscribed rectangle inside the polygon. if there are holes, the rectangle should avoid them.

    |

    *Overload 3:*
     find the largest area of the inscribed rectangle inside the MultiPolygon. if there are holes, the rectangle should avoid them.
    """
    return _pyaqcv.max_area_inner_rect(*args)

def inter_between_arcs(arc1, arc2, intersect_pts):
    r"""
    find intersection points between two geometries, only finite geometry are supported.(including kCircle2f,kCircle2i,kArc2f)

    :type arc1: :py:class:`IGeometry`
    :param arc1: input geometry
    :type arc2: :py:class:`IGeometry`
    :param arc2: input geometry
    :type intersect_pts: :py:class:`MultiPoint2f`
    :param intersect_pts: intersection points between two geometries.
         if the two geometries are overlapping,it is the starting and ending points of the overlapping segment arcs
    :rtype: boolean
    :return: if the two geometries are overlapping return true.
    """
    return _pyaqcv.inter_between_arcs(arc1, arc2, intersect_pts)
kTileOrderVertical = _pyaqcv.kTileOrderVertical
r"""the images are copied in the vertical direction, i.e., the second image of Images will be below the first image."""
kTileOrderHorizontal = _pyaqcv.kTileOrderHorizontal
r"""the images are copied in the horizontal direction, i.e., the second image of Images will be to the right of the first image."""

def tile_images(*args):
    r"""
    To tile multiple input image objects into a large image,
    :type src: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
    :param src: The input Images which may be of different size.The input images have the same type or depth is 8U but the number of channels can be 1,3,4.
        If both single-channel and multi-channel exist, The multi-channel image is treated as the channel order from the BGR or BGRA.
    :type dst: :py:class:`Mat`
    :param dst: The maximum number of channels in the input image is used as the number of output image channels.
        Each tile has the same size, which is determined by the maximum width and height of all input images.
        If an input image is smaller than the tile size it is copied to the center of the respective tile.
    :type num_columns: int
    :param num_columns: In the output image the Num input images have been tiled into num_columns columns.
        If Num is not a multiple of NumColumns the output image will have zero gray values in the lower right corner of the image.
    :type tile_order: int
    :param tile_order: The parameter TileOrder determines the order in which the images are copied into the output.
    :type color: :py:class:`Scalar`, optional
    :param color: Fill the color where there is no image.
    :rtype: boolean
    :return: if succeed return true
    """
    return _pyaqcv.tile_images(*args)

def scale_image(src, dst, alpha, beta):
    r"""
    scale src image to dst by transformation:

     .. math::

         Val_dst = Val_src * \alpha + \beta
    :type src: :py:class:`Mat`
    :param src: input image with any type
    :type dst: :py:class:`Mat`
    :param dst: output image with same type of src
    :type alpha: float
    :param alpha: coefficient
    :type beta: float
    :param beta: bias to add
    """
    return _pyaqcv.scale_image(src, dst, alpha, beta)

def get_text_size(*args):
    r"""
    *Overload 1:*
     Calculates the rect of a text string.
    :type img_size: :py:class:`Size`
    :param img_size: Image size.If size is empty, the rect is not limited by the image boundaries.
    :type text: string
    :param text: Input text string.
    :type point: :py:class:`Point2i`
    :param point: Original point
    :type font_scale: float, optional
    :param font_scale: Font to use, see #HersheyFonts.
    :type font_face: int, optional
    :param font_face: Font scale factor that is multiplied by the font-specific base size.
    :type thickness: int, optional
    :param thickness: Thickness of lines used to render the text.
    :type text_anchor: int, optional
    :param text_anchor: The origin is in the top-left or bottom-left corner of the text
    :rtype: :py:class:`Rect2i`
    :return: The rect that contains the specified text.
    See also: draw(Mat,std::string,...)

    |

    *Overload 2:*
     Calculates the width and height of a text string.

    |

    *Overload 3:*
     Calculates the width and height of a text string.

    |

    *Overload 4:*
     Calculates the width and height of a text string.

    |

    *Overload 5:*
     Calculates the width and height of a text string.

    |

    *Overload 6:*
     Calculates the width and height of a text string.
    """
    return _pyaqcv.get_text_size(*args)

def get_text_size_utf8(*args):
    r"""
     Calculates the rect of a utf8 text string.
    :type img_size: :py:class:`Size`
    :param img_size: Image size.If size is empty, the rect is not limited by the image boundaries.
    :type text: string
    :param text: Input text string.
    :type point: :py:class:`Point2i`
    :param point: Original point
    :type font_size: int
    :param font_size: Font size in pixels.
    :type text_anchor: int, optional
    :param text_anchor: The origin is in the top-left or bottom-left corner of the text
    See also: draw_utf8
    """
    return _pyaqcv.get_text_size_utf8(*args)

def get_text_size_utf16(*args):
    r"""
     Calculates the rect of a utf16 text string. The parameters is same as 'get_text_size_utf8'.
    See also: draw_utf16
    """
    return _pyaqcv.get_text_size_utf16(*args)

def complement_ring(*args):
    r"""
    *Overload 1:*
     complement a sparse ring (distance between neightbors int x or y direction larger than max_dist) to a
    densy ring (distance between neightbors int x or y direction not larger than max_dist)
    :type r: :py:class:`Ring2f`
    :param r: ring to complement
    :type max_dist: float, optional
    :param max_dist: maximum distance between neighbor points,should larger than 1e-5


    |

    *Overload 2:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 3:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.
    """
    return _pyaqcv.complement_ring(*args)

def convert_to_connected(*args):
    r"""
    *Overload 1:*
     convert non-continuous contours to continuous contours.
    Warning!!! After completion, the inner loop and the outer loop are connected due to the middle plastic conversion and the 4 or 8 connection,
    and the illegal contour will be formed. However, since valid does not currently support 8-connected diagonal blob determinations,
    the validity determination is not performed here.
    :type input: :py:class:`MultiPolygon2i`
    :param input: converted contours.
    :type res: :py:class:`MultiPolygon2i`
    :param res:  conversion result.
    :type is_boundray: boolean, optional
    :param is_boundray: if true,it is used as a boundary.
    :type connectivity: int, optional
    :param connectivity: type of connectivity is 4 or 8.It is preferred to increase x when turning 4 diagonally connected
    Notes: :return empty Ring/Polygon/MultiPolygon when input is not include at least one pixel


    |

    *Overload 2:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 3:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 4:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 5:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 6:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 7:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 8:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 9:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 10:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 11:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 12:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 13:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 14:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 15:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 16:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.
    """
    return _pyaqcv.convert_to_connected(*args)

def convert_to_multipolygon(*args):
    r"""
    *Overload 1:*
     convert a geometry to a region represented by MultiPolygon2i type
    :type poly: :py:class:`MultiPolygon2i`
    :param poly: converted result
    :type rect: :py:class:`Rect2f`
    :param rect: rectangle wanted to convert
    :rtype: void
    :return: true if poly
    Notes: :return empty MultiPolygon when rect/rrect/circle/ellipse is not include at least one pixel


    |

    *Overload 2:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 3:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 4:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 5:*
     convert a geometry to MultiPolygon2f,max distance between neighbor point is
    :type geom: :py:class:`MultiPolygon2f`
    :param geom: converted result
    :type rect: :py:class:`Rect2f`
    :param rect: rectangle wanted to convert


    |

    *Overload 6:*
     convert a geometry to MultiPolygon2f,max distance between neighbor point is
    :type geom: :py:class:`MultiPolygon2f`
    :param geom: converted result
    :type rect: :py:class:`Rect2f`
    :param rect: rectangle wanted to convert


    |

    *Overload 7:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 8:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 9:*
     convert a geometry to MultiPolygon2f,max distance between neighbor point is
    :type geom: :py:class:`MultiPolygon2f`
    :param geom: converted result
    :type circle: :py:class:`Circle2f`
    :param circle: rectangle wanted to convert
    :type max_dist: float
    :param max_dist: maximum distance between neighbor points(should larger than 1e-5)
    Notes: huge amount of points maybe generated when max_dist is small


    |

    *Overload 10:*
     This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.
    """
    return _pyaqcv.convert_to_multipolygon(*args)
kSortGeomMassCenter = _pyaqcv.kSortGeomMassCenter
r"""sort with polygons' mass center"""
kSortGeomYminXmin = _pyaqcv.kSortGeomYminXmin
r"""sort with polygons' first point(the point with minimum y, then minimum x)"""
kSortGeomYmaxXmax = _pyaqcv.kSortGeomYmaxXmax
r"""sort with polygons' last point(the point with maximum y, then maximum x)"""
kSortGeomBBoxCenter = _pyaqcv.kSortGeomBBoxCenter
r"""sort with polygons' bounding box center"""
kSortGeomBBoxYminXmin = _pyaqcv.kSortGeomBBoxYminXmin
r"""sort with polygons' bounding box xmin&ymin(left upper point in the image cooradinate)"""
kSortGeomBBoxYminXmax = _pyaqcv.kSortGeomBBoxYminXmax
r"""sort with polygons' bounding box xmax&ymin(right upper point in the image cooradinate)"""
kSortGeomBBoxYmaxXmin = _pyaqcv.kSortGeomBBoxYmaxXmin
r"""sort with polygons' bounding box xmin&ymax(left bottom point in the image cooradinate)"""
kSortGeomBBoxYmaxXmax = _pyaqcv.kSortGeomBBoxYmaxXmax
r"""sort with polygons' bounding box xmax&ymax(right bottom point in the image cooradinate)"""

def sort_geometry(*args):
    r"""
    *Overload 1:*
    sort polyogns with specific feature
    :type src: :py:class:`MultiPolygon2f`
    :param src: input polygons
    :type res: :py:class:`MultiPolygon2f`
    :param res: sorted polygons
    :type feat_type: int
    :param feat_type: the feature point define the polygons' position
    :type axis: int
    :param axis: sort in witch axis, 0 indicates y axis, 1 indicates x axis
    :type reverse: boolean, optional
    :param reverse: reverse the sorted order
    :type grid_sort: boolean, optional
    :param grid_sort: sort feat points in grid mode. When grid_sort is true, feature points will first be sorted in given axis(x or y) and split
               points into different rows or columns, and then sorted elements in every row or columns
           Notes: split rule reference sort_geometry for MultiPoint.
    :type grid_size: float, optional
    :param grid_size: only useful when grid_sort is true, this define the row height and column width
    :rtype: boolean
    :return: true if ok


    |

    *Overload 2:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 3:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 4:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 5:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 6:*
    sort point
    :type src: :py:class:`MultiPoint2f`
    :param src: input points
    :type res: :py:class:`MultiPoint2f`
    :param res: sorted points
    :type axis: int
    :param axis: sort in witch axis, 0 indicates y axis, 1 indicates x axis
    :type reverse: boolean, optional
    :param reverse: reverse the sorted order
    :type grid_sort: boolean, optional
    :param grid_sort: sort feat points in grid mode. When grid_sort is true, feature points will first be sorted in given axis(x or y) and split
               points into different rows or columns, and then sorted elements in every row or column
           Notes: rows(columns) split rule: using the unsplited point with minimum y(x) as a row upper (column left) boundary,
           all point in the range [p.y, p.y+grid_size]([p.x, p.x+grid_size]) will be assembled into this row(column).points
           not assembled will be processed recurrently in the same way.
    :type grid_size: float, optional
    :param grid_size: only useful when grid_sort is true, this define the row height and column width
    :rtype: boolean
    :return: true if ok


    |

    *Overload 7:*
    sort point
    :type src: :py:class:`MultiPoint2f`
    :param src: input points
    :type res: :py:class:`MultiPoint2f`
    :param res: sorted points
    :type axis: int
    :param axis: sort in witch axis, 0 indicates y axis, 1 indicates x axis
    :type reverse: boolean, optional
    :param reverse: reverse the sorted order
    :type grid_sort: boolean, optional
    :param grid_sort: sort feat points in grid mode. When grid_sort is true, feature points will first be sorted in given axis(x or y) and split
               points into different rows or columns, and then sorted elements in every row or column
           Notes: rows(columns) split rule: using the unsplited point with minimum y(x) as a row upper (column left) boundary,
           all point in the range [p.y, p.y+grid_size]([p.x, p.x+grid_size]) will be assembled into this row(column).points
           not assembled will be processed recurrently in the same way.
    :param grid_size: only useful when grid_sort is true, this define the row height and column width
    :rtype: boolean
    :return: true if ok


    |

    *Overload 8:*
    sort point
    :type src: :py:class:`MultiPoint2f`
    :param src: input points
    :type res: :py:class:`MultiPoint2f`
    :param res: sorted points
    :type axis: int
    :param axis: sort in witch axis, 0 indicates y axis, 1 indicates x axis
    :type reverse: boolean, optional
    :param reverse: reverse the sorted order
    :param grid_sort: sort feat points in grid mode. When grid_sort is true, feature points will first be sorted in given axis(x or y) and split
               points into different rows or columns, and then sorted elements in every row or column
           Notes: rows(columns) split rule: using the unsplited point with minimum y(x) as a row upper (column left) boundary,
           all point in the range [p.y, p.y+grid_size]([p.x, p.x+grid_size]) will be assembled into this row(column).points
           not assembled will be processed recurrently in the same way.
    :param grid_size: only useful when grid_sort is true, this define the row height and column width
    :rtype: boolean
    :return: true if ok


    |

    *Overload 9:*
    sort point
    :type src: :py:class:`MultiPoint2f`
    :param src: input points
    :type res: :py:class:`MultiPoint2f`
    :param res: sorted points
    :type axis: int
    :param axis: sort in witch axis, 0 indicates y axis, 1 indicates x axis
    :param reverse: reverse the sorted order
    :param grid_sort: sort feat points in grid mode. When grid_sort is true, feature points will first be sorted in given axis(x or y) and split
               points into different rows or columns, and then sorted elements in every row or column
           Notes: rows(columns) split rule: using the unsplited point with minimum y(x) as a row upper (column left) boundary,
           all point in the range [p.y, p.y+grid_size]([p.x, p.x+grid_size]) will be assembled into this row(column).points
           not assembled will be processed recurrently in the same way.
    :param grid_size: only useful when grid_sort is true, this define the row height and column width
    :rtype: boolean
    :return: true if ok


    |

    *Overload 10:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 11:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 12:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.

    |

    *Overload 13:*
    This is an overloaded member function, provided for convenience.
    It differs from the above function only in what argument(s) it accepts.
    """
    return _pyaqcv.sort_geometry(*args)

def clip_line_to_segment(*args):
    r"""
    @ brief clip line to segment. End points of segment are the foot point of the most outer points
    :type line: :py:class:`Line2f`
    :param line: Line to be clipped
    :type pts: :py:class:`MultiPoint2f`
    :param pts: points to refrence to clip the line
    :type segment: :py:class:`Segment2f`
    :param segment: clipped segment
        return False will be return if failed in two conditions:
              a. pts only have one point
              b. length of clipped segment smaller than FLT_EPSILON
    """
    return _pyaqcv.clip_line_to_segment(*args)

def pose2d_compose(left, right, res):
    r"""
    compose to pose
    :type left: :py:class:`Mat`
    :param left: pose1 2*3 in AQ_64FC1 data type
    :type right: :py:class:`Mat`
    :param right: pose2 2*3 in AQ_64FC1 data type
    :type res: :py:class:`Mat`
    :param res: composed pose 2*3, AQ_64FC1 type  :math:`res = left \dot right`
    :rtype: boolean
    :return: true if ok,false if left and right is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_compose(left, right, res)

def pose2d_invert(src, res):
    r"""
    invert given pose
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type res: :py:class:`Mat`
    :param res: inverted pose 2*3, AQ_64FC1 type  :math:`res = inv(src)`
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_invert(src, res)

def pose2d_reflect(src, p1, p2, res):
    r"""
    adds a reflection about the axis given by the two points p1 and p2 to the pose,
    The axis p1-p2 is fixed in the transformation, i.e., the points on the axis remain unchanged when transformed using
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type p1: :py:class:`Point2f`
    :param p1: point on reflect axis
    :type p2: :py:class:`Point2f`
    :param p2: point on reflect axis
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1),or p1 is same to p2
    """
    return _pyaqcv.pose2d_reflect(src, p1, p2, res)

def pose2d_reflect_local(src, p, res):
    r"""
    adds a reflection about the axis given by the two points (0,0) and p to the homogeneous
    2D transformation matrix src and returns the resulting matrix in res.
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type p: :py:class:`Point2f`
    :param p: point on reflect axis
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1),or p1 is same to p2
    """
    return _pyaqcv.pose2d_reflect_local(src, p, res)

def pose2d_rotate(src, center, angle, res):
    r"""
    adds a rotate to given pose2d
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type center: :py:class:`Point2f`
    :param center:  fix point during the rotation
    :type angle: :py:class:`Radian`
    :param angle: rotate angle
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_rotate(src, center, angle, res)

def pose2d_rotate_local(src, angle, res):
    r"""
    adds a rotate to given pose2d. The fixed point of the transformation is the origin of the coordinate system.
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type angle: :py:class:`Radian`
    :param angle: rotate angle
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_rotate_local(src, angle, res)

def pose2d_scale(src, center, sx, sy, res):
    r"""
    adds a scale to given pose2d
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type center: :py:class:`Point2f`
    :param center:  fix point during the rotation
    :type sx: float
    :param sx: scale in x direction
    :type sy: float
    :param sy: scale in y direction
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_scale(src, center, sx, sy, res)

def pose2d_scale_local(src, sx, sy, res):
    r"""
    adds a scale to given pose2d. The fixed point of the transformation is the origin of the coordinate system.
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type sx: float
    :param sx: scale in x direction
    :type sy: float
    :param sy: scale in y direction
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_scale_local(src, sx, sy, res)

def pose2d_slant(src, center, angle_x, angle_y, res):
    r"""
    adds a slant to given pose2d
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type center: :py:class:`Point2f`
    :param center:  fix point during the rotation
    :type angle_x: :py:class:`Radian`
    :param angle_x: slant angle in x axis
    :type angle_y: :py:class:`Radian`
    :param angle_y: slant angle in y axis
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_slant(src, center, angle_x, angle_y, res)

def pose2d_slant_local(src, angle_x, angle_y, res):
    r"""
    adds a slant to given pose2d. The fixed point of the transformation is the origin of the coordinate system.
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type angle_x: :py:class:`Radian`
    :param angle_x: slant angle in x axis
    :type angle_y: :py:class:`Radian`
    :param angle_y: slant angle in y axis
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_slant_local(src, angle_x, angle_y, res)

def pose2d_translate(src, tx, ty, res):
    r"""
    adds a translate to given pose2d
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type tx: float
    :param tx: add tx to src in x axis,
    :type ty: float
    :param ty: add ty to src in y axis
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_translate(src, tx, ty, res)

def pose2d_translate_local(src, tx, ty, res):
    r"""
    adds a translate to given pose2d. The translation is performed relative to the local coordinate system.
    TODO: formula
    :type src: :py:class:`Mat`
    :param src: pose1 2*3 in AQ_64FC1 data type
    :type tx: float
    :param tx: add tx to src in x axis,
    :type ty: float
    :param ty: add ty to src in y axis
    :type res: :py:class:`Mat`
    :param res: result
    :rtype: boolean
    :return: true if ok,false if src is not valid pose2d(2*3 in AQ_64FC1)
    """
    return _pyaqcv.pose2d_translate_local(src, tx, ty, res)
class Region(object):
    r"""Multiple regions represented by run length coding."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_Region

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Generate a empty region with size() = 0.

        |

        *Overload 2:*

        Copy constructor.
        :type rhs: :py:class:`Region`
        :param rhs: other Region.

        |

        *Overload 3:*

        Move constructor.
        :type rhs: :py:class:`Region`
        :param rhs: other rvalue Region.

        |

        *Overload 4:*

        Create a region from an image, all regions whose pixel value in range are seen as a single region.
        :type img: :py:class:`Mat`
        :param img: source image in AQ_8UC1.
        :type low: int, optional
        :param low: low threshold.
        :type high: int, optional
        :param high: high threshold.
        :type invert: boolean, optional
        :param invert: if invert, the pixel whose value lower than low or higher than high is considered.
        :type mask: :py:class:`Mat`, optional
        :param mask: mask in AQ_8UC1, only non-zero pixel of mask is considered.

        |

        *Overload 5:*

        Create a region from an image, all regions whose pixel value in range are seen as a single region.
        :type img: :py:class:`Mat`
        :param img: source image in AQ_8UC1.
        :type low: int, optional
        :param low: low threshold.
        :type high: int, optional
        :param high: high threshold.
        :type invert: boolean, optional
        :param invert: if invert, the pixel whose value lower than low or higher than high is considered.
        :param mask: mask in AQ_8UC1, only non-zero pixel of mask is considered.

        |

        *Overload 6:*

        Create a region from an image, all regions whose pixel value in range are seen as a single region.
        :type img: :py:class:`Mat`
        :param img: source image in AQ_8UC1.
        :type low: int, optional
        :param low: low threshold.
        :type high: int, optional
        :param high: high threshold.
        :param invert: if invert, the pixel whose value lower than low or higher than high is considered.
        :param mask: mask in AQ_8UC1, only non-zero pixel of mask is considered.

        |

        *Overload 7:*

        Create a region from an image, all regions whose pixel value in range are seen as a single region.
        :type img: :py:class:`Mat`
        :param img: source image in AQ_8UC1.
        :type low: int, optional
        :param low: low threshold.
        :param high: high threshold.
        :param invert: if invert, the pixel whose value lower than low or higher than high is considered.
        :param mask: mask in AQ_8UC1, only non-zero pixel of mask is considered.

        |

        *Overload 8:*

        Create a region from an image, all regions whose pixel value in range are seen as a single region.
        :type img: :py:class:`Mat`
        :param img: source image in AQ_8UC1.
        :param low: low threshold.
        :param high: high threshold.
        :param invert: if invert, the pixel whose value lower than low or higher than high is considered.
        :param mask: mask in AQ_8UC1, only non-zero pixel of mask is considered.

        |

        *Overload 9:*

        Create a filled region from geometry type.
        :type geometry: :py:class:`IGeometry`
        :param geometry: input geometry, support type : kRing2f/kRing2i/kPolygon2f/kPolygon2i/kMultiPolygon2f/kMultiPolygon2i/
                            kMultiSegment2f/kRect2f/kRect2i/kRotateRect2f/kRotateRect2i/kCircle2f/kCircle2i/kEllipse2f.

        |

        *Overload 10:*

        Create a region from a runlength coding.
        :type row: std::vector< short,std::allocator< short > >
        :param row: row of each runlength.
        :type col_begin: std::vector< short,std::allocator< short > >
        :param col_begin: column of the starting point of each runlength.
        :type col_end: std::vector< short,std::allocator< short > >
        :param col_end: column of the ending point of each runlength.
        Notes: throw exception when runlength is illegal.
        """
        _pyaqcv.Region_swiginit(self, _pyaqcv.new_Region(*args))

    def empty(self, index=0):
        r"""
        Whether the region is empty.
        :type index: int, optional
        :param index: index of region, if index < 0, it judges if all regions are empty.
        Notes: throw exception when index out of range. For Region with size() = 0, it always returns true.
        """
        return _pyaqcv.Region_empty(self, index)

    def size(self):
        r"""Count of regions."""
        return _pyaqcv.Region_size(self)

    def get_region(self, index):
        r"""
        Get Region with index.
        :type index: int
        :param index: index to get.
        Notes: throw exception when index out of range.
        """
        return _pyaqcv.Region_get_region(self, index)

    def concat(self, rhs):
        r"""
        Concatenate two regions.
        :type rhs: :py:class:`Region`
        :param rhs: other Region.
        Notes: the size of output region is size() + rhs.size(). In the case of both size of current Region and rhs are zero,
        it returns the Region with size = 1 which contains an empty region.
        """
        return _pyaqcv.Region_concat(self, rhs)

    def label(self):
        r"""Label of first region, generally 0 indicates hole or background, 1 indicates foreground region."""
        return _pyaqcv.Region_label(self)

    def get_region_runs(self, row, col_begin, col_end):
        r"""
        Access the runlength coding of the first region.
        :type row: std::vector< short,std::allocator< short > >
        :param row: row of each runlength.
        :type col_begin: std::vector< short,std::allocator< short > >
        :param col_begin: column of the starting point of each runlength.
        :type col_end: std::vector< short,std::allocator< short > >
        :param col_end: column of the ending point of each runlength.
        """
        return _pyaqcv.Region_get_region_runs(self, row, col_begin, col_end)

    def to_mat(self, *args):
        r"""
        Convert the first region to AU_8UC1 image, region transforms to 255 and background to 0.

        .. code-block:: c++

              Region b(vg::Rect2i(vg::Point2i(-10, -20), vg::Point2i(20, 10)))
              Mat m1 = b.to_mat(Size(100, 100)); //return a 100x100 Mat with Region range from (0, 0) to (20, 10)
              Mat m2 = b.to_mat(); //return a 30x30 Mat with all 255
        :type img_size: :py:class:`Size`, optional
        :param img_size: size of output image, if not empty, it should larger than Region, and only the part of Region inside in img_size
                   will be drawn. Otherwise, use default minimum size enclosing the Region.
        Notes: return an empty mat when both Region and size are empty.
        """
        return _pyaqcv.Region_to_mat(self, *args)

    def dilation_rectangle(self, ksize):
        r"""
        Dilate a region with a rectangular structuring element.
        :type ksize: :py:class:`Size`
        :param ksize: Size of the structuring element, it must be positive and odd.
        """
        return _pyaqcv.Region_dilation_rectangle(self, ksize)

    def dilation_circle(self, radius):
        r"""
        Dilate a region with a circular structuring element.
        :type radius: float
        :param radius: radius of the structuring element, its range is from 0 to 512.
        """
        return _pyaqcv.Region_dilation_circle(self, radius)

    def erosion_rectangle(self, ksize):
        r"""
        Erode a region with a rectangular structuring element.
        :type ksize: :py:class:`Size`
        :param ksize: Size of the structuring element, it must be positive and odd.
        """
        return _pyaqcv.Region_erosion_rectangle(self, ksize)

    def erosion_circle(self, radius):
        r"""
        Erode a region with a circular structuring element.
        :type radius: float
        :param radius: radius of the structuring element, its range is from 0 to 512.
        """
        return _pyaqcv.Region_erosion_circle(self, radius)

    def opening_rectangle(self, ksize):
        r"""
        Open a region with a rectangular structuring element.
        :type ksize: :py:class:`Size`
        :param ksize: Size of the structuring element, it must be positive and odd.
        """
        return _pyaqcv.Region_opening_rectangle(self, ksize)

    def opening_circle(self, radius):
        r"""
        Open a region with a circular structuring element.
        :type radius: float
        :param radius: radius of the structuring element, its range is from 0 to 512.
        """
        return _pyaqcv.Region_opening_circle(self, radius)

    def closing_rectangle(self, ksize):
        r"""
        Close a region with a rectangular structuring element.
        :type ksize: :py:class:`Size`
        :param ksize: Size of the structuring element, it must be positive and odd.
        """
        return _pyaqcv.Region_closing_rectangle(self, ksize)

    def closing_circle(self, radius):
        r"""
        Close a region with a circular structuring element.
        :type radius: float
        :param radius: radius of the structuring element, its range is from 0 to 512.
        """
        return _pyaqcv.Region_closing_circle(self, radius)
    kRegionMorphErode = _pyaqcv.Region_kRegionMorphErode
    r"""erode"""
    kRegionMorphDilate = _pyaqcv.Region_kRegionMorphDilate
    r"""dilate"""
    kRegionMorphOpen = _pyaqcv.Region_kRegionMorphOpen
    r"""opening operation(erode+dilate)"""
    kRegionMorphClose = _pyaqcv.Region_kRegionMorphClose
    r"""closing operation(dilate+erode)"""
    kMorphRect = _pyaqcv.Region_kMorphRect
    r"""rectangular structuring element"""
    kMorphCircle = _pyaqcv.Region_kMorphCircle
    r"""circular structuring element"""

    def morphology(self, *args):
        r"""
        Morphological operation on region.
        :type type: int
        :param type: type of a morphological operation, see #RegionMorphType.
        :type ksize: :py:class:`Size`
        :param ksize: Size of the structuring element, it must be positive and odd.
        :type shape: int, optional
        :param shape: element shape, see #RegionMorphShape.
        """
        return _pyaqcv.Region_morphology(self, *args)

    def intersection(self, rhs):
        r"""
        Calculate the intersection of two regions.
        :type rhs: :py:class:`Region`
        :param rhs: other Region.
        :rtype: :py:class:`Region`
        :return: Region whose size is equal to minimum size between current Region and input Region.
        """
        return _pyaqcv.Region_intersection(self, rhs)

    def union2(self, rhs):
        r"""
        Calculate the union of two regions.
        :type rhs: :py:class:`Region`
        :param rhs: other Region.
        :rtype: :py:class:`Region`
        :return: Region whose size is equal to minimum size between current Region and input Region.
        """
        return _pyaqcv.Region_union2(self, rhs)

    def union_all(self):
        r"""Calculate the union of all regions."""
        return _pyaqcv.Region_union_all(self)

    def complement(self, *args):
        r"""
        Calculate the complement of a region.
        :type range: :py:class:`Rect2i`, optional
        :param range: range of scene, it should enclosing current region. If empty, use default range of each region.
        """
        return _pyaqcv.Region_complement(self, *args)

    def difference(self, rhs):
        r"""
        Calculate the difference of two regions.
        :type rhs: :py:class:`Region`
        :param rhs: other Region.
        :rtype: :py:class:`Region`
        :return: Region whose size is equal to minimum size between current Region and input Region.
        """
        return _pyaqcv.Region_difference(self, rhs)

    def symm_difference(self, rhs):
        r"""
        Calculate the symmetric difference of two regions.
        :type rhs: :py:class:`Region`
        :param rhs: other Region.
        :rtype: :py:class:`Region`
        :return: Region whose size is equal to minimum size between current Region and input Region.
        """
        return _pyaqcv.Region_symm_difference(self, rhs)

    def connection(self):
        r"""Compute the connected components of a region."""
        return _pyaqcv.Region_connection(self)

    def fill_up(self, *args):
        r"""
        Fill up holes in region.
        :type min_area: float, optional
        :param min_area: holes whose area equal to or larger than min_area will be filled.
        :type max_area: float, optional
        :param max_area: holes whose area equal to or smaller than max_area will be filled.
        """
        return _pyaqcv.Region_fill_up(self, *args)

    def area(self):
        r"""
        Area of the region.
        Notes: if the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_area(self)

    def mass_center(self):
        r"""
        Region's mass center.
        Notes: if the Region's size is 0, it returns a empty Point2f.
        """
        return _pyaqcv.Region_mass_center(self)

    def geom_center(self):
        r"""
        Region's geometry center.
        Notes: if the Region's size is 0, it returns a empty Point2f.
        """
        return _pyaqcv.Region_geom_center(self)

    def x_second_moment(self):
        r"""
        Region's secondary moment in x axis direction.
        Notes: if the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_x_second_moment(self)

    def y_second_moment(self):
        r"""
        Region's secondary moment in y axis direction.
        Notes: if the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_y_second_moment(self)

    def orientation(self):
        r"""
        Region's orientation (the direction with minimum secondary moment. The range is
        left[ -, ).
        Notes: if the Region's size is 0, it returns a empty Radian.
        """
        return _pyaqcv.Region_orientation(self)

    def circularity(self):
        r"""
        Region's circularity, standard circle's circularity is 1. 'circularity'
        Notes: result maybe error when connect_num() > 1. If the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_circularity(self)

    def roundness(self):
        r"""
        Region's roundness. 'roundness'
        Notes: if the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_roundness(self)

    def convexity(self):
        r"""
        Region's convexity. 'convexity'
        Notes: if the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_convexity(self)

    def compactness(self):
        r"""
        Region's compactness. 'compactness'
        Notes: if the region has more than one connected component, only first one is considered.
        If the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_compactness(self)

    def rectangularity(self):
        r"""
        Region's rectangularity. 'rectangularity'
        Notes: if the Region's size is 0, it returns 0.
        """
        return _pyaqcv.Region_rectangularity(self)

    def cover_point(self, point):
        r"""
        Test if the region contains a given point.
        :type point: :py:class:`Point2f`
        :param point: input point.
        """
        return _pyaqcv.Region_cover_point(self, point)

    def transform_translate(self, dx, dy):
        r"""
        Translate a region.
        :type dx: int
        :param dx: translate distance in x axis direction.
        :type dy: int
        :param dy: translate distance in y axis direction.
        """
        return _pyaqcv.Region_transform_translate(self, dx, dy)

    def find_contours(self, include_inners=True, pixel_edge_boundary=False):
        r"""
        Get region contours with consecutive pixel boundary polygon.
        :type include_inners: boolean, optional
        :param include_inners: if include inner contours.
        :type pixel_edge_boundary: boolean, optional
        :param pixel_edge_boundary: if get pixel edge boundary. Usually pixel edge boundary is one pixel 'smaller' than pixel boundary.
            It's valid only for region with more than one row and one column, otherwise it will be set to false.
        Notes: usually this function use by custom region operations when current region has multiple connected components,
        otherwise it return MultiPolygon2i with only one polygon. If the Region's size is 0, it returns a empty MultiPolygon2i.
        """
        return _pyaqcv.Region_find_contours(self, include_inners, pixel_edge_boundary)

    def convert_to_multipolygon2f(self):
        r"""
        Get region contours with consecutive pixel boundary polygon in MultiPolygon2f type.
        Notes: this function puts all contours in one MultiPolygon2f as it is.(This fucntion do not merge
        overlap regions.If merged multipolygon2f if prefered, call aqcv::Region::union_all first please.)
        """
        return _pyaqcv.Region_convert_to_multipolygon2f(self)

    def bounding_box(self):
        r"""
        Bounding rectangle parallel to the coordinate axes.
        Notes: if the Region's size is 0, it returns a empty Rect2i.
        """
        return _pyaqcv.Region_bounding_box(self)

    def min_area_rect(self):
        r"""
        Smallest bounding rectangle with any orientation.
        Notes: if the Region's size is 0, it returns a empty RotateRect2f.Angle of RotateRect
        is.. math::

            (-\frac{\pi}{2}, -\frac{\pi}{2}]
        """
        return _pyaqcv.Region_min_area_rect(self)

    def inner_rectangle(self):
        r"""
        Largest inner rectangle of a region.
        Notes: if the Region's size is 0, it returns a empty Rect2i.
        """
        return _pyaqcv.Region_inner_rectangle(self)

    def bounding_circle(self):
        r"""
        Smallest surrounding circle of a region.
        Notes: if the Region's size is 0, it returns a empty Circle2f.
        """
        return _pyaqcv.Region_bounding_circle(self)

    def inner_circle(self):
        r"""
        Largest inner circle of a region.
        Notes: if the position of the circle is ambiguous, the "first possible" position
        (as far upper left as possible) is returned. If the Region's size is 0, it returns
        a empty Circle2f.
        """
        return _pyaqcv.Region_inner_circle(self)

    def elliptic_axis(self):
        r"""
        Calculate the parameters of the equivalent ellipse.
        Notes: if the Region's size is 0, it returns a empty Ellipse2f. For single row region,
        it returns ellipse whose axis height is 0.5, for single column region, it returns
        ellipse whose axis width is 0.5.
        """
        return _pyaqcv.Region_elliptic_axis(self)

    def convex_hull(self):
        r"""
        Convex hull of a region.
        Notes: if the Region's size is 0, it returns a empty Ring2i.
        """
        return _pyaqcv.Region_convex_hull(self)
    kMaxArea = _pyaqcv.Region_kMaxArea
    r"""max area"""
    kLabel = _pyaqcv.Region_kLabel
    r"""label of the region"""
    kArea = _pyaqcv.Region_kArea
    r"""area of the region"""
    kRow = _pyaqcv.Region_kRow
    r"""row coordinate of the geometric center"""
    kColumn = _pyaqcv.Region_kColumn
    r"""column coordinate of the geometric center"""
    kWidth = _pyaqcv.Region_kWidth
    r"""width of the region (parallel to the coordinate axes)"""
    kHeight = _pyaqcv.Region_kHeight
    r"""height of the region (parallel to the coordinate axes)"""
    kRow1 = _pyaqcv.Region_kRow1
    r"""row coordinate of upper left corner"""
    kColumn1 = _pyaqcv.Region_kColumn1
    r"""column coordinate of upper left corner"""
    kRow2 = _pyaqcv.Region_kRow2
    r"""row coordinate of lower right corner"""
    kColumn2 = _pyaqcv.Region_kColumn2
    r"""column coordinate of lower right corner"""
    kCircularity = _pyaqcv.Region_kCircularity
    r"""'circularity'"""
    kCompactness = _pyaqcv.Region_kCompactness
    r"""'compactness'"""
    kConvexity = _pyaqcv.Region_kConvexity
    r"""'convexity'"""
    kRectangularity = _pyaqcv.Region_kRectangularity
    r"""'rectangularity'"""
    kOuterRadius = _pyaqcv.Region_kOuterRadius
    r"""radius of smallest surrounding circle"""
    kInnerRadius = _pyaqcv.Region_kInnerRadius
    r"""radius of largest inner circle"""
    kInnerWidth = _pyaqcv.Region_kInnerWidth
    r"""width of the largest axis-parallel rectangle that fits into the region"""
    kInnerHeight = _pyaqcv.Region_kInnerHeight
    r"""height of the largest axis-parallel rectangle that fits into the region"""
    kRoundness = _pyaqcv.Region_kRoundness
    r"""'roundness'"""
    kOrientation = _pyaqcv.Region_kOrientation
    r"""'orientation' (in radian)"""
    kMassCenterRow = _pyaqcv.Region_kMassCenterRow
    r"""row coordinate of the mass center"""
    kMassCenterColumn = _pyaqcv.Region_kMassCenterColumn
    r"""column coordinate of the mass center"""
    kMinAreaRectLongSide = _pyaqcv.Region_kMinAreaRectLongSide
    r"""long side of the smallest surrounding rectangle"""
    kMinAreaRectShortSide = _pyaqcv.Region_kMinAreaRectShortSide
    r"""short side of the smallest surrounding rectangle"""
    kMinAreaRectCenterRow = _pyaqcv.Region_kMinAreaRectCenterRow
    r"""row coordinate of center of the smallest surrounding rectangle"""
    kMinAreaRectCenterColumn = _pyaqcv.Region_kMinAreaRectCenterColumn
    r"""column coordinate of center of the smallest surrounding rectangle"""
    kMinAreaRectAngle = _pyaqcv.Region_kMinAreaRectAngle
    r"""orientation of the smallest surrounding rectangle (in radian)"""
    kMomentX2nd = _pyaqcv.Region_kMomentX2nd
    r"""secondary moment in x axis direction"""
    kMomentY2nd = _pyaqcv.Region_kMomentY2nd
    r"""secondary moment in y axis direction"""

    def region_features(self, *args):
        r"""
        Calculate shape features of regions.
        :type types: std::vector< aqcv::Region::FeatureType,std::allocator< aqcv::Region::FeatureType > >
        :param types: region feature types, see #FeatureType.
        Notes: if there is only one element in types whose type is kMaxArea, the function returns a single value in output.
        If there is more than one element in types, the output has regions' size multiply types' size elements, and all
        elements with type kMaxArea will be ignored. The sequence in output is feature_1, feature_2 ... feature_n of first
        region, then features of second region, and so on. If the Region's size is 0, it returns a single value 0.
        """
        return _pyaqcv.Region_region_features(self, *args)
    kAnd = _pyaqcv.Region_kAnd
    r"""all filters connect with AND, region must satisfy all filters"""
    kOr = _pyaqcv.Region_kOr
    r"""all filters connect with OR, region only need satisfy one filter at least"""

    def select_shape(self, *args):
        r"""
        Choose regions with the aid of shape features.
        :type feats: std::vector< aqcv::Region::SelectFeature,std::allocator< aqcv::Region::SelectFeature > >
        :param feats: a series of select features.
        :type logic: int, optional
        :param logic: select logic, see #SelectLogic.
        Notes: if there is only one feature in feats whose type is kMaxArea, the function returns
        a single region in Region with max area, and parameter logic will be ignored. If there is
        more than one feature in feats, all features with type kMaxArea will be ignored.
        """
        return _pyaqcv.Region_select_shape(self, *args)
    kConvex = _pyaqcv.Region_kConvex
    r"""convex hull"""
    kEllipse = _pyaqcv.Region_kEllipse
    r"""ellipse with the same moments and area as the input region"""
    kOuterCircle = _pyaqcv.Region_kOuterCircle
    r"""smallest enclosing circle"""
    kInnerCircle = _pyaqcv.Region_kInnerCircle
    r"""largest circle fitting into the region"""
    kBoundingBox = _pyaqcv.Region_kBoundingBox
    r"""smallest enclosing rectangle parallel to the coordinate axes"""
    kMinAreaRect = _pyaqcv.Region_kMinAreaRect
    r"""smallest enclosing rectangle"""
    kInnerRectangle = _pyaqcv.Region_kInnerRectangle
    r"""largest axis-parallel rectangle fitting into the region distance to the center of gravity of the input region"""

    def shape_transform(self, type):
        r"""
        Transform the shape of a region.
        :type type: int
        :param type: region shape transform type, see #ShapeTransType.
        """
        return _pyaqcv.Region_shape_transform(self, type)
    kFirstPoint = _pyaqcv.Region_kFirstPoint
    r"""the point with the lowest column value in the first row of the region (not implement)"""
    kLastPoint = _pyaqcv.Region_kLastPoint
    r"""the point with the highest column value in the last row of the region (not implement)"""
    kLowerLeft = _pyaqcv.Region_kLowerLeft
    r"""upper left corner of the surrounding rectangle (not implement)"""
    kLowerRight = _pyaqcv.Region_kLowerRight
    r"""upper right corner of the surrounding rectangle (not implement)"""
    kUpperLeft = _pyaqcv.Region_kUpperLeft
    r"""lower left corner of the surrounding rectangle (not implement)"""
    kUpperRight = _pyaqcv.Region_kUpperRight
    r"""lower right corner of the surrounding rectangle (not implement)"""
    kCharacter = _pyaqcv.Region_kCharacter
    r"""the regions are treated like characters, which can be read horizontally or vertically according to the reading direction"""

    def sort_region(self, mode, axis=0, reverse=False, overlap=0.15):
        r"""
        Sorting of regions with respect to their relative position.
        :type mode: int
        :param mode: sort mode, see #SortMode. (for now, only support kCharacter.)
        :type axis: int, optional
        :param axis: sort first in which axis, 0 indicates sorting first with respect to row, then to column,
            1 indicates sorting first with respect to column, then to row.
        :type reverse: boolean, optional
        :param reverse: determine whether reverse the sorted order, false for increasing and true for decreasing.
        :type overlap: float, optional
        :param overlap: maximum percentage of overlap, overlap between adjacent rows (or columns) exceed this
            value will be considered as same rows (or columns), only used for kCharacter mode.
        """
        return _pyaqcv.Region_sort_region(self, mode, axis, reverse, overlap)

    def sort_by_feature(self, type, ascending=False):
        r"""
        Sorting of regions with respect to their features.
        :type type: int
        :param type: region feature type, see #FeatureType.
        :type ascending: boolean, optional
        :param ascending: if true, sort in ascending order, otherwise in decending order.
        :rtype: :py:class:`Region`
        :return: sorted region (original region will not change)
        """
        return _pyaqcv.Region_sort_by_feature(self, type, ascending)

    def min_max_gray(self, img, min_val, max_val):
        r"""
        Minimum and maximum gray value of the region.
        :type img: :py:class:`Mat`
        :param img: input image in AQ_8UC1.
        :type min_val: std::vector< double,std::allocator< double > >
        :param min_val: minimum gray value of each region.
        :type max_val: std::vector< double,std::allocator< double > >
        :param max_val: maximum gray value of each region.
        :rtype: boolean
        :return: true if successed (0 if region is empty or not intersect with img), false if Region's size is 0,
            empty img or error img type.
        """
        return _pyaqcv.Region_min_max_gray(self, img, min_val, max_val)

    def mean_gray(self, img, mean_val):
        r"""
        Mean gray value of the region.
        :type img: :py:class:`Mat`
        :param img: input image in AQ_8UC1.
        :type mean_val: std::vector< double,std::allocator< double > >
        :param mean_val: mean gray value of each region.
        :rtype: boolean
        :return: true if successed (0 if region is empty or not intersect with img), false if Region's size is 0,
            empty img or error img type.
        """
        return _pyaqcv.Region_mean_gray(self, img, mean_val)

    def mean_std_dev_gray(self, img, mean_val, std_dev_val):
        r"""
        Mean and standard deviation gray value of the region.
        :type img: :py:class:`Mat`
        :param img: input image in AQ_8UC1.
        :type mean_val: std::vector< double,std::allocator< double > >
        :param mean_val: mean gray value of each region.
        :type std_dev_val: std::vector< double,std::allocator< double > >
        :param std_dev_val: standard deviation gray value of each region.
        :rtype: boolean
        :return: true if successed (0 if region is empty or not intersect with img), false if Region's size is 0,
            empty img or error img type.
        """
        return _pyaqcv.Region_mean_std_dev_gray(self, img, mean_val, std_dev_val)

# Register Region in _pyaqcv:
_pyaqcv.Region_swigregister(Region)
class AqRegionSelectFeature(object):
    r"""
    Region select feature.
    :param type: region feature type, see #FeatureType. If type is kMaxArea, other parameter min/max/invert will
        be ignored.
    :param min: low limit of filter.
    :param max: high limit of filter.
    :param invert: if invert, the region whose properties smaller than min or larger than max will be considered.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_pyaqcv.AqRegionSelectFeature_type_get, _pyaqcv.AqRegionSelectFeature_type_set)
    min = property(_pyaqcv.AqRegionSelectFeature_min_get, _pyaqcv.AqRegionSelectFeature_min_set)
    max = property(_pyaqcv.AqRegionSelectFeature_max_get, _pyaqcv.AqRegionSelectFeature_max_set)
    invert = property(_pyaqcv.AqRegionSelectFeature_invert_get, _pyaqcv.AqRegionSelectFeature_invert_set)

    def __init__(self):
        _pyaqcv.AqRegionSelectFeature_swiginit(self, _pyaqcv.new_AqRegionSelectFeature())
    __swig_destroy__ = _pyaqcv.delete_AqRegionSelectFeature

# Register AqRegionSelectFeature in _pyaqcv:
_pyaqcv.AqRegionSelectFeature_swigregister(AqRegionSelectFeature)
class PhotometricStero(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.PhotometricStero_swiginit(self, _pyaqcv.new_PhotometricStero())
    __swig_destroy__ = _pyaqcv.delete_PhotometricStero
    all_type = _pyaqcv.PhotometricStero_all_type
    albedo_type = _pyaqcv.PhotometricStero_albedo_type
    normal_type = _pyaqcv.PhotometricStero_normal_type
    gradient_type = _pyaqcv.PhotometricStero_gradient_type
    normalized_gradient_type = _pyaqcv.PhotometricStero_normalized_gradient_type
    height_type = _pyaqcv.PhotometricStero_height_type
    mean_shape_type = _pyaqcv.PhotometricStero_mean_shape_type
    gauss_shape_type = _pyaqcv.PhotometricStero_gauss_shape_type

    def photometric_stereo(self, *args):
        r"""
        calib/uncalib photometric stereo, execute it before getting results.
        :type images: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
        :param images:  the input images(only AQ_8UC1 type was supported) list.
        :type result_types: std::vector< aqcv::PhotometricStero::ResultType,std::allocator< aqcv::PhotometricStero::ResultType > >, optional
        :param result_types: the results in result_types will be calculate togather. When the value is empty, result will be calculate alone.
        :type tilts: std::vector< visionflow::geometry::Radian,std::allocator< visionflow::geometry::Radian > >, optional
        :param tilts: the calibrated tilts. When the value is empty, use uncalib photometric stereo.
        :type slants: std::vector< visionflow::geometry::Radian,std::allocator< visionflow::geometry::Radian > >, optional
        :param slants: the calibrated slants. When the value is empty, use uncalib photometric stereo.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.PhotometricStero_photometric_stereo(self, *args)

    def get_albedo(self, visual=False):
        r"""
        get albedo.
        :type visual: boolean, optional
        :param visual: Whether or not visualize.
        Notes: true-return the visualized mat, false-return the origin mat.
        """
        return _pyaqcv.PhotometricStero_get_albedo(self, visual)

    def get_normal(self, visual=False):
        r"""get normal."""
        return _pyaqcv.PhotometricStero_get_normal(self, visual)

    def get_gradient(self):
        r"""get gradient."""
        return _pyaqcv.PhotometricStero_get_gradient(self)

    def get_normalized_gradient(self):
        r"""get normalized gradient."""
        return _pyaqcv.PhotometricStero_get_normalized_gradient(self)

    def get_mean_shape(self, visual=False, sigma=1):
        r"""get mean shape."""
        return _pyaqcv.PhotometricStero_get_mean_shape(self, visual, sigma)

    def get_gauss_shape(self, visual=False, sigma=1):
        r"""get gauss shape."""
        return _pyaqcv.PhotometricStero_get_gauss_shape(self, visual, sigma)

    def get_height(self, visual=False):
        r"""get height which is imcomplete.(TODO)"""
        return _pyaqcv.PhotometricStero_get_height(self, visual)

    def set_precision(self, precision):
        r"""
        Set/Get precision.
        :type precision: float
        :param precision: Speed up uncalib photometric stereo, 0.1 - 1, default is 1 - don't speed up. When the speed is faster, the result could be worse.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.PhotometricStero_set_precision(self, precision)

    def get_precision(self):
        return _pyaqcv.PhotometricStero_get_precision(self)

# Register PhotometricStero in _pyaqcv:
_pyaqcv.PhotometricStero_swigregister(PhotometricStero)
class PhotometricSteroCalib(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.PhotometricSteroCalib_swiginit(self, _pyaqcv.new_PhotometricSteroCalib())
    __swig_destroy__ = _pyaqcv.delete_PhotometricSteroCalib

    def calibration(self, images, tilts, slants, threshold=170):
        r"""
        photometric stereo calibration.
        :type images: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
        :param images:  the input images(only AQ_8UC1 type image was supported) list.
        :type tilts: std::vector< visionflow::geometry::Radian,std::allocator< visionflow::geometry::Radian > >
        :param tilts: the angle with x-y plane.
        :type slants: std::vector< visionflow::geometry::Radian,std::allocator< visionflow::geometry::Radian > >
        :param slants: the angle with z axis.
        :type threshold: int, optional
        :param threshold: pixel value > threshold will be selected to calibrate, please set the value smaller when the light is weak.
        Notes: threshold value range is [0,255]
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.PhotometricSteroCalib_calibration(self, images, tilts, slants, threshold)

    def set_find_sphere_model(self, auto_find, threshold=40):
        r"""
        Set/Get finding sphere model.
        :type auto_find: boolean
        :param auto_find: auto find circle(sphere).
        :type threshold: int, optional
        :param threshold:  pixel value > threshold will be selected as a part of circle.
        Notes: threshold value range is [0,255]
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.PhotometricSteroCalib_set_find_sphere_model(self, auto_find, threshold)

    def get_find_sphere_model(self):
        return _pyaqcv.PhotometricSteroCalib_get_find_sphere_model(self)

    def set_sphere_position(self, center, radius):
        r"""
        Set/Get sphere position.
        :type center: :py:class:`Point2f`
        :param center: calibration sphere's center point.
        :type radius: float
        :param radius: calibration sphere's radius.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.PhotometricSteroCalib_set_sphere_position(self, center, radius)

    def get_sphere_position(self, center, radius):
        return _pyaqcv.PhotometricSteroCalib_get_sphere_position(self, center, radius)

# Register PhotometricSteroCalib in _pyaqcv:
_pyaqcv.PhotometricSteroCalib_swigregister(PhotometricSteroCalib)
class Pose3DBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Pose3DType_kPoseRTMatrix = _pyaqcv.Pose3DBase_Pose3DType_kPoseRTMatrix
    r"""RT Matrix"""
    Pose3DType_kPoseAngleAxis = _pyaqcv.Pose3DBase_Pose3DType_kPoseAngleAxis
    r"""Axis Angle"""
    Pose3DType_kPoseQuad = _pyaqcv.Pose3DBase_Pose3DType_kPoseQuad
    r"""Quaternion"""
    __swig_destroy__ = _pyaqcv.delete_Pose3DBase

    def get_rt_matrix(self):
        return _pyaqcv.Pose3DBase_get_rt_matrix(self)

# Register Pose3DBase in _pyaqcv:
_pyaqcv.Pose3DBase_swigregister(Pose3DBase)
class Pose3DRT(Pose3DBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor

        |

        *Overload 2:*

        Constructor
        :type RT: :py:class:`Mat`
        :param RT:  input RT 4X4  or 3x4 matrix

        |

        *Overload 3:*

        Constructor
        :type pose: :py:class:`Pose3DRT`
        :param pose: Pose3DRT

        |

        *Overload 4:*

        Constructor
        :type R: :py:class:`Mat`
        :param R: rotation 3X3 matrix
        :type T: :py:class:`Mat`
        :param T: translation 3X1 matrix
        """
        _pyaqcv.Pose3DRT_swiginit(self, _pyaqcv.new_Pose3DRT(*args))
    __swig_destroy__ = _pyaqcv.delete_Pose3DRT

    def get_rt_matrix(self):
        r"""
        Get RT 4X4 matrix
        :rtype: :py:class:`Mat`
        :return: RT 4X4 matrix
        """
        return _pyaqcv.Pose3DRT_get_rt_matrix(self)

    def get_rotation(self):
        r"""
        Get rotation 3X3 matrix
        :rtype: :py:class:`Mat`
        :return: rotation 3X3 matrix
        """
        return _pyaqcv.Pose3DRT_get_rotation(self)

    def get_translation(self):
        r"""
        Get translation 3X1 matrix
        :rtype: :py:class:`Mat`
        :return: translation 3X1 matrix
        """
        return _pyaqcv.Pose3DRT_get_translation(self)

    def return_invert(self):
        r"""
        return inverted pose,current pose will not be changed
        :rtype: :py:class:`Pose3DRT`
        :return: inverted pose
        """
        return _pyaqcv.Pose3DRT_return_invert(self)

    def return_compose_with(self, pose_B):
        r"""
        compose two pose, current pose will be treated as A
        result will be  :math:`pose_{result} = pose_A * pose_B`
        :type pose_B: :py:class:`Pose3DRT`
        :param pose_B: B matrix
        :rtype: :py:class:`Pose3DRT`
        :return: new pose of A*B
        Notes: the multiply order is difference with 'Pose3DRT::transform'
        """
        return _pyaqcv.Pose3DRT_return_compose_with(self, pose_B)

    def invert(self):
        r"""
        invert current pose
        :rtype: :py:class:`Pose3DRT`
        :return: reference of current pose(inverted)
        """
        return _pyaqcv.Pose3DRT_invert(self)

    def set_rotation(self, R):
        r"""
        Set current pose's rotation to R
        :type R: :py:class:`Mat`
        :param R:  rotation 3X3 matrix in AQ_64FC1 type
        :rtype: boolean
        :return: true if ok, false when Mat is not 3x3 in AQ_64FC1 type
        """
        return _pyaqcv.Pose3DRT_set_rotation(self, R)

    def set_translation_mat(self, T):
        r"""
        Set translation matrix
        :type T: :py:class:`Mat`
        :param T:  translation 3X1 matrix
        :rtype: boolean
        :return: true if ok, false when Mat is not 3x1 in AQ_64FC1 type
        """
        return _pyaqcv.Pose3DRT_set_translation_mat(self, T)

    def set_translation(self, tx, ty, tz):
        r"""
        Set translation matrix
        :type tx: float
        :param tx:  translation x position
        :type ty: float
        :param ty:  translation y position
        :type tz: float
        :param tz:  translation z position
        :rtype: :py:class:`Pose3DRT`
        :return: reference of current pose
        """
        return _pyaqcv.Pose3DRT_set_translation(self, tx, ty, tz)

    def transform(self, pose_B):
        r"""
         compose with another pose, current pose will be treated as A
        current pose will be  :math:`pose_A = pose_B * pose_A`
        :type pose_B: :py:class:`Pose3DRT`
        :param pose_B: pose indicating transform infomation
        :rtype: :py:class:`Pose3DRT`
        :return: reference of current pose(transformed)
        Notes: the multiply order is difference with 'return_compose_with'
        """
        return _pyaqcv.Pose3DRT_transform(self, pose_B)

    def rotate(self, *args):
        r"""
        *Overload 1:*

        rotate current pose

         .. math::

             R = R_z * R_y * R_x
        where

         .. math::

             R_x = \begin{bmatrix} 1 & 0 & 0 \\ 0 & cos(x) & -sin(x) \\ 0 & sin(x) & cos(x) \end{bmatrix}
             R_y = \begin{bmatrix} cos(y) & 0 & sin(y) \\ 0 & 1 & 0 \\ -sin(y) & 0 & cos(y) \end{bmatrix}
             R_z = \begin{bmatrix} cos(x) & -sin(x) & 0 \\ sin(x) & cos(x) & 0 \\ 0 & 0 & 1  \end{bmatrix}
        the result will be

         .. math::

             Pose = \begin{bmatrix}1& 0 & 0 & center.x \\ 0 & 1 & 0 & center.y \\ 0 & 0 & 1 & center.y \\0 & 0 & 0 & 1\end{bmatrix}
             * \begin{bmatrix} R & & & 0 \\ & & & 0\\& & & 0\\ 0 & 0 & 0 & 1\end{bmatrix}
             * \begin{bmatrix}1& 0 & 0 & -center.x \\ 0 & 1 & 0 & -center.y \\ 0 & 0 & 1 & -center.y\\0 & 0 & 0 & 1\end{bmatrix} * Pose
        :type center: :py:class:`Point3d`
        :param center:  rotate center
        :type x: :py:class:`Radian`
        :param x:  rotation angle around x axis
        :type y: :py:class:`Radian`
        :param y:  rotation angle around y axis
        :type z: :py:class:`Radian`
        :param z:  rotation angle around z axis
        :rtype: :py:class:`Pose3DRT`
        :return: reference of current pose(rotated)

        |

        *Overload 2:*

        rotate current pose around axis angle
        :type center: :py:class:`Point3d`
        :param center:  rotate center
        :type angle_axis: :py:class:`Vec3d`
        :param angle_axis:  rotate axis
        :type angle: :py:class:`Radian`
        :param angle:  rotation angle around axis
        :rtype: :py:class:`Pose3DRT`
        :return: reference of current pose(rotated)
            the result will be

             .. math::

                 Pose = \begin{bmatrix}1& 0 & 0 & center.x \\ 0 & 1 & 0 & center.y \\ 0 & 0 & 1 & center.y \\0 & 0 & 0 & 1\end{bmatrix}
                 * \begin{bmatrix} R & & & 0 \\ & & & 0\\& & & 0\\ 0 & 0 & 0 & 1\end{bmatrix}
                 * \begin{bmatrix}1& 0 & 0 & -center.x \\ 0 & 1 & 0 & -center.y \\ 0 & 0 & 1 & -center.y\\0 & 0 & 0 & 1\end{bmatrix} * Pose

         .. math::

             R = u \cdot u^T + cos(angle) \cdot(I - u . u^T) + sin(angle) \cdot S
        where.. math::

            u = \frac{Axis}{\parallel Axis \parallel} = (\acute{x}, \acute{y}, \acute{y})^T \quad
             I = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} \quad
            S = \begin{bmatrix} 0 & -\acute{z} & \acute{y} \\ \acute{z} & 0 & -\acute{x} \\ -\acute{y} & \acute{x} & 0\end{bmatrix}
        """
        return _pyaqcv.Pose3DRT_rotate(self, *args)

    def translate(self, *args):
        r"""
        translate current pose
        :type tx: float
        :param tx:  translation in x axis
        :type ty: float
        :param ty:  translation in y axis
        :type tz: float
        :param tz:  translation in z axis
        :rtype: :py:class:`Pose3DRT`
        :return: reference of current pose(translated)
            the result will be

             .. math::

                 Pose = \begin{bmatrix}1& 0 & 0 & tx \\ 0 & 1 & 0 & ty \\ 0 & 0 & 1 & ty \\0 & 0 & 0 & 1\end{bmatrix} * Pose
        """
        return _pyaqcv.Pose3DRT_translate(self, *args)

# Register Pose3DRT in _pyaqcv:
_pyaqcv.Pose3DRT_swigregister(Pose3DRT)
class CameraViewFeatures(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Features extracted from one camera viewing a calibration board
        :type img_points: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_points:  image feature points, unit is pixel
        :type obj_points: std::vector< aqcv::Point3f,std::allocator< aqcv::Point3f > >
        :param obj_points:  physical feature points, unit is meter
        :type idx: std::vector< int,std::allocator< int > >, optional
        :param idx:  image feature points index.can default

        |

        *Overload 2:*

        Features extracted from one camera viewing a calibration board
        :type img_points: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_points:  image feature points, unit is pixel
        :type obj_points: std::vector< aqcv::Point3f,std::allocator< aqcv::Point3f > >
        :param obj_points:  physical feature points, unit is meter
        :param idx:  image feature points index.can default
        """
        _pyaqcv.CameraViewFeatures_swiginit(self, _pyaqcv.new_CameraViewFeatures(*args))
    __swig_destroy__ = _pyaqcv.delete_CameraViewFeatures

    def is_valid(self):
        r"""
        Judge the features is not valid
        :rtype: boolean
        :return: valid is true, not valid is false
        """
        return _pyaqcv.CameraViewFeatures_is_valid(self)

    def get_image_pts(self):
        r"""
        Get image points features
        :rtype: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :return: image points features
        """
        return _pyaqcv.CameraViewFeatures_get_image_pts(self)

    def get_indexs(self):
        r"""
        Get image points features
        :rtype: std::vector< int,std::allocator< int > >
        :return: image points features' indexs
        """
        return _pyaqcv.CameraViewFeatures_get_indexs(self)

    def get_features(self, img_points, obj_points, idx=None):
        r"""
        Get image points features and physical points features
        :type img_points: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_points: physical points features
        :type obj_points: std::vector< aqcv::Point3f,std::allocator< aqcv::Point3f > >
        :param obj_points: image points features
        :type idx: std::vector< int,std::allocator< int > >, optional
        :param idx: index of image points features
        """
        return _pyaqcv.CameraViewFeatures_get_features(self, img_points, obj_points, idx)

    def estimate_pixel_scale(self):
        r"""
         get estimated pixel scale in meter. this is estimated by the average distance between neighbor points
        :rtype: float
        :return: estimated pixel scale in meter. Negitave value indicates invalid.
        """
        return _pyaqcv.CameraViewFeatures_estimate_pixel_scale(self)

# Register CameraViewFeatures in _pyaqcv:
_pyaqcv.CameraViewFeatures_swigregister(CameraViewFeatures)
class CalibBoardModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kAQBoardRect = _pyaqcv.CalibBoardModel_kAQBoardRect
    r"""see user guide"""
    kAQBoardThreeWhite = _pyaqcv.CalibBoardModel_kAQBoardThreeWhite
    r"""see user guide"""
    kAQBoardThreeBig = _pyaqcv.CalibBoardModel_kAQBoardThreeBig
    r"""see user guide"""
    kChessBoard = _pyaqcv.CalibBoardModel_kChessBoard
    r"""see user guide"""
    kChessBoardWithOrigin = _pyaqcv.CalibBoardModel_kChessBoardWithOrigin
    r"""see user guide"""
    kWhite = _pyaqcv.CalibBoardModel_kWhite
    r"""background is white, only valid to kAQBoardRect, kAQBoardThreeWhite, kAQBoardThreeBig"""
    kBlack = _pyaqcv.CalibBoardModel_kBlack
    r"""background is black, only valid to kAQBoardRect, kAQBoardThreeWhite, kAQBoardThreeBig"""

    def __init__(self, *args):
        r"""

        :type type: int, optional
        :param type:  CalibBoard type. please see enum BoardType
        :type background: int, optional
        :param background:  BoardBackGround type. please see enum BoardBackGround
        :type grid_width: int, optional
        :param grid_width:  only valid to kAQBoardRect, kAQBoardThreeWhite, kAQBoardThreeBig
        :type grid_height: int, optional
        :param grid_height:  only valid to kAQBoardRect, kAQBoardThreeWhite, kAQBoardThreeBig
        :type scale: float, optional
        :param scale:  scale is the diatance between two circle center or two corner, unit is m
        :type diameter_rate: float, optional
        :param diameter_rate:  only valid to kAQBoardRect, kAQBoardThreeWhite, kAQBoardThreeBig
        """
        _pyaqcv.CalibBoardModel_swiginit(self, _pyaqcv.new_CalibBoardModel(*args))
    __swig_destroy__ = _pyaqcv.delete_CalibBoardModel

    def detect(self, view_img, features):
        r"""
         extract points feature from a image
        :type view_img: :py:class:`Mat`
        :param view_img:  input camera view image
        :type features: :py:class:`CameraViewFeatures`
        :param features:  output points feature
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CalibBoardModel_detect(self, view_img, features)

# Register CalibBoardModel in _pyaqcv:
_pyaqcv.CalibBoardModel_swigregister(CalibBoardModel)
class CameraIntrinParamNoneLinear(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_CameraIntrinParamNoneLinear

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Camera nonelinear params including linear param and distoration param
        :type width: int
        :param width: input width of camera image
        :type height: int
        :param height: input height of camera image

        |

        *Overload 2:*

        Camera nonelinear params include linear param and distoration param
        :type width: int
        :param width:  input width of camera image
        :type height: int
        :param height:  input height of camera image
        :type fx: float
        :param fx:  input focus in x direction
        :type fy: float
        :param fy:  input focus in y direction
        :type cx: float
        :param cx:  input x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  input y position of lens centers, unit is pixel
        :type k1: float, optional
        :param k1:  input radial lens distoration
        :type k2: float, optional
        :param k2:  input radial lens distoration
        :type p1: float, optional
        :param p1:  input tangential lens distortion
        :type p2: float, optional
        :param p2:  input tangential lens distortion
        :type k3: float, optional
        :param k3:  input radial lens distoration

        |

        *Overload 3:*

        Camera nonelinear params include linear param and distoration param
        :type width: int
        :param width:  input width of camera image
        :type height: int
        :param height:  input height of camera image
        :type fx: float
        :param fx:  input focus in x direction
        :type fy: float
        :param fy:  input focus in y direction
        :type cx: float
        :param cx:  input x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  input y position of lens centers, unit is pixel
        :type k1: float, optional
        :param k1:  input radial lens distoration
        :type k2: float, optional
        :param k2:  input radial lens distoration
        :type p1: float, optional
        :param p1:  input tangential lens distortion
        :type p2: float, optional
        :param p2:  input tangential lens distortion
        :param k3:  input radial lens distoration

        |

        *Overload 4:*

        Camera nonelinear params include linear param and distoration param
        :type width: int
        :param width:  input width of camera image
        :type height: int
        :param height:  input height of camera image
        :type fx: float
        :param fx:  input focus in x direction
        :type fy: float
        :param fy:  input focus in y direction
        :type cx: float
        :param cx:  input x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  input y position of lens centers, unit is pixel
        :type k1: float, optional
        :param k1:  input radial lens distoration
        :type k2: float, optional
        :param k2:  input radial lens distoration
        :type p1: float, optional
        :param p1:  input tangential lens distortion
        :param p2:  input tangential lens distortion
        :param k3:  input radial lens distoration

        |

        *Overload 5:*

        Camera nonelinear params include linear param and distoration param
        :type width: int
        :param width:  input width of camera image
        :type height: int
        :param height:  input height of camera image
        :type fx: float
        :param fx:  input focus in x direction
        :type fy: float
        :param fy:  input focus in y direction
        :type cx: float
        :param cx:  input x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  input y position of lens centers, unit is pixel
        :type k1: float, optional
        :param k1:  input radial lens distoration
        :type k2: float, optional
        :param k2:  input radial lens distoration
        :param p1:  input tangential lens distortion
        :param p2:  input tangential lens distortion
        :param k3:  input radial lens distoration

        |

        *Overload 6:*

        Camera nonelinear params include linear param and distoration param
        :type width: int
        :param width:  input width of camera image
        :type height: int
        :param height:  input height of camera image
        :type fx: float
        :param fx:  input focus in x direction
        :type fy: float
        :param fy:  input focus in y direction
        :type cx: float
        :param cx:  input x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  input y position of lens centers, unit is pixel
        :type k1: float, optional
        :param k1:  input radial lens distoration
        :param k2:  input radial lens distoration
        :param p1:  input tangential lens distortion
        :param p2:  input tangential lens distortion
        :param k3:  input radial lens distoration

        |

        *Overload 7:*

        Camera nonelinear params include linear param and distoration param
        :type width: int
        :param width:  input width of camera image
        :type height: int
        :param height:  input height of camera image
        :type fx: float
        :param fx:  input focus in x direction
        :type fy: float
        :param fy:  input focus in y direction
        :type cx: float
        :param cx:  input x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  input y position of lens centers, unit is pixel
        :param k1:  input radial lens distoration
        :param k2:  input radial lens distoration
        :param p1:  input tangential lens distortion
        :param p2:  input tangential lens distortion
        :param k3:  input radial lens distoration

        |

        *Overload 8:*

        Camera nonelinear params include linear param and distoration param
        :type width: int
        :param width:  input width of camera image
        :type height: int
        :param height:  input height of camera image
        :type intr_param: :py:class:`Mat`
        :param intr_param: input intr_param look like:

                   .. math::

                       \begin{bmatrix}fx & 0 & cx \\ 0 & fy & cy \\ 0 & 0 & 1 \end{bmatrix}
        :type dist_param: :py:class:`Mat`
        :param dist_param:  input dist_param look like:

                   .. math::

                       \begin{bmatrix} k1 & k2 & p1 & p2 & k3 \end{bmatrix}
        """
        _pyaqcv.CameraIntrinParamNoneLinear_swiginit(self, _pyaqcv.new_CameraIntrinParamNoneLinear(*args))

    def get_param(self, *args):
        r"""
        *Overload 1:*

        Get camera nonelinear params
        :type width: int
        :param width:  output width of camera image
        :type height: int
        :param height:  output height of camera image
        :type fx: float
        :param fx:  output focus in x direction
        :type fy: float
        :param fy:  output focus in y direction
        :type cx: float
        :param cx:  output x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  output y position of lens centers, unit is pixel
        :type k1: float
        :param k1:  output radial lens distoration
        :type k2: float
        :param k2:  output radial lens distoration
        :type p1: float
        :param p1:  output tangential lens distortion
        :type p2: float
        :param p2:  output tangential lens distortion
        :type k3: float
        :param k3:  output radial lens distoration

        |

        *Overload 2:*

        Get camera nonelinear params
        :type width: int
        :param width:  output width of camera image
        :type height: int
        :param height:  output height of camera image
        :type intr_param: :py:class:`Mat`
        :param intr_param: output intr_param look like:

                   .. math::

                       \begin{bmatrix} fx & 0 & cx \\ 0 & fy & cy \\ 0 & 0 & 1 \end{bmatrix}
        :type dist_param: :py:class:`Mat`
        :param dist_param:  output dist_param look like:

                   .. math::

                       \begin{bmatrix} k1 & k2 & p1 & p2 & k3 \end{bmatrix}
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_get_param(self, *args)

    def get_size(self, width, height):
        r"""
        Get camera image size
        :type width: int
        :param width:  output width of camera image
        :type height: int
        :param height:  output height of camera image
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_get_size(self, width, height)

    def set_size(self, width, height):
        r"""
        Set camera image size
        :type width: int
        :param width:  inout width of camera image
        :type height: int
        :param height:  input height of camera image
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_set_size(self, width, height)

    def get_intrinsic(self):
        r"""
        Get camera linear param part
        :rtype: :py:class:`Mat`
        :return: output look like:

                   .. math::

                       \begin{bmatrix}
                             k1 & k2 & p1 & p2 & k3
                             \end{bmatrix}
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_get_intrinsic(self)

    def set_intrinsic(self, intr):
        r"""
        Set camera linear param part
        :type intr: :py:class:`Mat`
        :param intr:  input look like:

                   .. math::

                       \begin{bmatrix}
                             k1 & k2 & p1 & p2 & k3
                             \end{bmatrix}
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_set_intrinsic(self, intr)

    def get_distoration(self):
        r"""
        Get camera distoration param part
        :rtype: :py:class:`Mat`
        :return: output look like:

                   .. math::

                       \begin{bmatrix}
                             fx & 0 & cx \\
                             0 & fy & cy \\
                             0 & 0 & 1
                             \end{bmatrix}
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_get_distoration(self)

    def set_distoration(self, dist):
        r"""
        Set camera distoration param part
        :type dist: :py:class:`Mat`
        :param dist:  input look like:

                   .. math::

                       \begin{bmatrix}
                             fx & 0 & cx \\
                             0 & fy & cy \\
                             0 & 0 & 1
                             \end{bmatrix}
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_set_distoration(self, dist)

    def is_valid(self):
        r"""
        whether CameraIntrinParamNoneLinear is valid(fx>0, fy>0, width>0 and height > 0)
        :rtype: boolean
        :return: valid is true, not valid is false
        """
        return _pyaqcv.CameraIntrinParamNoneLinear_is_valid(self)

# Register CameraIntrinParamNoneLinear in _pyaqcv:
_pyaqcv.CameraIntrinParamNoneLinear_swigregister(CameraIntrinParamNoneLinear)
class CameraModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Camera model including camera intrinsic param and camera pose
        :type camera_param: :py:class:`CameraIntrinParamNoneLinear`
        :param camera_param:  input camera intrinsic param
        :type camera_name: string, optional
        :param camera_name:  input a name with a camera
        :type camera_pose: :py:class:`Pose3DRT`, optional
        :param camera_pose:  input see Pose3DRT

        |

        *Overload 2:*

        Camera model including camera intrinsic param and camera pose
        :type camera_param: :py:class:`CameraIntrinParamNoneLinear`
        :param camera_param:  input camera intrinsic param
        :type camera_name: string, optional
        :param camera_name:  input a name with a camera
        :param camera_pose:  input see Pose3DRT

        |

        *Overload 3:*

        Camera model including camera intrinsic param and camera pose
        :type camera_param: :py:class:`CameraIntrinParamNoneLinear`
        :param camera_param:  input camera intrinsic param
        :param camera_name:  input a name with a camera
        :param camera_pose:  input see Pose3DRT
        """
        _pyaqcv.CameraModel_swiginit(self, _pyaqcv.new_CameraModel(*args))
    __swig_destroy__ = _pyaqcv.delete_CameraModel

    def set_camera_param(self, camera_param):
        r"""
        Set camera intrinsic param
        :type camera_param: :py:class:`CameraIntrinParamNoneLinear`
        :param camera_param:  input camera intrinsic param
        """
        return _pyaqcv.CameraModel_set_camera_param(self, camera_param)

    def get_camera_param(self, *args):
        r"""
        *Overload 1:*

        Get camera intrinsic param
        :rtype: :py:class:`CameraIntrinParamNoneLinear`
        :return: see CameraIntrinParamNoneLinear

        |

        *Overload 2:*

        Get camera intrinsic param
        :rtype: :py:class:`CameraIntrinParamNoneLinear`
        :return: see CameraIntrinParamNoneLinear
        Notes: this is const function
        """
        return _pyaqcv.CameraModel_get_camera_param(self, *args)

    def set_camera_pose(self, camera_pose):
        r"""
        Set camera pose
        :param input: see Pose3DRT
        """
        return _pyaqcv.CameraModel_set_camera_pose(self, camera_pose)

    def get_camera_pose(self, *args):
        r"""
        *Overload 1:*

        Get camera pose
        :rtype: :py:class:`Pose3DRT`
        :return: see Pose3DRT

        |

        *Overload 2:*

        Get camera pose
        :rtype: :py:class:`Pose3DRT`
        :return: see Pose3DRT
        Notes: this is const function
        """
        return _pyaqcv.CameraModel_get_camera_pose(self, *args)

    def compute_obj_pose(self, *args):
        r"""
        *Overload 1:*

        Computing camera view object pose
        :type img_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_pts:  inout camera view image points
        :type obj_pts: std::vector< aqcv::Point3f,std::allocator< aqcv::Point3f > >
        :param obj_pts:  input physical object points
        :type view_pose: :py:class:`Pose3DRT`
        :param view_pose:  output camrea view object pose,see Pose3DRT
        :rtype: boolean
        :return: success is true, failure is false

        |

        *Overload 2:*

        Computing camera view object pose
        :type board_model: :py:class:`CalibBoardModel`
        :param board_model: calib board model
        :type img: :py:class:`Mat`
        :param img:  input image
        :type pose: :py:class:`Pose3DRT`
        :param pose:  pose of img in camera
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraModel_compute_obj_pose(self, *args)

    def is_valid(self):
        r"""
        whether the CameraModel is valid(camera parameter valid) or not
        :rtype: boolean
        :return: valid is true, not valid is false
        """
        return _pyaqcv.CameraModel_is_valid(self)

    def image_points_to_world_plane(self, world_plane, img_pts, world_pts):
        r"""
        Project image points to world_plane(plane of measurements)
        :type world_plane: :py:class:`Pose3DRT`
        :param world_plane:  pose world_plane in camera
        :type img_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_pts:  points in image coordinate system
        :type world_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param world_pts:  points in world coordinate system
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraModel_image_points_to_world_plane(self, world_plane, img_pts, world_pts)

    def world_plane_points_to_image(self, world_plane, world_pts, img_pts):
        r"""
        Project world_plane(plane of measurements) to image points
        :type world_plane: :py:class:`Pose3DRT`
        :param world_plane:  pose world_plane in camera
        :type world_pts: std::vector< aqcv::Point3f,std::allocator< aqcv::Point3f > >
        :param world_pts:  points in world coordinate system
        :type img_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_pts:  points in image coordinate system
        """
        return _pyaqcv.CameraModel_world_plane_points_to_image(self, world_plane, world_pts, img_pts)

    def image_to_world_plane(self, world_plane, img, world_image, scale, out_image_size):
        r"""
        Rectify image into world_plane(plane of measurements)
        :type world_plane: :py:class:`Pose3DRT`
        :param world_plane:  pose world_plane in camera
        :type img: :py:class:`Mat`
        :param img:  inout image
        :type world_image: :py:class:`Mat`
        :param world_image:  rectified image
        :type scale: float
        :param scale:  m/pixel, such as 0.001==1mm/pixel
        :type out_image_size: :py:class:`Size`
        :param out_image_size:  rectified image size
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraModel_image_to_world_plane(self, world_plane, img, world_image, scale, out_image_size)

# Register CameraModel in _pyaqcv:
_pyaqcv.CameraModel_swigregister(CameraModel)
class PointPairCameraModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kTranslation = _pyaqcv.PointPairCameraModel_kTranslation
    r"""minimum required one points"""
    kTranslationRotationScale = _pyaqcv.PointPairCameraModel_kTranslationRotationScale
    r"""minimum required two points"""
    kAffine = _pyaqcv.PointPairCameraModel_kAffine
    r"""minimum required three points"""
    kPerspective = _pyaqcv.PointPairCameraModel_kPerspective
    r"""minimum required four points"""

    def __init__(self, *args):
        _pyaqcv.PointPairCameraModel_swiginit(self, _pyaqcv.new_PointPairCameraModel(*args))
    __swig_destroy__ = _pyaqcv.delete_PointPairCameraModel

    def set_model(self, matrix_33):
        r"""
        set transformation matrix(single channel kDepth64 type wit 3x3),
        :rtype: boolean
        :return: true if matrix's content conformance to the specified PointPairCameraModelType.
        """
        return _pyaqcv.PointPairCameraModel_set_model(self, matrix_33)

    def set_calib_type(self, type):
        r"""
        set calib type
        :type type: int
        :param type: PointPaircalibType to set.
        """
        return _pyaqcv.PointPairCameraModel_set_calib_type(self, type)

    def get_calib_type(self):
        r"""
        get calib type
        :rtype: int
        :return: current PointPaircalibType.
        """
        return _pyaqcv.PointPairCameraModel_get_calib_type(self)

    def get_model(self):
        r"""get transformation matrix"""
        return _pyaqcv.PointPairCameraModel_get_model(self)

    def calib(self, img_pts, world_pts, error):
        return _pyaqcv.PointPairCameraModel_calib(self, img_pts, world_pts, error)

    def image_points_to_world_plane(self, img_pts, world_pts):
        r"""
        Project image points to world_plane(plane of measurements)
        :param world_plane:  pose world_plane in camera
        :type img_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_pts:  points in image coordinate system
        :type world_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param world_pts:  points in world coordinate system
        """
        return _pyaqcv.PointPairCameraModel_image_points_to_world_plane(self, img_pts, world_pts)

    def world_plane_points_to_image(self, world_pts, img_pts):
        r"""
        Project world_plane(plane of measurements) to image points
        :param world_plane:  pose world_plane in camera
        :type world_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param world_pts:  points in world coordinate system
        :type img_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_pts:  points in image coordinate system
        """
        return _pyaqcv.PointPairCameraModel_world_plane_points_to_image(self, world_pts, img_pts)

    def image_to_world_plane(self, img, world_image, scale, out_image_size):
        r"""
        Rectify image into world_plane(plane of measurements)
        :param world_plane:  pose world_plane in camera
        :type img: :py:class:`Mat`
        :param img:  inout image
        :type world_image: :py:class:`Mat`
        :param world_image:  rectified image
        :type scale: float
        :param scale:  m/pixel, such as 0.001==1mm/pixel
        :type out_image_size: :py:class:`Size`
        :param out_image_size:  rectified image size
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.PointPairCameraModel_image_to_world_plane(self, img, world_image, scale, out_image_size)

# Register PointPairCameraModel in _pyaqcv:
_pyaqcv.PointPairCameraModel_swigregister(PointPairCameraModel)
class SingleCameraCalib(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, camera_model, fix_intrinsic):
        r"""
        Create single camera calibrater
        :type camera_model: :py:class:`CameraModel`
        :param camera_model:  input camera model
        :type fix_intrinsic: boolean
        :param fix_intrinsic:  input is or not using intrinsic fixed
        """
        _pyaqcv.SingleCameraCalib_swiginit(self, _pyaqcv.new_SingleCameraCalib(camera_model, fix_intrinsic))
    __swig_destroy__ = _pyaqcv.delete_SingleCameraCalib

    def set_ignore_tangent_dist(self, ignore_tangent_dist):
        return _pyaqcv.SingleCameraCalib_set_ignore_tangent_dist(self, ignore_tangent_dist)

    def get_ignore_tangent_dist(self):
        return _pyaqcv.SingleCameraCalib_get_ignore_tangent_dist(self)

    def add_view_feature(self, view_idx, viewfeature):
        r"""
        Add calibrate feature
        :type view_idx: int
        :param view_idx:  camera view features index
        :type viewfeature: :py:class:`CameraViewFeatures`
        :param viewfeature:  camera view features, see CameraViewFeatures
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_add_view_feature(self, view_idx, viewfeature)

    def set_calibboard(self, board_info):
        r"""
        Set calibrate board
        :type board_info: :py:class:`CalibBoardModel`
        :param board_info:  calib board infomation, see CalibBoardModel
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_set_calibboard(self, board_info)

    def add_view_image(self, view_idx, img):
        r"""
        Add calibrate board view image
        :type view_idx: int
        :param view_idx:  camera view image index
        :type img: :py:class:`Mat`
        :param img:  camera view image
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_add_view_image(self, view_idx, img)

    def calibrate(self):
        r"""
        Run calibrate
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_calibrate(self)

    def get_camera_model(self, *args):
        r"""
        *Overload 1:*

        Get camera model
        :rtype: :py:class:`CameraModel`
        :return: Camera model, see CameraModel
        Notes: this is const function

        |

        *Overload 2:*

        Get camera model
        :rtype: :py:class:`CameraModel`
        :return: Camera model, see CameraModel
        """
        return _pyaqcv.SingleCameraCalib_get_camera_model(self, *args)

    def get_view_feature(self, view_idx, viewfeature):
        r"""
        Get camera view features
        :type view_idx: int
        :param view_idx:  input camera view index
        :type viewfeature: :py:class:`CameraViewFeatures`
        :param viewfeature:  output camera view feature of index
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_get_view_feature(self, view_idx, viewfeature)

    def get_all_view_feature(self):
        r"""
        Get all camera view features
        :rtype: std::map< int,aqcv::CameraViewFeatures,std::less< int >,std::allocator< std::pair< int const,aqcv::CameraViewFeatures > > >
        :return: all camera view features
        """
        return _pyaqcv.SingleCameraCalib_get_all_view_feature(self)

    def get_view_pose(self, id, pose):
        r"""
        Get view pose
        :type id: int
        :param id:  input camera view index
        :type pose: :py:class:`Pose3DRT`
        :param pose:  output camera view object pose
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_get_view_pose(self, id, pose)

    def get_all_view_pose(self):
        r"""
        Get all view pose
        :rtype: std::map< int,aqcv::Pose3DRT,std::less< int >,std::allocator< std::pair< int const,aqcv::Pose3DRT > > >
        :return: all camera view pose
        """
        return _pyaqcv.SingleCameraCalib_get_all_view_pose(self)

    def get_rms(self):
        r"""
        Get rms error
        :rtype: float
        :return: mean rms error
        """
        return _pyaqcv.SingleCameraCalib_get_rms(self)

    def get_max_err(self):
        r"""
        Get max error
        :rtype: float
        :return: max error, unit is pixel
        Notes: rms-root mean square
        """
        return _pyaqcv.SingleCameraCalib_get_max_err(self)

    def get_view_project_pts(self, id, proj_pts):
        r"""
        Get points projected from 3d
        :type id: int
        :param id:  input camera view index
        :type proj_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param proj_pts:  output points projected from 3d
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_get_view_project_pts(self, id, proj_pts)

    def get_view_rms(self, id, rms_err):
        r"""
        Get each camera view rms error
        :type id: int
        :param id:  input camera view index
        :type rms_err: float
        :param rms_err:  output rms error
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_get_view_rms(self, id, rms_err)

    def get_all_view_rms(self):
        r"""
        Get all camera view rms error
        :rtype: std::map< int,double,std::less< int >,std::allocator< std::pair< int const,double > > >
        :return: all rms error
        """
        return _pyaqcv.SingleCameraCalib_get_all_view_rms(self)

    def get_view_max_err(self, id, max_err):
        r"""
        Get each camera view max error
        :type id: int
        :param id:  input camera view index
        :type max_err: float
        :param max_err:  output max error of corresponding to id, unit is pixel
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_get_view_max_err(self, id, max_err)

    def get_all_view_max_err(self):
        r"""
        Get all camera view max error
        :rtype: std::map< int,double,std::less< int >,std::allocator< std::pair< int const,double > > >
        :return: output max error, unit is pixel
        """
        return _pyaqcv.SingleCameraCalib_get_all_view_max_err(self)

    def get_world_coordinate(self, id, cam_in_obj):
        r"""
        Get WCS
        :type id: int
        :param id:  input camera view index
        :type cam_in_obj: :py:class:`Pose3DRT`
        :param cam_in_obj: output camera pose in reference object
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.SingleCameraCalib_get_world_coordinate(self, id, cam_in_obj)

# Register SingleCameraCalib in _pyaqcv:
_pyaqcv.SingleCameraCalib_swigregister(SingleCameraCalib)
class MultiCamerasCalib(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, cameras, ref_cam_idx):
        r"""
        Create multi camera calibrater
        :type cameras: std::vector< aqcv::CameraModel,std::allocator< aqcv::CameraModel > >
        :param cameras:  input camera model vector
        :type ref_cam_idx: int
        :param ref_cam_idx:  input reference camera index
        """
        _pyaqcv.MultiCamerasCalib_swiginit(self, _pyaqcv.new_MultiCamerasCalib(cameras, ref_cam_idx))
    __swig_destroy__ = _pyaqcv.delete_MultiCamerasCalib

    def set_calibboard(self, board_info):
        r"""
        Set calibrate board
        :type board_info: :py:class:`CalibBoardModel`
        :param board_info:  calib board infomation, see CalibBoardModel
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.MultiCamerasCalib_set_calibboard(self, board_info)

    def add_camera_view(self, *args):
        r"""
        *Overload 1:*

        Add calibrate feature
        :type cam_idx: int
        :param cam_idx:  camera index
        :type view_idx: int
        :param view_idx:  camera view features index
        :param viewfeature:  camera view features, see CameraViewFeatures
        :rtype: boolean
        :return: success is true, failure is false

        |

        *Overload 2:*

        Add camera view
        :type cam_idx: int
        :param cam_idx:  camera index
        :type view_idx: int
        :param view_idx:  camera view image index
        :type img: :py:class:`Mat`
        :param img:  camera view image
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.MultiCamerasCalib_add_camera_view(self, *args)

    def calibrate(self):
        r"""
        Run calibrate
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.MultiCamerasCalib_calibrate(self)

    def get_camera_model(self, cam_idx, camera_model):
        r"""
        Get camera model
        :type cam_idx: int
        :param cam_idx:  input camera index
        :type camera_model: :py:class:`CameraModel`
        :param camera_model: output camera model of corresponding to cam_idx
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.MultiCamerasCalib_get_camera_model(self, cam_idx, camera_model)

    def get_all_camera_model(self):
        r"""
        Get all camera model
        :rtype: std::vector< aqcv::CameraModel,std::allocator< aqcv::CameraModel > >
        :return: cameras model vector
        """
        return _pyaqcv.MultiCamerasCalib_get_all_camera_model(self)

    def get_all_view_feature(self):
        r"""
        Get all camera view features
        :rtype: std::vector< std::map< int,aqcv::CameraViewFeatures,std::less< int >,std::allocator< std::pair< int const,aqcv::CameraViewFeatures > > >,std::allocator< std::map< int,aqcv::CameraViewFeatures,std::less< int >,std::allocator< std::pair< int const,aqcv::CameraViewFeatures > > > > >
        :return: all camera view features
        """
        return _pyaqcv.MultiCamerasCalib_get_all_view_feature(self)

    def get_pose_in_ref(self):
        r"""
        Get all object pose in reference camera
        :rtype: std::map< int,aqcv::Pose3DRT,std::less< int >,std::allocator< std::pair< int const,aqcv::Pose3DRT > > >
        :return: all object pose
        """
        return _pyaqcv.MultiCamerasCalib_get_pose_in_ref(self)

    def get_rms(self):
        r"""
        Get rms error
        :rtype: float
        :return: mean rms error
        """
        return _pyaqcv.MultiCamerasCalib_get_rms(self)

    def get_max_err(self):
        r"""
        Get max error
        :rtype: float
        :return: max error, unit is pixel
        Notes: rms-root mean square
        """
        return _pyaqcv.MultiCamerasCalib_get_max_err(self)

    def get_view_project_pts(self, id, proj_pts):
        r"""
        Get points projected from 3d
        :type id: int
        :param id:  input camera view index
        :type proj_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param proj_pts:  output points projected from 3d
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.MultiCamerasCalib_get_view_project_pts(self, id, proj_pts)

    def get_view_rms(self, id, rms_err):
        r"""
        Get each camera view rms error
        :type id: int
        :param id:  input camera view index
        :type rms_err: float
        :param rms_err:  output rms error of corresponding to id
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.MultiCamerasCalib_get_view_rms(self, id, rms_err)

    def get_all_view_rms(self):
        r"""
        Get all camera view rms error
        :rtype: std::map< int,double,std::less< int >,std::allocator< std::pair< int const,double > > >
        :return: all rms error
        """
        return _pyaqcv.MultiCamerasCalib_get_all_view_rms(self)

    def get_view_max_err(self, id, max_err):
        r"""
        Get each camera view max error
        :type id: int
        :param id:  input camera view index
        :type max_err: float
        :param max_err:  output max error of corresponding to id, unit is pixel
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.MultiCamerasCalib_get_view_max_err(self, id, max_err)

    def get_all_view_max_err(self):
        r"""
        Get all camera view max error
        :rtype: std::map< int,double,std::less< int >,std::allocator< std::pair< int const,double > > >
        :return: output max error, unit is pixel
        """
        return _pyaqcv.MultiCamerasCalib_get_all_view_max_err(self)

# Register MultiCamerasCalib in _pyaqcv:
_pyaqcv.MultiCamerasCalib_swigregister(MultiCamerasCalib)
kNoHandEyeType = _pyaqcv.kNoHandEyeType
kIsEyeToHandSixAxisRobot = _pyaqcv.kIsEyeToHandSixAxisRobot
kIsEyeToHandFourAxisRobot = _pyaqcv.kIsEyeToHandFourAxisRobot
kIsEyeInHandSixAxisRobot = _pyaqcv.kIsEyeInHandSixAxisRobot
kIsEyeInHandFourAxisRobot = _pyaqcv.kIsEyeInHandFourAxisRobot
class HandEyeResult(object):
    r"""Result of handeye calib"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.HandEyeResult_swiginit(self, _pyaqcv.new_HandEyeResult())
    __swig_destroy__ = _pyaqcv.delete_HandEyeResult

    def is_valid(self):
        r"""
        Determine if HandEyeResult is valid
        :rtype: boolean
        :return: True is valid, false is not valid
        """
        return _pyaqcv.HandEyeResult_is_valid(self)

    def get_xxx_in_camera(self):
        r"""
        Get result of handeye calib
        :rtype: :py:class:`Pose3DRT`
        :return: HandToEye get base_in_camera, HandInEye get tool_in_camera
        """
        return _pyaqcv.HandEyeResult_get_xxx_in_camera(self)

    def get_obj_in_xxx(self):
        r"""
        Get result of handeye calib
        :rtype: :py:class:`Pose3DRT`
        :return: HandToEye get obj_in_tool, HandInEye get obj_in_base
        """
        return _pyaqcv.HandEyeResult_get_obj_in_xxx(self)

    def get_mean_position_error(self):
        r"""
        Get mean position error
        Notes: unit is m
        """
        return _pyaqcv.HandEyeResult_get_mean_position_error(self)

    def get_mean_rotation_error(self):
        r"""
        Get mean rotation error
        Notes: unit is degree
        """
        return _pyaqcv.HandEyeResult_get_mean_rotation_error(self)

    def get_max_position_error(self):
        r"""
        Get max position error
        Notes: unit is m
        """
        return _pyaqcv.HandEyeResult_get_max_position_error(self)

    def get_max_rotation_error(self):
        r"""
        Get max rotation error
        Notes: unit is degree
        """
        return _pyaqcv.HandEyeResult_get_max_rotation_error(self)

    def get_handeye_type(self):
        r"""
        Get handeye calib type
        :rtype: int
        :return: please see HandEyeType
        """
        return _pyaqcv.HandEyeResult_get_handeye_type(self)

    def get_delta_z(self):
        r"""
        Get scara fix ambiguity z value
        :rtype: float
        :return: z value
        """
        return _pyaqcv.HandEyeResult_get_delta_z(self)

# Register HandEyeResult in _pyaqcv:
_pyaqcv.HandEyeResult_swigregister(HandEyeResult)
class HandEyeCalib(object):
    r"""Process of handeye calib"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, handeye_type):
        r"""
        Step1 Create HandEyeCalib
        :type handeye_type: int
        :param handeye_type:  please see HandEyeType
        """
        _pyaqcv.HandEyeCalib_swiginit(self, _pyaqcv.new_HandEyeCalib(handeye_type))
    __swig_destroy__ = _pyaqcv.delete_HandEyeCalib

    def set_calibboard(self, calib_board):
        r"""
        Step2.1.1 Set calibboard
        :type calib_board: :py:class:`CalibBoardModel`
        :param calib_board:  calibboard description
        Notes: Step2.1, Step2.2 are not used at the same time
        """
        return _pyaqcv.HandEyeCalib_set_calibboard(self, calib_board)

    def add_robot_camera_data(self, *args):
        r"""
        *Overload 1:*

        Step2.1.2 Add robot and camera data related
        :type idx: int
        :param idx:  index of data
        :type robot_pose: :py:class:`Pose3DRT`
        :param robot_pose:  robot tool pose in robot base coordinate system, please see Pose3DRT
        :type camera_view_image: :py:class:`Mat`
        :param camera_view_image:  image of calibboard view, need firstly set_calibboard
        Notes: Step2.1, Step2.2 are not used at the same time

        |

        *Overload 2:*

        Step2.2.1 Add robot and camera data related
        :type idx: int
        :param idx:  index of data
        :type robot_pose: :py:class:`Pose3DRT`
        :param robot_pose:  robot tool pose in robot base coordinate system, please see Pose3DRT
        :type camera_view_pose: :py:class:`Pose3DRT`
        :param camera_view_pose:  calibboard pose in camera coordinate system, please see Pose3DRT
        Notes: Step2.1, Step2.2 are not used at the same time
        """
        return _pyaqcv.HandEyeCalib_add_robot_camera_data(self, *args)

    def set_scara_fix_ambiguity_data_handtoeye(self, ref_camera_view_pose, ref_robot_pose):
        r"""
        Step3.1 Add fix ambiguity data handtoeye, need move the robot tool to calibboard origin
        :type ref_camera_view_pose: :py:class:`Pose3DRT`
        :param ref_camera_view_pose:  calibboard pose in camera coordinate system, please see Pose3DRT
        :type ref_robot_pose: :py:class:`Pose3DRT`
        :param ref_robot_pose:  robot tool pose in robot base coordinate system, please see Pose3DRT
        Notes: Step3.1 is only used by kIsEyeToHandFourAxisRobot to calibrate delta_z
        Step3.1, Step3.2 and Step3.3 are not used at the same time
        """
        return _pyaqcv.HandEyeCalib_set_scara_fix_ambiguity_data_handtoeye(self, ref_camera_view_pose, ref_robot_pose)

    def set_scara_fix_ambiguity_data_handineye(self, ref_camera_view_pose, ref_robot_pose, origin_robot_pose):
        r"""
        Step3.2 Add fix ambiguity data handineye, first make camera can see both robot tool and calibboard, second move robot tool to calibboard origin
        :type ref_camera_view_pose: :py:class:`Pose3DRT`
        :param ref_camera_view_pose:  calibboard pose in camera coordinate system, please see Pose3DRT
        :type ref_robot_pose: :py:class:`Pose3DRT`
        :param ref_robot_pose:  robot tool pose in robot base coordinate system, please see Pose3DRT
        :type origin_robot_pose: :py:class:`Pose3DRT`
        :param origin_robot_pose:  robot tool pose in robot base coordinate system, when moving robot tool to calibboard origin, please see Pose3DRT
        Notes: Step3.2 is only used by kIsEyeInHandFourAxisRobot to calib delta_z
        Step3.1, Step3.2 and Step3.3 are not used at the same time
        """
        return _pyaqcv.HandEyeCalib_set_scara_fix_ambiguity_data_handineye(self, ref_camera_view_pose, ref_robot_pose, origin_robot_pose)

    def set_delta_z(self, delta_z):
        r"""
        Step3.3 Set scara fix ambiguity z value
        :type delta_z: float
        :param delta_z: unit is m.
        Notes: Step3.3 is only used when delta_z is known.
        Step3.1, Step3.2 and Step3.3 are not used at the same time
        """
        return _pyaqcv.HandEyeCalib_set_delta_z(self, delta_z)

    def calibrate(self):
        r"""
        Step4 run calibbate
        :rtype: boolean
        :return: True is success, false is not success
        """
        return _pyaqcv.HandEyeCalib_calibrate(self)

    def get_camera_view_pose(self, idx, camera_view_pose):
        r"""
        Get the index of calibboard pose in camera coordinate system, when input camera_view_image
        :type idx: int
        :param idx:  index of camera_view_pose
        :type camera_view_pose: :py:class:`Pose3DRT`
        :param camera_view_pose:  calibboard pose in camera coordinate system, please see Pose3DRT
        """
        return _pyaqcv.HandEyeCalib_get_camera_view_pose(self, idx, camera_view_pose)

    def get_all_camera_view_pose(self):
        r"""
        Get all calibboard pose in camera coordinate system, when input camera_view_image
        :rtype: std::map< int,aqcv::Pose3DRT,std::less< int >,std::allocator< std::pair< int const,aqcv::Pose3DRT > > >
        :return: all calibboard pose in camera coordinate system
        """
        return _pyaqcv.HandEyeCalib_get_all_camera_view_pose(self)

    def get_camera_model(self):
        r"""
        Get camera model
        :rtype: :py:class:`CameraModel`
        :return: please see CameraModel
        Notes: valid to Step2.1, not valid to Step2.2
        """
        return _pyaqcv.HandEyeCalib_get_camera_model(self)

    def get_handeye_result(self):
        r"""
        Get handeye result
        :rtype: :py:class:`HandEyeResult`
        :return: please see HandEyeRusult
        """
        return _pyaqcv.HandEyeCalib_get_handeye_result(self)

# Register HandEyeCalib in _pyaqcv:
_pyaqcv.HandEyeCalib_swigregister(HandEyeCalib)
class Blob(object):
    r"""
    blob's in image are organized by tree hierarchy(hold by class BlobHierarchies),you can get the pointer of
    blob to access it's properties.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.Blob_swiginit(self, _pyaqcv.new_Blob())
    __swig_destroy__ = _pyaqcv.delete_Blob

    def parent(self):
        r"""get pointer of current blob's parent(which directly containt current blob)"""
        return _pyaqcv.Blob_parent(self)

    def prev_sibling(self):
        r"""get pointer of current blob's previous sibling blob"""
        return _pyaqcv.Blob_prev_sibling(self)

    def next_sibling(self):
        r"""get pointer of current blob's next sibling blob"""
        return _pyaqcv.Blob_next_sibling(self)

    def first_child(self):
        r"""get pointer of current blob's first child blob"""
        return _pyaqcv.Blob_first_child(self)

    def last_child(self):
        r"""get pointer of current blob's last child blob"""
        return _pyaqcv.Blob_last_child(self)

    def empty(self):
        r"""
        whether the blob is empty(empty blob is used to hold the blob tree root or something else)
        it's your duty to check whether the blob is empty before you try to access all properties.
        """
        return _pyaqcv.Blob_empty(self)

    def child_count(self):
        r"""child blob count, only direct child, not include grand_childs."""
        return _pyaqcv.Blob_child_count(self)

    def id(self):
        r"""index of current blob"""
        return _pyaqcv.Blob_id(self)

    def label(self):
        r"""blob label, generally 0 indicates hole, 1 indicates target blob"""
        return _pyaqcv.Blob_label(self)

    def filtered(self):
        r"""whether current blob if filtered by filter rules 'BlobHierarchies::set_filter'"""
        return _pyaqcv.Blob_filtered(self)

    def clipped(self):
        r"""whether current blob is clipped out 'BlobHierarchies::ConnectivityType'"""
        return _pyaqcv.Blob_clipped(self)

    def area(self):
        r"""the area of current blob"""
        return _pyaqcv.Blob_area(self)

    def get_mass_center(self):
        r"""mass center of current blob"""
        return _pyaqcv.Blob_get_mass_center(self)

    def get_geom_center(self):
        r"""geometry center of current blob"""
        return _pyaqcv.Blob_get_geom_center(self)

    def get_bbox(self):
        r"""upright bounding box of current blob"""
        return _pyaqcv.Blob_get_bbox(self)

    def get_min_area_bbox(self):
        r"""min area bounding box of current blob"""
        return _pyaqcv.Blob_get_min_area_bbox(self)

    def get_x_moment(self):
        r"""blob's secondary moment in x axis direction"""
        return _pyaqcv.Blob_get_x_moment(self)

    def get_y_moment(self):
        r"""blob's secondary moment in y axis direction"""
        return _pyaqcv.Blob_get_y_moment(self)

    def get_min_moment(self):
        r"""blob's minimum secondary moment in it's angle direction"""
        return _pyaqcv.Blob_get_min_moment(self)

    def get_max_moment(self):
        r"""blob's maxmimum secondary moment"""
        return _pyaqcv.Blob_get_max_moment(self)

    def get_angle(self):
        r"""blob's direction(the direction with minimum secondary moment,  :math:`\frac{-\pi}{2}~\frac{\pi}{2}` )"""
        return _pyaqcv.Blob_get_angle(self)

    def get_elongation(self):
        r"""blob's elongation  :math:`E = \frac{{\chi _{max}^2}}{{\chi _{min}^2}}` , where min max means the minimum and maximum second moment"""
        return _pyaqcv.Blob_get_elongation(self)

    def get_principal_bbox(self):
        r"""bounding box in blob's principal direction(minimum second moment direction)"""
        return _pyaqcv.Blob_get_principal_bbox(self)

    def get_min_gray_val(self):
        r"""minimum gray value in the blob region"""
        return _pyaqcv.Blob_get_min_gray_val(self)

    def get_max_gray_val(self):
        r"""maximum gray value in the blob region"""
        return _pyaqcv.Blob_get_max_gray_val(self)

    def get_avg_gray_val(self):
        r"""mean gray value in the blob region"""
        return _pyaqcv.Blob_get_avg_gray_val(self)

    def get_stddiv_gray_val(self):
        r"""standard deviation of gray value in the blob region"""
        return _pyaqcv.Blob_get_stddiv_gray_val(self)

    def get_boundary_length(self):
        r"""blob's boundary pixels count(boundary pixels are 4-connect)"""
        return _pyaqcv.Blob_get_boundary_length(self)

    def get_perimeter(self):
        r"""blob's boundary pixels external edge length"""
        return _pyaqcv.Blob_get_perimeter(self)

    def get_circularity(self):
        r"""blob's circularity, standard circle's circularity is 1. 'circularity'"""
        return _pyaqcv.Blob_get_circularity(self)

    def get_roundness(self):
        r"""blob's roundness 'roundness'"""
        return _pyaqcv.Blob_get_roundness(self)

    def get_compactness(self):
        r"""get blob's compactness 'compactness'"""
        return _pyaqcv.Blob_get_compactness(self)

    def get_contour(self):
        r"""the blob contour with pixel boundary (do not contain hole's boundary)"""
        return _pyaqcv.Blob_get_contour(self)

    def get_region(self):
        r"""the blob region with pixel boundary polygon"""
        return _pyaqcv.Blob_get_region(self)

    def get_inner_points(self):
        r"""all pixels position in the blob"""
        return _pyaqcv.Blob_get_inner_points(self)

# Register Blob in _pyaqcv:
_pyaqcv.Blob_swigregister(Blob)
class BlobHierarchies(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_BlobHierarchies
    kWholeImageBlob = _pyaqcv.BlobHierarchies_kWholeImageBlob
    r"""take whole image none zero region as a single blob"""
    kGrayScale = _pyaqcv.BlobHierarchies_kGrayScale
    r"""take every connect reigon as a blob"""

    def connectivity_type(self):
        r"""get current blob hierarchies connectivity type"""
        return _pyaqcv.BlobHierarchies_connectivity_type(self)

    def minimum_blob_area(self):
        r"""minimum blob area to be accepted 'ExtractBlobs::set_minimum_area'"""
        return _pyaqcv.BlobHierarchies_minimum_blob_area(self)

    def first_top(self):
        r"""get first blob tree root"""
        return _pyaqcv.BlobHierarchies_first_top(self)

    def last_top(self):
        r"""get first blob tree root"""
        return _pyaqcv.BlobHierarchies_last_top(self)

    def get_blob(self, index):
        r"""get blob pointer with index"""
        return _pyaqcv.BlobHierarchies_get_blob(self, index)

    def draw_blob(self, blob_img, index=0):
        r"""
        draw a blob on out_img
        :type blob_img: :py:class:`Mat`
        :param blob_img: draw canvas, blob region is filled with 255 and bg are filled with zero
        :type index: int, optional
        :param index: which blob should be drawn,(0 means all blobs)
        """
        return _pyaqcv.BlobHierarchies_draw_blob(self, blob_img, index)

    def blob_count(self):
        r"""get blob count"""
        return _pyaqcv.BlobHierarchies_blob_count(self)

    def get_all_blobs(self):
        r"""get all blobs pointers"""
        return _pyaqcv.BlobHierarchies_get_all_blobs(self)

    def get_contours(self):
        r"""get all blobs contours"""
        return _pyaqcv.BlobHierarchies_get_contours(self)

    def to_multipolygon(self, polygons):
        r"""
        convert all blobs to MultiPolygon2i (hole blob will be ignored)
        :type polygons: :py:class:`MultiPolygon2i`
        :param polygons: result MultiPolygon2i
        :rtype: boolean
        :return: true if foreground blob not empty.
        """
        return _pyaqcv.BlobHierarchies_to_multipolygon(self, polygons)
    kLabel = _pyaqcv.BlobHierarchies_kLabel
    kArea = _pyaqcv.BlobHierarchies_kArea
    kChildrenCount = _pyaqcv.BlobHierarchies_kChildrenCount
    kAngle = _pyaqcv.BlobHierarchies_kAngle
    kBBoxCenterX = _pyaqcv.BlobHierarchies_kBBoxCenterX
    kBBoxCenterY = _pyaqcv.BlobHierarchies_kBBoxCenterY
    kBBoxX = _pyaqcv.BlobHierarchies_kBBoxX
    KBBoxY = _pyaqcv.BlobHierarchies_KBBoxY
    kBBoxWidth = _pyaqcv.BlobHierarchies_kBBoxWidth
    kBBoxHeight = _pyaqcv.BlobHierarchies_kBBoxHeight
    kBoundaryLength = _pyaqcv.BlobHierarchies_kBoundaryLength
    kPerimeter = _pyaqcv.BlobHierarchies_kPerimeter

    def set_filter(self, type, low_limit, high_limit):
        return _pyaqcv.BlobHierarchies_set_filter(self, type, low_limit, high_limit)

    def clear_filters(self):
        return _pyaqcv.BlobHierarchies_clear_filters(self)

    def sort(self, type, ascending):
        return _pyaqcv.BlobHierarchies_sort(self, type, ascending)

    def clear_sort(self):
        return _pyaqcv.BlobHierarchies_clear_sort(self)

# Register BlobHierarchies in _pyaqcv:
_pyaqcv.BlobHierarchies_swigregister(BlobHierarchies)
class ExtractBlobs(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.ExtractBlobs_swiginit(self, _pyaqcv.new_ExtractBlobs())
    __swig_destroy__ = _pyaqcv.delete_ExtractBlobs

    def segment_thresh(self, thresh, invert=False):
        r"""
        binarize image threshold
        :type thresh: int
        :param thresh:  threshold value to binarize image, value<thresh = 0, value >= thresh=255
                          if thresh < 0, auto threshold(OTSU) will be applied
        :type invert: boolean, optional
        :param invert:  invert the binarized image, value<thresh = 255
        """
        return _pyaqcv.ExtractBlobs_segment_thresh(self, thresh, invert)

    def set_mask(self, mask):
        r"""
        mask some region that don't care
        :type mask: :py:class:`Mat`
        :param mask:  mask image using to mask some region out
        """
        return _pyaqcv.ExtractBlobs_set_mask(self, mask)

    def set_mask_offset(self, offset):
        r"""mask image's coordinate offset relative to base image(on which to analysis blobs)"""
        return _pyaqcv.ExtractBlobs_set_mask_offset(self, offset)

    def clear_mask(self):
        r"""remove mask image"""
        return _pyaqcv.ExtractBlobs_clear_mask(self)
    kDilate3x1 = _pyaqcv.ExtractBlobs_kDilate3x1
    r"""kernel with size:wxh, e.g. 3x1 means the kernel is [1,1,1], and 1x3 means [1,1,1]^T"""
    kDilate1x3 = _pyaqcv.ExtractBlobs_kDilate1x3
    kDilate3x3 = _pyaqcv.ExtractBlobs_kDilate3x3
    kErode3x1 = _pyaqcv.ExtractBlobs_kErode3x1
    kErode1x3 = _pyaqcv.ExtractBlobs_kErode1x3
    kErode3x3 = _pyaqcv.ExtractBlobs_kErode3x3
    kOpen3x1 = _pyaqcv.ExtractBlobs_kOpen3x1
    kOpen1x3 = _pyaqcv.ExtractBlobs_kOpen1x3
    kOpen3x3 = _pyaqcv.ExtractBlobs_kOpen3x3
    kClose3x1 = _pyaqcv.ExtractBlobs_kClose3x1
    kClose1x3 = _pyaqcv.ExtractBlobs_kClose1x3
    kClose3x3 = _pyaqcv.ExtractBlobs_kClose3x3
    kDilate = _pyaqcv.ExtractBlobs_kDilate
    r"""kernel without size:only used in get_morph_ops_vec, must specify size before use"""
    kErode = _pyaqcv.ExtractBlobs_kErode
    kOpen = _pyaqcv.ExtractBlobs_kOpen
    kClose = _pyaqcv.ExtractBlobs_kClose

    @staticmethod
    def get_morph_ops_vec(morph_ops, type, kernel_size):
        r"""
        get a vector of morphology operations, support arbitrary size morphology operations.
        :type morph_ops: std::vector< aqcv::ExtractBlobs::MorphOpType,std::allocator< aqcv::ExtractBlobs::MorphOpType > >
        :param morph_ops: input and output MorphOpType vector. It doesn't change original elements(if has),
                             only pushback new elements into vector.
        :type type: int
        :param type: morphology type, only support kernel without size, see #MorphOpType.
        :type kernel_size: :py:class:`Size`
        :param kernel_size: arbitrary kernel size. It should be odd and greater than (1, 1).
        """
        return _pyaqcv.ExtractBlobs_get_morph_ops_vec(morph_ops, type, kernel_size)

    def morph_ops(self, ops):
        r"""execute morphology operation on blob, using each op in ops."""
        return _pyaqcv.ExtractBlobs_morph_ops(self, ops)

    def connectivity_type(self, connect_type):
        r"""set blob hierarchies' connectivity type"""
        return _pyaqcv.ExtractBlobs_connectivity_type(self, connect_type)

    def set_minimum_area(self, area):
        r"""minimum blob area to be accepted(blobs' area lower than the minimum area will be pruned)"""
        return _pyaqcv.ExtractBlobs_set_minimum_area(self, area)

    def execute(self, *args):
        r"""
        execute blob analysis process.
        :type gray_img: :py:class:`Mat`
        :param gray_img:  image one which to analysis, gray_img must be image with single channel with uchar data type.
        :type roi: :py:class:`Rect2i`
        :param roi:       the region where to do blob analysis
        :rtype: boolean
        :return: true if successed; the region of ROI should be totally in image region
        """
        return _pyaqcv.ExtractBlobs_execute(self, *args)

    def get_blob_hierarchies(self):
        r"""
        get blob hierarchies pointer. you can get each blob from the hierarchies
        note: resource of BlobHierarchies was kept by the ExtractBlobs,which means you must maintained
        ExtractBlobs's lifecycle during you operating with blob hierarchies;
        """
        return _pyaqcv.ExtractBlobs_get_blob_hierarchies(self)

# Register ExtractBlobs in _pyaqcv:
_pyaqcv.ExtractBlobs_swigregister(ExtractBlobs)
kSingleWholeImageBlob = _pyaqcv.kSingleWholeImageBlob
r"""take whole image none zero region as a single blob"""
kForegroundOnly = _pyaqcv.kForegroundOnly
r"""take every connect none zero region as a single blob (default)"""
kAllBlobs = _pyaqcv.kAllBlobs
r"""take every connect reigon as a blob, include foreground, hole and background"""
kBlobAndHole = _pyaqcv.kBlobAndHole
r"""take every connect reigon as a blob, include foreground and hole"""
class BlobExc(object):
    r"""blobs in image, you can get blobs' hierarchies and properties, or directly create and operate them."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_BlobExc

    def __init__(self, *args):
        r"""
        *Overload 1:*

        create a blob from an image, all regions whose pixel value in range are seen as a single blob.
        :type img: :py:class:`Mat`
        :param img: source image in AQ_8UC1.
        :type low: int
        :param low: low threshold.
        :type high: int
        :param high: high threshold.
        :type invert: boolean
        :param invert: if invert, the pixel whose value lower than low or higher than high is considered.
        :type roi: :py:class:`IGeometry`
        :param roi: roi in image, support type : kRing2f/kRing2i/kPolygon2f/kPolygon2i/kMultiPolygon2f/kMultiPolygon2i/
                       kRect2f/kRect2i/kRotateRect2f/kRotateRect2i/kCircle2f/kCircle2i/kEllipse2f.
                       other type will create an empty blob.
        Notes: use this function you can handle blob in custom way without #ExtractBlobsExc

        |

        *Overload 2:*

        create a blob from geometry type.
        :type geometry: :py:class:`IGeometry`
        :param geometry: input geometry, support type : kRing2f/kRing2i/kPolygon2f/kPolygon2i/kMultiPolygon2f/kMultiPolygon2i/
                            kMultiSegment2f/kRect2f/kRect2i/kRotateRect2f/kRotateRect2i/kCircle2f/kCircle2i/kEllipse2f.
        """
        _pyaqcv.BlobExc_swiginit(self, _pyaqcv.new_BlobExc(*args))

    def clone(self):
        r"""Creates a full copy of BlobExc."""
        return _pyaqcv.BlobExc_clone(self)

    def to_mat(self, *args):
        r"""
        convert blob to AU_8UC1 image, blob transforms to 255 and background to 0.

        .. code-block:: c++

              BlobExc b(vg::Rect2i(vg::Point2i(-10, -20), vg::Point2i(20, 10)))
              Mat m1 = b.to_mat(Size(100, 100)); //return a 100x100 Mat with blob range from (0, 0) to (20, 10)
              Mat m2 = b.to_mat(); //return a 30x30 Mat with all 255
        :type img_size: :py:class:`Size`, optional
        :param img_size: size of output image, if not empty, it should larger than blob, and only the part of blob inside in img_size
                   will be drawn. Otherwise, use default minimum size enclosing the blob.
        Notes: return an empty mat when both blob and size are empty.
        """
        return _pyaqcv.BlobExc_to_mat(self, *args)

    def empty(self):
        r"""
        whether the blob is empty
        Notes: If you extract blob by #ExtractBlobsExc, there is no empty blob. It can be empty when you use custom operations.
        Some properties can be accessed by empty blob (area = 0, etc.), others may abort the program. So It's better to
        check whether the blob is empty before you try to access its properties.
        """
        return _pyaqcv.BlobExc_empty(self)

    def parent(self):
        r"""get id of current blob's parent(which directly containt current blob), -1 means none"""
        return _pyaqcv.BlobExc_parent(self)

    def prev_sibling(self):
        r"""get id of current blob's previous sibling blob, -1 means none"""
        return _pyaqcv.BlobExc_prev_sibling(self)

    def next_sibling(self):
        r"""get id of current blob's next sibling blob, -1 means none"""
        return _pyaqcv.BlobExc_next_sibling(self)

    def first_child(self):
        r"""get id of current blob's first child blob, -1 means none"""
        return _pyaqcv.BlobExc_first_child(self)

    def last_child(self):
        r"""get id of current blob's last child blob, -1 means none"""
        return _pyaqcv.BlobExc_last_child(self)

    def all_children(self):
        r"""get id of current blob's all children blob"""
        return _pyaqcv.BlobExc_all_children(self)

    def children_count(self):
        r"""children blob count, only direct children, not include grandchildren"""
        return _pyaqcv.BlobExc_children_count(self)

    def id(self):
        r"""index of current blob"""
        return _pyaqcv.BlobExc_id(self)

    def label(self):
        r"""blob label, generally 0 indicates hole or background, 1 indicates target blob"""
        return _pyaqcv.BlobExc_label(self)

    def filtered(self):
        r"""whether current blob if filtered by filter rules"""
        return _pyaqcv.BlobExc_filtered(self)

    def area(self):
        r"""the area of current blob"""
        return _pyaqcv.BlobExc_area(self)

    def get_mass_center(self):
        r"""mass center of current blob"""
        return _pyaqcv.BlobExc_get_mass_center(self)

    def get_geom_center(self):
        r"""geometry center of current blob"""
        return _pyaqcv.BlobExc_get_geom_center(self)

    def get_x_moment(self):
        r"""blob's secondary moment in x axis direction"""
        return _pyaqcv.BlobExc_get_x_moment(self)

    def get_y_moment(self):
        r"""blob's secondary moment in y axis direction"""
        return _pyaqcv.BlobExc_get_y_moment(self)

    def get_angle(self):
        r"""blob's minimum secondary moment in it's angle direction  blob's maxmimum secondary moment  blob's direction(the direction with minimum secondary moment, left[ -, )"""
        return _pyaqcv.BlobExc_get_angle(self)

    def get_circularity(self):
        r"""
         blob's elongation  :math:`E = \frac{{\chi _{max}^2}}{{\chi _{min}^2}}` , where min max means the minimum and maximum second moment
        blob's circularity, standard circle's circularity is 1. 'circularity'
        Notes: result maybe error when connect_num() > 1
        """
        return _pyaqcv.BlobExc_get_circularity(self)

    def get_roundness(self):
        r"""blob's roundness 'roundness'"""
        return _pyaqcv.BlobExc_get_roundness(self)

    def get_convexity(self):
        r"""blob's convexity"""
        return _pyaqcv.BlobExc_get_convexity(self)

    def get_compactness(self):
        r"""
        blob's compactness 'compactness'
        Notes: if the blob has more than one connected component, only first one is considered
        """
        return _pyaqcv.BlobExc_get_compactness(self)

    def get_rectangularity(self):
        r"""blob's rectangularity"""
        return _pyaqcv.BlobExc_get_rectangularity(self)

    def get_inner_points(self):
        r"""all pixels position in the blob"""
        return _pyaqcv.BlobExc_get_inner_points(self)

    def get_contour(self):
        r"""the blob contour with pixel boundary (do not contain hole's boundary)"""
        return _pyaqcv.BlobExc_get_contour(self)

    def get_region(self):
        r"""the blob region with pixel boundary polygon"""
        return _pyaqcv.BlobExc_get_region(self)

    def get_all_regions(self):
        r"""
        get all blob regions with pixel boundary polygon
        Notes: usually this function use by custom blob operations when current blob has multiple connected components,
        otherwise it return MultiPolygon2i with only one polygon.
        """
        return _pyaqcv.BlobExc_get_all_regions(self)

    def get_boundary_length(self):
        r"""
        blob's boundary pixels count (boundary pixels are 4-connect)
        Notes: the result is same as visionflow::geometry::perimeter(get_contour())
        """
        return _pyaqcv.BlobExc_get_boundary_length(self)

    def get_perimeter(self):
        r"""blob's boundary pixels external edge length, usually small than boundary length"""
        return _pyaqcv.BlobExc_get_perimeter(self)

    def get_bbox(self):
        r"""upright bounding box of current blob"""
        return _pyaqcv.BlobExc_get_bbox(self)

    def get_min_area_rect(self):
        r"""min area bounding box of current blob"""
        return _pyaqcv.BlobExc_get_min_area_rect(self)

    def get_min_enclosing_circle(self):
        r"""bounding box in blob's principal direction(minimum second moment direction)  find a circle of the minimum area enclosing the blob"""
        return _pyaqcv.BlobExc_get_min_enclosing_circle(self)

    def get_max_inscribed_circle(self):
        r"""
        find maximum inscribed circle of blob
        Notes: if the blob has more than one connected components, only first one is considered
        """
        return _pyaqcv.BlobExc_get_max_inscribed_circle(self)

    def get_min_gray_val(self, *args):
        r"""
        minimum gray value in the blob region
        :type img: :py:class:`Mat`, optional
        :param img: the AQ_8UC1 img to compute minimum gray value, if empty, use image from ExtractBlobsExc::execute().
        """
        return _pyaqcv.BlobExc_get_min_gray_val(self, *args)

    def get_max_gray_val(self, *args):
        r"""
        maximum gray value in the blob region
        :type img: :py:class:`Mat`, optional
        :param img: the AQ_8UC1 img to compute maximum gray value, if empty, use image from ExtractBlobsExc::execute().
        """
        return _pyaqcv.BlobExc_get_max_gray_val(self, *args)

    def get_mean_gray_val(self, *args):
        r"""
        mean gray value in the blob region
        :type img: :py:class:`Mat`, optional
        :param img: the AQ_8UC1 img to compute mean gray value, if empty, use image from ExtractBlobsExc::execute().
        """
        return _pyaqcv.BlobExc_get_mean_gray_val(self, *args)

    def get_std_dev_gray_val(self, *args):
        r"""
        standard deviation of gray value in the blob region
        :type img: :py:class:`Mat`, optional
        :param img: the AQ_8UC1 img to compute standard deviation of gray value, if empty, use image from ExtractBlobsExc::execute().
        """
        return _pyaqcv.BlobExc_get_std_dev_gray_val(self, *args)

    def morphology(self, op, shape, ksize):
        r"""
        morphological operation on blob.
        :type op: int
        :param op: Type of a morphological operation, see #MorphologyTypes, only support kMorphologyErode, kMorphologyDilate,
            kMorphologyOpen and kMorphologyClose.
        :type ksize: :py:class:`Size`
        :param ksize: Size of the structuring element, it must be positive and odd.
        :type shape: int
        :param shape: Element shape that could be one of #MorphShapes.
        Notes: this function make blob's hierarchy invalid
        """
        return _pyaqcv.BlobExc_morphology(self, op, shape, ksize)

    def connection(self, *args):
        r"""
        computes the connected components of blob.
        :type blobs: std::vector< aqcv::BlobExc,std::allocator< aqcv::BlobExc > >
        :param blobs: all blobs after connection.
        :type type: int, optional
        :param type: type of connectivity, see #BlobConnectivityType.
        :type row_range: :py:class:`Range`, optional
        :param row_range: row range of scene, it should enclosing current blob (default is row range of current blob).
        :type col_range: :py:class:`Range`, optional
        :param col_range: column range of scene, it should enclosing current blob (default is column range of current blob).
        Notes: parameter row_range and col_range are only use for type kAllBlobs.
        """
        return _pyaqcv.BlobExc_connection(self, *args)

    def connect_num(self):
        r"""number of connection components"""
        return _pyaqcv.BlobExc_connect_num(self)

    def holes_num(self):
        r"""number of holes"""
        return _pyaqcv.BlobExc_holes_num(self)

    def cover_point(self, point):
        r"""
        Whether the point is covered by the blob
        :type point: :py:class:`Point2f`
        :param point: input point
        """
        return _pyaqcv.BlobExc_cover_point(self, point)

    def intersection_with(self, blob):
        r"""
        intersection with other blob
        :type blob: :py:class:`BlobExc`
        :param blob: other blob
        Notes: this function make blob's hierarchy invalid
        """
        return _pyaqcv.BlobExc_intersection_with(self, blob)

    @staticmethod
    def blob_intersection(src, dst):
        r"""
        blob intersection
        :type src: std::vector< aqcv::BlobExc,std::allocator< aqcv::BlobExc > >
        :param src: blobs for intersection
        :type dst: :py:class:`BlobExc`
        :param dst: blob after intersection
        """
        return _pyaqcv.BlobExc_blob_intersection(src, dst)

    def union_with(self, blob):
        r"""
        union with other blob
        :type blob: :py:class:`BlobExc`
        :param blob: other blob
        Notes: this function make blob's hierarchy invalid
        """
        return _pyaqcv.BlobExc_union_with(self, blob)

    @staticmethod
    def blob_union(src, dst):
        r"""
        blob union
        :type src: std::vector< aqcv::BlobExc,std::allocator< aqcv::BlobExc > >
        :param src: blobs for union
        :type dst: :py:class:`BlobExc`
        :param dst: blob after union
        """
        return _pyaqcv.BlobExc_blob_union(src, dst)

    def complement(self, *args):
        r"""
        complement of blob
        :type row_range: :py:class:`Range`, optional
        :param row_range: row range of scene, it should enclosing current blob (default is row range of current blob).
        :type col_range: :py:class:`Range`, optional
        :param col_range: column range of scene, it should enclosing current blob (default is column range of current blob).
        Notes: this function make blob's hierarchy invalid
        """
        return _pyaqcv.BlobExc_complement(self, *args)

    @staticmethod
    def blob_complement(*args):
        r"""
        blob complement
        :type src: :py:class:`BlobExc`
        :param src: blob for complement
        :type dst: :py:class:`BlobExc`
        :param dst: blob after complement
        :type row_range: :py:class:`Range`, optional
        :param row_range: row range of scene, it should enclosing current blob (default is row range of src blob).
        :type col_range: :py:class:`Range`, optional
        :param col_range: column range of scene, it should enclosing current blob (default is column range of src blob).
        """
        return _pyaqcv.BlobExc_blob_complement(*args)

    @staticmethod
    def blob_difference(src1, src2, dst):
        r"""
        blob difference src1 - src2
        :type src1: :py:class:`BlobExc`
        :param src1: first blob for difference
        :type src2: :py:class:`BlobExc`
        :param src2: second blob for difference
        :type dst: :py:class:`BlobExc`
        :param dst: blob after difference
        """
        return _pyaqcv.BlobExc_blob_difference(src1, src2, dst)

    @staticmethod
    def blob_symm_difference(src1, src2, dst):
        r"""
        blob symmetric difference (src1 - src2) U (src2 - src1)
        :type src1: :py:class:`BlobExc`
        :param src1: first blob for symmetric difference
        :type src2: :py:class:`BlobExc`
        :param src2: second blob for symmetric difference
        :type dst: :py:class:`BlobExc`
        :param dst: blob after symmetric difference
        """
        return _pyaqcv.BlobExc_blob_symm_difference(src1, src2, dst)

    def fill_up(self, *args):
        r"""
        fill up holes of blob
        :type min_area: float, optional
        :param min_area: holes whose area equal to or larger than min_area will be filled
        :type max_area: float, optional
        :param max_area: holes whose area equal to or smaller than max_area will be filled
        Notes: this function make blob's hierarchy invalid
        """
        return _pyaqcv.BlobExc_fill_up(self, *args)

    @staticmethod
    def blob_fill_up(*args):
        r"""
        fill up holes of blob
        :type src: :py:class:`BlobExc`
        :param src: blob for fill up
        :type dst: :py:class:`BlobExc`
        :param dst: blob after fill up
        :type min_area: float, optional
        :param min_area: holes whose area equal to or larger than min_area will be filled
        :type max_area: float, optional
        :param max_area: holes whose area equal to or smaller than max_area will be filled
        """
        return _pyaqcv.BlobExc_blob_fill_up(*args)

# Register BlobExc in _pyaqcv:
_pyaqcv.BlobExc_swigregister(BlobExc)
class ExtractBlobsExc(object):
    r"""blob tool."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.ExtractBlobsExc_swiginit(self, _pyaqcv.new_ExtractBlobsExc())
    __swig_destroy__ = _pyaqcv.delete_ExtractBlobsExc

    def set_segment_thresh(self, thresh, invert=False):
        r"""
        binarize image threshold
        :type thresh: int
        :param thresh: threshold value to binarize image, value < thresh = 0, value >= thresh=255
                          if thresh < 0, auto threshold(OTSU) will be applied
        :type invert: boolean, optional
        :param invert: invert the binarized image, value < thresh = 255
        """
        return _pyaqcv.ExtractBlobsExc_set_segment_thresh(self, thresh, invert)

    def set_segment_thresh_range(self, low, high, invert=False):
        r"""
        binarize image with threshold between low and high.
        :type low: int
        :param low: low threshold
        :type high: int
        :param high: high threshold
        :type invert: boolean, optional
        :param invert: if invert, the pixel whose value lower than low or higher than high is considered.
        """
        return _pyaqcv.ExtractBlobsExc_set_segment_thresh_range(self, low, high, invert)

    def set_segment_mean_std_dev(self, low_ratio, high_ratio, invert=False):
        r"""
        binarize image using mean and standard deviation, the pixel whose value near mean value will be segmented.
        :type low_ratio: float
        :param low_ratio: set the ratio of standard deviation lower than mean pixel value(low_thresh = mean - low_ratio * std_dev)
        :type high_ratio: float
        :param high_ratio: set the ratio of standard deviation higher than mean pixel value(high_thresh = mean + high_ratio * std_dev)
        :type invert: boolean, optional
        :param invert: if invert, the pixel whose value lower than low_thresh or higher than high_thresh is considered.
        Notes: it's more expensive than other segment method when using mask.
        """
        return _pyaqcv.ExtractBlobsExc_set_segment_mean_std_dev(self, low_ratio, high_ratio, invert)

    def set_segment_adaptive(self, block_size, c=0.0, invert=False):
        r"""
        binarize with adaptive threshold.
        :type block_size: int
        :param block_size: size of a pixel neighborhood that is used to calculate a threshold value. It should be odd and larger than 1.
        :type c: float, optional
        :param c: constant subtracted from the mean or weighted mean.
        :type invert: boolean, optional
        :param invert: if invert, the background is considered.
        See also: adaptive_threshold
        """
        return _pyaqcv.ExtractBlobsExc_set_segment_adaptive(self, block_size, c, invert)

    def add_morph_ops(self, op, shape, ksize):
        r"""
        Add morphological operation on blobs.
        :type ksize: :py:class:`Size`
        :param ksize: Size of the structuring element, it must be positive and odd.
        :type op: int
        :param op: Type of a morphological operation, see #MorphologyTypes, only support kMorphologyErode, kMorphologyDilate,
            kMorphologyOpen and kMorphologyClose.
        :type shape: int
        :param shape: Element shape that could be one of #MorphShapes.
        Notes: you can add multiple morphological operations, and they execute in sequence
        """
        return _pyaqcv.ExtractBlobsExc_add_morph_ops(self, op, shape, ksize)

    def clear_morph_ops(self):
        r"""clear all morphological operation"""
        return _pyaqcv.ExtractBlobsExc_clear_morph_ops(self)

    def set_connectivity_type(self, connect_type):
        r"""
        set blob hierarchies' connectivity type
        :type connect_type: int
        :param connect_type: connectivity type to set
        """
        return _pyaqcv.ExtractBlobsExc_set_connectivity_type(self, connect_type)

    def clear_connectivity_type(self):
        r"""clear connectivity type, use default type kForegroundOnly"""
        return _pyaqcv.ExtractBlobsExc_clear_connectivity_type(self)

    def set_minimum_area(self, area):
        r"""
        minimum blob area to be accepted(blobs' area lower than the minimum area will be pruned)
        :type area: int
        :param area: minimum area to set
        Notes: just for backward compatibility, use add_filter for more fine settings.
        """
        return _pyaqcv.ExtractBlobsExc_set_minimum_area(self, area)
    kLabel = _pyaqcv.ExtractBlobsExc_kLabel
    kArea = _pyaqcv.ExtractBlobsExc_kArea
    kAngle = _pyaqcv.ExtractBlobsExc_kAngle
    kBBoxCenterX = _pyaqcv.ExtractBlobsExc_kBBoxCenterX
    kBBoxCenterY = _pyaqcv.ExtractBlobsExc_kBBoxCenterY
    kBBoxX = _pyaqcv.ExtractBlobsExc_kBBoxX
    kBBoxY = _pyaqcv.ExtractBlobsExc_kBBoxY
    kBBoxBottomRightX = _pyaqcv.ExtractBlobsExc_kBBoxBottomRightX
    kBBoxBottomRightY = _pyaqcv.ExtractBlobsExc_kBBoxBottomRightY
    kBBoxWidth = _pyaqcv.ExtractBlobsExc_kBBoxWidth
    kBBoxHeight = _pyaqcv.ExtractBlobsExc_kBBoxHeight
    kMassCenterX = _pyaqcv.ExtractBlobsExc_kMassCenterX
    kMassCenterY = _pyaqcv.ExtractBlobsExc_kMassCenterY
    kMinRectLongSide = _pyaqcv.ExtractBlobsExc_kMinRectLongSide
    kMinRectShortSide = _pyaqcv.ExtractBlobsExc_kMinRectShortSide
    kMinRectCenterX = _pyaqcv.ExtractBlobsExc_kMinRectCenterX
    kMinRectCenterY = _pyaqcv.ExtractBlobsExc_kMinRectCenterY
    kMinRectAngle = _pyaqcv.ExtractBlobsExc_kMinRectAngle
    kCircularity = _pyaqcv.ExtractBlobsExc_kCircularity
    kRectangularity = _pyaqcv.ExtractBlobsExc_kRectangularity

    def add_filter(self, type, low_limit, high_limit, invert=False):
        r"""
        add filter for blobs
        :type type: int
        :param type: filter type, see #FilterType
        :type low_limit: float
        :param low_limit: low limit of filter
        :type high_limit: float
        :param high_limit: high limit of filter
        :type invert: boolean, optional
        :param invert: if invert, the blob whose properties smaller than low_limit or larger than high_limit will be considered.
        """
        return _pyaqcv.ExtractBlobsExc_add_filter(self, type, low_limit, high_limit, invert)
    kAnd = _pyaqcv.ExtractBlobsExc_kAnd
    r"""all filters connect with AND, blob must satisfy all filters (default)"""
    kOr = _pyaqcv.ExtractBlobsExc_kOr
    r"""all filters connect with OR, blob only need satisfy one filter at least"""

    def set_filter_logic(self, logic):
        r"""
        set filter logic
        :type logic: int
        :param logic: filter logic, see #FilterLogic
        """
        return _pyaqcv.ExtractBlobsExc_set_filter_logic(self, logic)

    def clear_filters(self):
        r"""clear all filters and logic"""
        return _pyaqcv.ExtractBlobsExc_clear_filters(self)

    def set_sort(self, type, ascending=False):
        r"""
        sort blobs by specify measure
        :type type: int
        :param type: sort type, see #FilterType
        :type ascending: boolean, optional
        :param ascending: if true, sort in ascending order, otherwise in decending order
        Notes: if you call this function multiple time, the parameters of last time will take effect.
        If you sort by min_area_rect/circularity/rectangularity, you should also add_filter for this FilterType.
        """
        return _pyaqcv.ExtractBlobsExc_set_sort(self, type, ascending)

    def clear_sort(self):
        r"""clear sort"""
        return _pyaqcv.ExtractBlobsExc_clear_sort(self)

    def set_fill_up(self, *args):
        r"""
        set if fill up holes of all blobs after connection (before filter and sort).
        :type fill_up: boolean, optional
        :param fill_up: if true, fill up holes of all blobs, default is false.
        :type min_area: float, optional
        :param min_area: holes whose area equal to or larger than min_area will be filled.
        :type max_area: float, optional
        :param max_area: holes whose area equal to or smaller than max_area will be filled.
        """
        return _pyaqcv.ExtractBlobsExc_set_fill_up(self, *args)

    def set_cal_gray_val(self, cal=False):
        r"""
        set if calculate min/max/mean/std_dev gray value of each blob, if not, all of these value is -1 for all blobs.
        :type cal: boolean, optional
        :param cal: if true, calculate min/max/mean/std_dev gray value of each blob, default is false.
        Notes: you can also use corresponding method in #BlobExc to calculate them.
        """
        return _pyaqcv.ExtractBlobsExc_set_cal_gray_val(self, cal)

    def execute(self, *args):
        r"""
        execute blob analysis process.
        :type img: :py:class:`Mat`
        :param img: image which to analysis, its type must be AQ_8UC1.
        :type roi: :py:class:`IGeometry`
        :param roi: the region where to do blob analysis.
            Support type:kRing2f/kRing2i/kPolygon2f/kPolygon2i/kMultiPolygon2f/kMultiPolygon2i/
                         kRect2f/kRect2i/kRotateRect2f/kRotateRect2i/kCircle2f/kCircle2i/kEllipse2f.
        :rtype: boolean
        :return: true if successed.
        Notes: If roi is empty, it returns true but there is no blob. If roi is not intersect with
        image, it throws an exception.
        """
        return _pyaqcv.ExtractBlobsExc_execute(self, *args)

    def get_blob(self, index):
        r"""
        get blob with index
        :type index: int
        :param index: index to get
        Notes: the return blob may be filtered by filter rules, please check before use.
        """
        return _pyaqcv.ExtractBlobsExc_get_blob(self, index)

    def get_all_blobs(self):
        r"""get all blobs, not include blobs filtered by filter rules"""
        return _pyaqcv.ExtractBlobsExc_get_all_blobs(self)

    def draw_blob(self, img, index=-1):
        r"""
        draw a blob on img
        :type img: :py:class:`Mat`
        :param img: draw canvas, blob region is filled with 255 and bg are filled with zero
        :type index: int, optional
        :param index: which blob should be drawn, -1 means all blobs
        Notes: you should draw blob with label = 1, otherwise nothing will be drawn
        """
        return _pyaqcv.ExtractBlobsExc_draw_blob(self, img, index)

    def blob_count(self):
        r"""get blob count after filtered (if set)"""
        return _pyaqcv.ExtractBlobsExc_blob_count(self)

    def get_contours(self):
        r"""get all blobs contours"""
        return _pyaqcv.ExtractBlobsExc_get_contours(self)

    def to_multipolygon(self, polygons, include_inners=False):
        r"""
        convert all blobs to MultiPolygon2i
        :type polygons: :py:class:`MultiPolygon2i`
        :param polygons: result MultiPolygon2i
        :type include_inners: boolean, optional
        :param include_inners: whether include inners
        :rtype: boolean
        :return: true if foreground blob not empty.
        """
        return _pyaqcv.ExtractBlobsExc_to_multipolygon(self, polygons, include_inners)

# Register ExtractBlobsExc in _pyaqcv:
_pyaqcv.ExtractBlobsExc_swigregister(ExtractBlobsExc)
class VisionSystemCalibResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    verticality_x = property(_pyaqcv.VisionSystemCalibResult_verticality_x_get, _pyaqcv.VisionSystemCalibResult_verticality_x_set, doc=r"""object verticality in x direction""")
    verticality_y = property(_pyaqcv.VisionSystemCalibResult_verticality_y_get, _pyaqcv.VisionSystemCalibResult_verticality_y_set, doc=r"""object verticality in y direction""")
    board_pos = property(_pyaqcv.VisionSystemCalibResult_board_pos_get, _pyaqcv.VisionSystemCalibResult_board_pos_set, doc=r"""calib board center position in image CS""")
    board_angle = property(_pyaqcv.VisionSystemCalibResult_board_angle_get, _pyaqcv.VisionSystemCalibResult_board_angle_set, doc=r"""calib board rotation angle with long axis [-90,90)""")
    pixel_equivalent = property(_pyaqcv.VisionSystemCalibResult_pixel_equivalent_get, _pyaqcv.VisionSystemCalibResult_pixel_equivalent_set, doc=r"""unit is mm/pixel""")
    mtf = property(_pyaqcv.VisionSystemCalibResult_mtf_get, _pyaqcv.VisionSystemCalibResult_mtf_set, doc=r"""can represent sharpness in linepair region""")
    rgb = property(_pyaqcv.VisionSystemCalibResult_rgb_get, _pyaqcv.VisionSystemCalibResult_rgb_set, doc=r"""in grayboard region""")

    def __init__(self):
        _pyaqcv.VisionSystemCalibResult_swiginit(self, _pyaqcv.new_VisionSystemCalibResult())
    __swig_destroy__ = _pyaqcv.delete_VisionSystemCalibResult

# Register VisionSystemCalibResult in _pyaqcv:
_pyaqcv.VisionSystemCalibResult_swigregister(VisionSystemCalibResult)
class VisionSystemCalib(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kAQ_8585V3 = _pyaqcv.VisionSystemCalib_kAQ_8585V3

    def __init__(self, *args):
        _pyaqcv.VisionSystemCalib_swiginit(self, _pyaqcv.new_VisionSystemCalib(*args))
    __swig_destroy__ = _pyaqcv.delete_VisionSystemCalib

    def execute(self, image, result):
        r"""
        Calculate imaging index
        :type image: :py:class:`Mat`
        :param image:  input image of calibboard view
        :type result: :py:class:`VisionSystemCalibResult`
        :param result:  please see VisionSystemCalibResult
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.VisionSystemCalib_execute(self, image, result)

# Register VisionSystemCalib in _pyaqcv:
_pyaqcv.VisionSystemCalib_swigregister(VisionSystemCalib)
kTranslationRotationScale = _pyaqcv.kTranslationRotationScale
r"""minimum required two points"""
kAffine = _pyaqcv.kAffine
r"""minimum required three points"""
kPerspective = _pyaqcv.kPerspective
r"""minimum required four points"""
kNoneLinear = _pyaqcv.kNoneLinear
r"""need calibration board image"""
class CameraModelPack(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CameraModelPack_swiginit(self, _pyaqcv.new_CameraModelPack())
    __swig_destroy__ = _pyaqcv.delete_CameraModelPack

    def get_calib_type(self):
        r"""get current camera model calibrate type."""
        return _pyaqcv.CameraModelPack_get_calib_type(self)

    def set_pixel_scale(self, pixel_scale):
        r"""
        Set the pixel equivalent of the rectified image
        :param scale: pixel equivalent, in meter.
        :rtype: boolean
        :return: if ok return true
        """
        return _pyaqcv.CameraModelPack_set_pixel_scale(self, pixel_scale)

    def get_pixel_scale(self):
        r"""
        Get the pixel equivalent of the rectified image
        :rtype: float
        :return: the pixel equivalent of the rectified image, in meter.
        """
        return _pyaqcv.CameraModelPack_get_pixel_scale(self)

    def set_camera_size(self, *args):
        r"""
        Set camera image size
        :type width: int
        :param width: camera width of image
        :type height: int
        :param height: camera height of image
        """
        return _pyaqcv.CameraModelPack_set_camera_size(self, *args)

    def get_camera_size(self):
        r"""
        Get camera image size
        :rtype: :py:class:`Size`
        :return: width, height of image
        """
        return _pyaqcv.CameraModelPack_get_camera_size(self)

    def get_rectify_size(self):
        r"""
        Set rectify out image size
        :param width: camera width of image
        :param height: camera height of image

        Get camera image size
        :rtype: :py:class:`Size`
        :return: width, height of image. 0x0 will be returned if invalid.
        """
        return _pyaqcv.CameraModelPack_get_rectify_size(self)

    def is_valid(self):
        r"""
        whether the CameraModel is valid(camera parameter valid) or not
        :rtype: boolean
        :return: valid is true, not valid is false
        """
        return _pyaqcv.CameraModelPack_is_valid(self)

    def init_rectify_map(self):
        r"""
        Initialize the map required during rectify to reduce the running time
        :rtype: boolean
        :return: If initialization successful is true,else is false
        """
        return _pyaqcv.CameraModelPack_init_rectify_map(self)

    def rectify(self, src, dst):
        r"""
        Correct the image according to the camera model
        :type src: :py:class:`Mat`
        :param src: input image
        :type dst: :py:class:`Mat`
        :param dst: output image
        """
        return _pyaqcv.CameraModelPack_rectify(self, src, dst)

    def image_point_to_world_plane(self, img_pt, world_pt):
        r"""
        Project image point to world_plane(plane of measurements)
        :type img_pt: :py:class:`Point2f`
        :param img_pt:  point in image coordinate system
        :type world_pt: :py:class:`Point2f`
        :param world_pt:  point in world coordinate system
        """
        return _pyaqcv.CameraModelPack_image_point_to_world_plane(self, img_pt, world_pt)

    def world_plane_point_to_image(self, *args):
        r"""
        Project world_plane(plane of measurements) to image point
        :type world_pt: :py:class:`Point3f`
        :param world_pt:  point in world coordinate system
        :type img_pt: :py:class:`Point2f`
        :param img_pt:  point in image coordinate system
        """
        return _pyaqcv.CameraModelPack_world_plane_point_to_image(self, *args)

    def image_points_to_world_plane(self, img_pts, world_pts):
        r"""
        Project image points to world_plane(plane of measurements)
        :type img_pts: :py:class:`MultiPoint2f`
        :param img_pts:  points in image coordinate system
        :type world_pts: :py:class:`MultiPoint2f`
        :param world_pts:  points in world coordinate system
        """
        return _pyaqcv.CameraModelPack_image_points_to_world_plane(self, img_pts, world_pts)

    def world_plane_points_to_image(self, *args):
        r"""
        Project world_plane(plane of measurements) to image points
        :type world_pts: std::vector< aqcv::Point3f,std::allocator< aqcv::Point3f > >
        :param world_pts:  points in world coordinate system
        :type img_pts: :py:class:`MultiPoint2f`
        :param img_pts:  points in image coordinate system
        """
        return _pyaqcv.CameraModelPack_world_plane_points_to_image(self, *args)

    def get_nonlinear_param(self, *args):
        r"""
        *Overload 1:*

        Get nonlinear camera params
        :type width: int
        :param width:  output width of camera image
        :type height: int
        :param height:  output height of camera image
        :type fx: float
        :param fx:  output focus in x direction
        :type fy: float
        :param fy:  output focus in y direction
        :type cx: float
        :param cx:  output x position of lens centers, unit is pixel
        :type cy: float
        :param cy:  output y position of lens centers, unit is pixel
        :type k1: float
        :param k1:  output radial lens distoration
        :type k2: float
        :param k2:  output radial lens distoration
        :type p1: float
        :param p1:  output tangential lens distortion
        :type p2: float
        :param p2:  output tangential lens distortion
        :type k3: float
        :param k3:  output radial lens distoration
        :rtype: boolean
        :return: if param exists return true

        |

        *Overload 2:*

        Get nonlinear camera params
        :type width: int
        :param width:  output width of camera image
        :type height: int
        :param height:  output height of camera image
        :type intr_param: :py:class:`Mat`
        :param intr_param: output intr_param look like:

                   .. math::

                       \begin{bmatrix} fx & 0 & cx \\ 0 & fy & cy \\ 0 & 0 & 1 \end{bmatrix}
        :type dist_param: :py:class:`Mat`
        :param dist_param:  output dist_param look like:

                   .. math::

                       \begin{bmatrix} k1 & k2 & p1 & p2 & k3 \end{bmatrix}
        :rtype: boolean
        :return: if param exists return true
        """
        return _pyaqcv.CameraModelPack_get_nonlinear_param(self, *args)

    def get_linear_param(self, width, height, param):
        r"""
        Get linear camera params
        :type width: int
        :param width:  output width of camera image
        :type height: int
        :param height:  output height of camera image
        :type param: :py:class:`Mat`
        :param param: output param
        :rtype: boolean
        :return: if param exists return true
        """
        return _pyaqcv.CameraModelPack_get_linear_param(self, width, height, param)

# Register CameraModelPack in _pyaqcv:
_pyaqcv.CameraModelPack_swigregister(CameraModelPack)
class CameraCalib(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kAQBoarRect = _pyaqcv.CameraCalib_kAQBoarRect
    kChessBoard = _pyaqcv.CameraCalib_kChessBoard

    def __init__(self):
        _pyaqcv.CameraCalib_swiginit(self, _pyaqcv.new_CameraCalib())
    __swig_destroy__ = _pyaqcv.delete_CameraCalib

    def set_board_type(self, board_type):
        r"""
        Set the calibration board style
        :type board_type: int
        :param board_type: calibration board style
        """
        return _pyaqcv.CameraCalib_set_board_type(self, board_type)

    def get_board_type(self):
        r"""
        Get the calibration board style
        :rtype: int
        :return: the calibration board style
        """
        return _pyaqcv.CameraCalib_get_board_type(self)

    def set_grid_size(self, *args):
        r"""
        Set the calibration board size
        :type grid_width: int
        :param grid_width:  output width of calibration board
        :type grid_height: int
        :param grid_height:  output height of calibration board
        :rtype: boolean
        :return: if ok return ture
        """
        return _pyaqcv.CameraCalib_set_grid_size(self, *args)

    def get_grid_size(self):
        r"""
        Get the calibration board size
        :rtype: :py:class:`Size`
        :return: width and height of calibration board
        """
        return _pyaqcv.CameraCalib_get_grid_size(self)

    def set_grid_scale(self, grid_scale):
        r"""
        Set the physical distance between adjacent marking points on the calibration board, in meter.
        :type grid_scale: float
        :param grid_scale: physical distance between adjacent marking points on the calibration board, in meter.
        :rtype: boolean
        :return: if ok return true
        """
        return _pyaqcv.CameraCalib_set_grid_scale(self, grid_scale)

    def get_grid_scale(self):
        r"""
        Get the physical distance between adjacent marking points on the calibration board
        :rtype: float
        :return: physical distance between adjacent marking points on the calibration board, in meter.
        """
        return _pyaqcv.CameraCalib_get_grid_scale(self)

    def set_calib_type(self, calib_type):
        r"""
        Set calib type
        :param type: PointPaircalibType to set.
        """
        return _pyaqcv.CameraCalib_set_calib_type(self, calib_type)

    def get_calib_type(self):
        r"""
        Get calib type
        :rtype: int
        :return: calib type.
        """
        return _pyaqcv.CameraCalib_get_calib_type(self)

    def add_view_image(self, view_idx, img):
        r"""
        Add calibrate board view image
        :type view_idx: int
        :param view_idx:  camera view image index
        :type img: :py:class:`Mat`
        :param img:  camera view image
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraCalib_add_view_image(self, view_idx, img)

    def add_view_feature(self, view_idx, img_pts, world_pts, img_size):
        r"""
        Add calibrate board points,Only available on calibration type kTranslationRotationScale, kAffine and kPerspective
        :type view_idx: int
        :param view_idx:  camera view image index
        :type img_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param img_pts: The image point
        :type world_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param world_pts: The world coordinates corresponding to the image point
        :type img_size: :py:class:`Size`
        :param img_size: The size of image where img_pts detected from. Size must be equal to previous setted size(by add_view_feature or add_view_image).
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraCalib_add_view_feature(self, view_idx, img_pts, world_pts, img_size)

    def set_reference_view(self, reference_idx):
        r"""
        Set the image index of the reference work plane
        :type reference_idx: int
        :param reference_idx:  camera view image index
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraCalib_set_reference_view(self, reference_idx)

    def calibrate(self):
        r"""
        Run calibrate
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraCalib_calibrate(self)

    def get_view_feature(self, view_idx, viewfeature):
        r"""
        Get camera view features
        :type view_idx: int
        :param view_idx:  input camera view index
        :type viewfeature: :py:class:`CameraViewFeatures`
        :param viewfeature:  output camera view feature of index
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraCalib_get_view_feature(self, view_idx, viewfeature)

    def get_rms(self):
        r"""
        Get rms error
        :rtype: float
        :return: mean rms error
        """
        return _pyaqcv.CameraCalib_get_rms(self)

    def get_camera_model(self, *args):
        r"""
        *Overload 1:*

        Get camera model
        :rtype: :py:class:`CameraModelPack`
        :return: Camera model, see CameraModel
        Notes: this is const function

        |

        *Overload 2:*

        Get camera model
        :rtype: :py:class:`CameraModelPack`
        :return: Camera model, see CameraModel
        """
        return _pyaqcv.CameraCalib_get_camera_model(self, *args)

    def get_view_project_pts(self, id, proj_pts):
        r"""
        Get project points in camera view image
        :type id: int
        :param id: view id
        :type proj_pts: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
        :param proj_pts: project points
        :rtype: boolean
        :return: success is true, failure is false
        """
        return _pyaqcv.CameraCalib_get_view_project_pts(self, id, proj_pts)

# Register CameraCalib in _pyaqcv:
_pyaqcv.CameraCalib_swigregister(CameraCalib)
class EvaluateImageSharpness(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kStepDiffer = _pyaqcv.EvaluateImageSharpness_kStepDiffer
    r"""pixel differ"""
    kSelfCorrelation = _pyaqcv.EvaluateImageSharpness_kSelfCorrelation
    r"""self correlation"""
    kGradientEnergy = _pyaqcv.EvaluateImageSharpness_kGradientEnergy
    r"""edge gradient energy"""
    kBandPassFilter = _pyaqcv.EvaluateImageSharpness_kBandPassFilter
    r"""band pass"""

    def __init__(self):
        _pyaqcv.EvaluateImageSharpness_swiginit(self, _pyaqcv.new_EvaluateImageSharpness())
    __swig_destroy__ = _pyaqcv.delete_EvaluateImageSharpness

    def set_sharpness_method(self, mode):
        r"""set sharpness compute method"""
        return _pyaqcv.EvaluateImageSharpness_set_sharpness_method(self, mode)

    def get_sharpness_method(self):
        r"""get sharpness compute method"""
        return _pyaqcv.EvaluateImageSharpness_get_sharpness_method(self)

    def set_differ_step(self, dx, dy):
        r"""
        set/get pixel differenct compute step, only used with 'kStepDiffer'
        Notes: dx and dy should not both be 0
        :type dx: int
        :param dx: step in x direction between pixels to compute intensity difference(0~width-1)
        :type dy: int
        :param dy: step in x direction between pixels to compute intensity difference(0~height-1)
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.EvaluateImageSharpness_set_differ_step(self, dx, dy)

    def get_differ_step(self, dx, dy):
        return _pyaqcv.EvaluateImageSharpness_get_differ_step(self, dx, dy)

    def set_gradient_smooth_sigma(self, sigma_x, sigma_y):
        r"""
        set/get smooth parameters,only used with 'kGradientEnergy'
        :type sigma_x: float
        :param sigma_x: sigma of gaussian smooth method in x direction (> 0.5)
        :type sigma_y: float
        :param sigma_y: sigma of gaussian smooth method in y direction (> 0.5)
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.EvaluateImageSharpness_set_gradient_smooth_sigma(self, sigma_x, sigma_y)

    def get_gradient_smooth_sigma(self, sigma_x, sigma_y):
        return _pyaqcv.EvaluateImageSharpness_get_gradient_smooth_sigma(self, sigma_x, sigma_y)

    def set_bandpass_filter_range(self, low, high):
        r"""
        set/get band pass filter parameters,only used with 'kBandPassFilter'
        :type low: float
        :param low: lower limit of band range [0, 0.5]
        :type high: float
        :param high: lower limit of band range [low, 0.5]
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.EvaluateImageSharpness_set_bandpass_filter_range(self, low, high)

    def get_bandpass_filter_range(self, low, high):
        return _pyaqcv.EvaluateImageSharpness_get_bandpass_filter_range(self, low, high)

    def execute(self, img, roi):
        r"""
        compute image sharpness in roi region
        :type img: :py:class:`Mat`
        :param img: image to compute sharpness, only single channel in kDepth_U8 is accepted
        :type roi: :py:class:`Rect2i`
        :param roi: region of interest.
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.EvaluateImageSharpness_execute(self, img, roi)

    def get_result(self):
        r"""get computed sharpness"""
        return _pyaqcv.EvaluateImageSharpness_get_result(self)

# Register EvaluateImageSharpness in _pyaqcv:
_pyaqcv.EvaluateImageSharpness_swigregister(EvaluateImageSharpness)
class WarpCirclePolar(object):
    r"""a convenient wrapper for circle spread"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""constructor 'set_annular'"""
        _pyaqcv.WarpCirclePolar_swiginit(self, _pyaqcv.new_WarpCirclePolar(*args))
    __swig_destroy__ = _pyaqcv.delete_WarpCirclePolar

    def set_annular(self, center, r_start, r_end, start_angle, span_angle):
        r"""
         set circle polar parameters
        :type center: :py:class:`Point2f`
        :param center:	    center of ploar origin
        :type r_start: float
        :param r_start:		the start radius of annulus, should be none negative
        :type r_end: float
        :param r_end:		the end radius of annulus, should be none negative
        :type start_angle: :py:class:`Radian`
        :param start_angle:  from where begin to warp
        :type span_angle: :py:class:`Radian`
        :param span_angle:  total angle span of the annulus, can be positive or nefative
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.WarpCirclePolar_set_annular(self, center, r_start, r_end, start_angle, span_angle)

    def get_annular(self, center, r_start=None, r_end=None, start_angle=None, span_angle=None):
        r"""
         get parameters
        'set_annular'
        """
        return _pyaqcv.WarpCirclePolar_get_annular(self, center, r_start, r_end, start_angle, span_angle)

    def polar_to_cart(self, *args):
        r"""
        *Overload 1:*
         project polar point to cartesian coordinate
        :type polar_size: :py:class:`Size`
        :param polar_size: polar image size(for polar image size maybe scaled,so you should define polar image size)
        :type polar_pt: :py:class:`Point2f`
        :param polar_pt: the point in polar coordinate
        :type cart_pt: :py:class:`Point2f`
        :param cart_pt:  the project point into cartesian coordinate

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.

        |

        *Overload 3:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        return _pyaqcv.WarpCirclePolar_polar_to_cart(self, *args)

    def cart_to_polar(self, *args):
        r"""
        *Overload 1:*
         project polar point to cartesian coordinate
        :type polar_size: :py:class:`Size`
        :param polar_size: polar image size(for polar image size maybe scaled,so you should define polar image size)
        :type cart_pt: :py:class:`Point2f`
        :param cart_pt: the point in cartesian coordinate
        :type polar_pt: :py:class:`Point2f`
        :param polar_pt: the project point into polar coordinate

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.

        |

        *Overload 3:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        return _pyaqcv.WarpCirclePolar_cart_to_polar(self, *args)

    def circle_spread(self, *args):
        r"""
        wrap circle spread(cart to polar)
        :type cart_img: :py:class:`Mat`
        :param cart_img:	src image wantted to be warpped
        :type polar_img: :py:class:`Mat`
        :param polar_img:	warpped result image
        :type polar_size: :py:class:`Size`
        :param polar_size:  the size of result image, dsize will be set adaptively with given annulus when given dsize is empty
        :type inter_method: int, optional
        :param inter_method:	'InterMethod'
        :type border_mode: int, optional
        :param border_mode:	'BorderTypes'
        :type border_value: :py:class:`Scalar`, optional
        :param border_value:	value to be filled when out of boundaries
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.WarpCirclePolar_circle_spread(self, *args)

    def circle_spread_inv(self, *args):
        r"""
        wrap image from polar back to cart
        :type polar_img: :py:class:`Mat`
        :param polar_img:	src image wantted to be warpped
        :type cart_img: :py:class:`Mat`
        :param cart_img:	warpped result image
        :type cart_size: :py:class:`Size`
        :param cart_size:  the size of result image
        :type inter_method: int, optional
        :param inter_method:	'InterMethod'
        :type border_mode: int, optional
        :param border_mode:	'BorderTypes'
        :type border_value: :py:class:`Scalar`, optional
        :param border_value:	value to be filled when out of boundaries
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.WarpCirclePolar_circle_spread_inv(self, *args)

# Register WarpCirclePolar in _pyaqcv:
_pyaqcv.WarpCirclePolar_swigregister(WarpCirclePolar)
EdgePolarityType_kDarkToLight = _pyaqcv.EdgePolarityType_kDarkToLight
r"""search polarity is from dark to light"""
EdgePolarityType_kLightToDark = _pyaqcv.EdgePolarityType_kLightToDark
r"""search polarity is from light to dark"""
EdgePolarityType_kBoth = _pyaqcv.EdgePolarityType_kBoth
r"""either kDarkToLight or kLightToDark"""
EdgeOrderType_kBestScore = _pyaqcv.EdgeOrderType_kBestScore
r"""select the edge with highest score"""
EdgeOrderType_kFirstEdge = _pyaqcv.EdgeOrderType_kFirstEdge
r"""select the first edge in search direction"""
EdgeOrderType_kLastEdge = _pyaqcv.EdgeOrderType_kLastEdge
r"""select the last edge in search direction"""
class CircularAnnulusSection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    arc = property(_pyaqcv.CircularAnnulusSection_arc_get, _pyaqcv.CircularAnnulusSection_arc_set)
    radial_scale = property(_pyaqcv.CircularAnnulusSection_radial_scale_get, _pyaqcv.CircularAnnulusSection_radial_scale_set)

    def __init__(self):
        _pyaqcv.CircularAnnulusSection_swiginit(self, _pyaqcv.new_CircularAnnulusSection())
    __swig_destroy__ = _pyaqcv.delete_CircularAnnulusSection

# Register CircularAnnulusSection in _pyaqcv:
_pyaqcv.CircularAnnulusSection_swigregister(CircularAnnulusSection)
kFindDirectionLeftToRight = _pyaqcv.kFindDirectionLeftToRight
r"""from the left of the ROI to the right along the calipers distribution direction"""
kFindDirectionRightToLeft = _pyaqcv.kFindDirectionRightToLeft
r"""from the right of the ROI to the left along the calipers distribution direction"""
kFindDirectionCenterOutward = _pyaqcv.kFindDirectionCenterOutward
r"""from center to outer, only support edge pair"""
kFindDirectionOutsideIn = _pyaqcv.kFindDirectionOutsideIn
r"""from outer to center, only support edge pair"""
kEdgeFlawSortBySize = _pyaqcv.kEdgeFlawSortBySize
kEdgeFlawSortByArea = _pyaqcv.kEdgeFlawSortByArea
kEdgeFlawSortByPos = _pyaqcv.kEdgeFlawSortByPos
kEdgeInspectSingleLine = _pyaqcv.kEdgeInspectSingleLine
kEdgeInspectSingleCircle = _pyaqcv.kEdgeInspectSingleCircle
kEdgeFlawNormal = _pyaqcv.kEdgeFlawNormal
kEdgeFlawLeftDefect = _pyaqcv.kEdgeFlawLeftDefect
kEdgeFlawRightDefect = _pyaqcv.kEdgeFlawRightDefect
kEdgeFlawGap = _pyaqcv.kEdgeFlawGap
kDualEdgeMaxScore = _pyaqcv.kDualEdgeMaxScore
kDualEdgeOuter = _pyaqcv.kDualEdgeOuter
kDualEdgeInner = _pyaqcv.kDualEdgeInner
kDualEdgeOuterDiameter = _pyaqcv.kDualEdgeOuterDiameter
r"""Only supports full circle calipers distribution"""
kDualEdgeInnerDiameter = _pyaqcv.kDualEdgeInnerDiameter
r"""Only supports full circle calipers distribution"""
class EdgeFlaw(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pos = property(_pyaqcv.EdgeFlaw_pos_get, _pyaqcv.EdgeFlaw_pos_set)
    area = property(_pyaqcv.EdgeFlaw_area_get, _pyaqcv.EdgeFlaw_area_set)
    size = property(_pyaqcv.EdgeFlaw_size_get, _pyaqcv.EdgeFlaw_size_set)
    start_calip_index = property(_pyaqcv.EdgeFlaw_start_calip_index_get, _pyaqcv.EdgeFlaw_start_calip_index_set)
    end_calip_index = property(_pyaqcv.EdgeFlaw_end_calip_index_get, _pyaqcv.EdgeFlaw_end_calip_index_set)
    flaw_type = property(_pyaqcv.EdgeFlaw_flaw_type_get, _pyaqcv.EdgeFlaw_flaw_type_set)

    def __init__(self):
        _pyaqcv.EdgeFlaw_swiginit(self, _pyaqcv.new_EdgeFlaw())
    __swig_destroy__ = _pyaqcv.delete_EdgeFlaw

# Register EdgeFlaw in _pyaqcv:
_pyaqcv.EdgeFlaw_swigregister(EdgeFlaw)
class EdgePositionDefectParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_EdgePositionDefectParams

    def __init__(self, *args):
        r"""
        Construct a new Edge Position Defect Params object
        :type min_distance: float, optional
        :param min_distance: from the edge and the line fit less than this value is not a defect, set_defect_distance, get_defect_distance
        :type max_distance: float, optional
        :param max_distance: from the edge and the line fit greater than this value is not a defect, set_defect_distance, get_defect_distance
        :type size_enabled: boolean, optional
        :param size_enabled: whether or not filter defects size(the length along the edge) enable_defect_size, get_defect_size_enabled, set_defect_size, get_defect_size
        :type min_size: float, optional
        :param min_size: the minimum defect size in pixel set_defect_size, get_defect_size
        :type max_size: float, optional
        :param max_size: the maximum defect size in pixel set_defect_size, get_defect_size
        :type area_enabled: boolean, optional
        :param area_enabled: whether or not filter defects area enable_defect_area, get_defect_area_enabled, set_defect_area, get_defect_area
        :type min_area: float, optional
        :param min_area: the minimum defect area in pixel set_defect_area, get_defect_area
        :type max_area: float, optional
        :param max_area: the minimum defect area in pixel set_defect_area, get_defect_area
        :type filter_left_defect: boolean, optional
        :param filter_left_defect: whether or not filter left defects enable_filter_left_defect, get_filter_left_defect_enabled, enable_filter_defect
        :type filter_right_defect: boolean, optional
        :param filter_right_defect: whether or not filter right defects enable_filter_right_defect, get_filter_right_defect_enabled, enable_filter_defect
        :type st_sort_type: int, optional
        :param st_sort_type: specify how the detected defects will be sorted set_defects_sort_type, get_defects_sort_type
        :type max_defects_num: int, optional
        :param max_defects_num: the maximum number of defects should be detect, set_defect_max_num, get_defect_max_num
        """
        _pyaqcv.EdgePositionDefectParams_swiginit(self, _pyaqcv.new_EdgePositionDefectParams(*args))

    def set_defect_max_num(self, max_defects_num):
        return _pyaqcv.EdgePositionDefectParams_set_defect_max_num(self, max_defects_num)

    def get_defect_max_num(self):
        return _pyaqcv.EdgePositionDefectParams_get_defect_max_num(self)

    def set_defect_distance(self, min_distance, max_distance):
        return _pyaqcv.EdgePositionDefectParams_set_defect_distance(self, min_distance, max_distance)

    def get_defect_distance(self, min_distance, max_distance):
        return _pyaqcv.EdgePositionDefectParams_get_defect_distance(self, min_distance, max_distance)

    def enable_defect_size(self, size_enabled):
        return _pyaqcv.EdgePositionDefectParams_enable_defect_size(self, size_enabled)

    def get_defect_size_enabled(self):
        return _pyaqcv.EdgePositionDefectParams_get_defect_size_enabled(self)

    def set_defect_size(self, min_size, max_size):
        return _pyaqcv.EdgePositionDefectParams_set_defect_size(self, min_size, max_size)

    def get_defect_size(self, min_size, max_size):
        return _pyaqcv.EdgePositionDefectParams_get_defect_size(self, min_size, max_size)

    def enable_defect_area(self, area_enabled):
        return _pyaqcv.EdgePositionDefectParams_enable_defect_area(self, area_enabled)

    def get_defect_area_enabled(self):
        return _pyaqcv.EdgePositionDefectParams_get_defect_area_enabled(self)

    def set_defect_area(self, min_area, max_area):
        return _pyaqcv.EdgePositionDefectParams_set_defect_area(self, min_area, max_area)

    def get_defect_area(self, min_area, max_area):
        return _pyaqcv.EdgePositionDefectParams_get_defect_area(self, min_area, max_area)

    def enable_filter_left_defect(self, filter_left_defect):
        return _pyaqcv.EdgePositionDefectParams_enable_filter_left_defect(self, filter_left_defect)

    def get_filter_left_defect_enabled(self):
        return _pyaqcv.EdgePositionDefectParams_get_filter_left_defect_enabled(self)

    def enable_filter_right_defect(self, filter_right_defect):
        return _pyaqcv.EdgePositionDefectParams_enable_filter_right_defect(self, filter_right_defect)

    def get_filter_right_defect_enabled(self):
        return _pyaqcv.EdgePositionDefectParams_get_filter_right_defect_enabled(self)

    def get_filter_defect_enabled(self, filter_left_defect, filter_right_defect):
        return _pyaqcv.EdgePositionDefectParams_get_filter_defect_enabled(self, filter_left_defect, filter_right_defect)

    def set_defects_sort_type(self, st_sort_type):
        return _pyaqcv.EdgePositionDefectParams_set_defects_sort_type(self, st_sort_type)

    def get_defects_sort_type(self):
        return _pyaqcv.EdgePositionDefectParams_get_defects_sort_type(self)

    def is_valid(self):
        return _pyaqcv.EdgePositionDefectParams_is_valid(self)

# Register EdgePositionDefectParams in _pyaqcv:
_pyaqcv.EdgePositionDefectParams_swigregister(EdgePositionDefectParams)
class EdgeGapParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_EdgeGapParams

    def __init__(self, *args):
        r"""
        Construct a new Edge Gap Params object
        :type gap_enabled: boolean, optional
        :param gap_enabled: whether or not filter gap size enable_gap, get_gap_enabled, set_gap, get_gap
        :type gap_min: float, optional
        :param gap_min: the minimum gap(the length along the edge) in pixels set_gap_size, get_gap_size, set_gap, get_gap
        :type gap_max: float, optional
        :param gap_max: the maximum gap in pixels set_gap_size, get_gap_size
        :type max_gaps_num: int, optional
        :param max_gaps_num: the maximum number of gaps should be detect set_gap_maxnum, get_gap_maxnum, set_gap, get_gap
        :type ignore_gap_end: boolean, optional
        :param ignore_gap_end: whether or not gaps detected at the beginning and end of the ROI enable_ignore_gap_end, get_ignore_gap_end_enabled
        :type st_sort_type: int, optional
        :param st_sort_type: specify how the detected gaps will be sorted set_gaps_sort_type, get_gaps_sort_type
        """
        _pyaqcv.EdgeGapParams_swiginit(self, _pyaqcv.new_EdgeGapParams(*args))

    def set_gap_maxnum(self, max_gaps_num):
        return _pyaqcv.EdgeGapParams_set_gap_maxnum(self, max_gaps_num)

    def get_gap_maxnum(self):
        return _pyaqcv.EdgeGapParams_get_gap_maxnum(self)

    def enable_gap(self, gap_enabled):
        return _pyaqcv.EdgeGapParams_enable_gap(self, gap_enabled)

    def get_gap_enabled(self):
        return _pyaqcv.EdgeGapParams_get_gap_enabled(self)

    def set_gap_size(self, gap_min, gap_max):
        return _pyaqcv.EdgeGapParams_set_gap_size(self, gap_min, gap_max)

    def get_gap_size(self, gap_min, gap_max):
        return _pyaqcv.EdgeGapParams_get_gap_size(self, gap_min, gap_max)

    def enable_ignore_gap_end(self, ignore_gap_end):
        return _pyaqcv.EdgeGapParams_enable_ignore_gap_end(self, ignore_gap_end)

    def get_ignore_gap_end_enabled(self):
        return _pyaqcv.EdgeGapParams_get_ignore_gap_end_enabled(self)

    def set_gaps_sort_type(self, st_sort_type):
        return _pyaqcv.EdgeGapParams_set_gaps_sort_type(self, st_sort_type)

    def get_gaps_sort_type(self):
        return _pyaqcv.EdgeGapParams_get_gaps_sort_type(self)

    def is_valid(self):
        return _pyaqcv.EdgeGapParams_is_valid(self)

# Register EdgeGapParams in _pyaqcv:
_pyaqcv.EdgeGapParams_swigregister(EdgeGapParams)
class EdgeFitParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, filter_outliers_enabled=False, fit_distance_filter=5, rescore_enabled=False, refit_enabled=False):
        _pyaqcv.EdgeFitParams_swiginit(self, _pyaqcv.new_EdgeFitParams(filter_outliers_enabled, fit_distance_filter, rescore_enabled, refit_enabled))
    __swig_destroy__ = _pyaqcv.delete_EdgeFitParams

    def enable_filter_outliers(self, filter_outliers_enabled):
        r"""
        Enables or disables the filter outliers.
        :type filter_outliers_enabled: boolean
        :param filter_outliers_enabled:  remove points from the fitting that are further than the distance specified set_fit_distance_filter
        """
        return _pyaqcv.EdgeFitParams_enable_filter_outliers(self, filter_outliers_enabled)

    def get_filter_outliers_enabled(self):
        r"""
        Get current state of the filter outliers
        :rtype: boolean
        :return: true if enabled
        """
        return _pyaqcv.EdgeFitParams_get_filter_outliers_enabled(self)

    def set_fit_distance_filter(self, fit_distance_filter):
        r"""
        Set the fit distance filter object
        :type fit_distance_filter: int
        :param fit_distance_filter: the distance in pixels, default 2, (0, ...)
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.EdgeFitParams_set_fit_distance_filter(self, fit_distance_filter)

    def get_fit_distance_filter(self):
        r"""
        Get the fit distance filter object
        See also: set_fit_distance_filter
        """
        return _pyaqcv.EdgeFitParams_get_fit_distance_filter(self)

    def enable_rescore(self, rescore_enabled):
        r"""
        Enables or disables the rescore.
        :type rescore_enabled: boolean
        :param rescore_enabled: rescored to select edges which are closer to the line fit
        """
        return _pyaqcv.EdgeFitParams_enable_rescore(self, rescore_enabled)

    def get_rescore_enabled(self):
        r"""
        Get current state of the rescore.
        See also: enable_rescore
        """
        return _pyaqcv.EdgeFitParams_get_rescore_enabled(self)

    def enable_refit(self, refit_enabled):
        r"""
        Enables or disables the re_fit.
        :type refit_enabled: boolean
        :param refit_enabled: refit the line fit after the edges have been re-scored
        """
        return _pyaqcv.EdgeFitParams_enable_refit(self, refit_enabled)

    def get_refit_enabled(self):
        r"""
        Get current state of the refit
        See also: enable_refit
        """
        return _pyaqcv.EdgeFitParams_get_refit_enabled(self)

# Register EdgeFitParams in _pyaqcv:
_pyaqcv.EdgeFitParams_swigregister(EdgeFitParams)
class SingleEdgeScoreParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, first_edge_enabled=True, strongest_edge_enabled=False, score_threshold=20):
        _pyaqcv.SingleEdgeScoreParams_swiginit(self, _pyaqcv.new_SingleEdgeScoreParams(first_edge_enabled, strongest_edge_enabled, score_threshold))
    __swig_destroy__ = _pyaqcv.delete_SingleEdgeScoreParams

    def enable_first_edge(self, first_edge_enabled):
        r"""
        Enables or disables the first edge.
        :type first_edge_enabled: boolean
        :param first_edge_enabled: the first edge along the search direction
        Notes: if both "first_edge" and "strongest_edge" are set to true, the score is calculated as the geometric average.
        """
        return _pyaqcv.SingleEdgeScoreParams_enable_first_edge(self, first_edge_enabled)

    def get_first_edge_enabled(self):
        r"""
        Get current state of the first edge.
        :rtype: boolean
        :return: true if enabled
        """
        return _pyaqcv.SingleEdgeScoreParams_get_first_edge_enabled(self)

    def enable_strongest_edge(self, strongest_edge_enabled):
        r"""
        Enables or disables the strongest edge.
        :type strongest_edge_enabled: boolean
        :param strongest_edge_enabled: the edge that has the max score
        Notes: if both "first_edge" and "strongest_edge" are set to true, the score is calculated as the geometric average.
        """
        return _pyaqcv.SingleEdgeScoreParams_enable_strongest_edge(self, strongest_edge_enabled)

    def get_strongest_edge_enabled(self):
        r"""
        Get current state of the strongest edge.
        :rtype: boolean
        :return: true if enabled
        """
        return _pyaqcv.SingleEdgeScoreParams_get_strongest_edge_enabled(self)

    def set_score_threshold(self, score_threshold):
        r"""
        Set the score threshold object
        :type score_threshold: int
        :param score_threshold:  the minimum score, (0,255), default 10
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeScoreParams_set_score_threshold(self, score_threshold)

    def get_score_threshold(self):
        r"""
        Get the score threshold object
        :rtype: int
        :return: score threshold
        See also: set_score_threshold
        """
        return _pyaqcv.SingleEdgeScoreParams_get_score_threshold(self)

# Register SingleEdgeScoreParams in _pyaqcv:
_pyaqcv.SingleEdgeScoreParams_swigregister(SingleEdgeScoreParams)
class DualEdgeScoreParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.DualEdgeScoreParams_swiginit(self, _pyaqcv.new_DualEdgeScoreParams(*args))
    __swig_destroy__ = _pyaqcv.delete_DualEdgeScoreParams

    def set_single_edge_score_param(self, single_edge_score_param):
        return _pyaqcv.DualEdgeScoreParams_set_single_edge_score_param(self, single_edge_score_param)

    def get_single_edge_score_param(self):
        return _pyaqcv.DualEdgeScoreParams_get_single_edge_score_param(self)

    def enable_pair_size(self, pair_size_enabled):
        r"""
        Enables or disables the pair size.
        :type pair_size_enabled: boolean
        :param pair_size_enabled:
        """
        return _pyaqcv.DualEdgeScoreParams_enable_pair_size(self, pair_size_enabled)

    def get_pair_size_enabled(self):
        r"""
        Get current state of the first edge.
        :rtype: boolean
        :return: true if enabled
        """
        return _pyaqcv.DualEdgeScoreParams_get_pair_size_enabled(self)

    def set_pair_size(self, pair_size):
        r"""
        Set the pair size object.
        :type pair_size: float
        :param pair_size: specifies the edge pair size at which the highest score is achieved
        :rtype: boolean
        :return: true if successed
        Notes: if "first_edge", "strongest_edge", "pair_size" are set to true, the score is calculated as the geometric average.
        """
        return _pyaqcv.DualEdgeScoreParams_set_pair_size(self, pair_size)

    def get_pair_size(self):
        r"""Get the pair size object."""
        return _pyaqcv.DualEdgeScoreParams_get_pair_size(self)

# Register DualEdgeScoreParams in _pyaqcv:
_pyaqcv.DualEdgeScoreParams_swigregister(DualEdgeScoreParams)
class ProfileCaliperSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    kLineSeg = _pyaqcv.ProfileCaliperSet_kLineSeg
    kCircleArc = _pyaqcv.ProfileCaliperSet_kCircleArc
    __swig_destroy__ = _pyaqcv.delete_ProfileCaliperSet

    def set_caliper_height(self, height):
        r"""
        Set the caliper height object
        :type height: int
        :param height: the length of each caliper region along the caliper search direction
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.ProfileCaliperSet_set_caliper_height(self, height)

    def get_caliper_height(self):
        return _pyaqcv.ProfileCaliperSet_get_caliper_height(self)

    def set_caliper_width(self, width):
        r"""
        Set the caliper width object
        :type width: int
        :param width: caliper regions' width and space between neightboors
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.ProfileCaliperSet_set_caliper_width(self, width)

    def get_caliper_width(self):
        return _pyaqcv.ProfileCaliperSet_get_caliper_width(self)

    def set_caliper_space(self, space):
        r"""
        Set the caliper space object
        :type space: int
        :param space: space(in pixel) between adjacent calipers
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.ProfileCaliperSet_set_caliper_space(self, space)

    def get_caliper_space(self):
        return _pyaqcv.ProfileCaliperSet_get_caliper_space(self)

    def get_caliper_rects(self):
        r"""
        Get the caliper rects object
        :rtype: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :return: the detection region of all calipers
        """
        return _pyaqcv.ProfileCaliperSet_get_caliper_rects(self)

    def get_type(self):
        return _pyaqcv.ProfileCaliperSet_get_type(self)

# Register ProfileCaliperSet in _pyaqcv:
_pyaqcv.ProfileCaliperSet_swigregister(ProfileCaliperSet)
class LineProfileCaliperSet(ProfileCaliperSet):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.LineProfileCaliperSet_swiginit(self, _pyaqcv.new_LineProfileCaliperSet())
    __swig_destroy__ = _pyaqcv.delete_LineProfileCaliperSet

    def set_lineseg(self, lineseg_profile):
        r"""
        Set the lineseg object
        :type lineseg_profile: :py:class:`Segment2f`
        :param lineseg_profile: calipers center are distributed along the line segment
        :rtype: boolean
        :return: true if successed
        Notes: A form of caliper arrangement, distributed along a line segment
        """
        return _pyaqcv.LineProfileCaliperSet_set_lineseg(self, lineseg_profile)

    def get_lineseg(self):
        return _pyaqcv.LineProfileCaliperSet_get_lineseg(self)

    def set_roi(self, roi):
        r"""
        Set the roi object
        :type roi: :py:class:`RotateRect2f`
        :param roi: calipers are distributed along the width of roi,
            and the height of caliper is equal to the height of roi.
        :rtype: boolean
        :return: true if successed
        Notes: A form of caliper arrangement, distributed along a rotated rectangle,
        """
        return _pyaqcv.LineProfileCaliperSet_set_roi(self, roi)

    def get_roi(self, roi):
        return _pyaqcv.LineProfileCaliperSet_get_roi(self, roi)

    def get_caliper_rects(self):
        return _pyaqcv.LineProfileCaliperSet_get_caliper_rects(self)

    def get_type(self):
        return _pyaqcv.LineProfileCaliperSet_get_type(self)

# Register LineProfileCaliperSet in _pyaqcv:
_pyaqcv.LineProfileCaliperSet_swigregister(LineProfileCaliperSet)
class CircleProfileCaliperSet(ProfileCaliperSet):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CircleProfileCaliperSet_swiginit(self, _pyaqcv.new_CircleProfileCaliperSet())
    __swig_destroy__ = _pyaqcv.delete_CircleProfileCaliperSet

    def set_arc(self, circlearc_profile):
        r"""
        Set the circlearc object
        :type circlearc_profile: :py:class:`Arc2f`
        :param circlearc_profile: calipers center are distributed along the circle arc
        :rtype: boolean
        :return: true if successed
        Notes: A form of caliper arrangement, distributed along a arc
        """
        return _pyaqcv.CircleProfileCaliperSet_set_arc(self, circlearc_profile)

    def get_arc(self):
        return _pyaqcv.CircleProfileCaliperSet_get_arc(self)

    def set_roi(self, center, r_start, r_end, angle, angle_span):
        r"""
        :type center: :py:class:`Point2f`
        :param center: center of search annulus region
        :type r_start: float
        :param r_start: first radius of the annulus search region, the direction if from r_start to r_end
        :type r_end: float
        :param r_end: second radius of the annulus search region, the direction if from r_start to r_end
        :type angle: :py:class:`Radian`
        :param angle: start angle of the annulus region
        :type angle_span: :py:class:`Radian`
        :param angle_span: annulus angle span
        :rtype: boolean
        :return: true if successed
        Notes: A form of caliper arrangement, distributed along a arc annulus
        """
        return _pyaqcv.CircleProfileCaliperSet_set_roi(self, center, r_start, r_end, angle, angle_span)

    def get_roi(self, center, r_start, r_end, angle, angle_span):
        return _pyaqcv.CircleProfileCaliperSet_get_roi(self, center, r_start, r_end, angle, angle_span)

    def get_caliper_rects(self):
        return _pyaqcv.CircleProfileCaliperSet_get_caliper_rects(self)

    def get_type(self):
        return _pyaqcv.CircleProfileCaliperSet_get_type(self)

# Register CircleProfileCaliperSet in _pyaqcv:
_pyaqcv.CircleProfileCaliperSet_swigregister(CircleProfileCaliperSet)
class CaliperSingleEdgeResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CaliperSingleEdgeResult_swiginit(self, _pyaqcv.new_CaliperSingleEdgeResult())
    score = property(_pyaqcv.CaliperSingleEdgeResult_score_get, _pyaqcv.CaliperSingleEdgeResult_score_set, doc=r"""score of the result in the range 0.0-1.0""")
    edge_point = property(_pyaqcv.CaliperSingleEdgeResult_edge_point_get, _pyaqcv.CaliperSingleEdgeResult_edge_point_set, doc=r"""the (x,y) position of the result in the input image.""")
    offset = property(_pyaqcv.CaliperSingleEdgeResult_offset_get, _pyaqcv.CaliperSingleEdgeResult_offset_set, doc=r"""the offset along the x axis relative to the center of the input region. In AnnularCaliper, the circumferential distance from the beginning Angle to the edge point""")
    contrast = property(_pyaqcv.CaliperSingleEdgeResult_contrast_get, _pyaqcv.CaliperSingleEdgeResult_contrast_set, doc=r"""contrast of the edge in the range -255-255, negative contrasts represent light to dark""")
    angle = property(_pyaqcv.CaliperSingleEdgeResult_angle_get, _pyaqcv.CaliperSingleEdgeResult_angle_set, doc=r"""the angle is 0, when the ROI is RotateRect2f. In AnnularCaliper,the Angle between the vector from the center of the circle to this point and the X-axis""")
    sensitivity = property(_pyaqcv.CaliperSingleEdgeResult_sensitivity_get, _pyaqcv.CaliperSingleEdgeResult_sensitivity_set, doc=r"""the ratio of the current edge contrast to the maximum contrast in the range 0.0-1.0""")
    polarity = property(_pyaqcv.CaliperSingleEdgeResult_polarity_get, _pyaqcv.CaliperSingleEdgeResult_polarity_set, doc=r"""polarity of the edge""")
    __swig_destroy__ = _pyaqcv.delete_CaliperSingleEdgeResult

# Register CaliperSingleEdgeResult in _pyaqcv:
_pyaqcv.CaliperSingleEdgeResult_swigregister(CaliperSingleEdgeResult)
class CaliperSingleEdge(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CaliperSingleEdge_swiginit(self, _pyaqcv.new_CaliperSingleEdge())
    __swig_destroy__ = _pyaqcv.delete_CaliperSingleEdge

    def set_edge_polarity(self, edge_polarity):
        r"""
        Set edge polarity.
        :type edge_polarity: int
        :param edge_polarity:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.CaliperSingleEdge_set_edge_polarity(self, edge_polarity)

    def get_edge_polarity(self):
        r"""
        Get edge polarity.
        See also: set_edge_polarity.
        """
        return _pyaqcv.CaliperSingleEdge_get_edge_polarity(self)

    def set_sensitivity_threshold(self, sensitivity_threshold):
        r"""
        Set sensitivity threshold.
        :type sensitivity_threshold: float
        :param sensitivity_threshold:  minimum sensitivity required for an edge
        """
        return _pyaqcv.CaliperSingleEdge_set_sensitivity_threshold(self, sensitivity_threshold)

    def get_sensitivity_threshold(self):
        r"""
        Get sensitivity threshold.
        See also: set_sensitivity_threshold
        """
        return _pyaqcv.CaliperSingleEdge_get_sensitivity_threshold(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold:  minimum contrast required for an edge to be
            considered during the scoring phase
        """
        return _pyaqcv.CaliperSingleEdge_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.CaliperSingleEdge_get_contrast_threshold(self)

    def set_filter_half_size(self, size):
        r"""
        Set filter half size.
        :type size: int
        :param size:  filter half size in pixels
        """
        return _pyaqcv.CaliperSingleEdge_set_filter_half_size(self, size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.CaliperSingleEdge_get_filter_half_size(self)

    def set_max_result_num(self, num):
        r"""
        Set max result number.
        :type num: int
        :param num: max number of results to find
        """
        return _pyaqcv.CaliperSingleEdge_set_max_result_num(self, num)

    def get_max_result_num(self):
        r"""
        Get max result number.
        See also: set_max_result_num
        """
        return _pyaqcv.CaliperSingleEdge_get_max_result_num(self)

    def set_edge_order(self, type):
        r"""
        set which edge is perferred
        :type type: int
        :param type: perferred edge order type
        """
        return _pyaqcv.CaliperSingleEdge_set_edge_order(self, type)

    def get_edge_order(self):
        r"""get perferred edge order type"""
        return _pyaqcv.CaliperSingleEdge_get_edge_order(self)

    def enable_function_contrast(self, enable):
        r"""
        Whether this scorer will be used.
        :type enable: boolean
        :param enable:  true if this scorer be used, false otherwise.
        """
        return _pyaqcv.CaliperSingleEdge_enable_function_contrast(self, enable)

    def is_function_contrast_enabled(self):
        r"""See also: enable_function_contrast"""
        return _pyaqcv.CaliperSingleEdge_is_function_contrast_enabled(self)

    def set_function_contrast(self, X0, X1, XC, Y0, Y1):
        r"""
        Set the parameters used to map an edge candidate's contrast to a score.
        :type X0: float
        :param X0:  values between x0 and x1 are mapped to a score that is between y0 and y1, while contrast values on the other side of x0 are mapped to a score of y0.
        :type X1: float
        :param X1:  value of x1 must fall between the values of xc and x0. Contrast values between x0 and x1 are mapped to a score that is between y0 and y1, while contrast values
            between xc and x1 are mapped to a score of y1.
        :type XC: float
        :param XC:  values between xc and x1 are mapped to a score of y1, while contrast values on the other side of xc are mapped to a score of zero.
        :type Y0: float
        :param Y0:  the maximum score that will be produced by this scoring function. This unitless value is in the range of 0.0 through 1.0, and must be greater than the y1 value
        :type Y1: float
        :param Y1:  the minimum non-zero score that will be produced by this scoring function. This unitless value is in the range of 0.0 through 1.0, and must be less than the y0 value.
        """
        return _pyaqcv.CaliperSingleEdge_set_function_contrast(self, X0, X1, XC, Y0, Y1)

    def get_function_contrast(self, X0, X1, XC, Y0, Y1):
        r"""See also: set_function_contrast"""
        return _pyaqcv.CaliperSingleEdge_get_function_contrast(self, X0, X1, XC, Y0, Y1)

    def enable_function_center_distance(self, enable):
        r"""
        Whether this scorer will be used.
        :type enable: boolean
        :param enable:  true if this scorer be used, false otherwise.
        """
        return _pyaqcv.CaliperSingleEdge_enable_function_center_distance(self, enable)

    def is_function_center_distance_enabled(self):
        r"""See also: enable_function_center_distance"""
        return _pyaqcv.CaliperSingleEdge_is_function_center_distance_enabled(self)

    def set_function_center_distance(self, X0, X1, XC, Y0, Y1):
        r"""
        Set center distance scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_set_function_center_distance(self, X0, X1, XC, Y0, Y1)

    def get_function_center_distance(self, X0, X1, XC, Y0, Y1):
        r"""
        Get center distance scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_get_function_center_distance(self, X0, X1, XC, Y0, Y1)

    def enable_function_center_offset(self, enable):
        r"""
        Whether this scorer will be used.
        :type enable: boolean
        :param enable:  true if this scorer be used, false otherwise.
        """
        return _pyaqcv.CaliperSingleEdge_enable_function_center_offset(self, enable)

    def is_function_center_offset_enabled(self):
        r"""See also: enable_function_center_offset"""
        return _pyaqcv.CaliperSingleEdge_is_function_center_offset_enabled(self)

    def set_function_center_offset(self, X0, X1, XC, Y0, Y1):
        r"""
        Set center offset scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_set_function_center_offset(self, X0, X1, XC, Y0, Y1)

    def get_function_center_offset(self, X0, X1, XC, Y0, Y1):
        r"""
        Get center offset scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_get_function_center_offset(self, X0, X1, XC, Y0, Y1)

    def enable_function_polarity(self, enable):
        r"""
        Whether this scorer will be used.
        :type enable: boolean
        :param enable:  true if this scorer be used, false otherwise.
        """
        return _pyaqcv.CaliperSingleEdge_enable_function_polarity(self, enable)

    def is_function_polarity_enabled(self):
        r"""See also: enable_function_polarity"""
        return _pyaqcv.CaliperSingleEdge_is_function_polarity_enabled(self)

    def set_function_polarity(self, X0, X1, XC, Y0, Y1):
        r"""
        Set polarity scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_set_function_polarity(self, X0, X1, XC, Y0, Y1)

    def get_function_polarity(self, X0, X1, XC, Y0, Y1):
        r"""
        Get polarity scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_get_function_polarity(self, X0, X1, XC, Y0, Y1)

    def enable_function_light_polarity(self, enable):
        r"""
        Whether this scorer will be used.
        :type enable: boolean
        :param enable:  true if this scorer be used, false otherwise.
        """
        return _pyaqcv.CaliperSingleEdge_enable_function_light_polarity(self, enable)

    def is_function_light_polarity_enabled(self):
        r"""See also: enable_function_light_polarity"""
        return _pyaqcv.CaliperSingleEdge_is_function_light_polarity_enabled(self)

    def set_function_light_polarity(self, X0, X1, XC, Y0, Y1):
        r"""
        Set light polarity scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_set_function_light_polarity(self, X0, X1, XC, Y0, Y1)

    def get_function_light_polarity(self, X0, X1, XC, Y0, Y1):
        r"""
        Get light polarity scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_get_function_light_polarity(self, X0, X1, XC, Y0, Y1)

    def enable_function_dark_polarity(self, enable):
        r"""
        Whether this scorer will be used.
        :type enable: boolean
        :param enable:  true if this scorer be used, false otherwise.
        """
        return _pyaqcv.CaliperSingleEdge_enable_function_dark_polarity(self, enable)

    def is_function_dark_polarity_enabled(self):
        r"""See also: enable_function_dark_polarity"""
        return _pyaqcv.CaliperSingleEdge_is_function_dark_polarity_enabled(self)

    def set_function_dark_polarity(self, X0, X1, XC, Y0, Y1):
        r"""
        Set dark polarity scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_set_function_dark_polarity(self, X0, X1, XC, Y0, Y1)

    def get_function_dark_polarity(self, X0, X1, XC, Y0, Y1):
        r"""
        Get dark polarity scorer.
        See also: set_function_contrast
        """
        return _pyaqcv.CaliperSingleEdge_get_function_dark_polarity(self, X0, X1, XC, Y0, Y1)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.CaliperSingleEdge_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.CaliperSingleEdge_get_mask_region(self)

    def execute(self, image, roi):
        r"""
        Apply the caliper to the given image.
        :type image: :py:class:`Mat`
        :param image:  input image
        :type roi: :py:class:`RotateRect2f`
        :param roi: sample region
        :rtype: boolean
        :return: true if success, false otherwise.
        """
        return _pyaqcv.CaliperSingleEdge_execute(self, image, roi)

    def get_result_num(self):
        r"""
        Get result number of this execute.
        :rtype: int
        :return: 
        """
        return _pyaqcv.CaliperSingleEdge_get_result_num(self)

    def get_caliper_result(self, index, res):
        r"""
        Get edge result of this execute.
        :type index: int
        :param index:  id of edge
        :type res: :py:class:`CaliperSingleEdgeResult`
        :param res:  'CaliperSingleEdgeResult'
        :rtype: boolean
        :return: true if success
        """
        return _pyaqcv.CaliperSingleEdge_get_caliper_result(self, index, res)

    def get_project_image(self):
        r"""
        Get projected image.
        :rtype: :py:class:`Mat`
        :return: these values represent the gray at each point in the projected image.
        """
        return _pyaqcv.CaliperSingleEdge_get_project_image(self)

    def get_contrast_image(self):
        r"""
        Get filtered image.
        :rtype: :py:class:`Mat`
        :return: these values represent the contrast at each point in the filtered image.
        """
        return _pyaqcv.CaliperSingleEdge_get_contrast_image(self)

    def clear_result(self):
        r"""Clear result."""
        return _pyaqcv.CaliperSingleEdge_clear_result(self)

# Register CaliperSingleEdge in _pyaqcv:
_pyaqcv.CaliperSingleEdge_swigregister(CaliperSingleEdge)
class CaliperDualEdgeResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CaliperDualEdgeResult_swiginit(self, _pyaqcv.new_CaliperDualEdgeResult())
    score = property(_pyaqcv.CaliperDualEdgeResult_score_get, _pyaqcv.CaliperDualEdgeResult_score_set)
    center_point = property(_pyaqcv.CaliperDualEdgeResult_center_point_get, _pyaqcv.CaliperDualEdgeResult_center_point_set)
    center_offset = property(_pyaqcv.CaliperDualEdgeResult_center_offset_get, _pyaqcv.CaliperDualEdgeResult_center_offset_set)
    two_edge_width = property(_pyaqcv.CaliperDualEdgeResult_two_edge_width_get, _pyaqcv.CaliperDualEdgeResult_two_edge_width_set)
    edge1_point = property(_pyaqcv.CaliperDualEdgeResult_edge1_point_get, _pyaqcv.CaliperDualEdgeResult_edge1_point_set)
    edge1_point_offset = property(_pyaqcv.CaliperDualEdgeResult_edge1_point_offset_get, _pyaqcv.CaliperDualEdgeResult_edge1_point_offset_set)
    edge1_point_contrast = property(_pyaqcv.CaliperDualEdgeResult_edge1_point_contrast_get, _pyaqcv.CaliperDualEdgeResult_edge1_point_contrast_set)
    edge2_point = property(_pyaqcv.CaliperDualEdgeResult_edge2_point_get, _pyaqcv.CaliperDualEdgeResult_edge2_point_set)
    edge2_point_offset = property(_pyaqcv.CaliperDualEdgeResult_edge2_point_offset_get, _pyaqcv.CaliperDualEdgeResult_edge2_point_offset_set)
    edge2_point_contrast = property(_pyaqcv.CaliperDualEdgeResult_edge2_point_contrast_get, _pyaqcv.CaliperDualEdgeResult_edge2_point_contrast_set)
    __swig_destroy__ = _pyaqcv.delete_CaliperDualEdgeResult

# Register CaliperDualEdgeResult in _pyaqcv:
_pyaqcv.CaliperDualEdgeResult_swigregister(CaliperDualEdgeResult)
class CaliperDualEdge(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CaliperDualEdge_swiginit(self, _pyaqcv.new_CaliperDualEdge())
    __swig_destroy__ = _pyaqcv.delete_CaliperDualEdge

    def set_edge_polarity(self, edge1_polarity, edge2_polarity):
        return _pyaqcv.CaliperDualEdge_set_edge_polarity(self, edge1_polarity, edge2_polarity)

    def get_edge1_polarity(self):
        return _pyaqcv.CaliperDualEdge_get_edge1_polarity(self)

    def get_edge2_polarity(self):
        return _pyaqcv.CaliperDualEdge_get_edge2_polarity(self)

    def set_edge_pair_width(self, edge_pair_width):
        return _pyaqcv.CaliperDualEdge_set_edge_pair_width(self, edge_pair_width)

    def get_edge_pair_width(self):
        return _pyaqcv.CaliperDualEdge_get_edge_pair_width(self)

    def set_contrast_threshold(self, contrast_threshold):
        return _pyaqcv.CaliperDualEdge_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        return _pyaqcv.CaliperDualEdge_get_contrast_threshold(self)

    def set_filter_half_size(self, size):
        return _pyaqcv.CaliperDualEdge_set_filter_half_size(self, size)

    def get_filter_half_size(self):
        return _pyaqcv.CaliperDualEdge_get_filter_half_size(self)

    def set_max_result_num(self, num):
        return _pyaqcv.CaliperDualEdge_set_max_result_num(self, num)

    def get_max_result_num(self):
        return _pyaqcv.CaliperDualEdge_get_max_result_num(self)

    def enable_function_contrast(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_contrast(self, enable)

    def is_function_contrast_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_contrast_enabled(self)

    def set_function_contrast(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_contrast(self, X0, X1, XC, Y0, Y1)

    def get_function_contrast(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_contrast(self, X0, X1, XC, Y0, Y1)

    def enable_function_center_distance(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_center_distance(self, enable)

    def is_function_center_distance_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_center_distance_enabled(self)

    def set_function_center_distance(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_center_distance(self, X0, X1, XC, Y0, Y1)

    def get_function_center_distance(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_center_distance(self, X0, X1, XC, Y0, Y1)

    def enable_function_center_offset(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_center_offset(self, enable)

    def is_function_center_offset_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_center_offset_enabled(self)

    def set_function_center_offset(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_center_offset(self, X0, X1, XC, Y0, Y1)

    def get_function_center_offset(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_center_offset(self, X0, X1, XC, Y0, Y1)

    def enable_function_center_distance_norm(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_center_distance_norm(self, enable)

    def is_function_center_distance_norm_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_center_distance_norm_enabled(self)

    def set_function_center_distance_norm(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_center_distance_norm(self, X0, X1, XC, Y0, Y1)

    def get_function_center_distance_norm(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_center_distance_norm(self, X0, X1, XC, Y0, Y1)

    def enable_function_center_offset_norm(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_center_offset_norm(self, enable)

    def is_function_center_offset_norm_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_center_offset_norm_enabled(self)

    def set_function_center_offset_norm(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_center_offset_norm(self, X0, X1, XC, Y0, Y1)

    def get_function_center_offset_norm(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_center_offset_norm(self, X0, X1, XC, Y0, Y1)

    def enable_function_width_norm(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_width_norm(self, enable)

    def is_function_width_norm_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_width_norm_enabled(self)

    def set_function_width_norm(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_width_norm(self, X0, X1, XC, Y0, Y1)

    def get_function_width_norm(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_width_norm(self, X0, X1, XC, Y0, Y1)

    def enable_function_width_diff_norm(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_width_diff_norm(self, enable)

    def is_function_width_diff_norm_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_width_diff_norm_enabled(self)

    def set_function_width_diff_norm(self, X0, X1, XC, Y0, Y1, X0H, X1H, XCH, Y0H, Y1H):
        return _pyaqcv.CaliperDualEdge_set_function_width_diff_norm(self, X0, X1, XC, Y0, Y1, X0H, X1H, XCH, Y0H, Y1H)

    def get_function_width_diff_norm(self, X0, X1, XC, Y0, Y1, X0H, X1H, XCH, Y0H, Y1H):
        return _pyaqcv.CaliperDualEdge_get_function_width_diff_norm(self, X0, X1, XC, Y0, Y1, X0H, X1H, XCH, Y0H, Y1H)

    def enable_function_width_diff_norm_abs(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_width_diff_norm_abs(self, enable)

    def is_function_width_diff_norm_abs_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_width_diff_norm_abs_enabled(self)

    def set_function_width_diff_norm_abs(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_width_diff_norm_abs(self, X0, X1, XC, Y0, Y1)

    def get_function_width_diff_norm_abs(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_width_diff_norm_abs(self, X0, X1, XC, Y0, Y1)

    def enable_function_straddle(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_straddle(self, enable)

    def is_function_straddle_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_straddle_enabled(self)

    def enable_function_average_gray(self, enable):
        return _pyaqcv.CaliperDualEdge_enable_function_average_gray(self, enable)

    def is_function_average_gray_enabled(self):
        return _pyaqcv.CaliperDualEdge_is_function_average_gray_enabled(self)

    def set_function_average_gray(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_set_function_average_gray(self, X0, X1, XC, Y0, Y1)

    def get_function_average_gray(self, X0, X1, XC, Y0, Y1):
        return _pyaqcv.CaliperDualEdge_get_function_average_gray(self, X0, X1, XC, Y0, Y1)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.CaliperDualEdge_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.CaliperDualEdge_get_mask_region(self)

    def execute(self, image, roi):
        return _pyaqcv.CaliperDualEdge_execute(self, image, roi)

    def get_result_num(self):
        return _pyaqcv.CaliperDualEdge_get_result_num(self)

    def get_caliper_result(self, index, res):
        return _pyaqcv.CaliperDualEdge_get_caliper_result(self, index, res)

    def get_project_image(self):
        return _pyaqcv.CaliperDualEdge_get_project_image(self)

    def get_contrast_image(self):
        return _pyaqcv.CaliperDualEdge_get_contrast_image(self)

    def clear_result(self):
        return _pyaqcv.CaliperDualEdge_clear_result(self)

# Register CaliperDualEdge in _pyaqcv:
_pyaqcv.CaliperDualEdge_swigregister(CaliperDualEdge)
kCaliperEdgeSortByScore = _pyaqcv.kCaliperEdgeSortByScore
kCaliperEdgeSortByDirection = _pyaqcv.kCaliperEdgeSortByDirection
class AnnularCaliper(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.AnnularCaliper_swiginit(self, _pyaqcv.new_AnnularCaliper())
    __swig_destroy__ = _pyaqcv.delete_AnnularCaliper

    def set_edge_polarity(self, edge_polarity):
        r"""
        Set edge polarity.
        :type edge_polarity: int
        :param edge_polarity:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.AnnularCaliper_set_edge_polarity(self, edge_polarity)

    def get_edge_polarity(self):
        r"""Get edge polarity."""
        return _pyaqcv.AnnularCaliper_get_edge_polarity(self)

    def set_sensitivity_threshold(self, sensitivity_threshold):
        r"""
        Set sensitivity threshold.
        :type sensitivity_threshold: float
        :param sensitivity_threshold:  minimum sensitivity required for an edge
        """
        return _pyaqcv.AnnularCaliper_set_sensitivity_threshold(self, sensitivity_threshold)

    def get_sensitivity_threshold(self):
        r"""
        Get sensitivity threshold.
        See also: set_sensitivity_threshold
        """
        return _pyaqcv.AnnularCaliper_get_sensitivity_threshold(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold:  minimum contrast required for an edge to be
            considered during the scoring phase
        """
        return _pyaqcv.AnnularCaliper_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.AnnularCaliper_get_contrast_threshold(self)

    def set_filter_half_size(self, size):
        r"""
        Set filter half size.
        :type size: int
        :param size:  filter half size in pixels
        """
        return _pyaqcv.AnnularCaliper_set_filter_half_size(self, size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.AnnularCaliper_get_filter_half_size(self)

    def set_max_result_num(self, num):
        r"""
        Set max result number.results will be filtered according to CaliperEdgeSortType.
        if it is kCaliperEdgeSortByScore, the results will be sorted by score, and return  the result with the highest score
        if it is kCaliperEdgeSortByDirection, the results will be sorted by span angle, and return the result closest to the start angle.
        :type num: int
        :param num: max number of results to find.
        """
        return _pyaqcv.AnnularCaliper_set_max_result_num(self, num)

    def get_max_result_num(self):
        r"""
        Get max result number.
        See also: set_max_result_num
        """
        return _pyaqcv.AnnularCaliper_get_max_result_num(self)

    def enable_angle_normalization(self, enable):
        r"""
        Normalization results
        :type enable: boolean
        :param enable: if true,the angle of results will be between 0 and 2pi, else,the angle of result will start at the start angle. default it is true.
        """
        return _pyaqcv.AnnularCaliper_enable_angle_normalization(self, enable)

    def is_angle_normalization(self):
        r"""See also: enable_normalization"""
        return _pyaqcv.AnnularCaliper_is_angle_normalization(self)

    def set_edge_sort_type(self, sort_type):
        r"""
        sort results by the evaluation type，if result size > max_result_num, redundant results will be removed.
        :type sort_type: int
        :param sort_type: method result sort by score or angle.
        """
        return _pyaqcv.AnnularCaliper_set_edge_sort_type(self, sort_type)

    def get_edge_sort_type(self):
        r"""
        Get sort results method
        See also: set_edge_sort_method
        """
        return _pyaqcv.AnnularCaliper_get_edge_sort_type(self)

    def execute(self, image, roi, radius_end):
        r"""
        Apply the caliper to the given image.
        :type image: :py:class:`Mat`
        :param image:  input image.Only suppoert AQ_8UC1.
        :type roi: :py:class:`Arc2f`
        :param roi: the arc of the roi
        :type radius_end: float
        :param radius_end: anthor radius of the roi
        :rtype: boolean
        :return: true if success, false otherwise.
        """
        return _pyaqcv.AnnularCaliper_execute(self, image, roi, radius_end)

    def get_result_num(self):
        r"""
        Get result number.
        :rtype: int
        :return: result number
        """
        return _pyaqcv.AnnularCaliper_get_result_num(self)

    def get_caliper_result(self, index, caliper_result):
        r"""
        Get edge result of this execute.
        :type index: int
        :param index:  id of edge
        :type caliper_result: :py:class:`CaliperSingleEdgeResult`
        :param caliper_result:  'CaliperSingleEdgeResult'
        :rtype: boolean
        :return: true if success
        """
        return _pyaqcv.AnnularCaliper_get_caliper_result(self, index, caliper_result)

    def get_caliper_results(self):
        r"""Get edge results of this execute."""
        return _pyaqcv.AnnularCaliper_get_caliper_results(self)

# Register AnnularCaliper in _pyaqcv:
_pyaqcv.AnnularCaliper_swigregister(AnnularCaliper)
class FindLine(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.FindLine_swiginit(self, _pyaqcv.new_FindLine())
    __swig_destroy__ = _pyaqcv.delete_FindLine

    def set_roi(self, roi):
        r"""
        set the line search region
        :type roi: :py:class:`RotateRect2f`
        :param roi:  the region where to find a line, it's x direction should be almost paraller to the line wantted to be found
                          and it's y direction is the caliper search direction and line order direction
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindLine_set_roi(self, roi)

    def get_roi(self, roi):
        r"""get roi"""
        return _pyaqcv.FindLine_get_roi(self, roi)

    def set_edge_polarity(self, polarity):
        r"""
        set(get) preferred edge polarity type
        :type polarity: int
        :param polarity: expect edge polarity
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindLine_set_edge_polarity(self, polarity)

    def get_edge_polarity(self):
        r"""get current edge polarity"""
        return _pyaqcv.FindLine_get_edge_polarity(self)

    def set_edge_threshold(self, thresh):
        r"""
        set(get) preferred edge contrast threshold
        :type thresh: float
        :param thresh:  edge contrast threshold(contrast lower than thresh will be ignored). range: (0, 255]
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindLine_set_edge_threshold(self, thresh)

    def get_edge_threshold(self):
        r"""get current edge threshold"""
        return _pyaqcv.FindLine_get_edge_threshold(self)

    def set_edge_order(self, type):
        r"""
        set which edge is perferred
        :type type: int
        :param type: perferred edge order type
        """
        return _pyaqcv.FindLine_set_edge_order(self, type)

    def get_edge_order(self):
        r"""get perferred edge order type"""
        return _pyaqcv.FindLine_get_edge_order(self)

    def set_edge_width(self, edge_width):
        r"""
        set perferred edge width
        :type edge_width: int
        :param edge_width: width of expect edge,usefull when edge is blur
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindLine_set_edge_width(self, edge_width)

    def get_edge_width(self):
        return _pyaqcv.FindLine_get_edge_width(self)

    def set_caliper_auto(self, enable=True):
        r"""
        whether to set calipers with default setting
        :type enable: boolean, optional
        :param enable: whether enable caliper params to set with auto settings.
        :rtype: boolean
        :return: true if secussed. False indicates some parameter is invalid in the mode changing to.
        """
        return _pyaqcv.FindLine_set_caliper_auto(self, enable)

    def is_caliper_auto(self):
        return _pyaqcv.FindLine_is_caliper_auto(self)

    def set_caliper_width(self, width):
        r"""set/get caliper regions' width and space between neightboors, only valid in non-auto caliper mode."""
        return _pyaqcv.FindLine_set_caliper_width(self, width)

    def get_caliper_width(self):
        return _pyaqcv.FindLine_get_caliper_width(self)

    def set_caliper_space(self, space):
        r"""set/get space(in pixel) between adjacent calipers"""
        return _pyaqcv.FindLine_set_caliper_space(self, space)

    def get_caliper_space(self):
        return _pyaqcv.FindLine_get_caliper_space(self)

    def set_outliers_ratio(self, ratio=0.3):
        r"""set/get noise caliper point ratio,it's useful when some noise exist in the image"""
        return _pyaqcv.FindLine_set_outliers_ratio(self, ratio)

    def get_outliers_ratio(self):
        return _pyaqcv.FindLine_get_outliers_ratio(self)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.FindLine_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.FindLine_get_mask_region(self)

    def execute(self, img, res, rms=None):
        r"""
        find line
        :type img: :py:class:`Mat`
        :param img: the image to search
        :type res: :py:class:`Segment2f`
        :param res: the result line(represented by line segment,it's endpoints it the cross points of line and ROI boundary)
        :type rms: float, optional
        :param rms: optional error(root of mean square)
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindLine_execute(self, img, res, rms)

    def get_edge_points(self, edge_points, inner_mask=None):
        r"""
        get edge points found by calipers
        :type edge_points: :py:class:`MultiPoint2f`
        :param edge_points: edge points
        :type inner_mask: std::vector< bool,std::allocator< bool > >, optional
        :param inner_mask: optional. mask indicates whether was used to fit result line.(true:inner, false:outlier)
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindLine_get_edge_points(self, edge_points, inner_mask)

    def get_caliper_rects(self):
        r"""
        get caliper sampling rois
        :rtype: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :return: all calipers' sampling roi rectangles
        """
        return _pyaqcv.FindLine_get_caliper_rects(self)

# Register FindLine in _pyaqcv:
_pyaqcv.FindLine_swigregister(FindLine)
CaliperDirectionType_kInnerToOuter = _pyaqcv.CaliperDirectionType_kInnerToOuter
r"""from inner to outer"""
CaliperDirectionType_kOuterToInner = _pyaqcv.CaliperDirectionType_kOuterToInner
r"""from outer to inner"""
class FindCircle(object):
    r"""vision tool used to find a circle shape in an image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.FindCircle_swiginit(self, _pyaqcv.new_FindCircle())
    __swig_destroy__ = _pyaqcv.delete_FindCircle

    def set_roi(self, *args):
        r"""
        *Overload 1:*

        set/get the circle search region
        :type roi: :py:class:`Arc2f`
        :param roi:  the first arc of the search annular sector
        :type radial_scale: float
        :param radial_scale: the rate between second arc and first arc of the annular sector,  :math:`R_2 = roi.radius * radial_scale` .
            the calipers' direction is from roi to R_2,caliper height is abs(R_2 - roi.radius).
        :rtype: boolean
        :return: true if successed.

        |

        *Overload 2:*

        This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.set the circle search region
        :type center: :py:class:`Point2f`
        :param center: center of search annulus region
        :type r_start: float
        :param r_start: first radius of the annulus search region, the direction if from r_start to r_end
        :type r_end: float
        :param r_end: second radius of the annulus search region, the direction if from r_start to r_end
        :type angle: :py:class:`Radian`
        :param angle: start angle of the annulus region.
        :type angle_span: :py:class:`Radian`
        :param angle_span: annulus angle span.
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.FindCircle_set_roi(self, *args)

    def get_roi(self, *args):
        return _pyaqcv.FindCircle_get_roi(self, *args)

    def set_edge_polarity(self, polarity):
        r"""set/get preferred edge polarity type"""
        return _pyaqcv.FindCircle_set_edge_polarity(self, polarity)

    def get_edge_polarity(self):
        return _pyaqcv.FindCircle_get_edge_polarity(self)

    def set_edge_threshold(self, thresh):
        r"""
        set(get) preferred edge contrast threshold
        :type thresh: float
        :param thresh:  edge contrast threshold(contrast lower than thresh will be ignored). range: (0, 255]
        """
        return _pyaqcv.FindCircle_set_edge_threshold(self, thresh)

    def get_edge_threshold(self):
        return _pyaqcv.FindCircle_get_edge_threshold(self)

    def set_edge_order(self, type):
        r"""set(get) which edge is perferred"""
        return _pyaqcv.FindCircle_set_edge_order(self, type)

    def get_edge_order(self):
        return _pyaqcv.FindCircle_get_edge_order(self)

    def set_edge_width(self, edge_width):
        r"""the width of the edge"""
        return _pyaqcv.FindCircle_set_edge_width(self, edge_width)

    def get_edge_width(self):
        return _pyaqcv.FindCircle_get_edge_width(self)

    def set_caliper_auto(self, enable=True):
        r"""
        whether to set calipers with auto setting
        :type enable: boolean, optional
        :param enable: whether enable caliper params to set with auto settings.
        :rtype: boolean
        :return: true if secussed. False indicates some parameter is invalid in the mode changing to.
        """
        return _pyaqcv.FindCircle_set_caliper_auto(self, enable)

    def is_caliper_auto(self):
        return _pyaqcv.FindCircle_is_caliper_auto(self)

    def set_caliper_width(self, width):
        r"""set/get caliper regions' width, only valid in non-auto caliper mode."""
        return _pyaqcv.FindCircle_set_caliper_width(self, width)

    def get_caliper_width(self):
        return _pyaqcv.FindCircle_get_caliper_width(self)

    def set_caliper_space(self, space):
        r"""set/get caliper regions'space between neightboors, only valid in non-auto caliper mode."""
        return _pyaqcv.FindCircle_set_caliper_space(self, space)

    def get_caliper_space(self):
        return _pyaqcv.FindCircle_get_caliper_space(self)

    def set_outliers_ratio(self, ratio=0.3):
        r"""set/get noise caliper point ratio,it's useful when some noise exist in the image"""
        return _pyaqcv.FindCircle_set_outliers_ratio(self, ratio)

    def get_outliers_ratio(self):
        return _pyaqcv.FindCircle_get_outliers_ratio(self)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.FindCircle_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.FindCircle_get_mask_region(self)

    def execute(self, img, res, rms=None):
        r"""
         execute find line process
        :type img: :py:class:`Mat`
        :param img: the image where to search
        :type res: :py:class:`Arc2f`
        :param res: the result circle(represented by arc,it's start angle and end_angle same to roi angle)
        :type rms: float, optional
        :param rms: optional error(root of mean square)
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindCircle_execute(self, img, res, rms)

    def get_edge_points(self, edge_points, inner_mask=None):
        r"""
        get edge points found by calipers
        :type edge_points: :py:class:`MultiPoint2f`
        :param edge_points: edge points
        :type inner_mask: std::vector< bool,std::allocator< bool > >, optional
        :param inner_mask: optional. mask indicates whether was used to fit result line.(true:inner, false:outlier)
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindCircle_get_edge_points(self, edge_points, inner_mask)

    def get_caliper_rects(self):
        r"""
        get caliper sampling rois
        :rtype: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :return: all calipers' sampling roi rectangles
        """
        return _pyaqcv.FindCircle_get_caliper_rects(self)

# Register FindCircle in _pyaqcv:
_pyaqcv.FindCircle_swigregister(FindCircle)
class FindEllipse(object):
    r"""vision tool used to find an ellipse shape in an image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kLeastSquare = _pyaqcv.FindEllipse_kLeastSquare
    r"""Simle least square, no weight"""
    kHuber = _pyaqcv.FindEllipse_kHuber
    r"""Huber weight"""
    kTukey = _pyaqcv.FindEllipse_kTukey
    r"""Tukey weight"""
    kExpectedOrientation = _pyaqcv.FindEllipse_kExpectedOrientation
    r"""Expected orientation constraint based geometry distance, need set_expected_orientation()"""

    def __init__(self):
        _pyaqcv.FindEllipse_swiginit(self, _pyaqcv.new_FindEllipse())
    __swig_destroy__ = _pyaqcv.delete_FindEllipse

    def set_roi(self, ellipse, start_angle, angle_span, caliper_height, direct):
        r"""
        This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.set/get the circle search region. This api only set the minimum required parameters,
        using set_xxx to set other parameters
        :type ellipse: :py:class:`Ellipse2f`
        :param ellipse:  anchor ellipse. the ellipse pass through all caliper rois'(rotated rectangle) center
        :type start_angle: :py:class:`Radian`
        :param start_angle:  start angle of the arc of ellipse region
        :type angle_span: :py:class:`Radian`
        :param angle_span:  span angle of the arc of ellipse region
        :type caliper_height: float
        :param caliper_height: caliper's height
        :type direct: int
        :param direct: caliper's direction
        :rtype: boolean
        :return: true if successed.
        """
        return _pyaqcv.FindEllipse_set_roi(self, ellipse, start_angle, angle_span, caliper_height, direct)

    def get_roi(self, ellipse, start_angle, angle_span, caliper_height, direct):
        r"""get roi See also: set_roi"""
        return _pyaqcv.FindEllipse_get_roi(self, ellipse, start_angle, angle_span, caliper_height, direct)

    def set_edge_polarity(self, polarity):
        r"""set/get preferred edge polarity type"""
        return _pyaqcv.FindEllipse_set_edge_polarity(self, polarity)

    def get_edge_polarity(self):
        return _pyaqcv.FindEllipse_get_edge_polarity(self)

    def set_edge_threshold(self, thresh):
        r"""
        set(get) preferred edge contrast threshold
        :type thresh: float
        :param thresh:  edge contrast threshold(contrast lower than thresh will be ignored)
        """
        return _pyaqcv.FindEllipse_set_edge_threshold(self, thresh)

    def get_edge_threshold(self):
        return _pyaqcv.FindEllipse_get_edge_threshold(self)

    def set_edge_order(self, type):
        r"""set(get) which edge is perferred"""
        return _pyaqcv.FindEllipse_set_edge_order(self, type)

    def get_edge_order(self):
        return _pyaqcv.FindEllipse_get_edge_order(self)

    def set_edge_width(self, edge_width):
        r"""
         the width of the edge.
        :type edge_width: int
        :param edge_width: expect edge width. range: >= 1.
        """
        return _pyaqcv.FindEllipse_set_edge_width(self, edge_width)

    def get_edge_width(self):
        return _pyaqcv.FindEllipse_get_edge_width(self)

    def set_caliper_auto(self, enable=True):
        r"""whether to set calipers with default setting"""
        return _pyaqcv.FindEllipse_set_caliper_auto(self, enable)

    def is_caliper_auto(self):
        return _pyaqcv.FindEllipse_is_caliper_auto(self)

    def set_caliper_width(self, width):
        r"""set/get caliper regions' width, only valid in non-auto caliper mode. range: >= 1."""
        return _pyaqcv.FindEllipse_set_caliper_width(self, width)

    def get_caliper_width(self):
        return _pyaqcv.FindEllipse_get_caliper_width(self)

    def set_caliper_space(self, space):
        r"""set/get caliper regions'space between neightboors, only valid in non-auto caliper mode."""
        return _pyaqcv.FindEllipse_set_caliper_space(self, space)

    def get_caliper_space(self):
        return _pyaqcv.FindEllipse_get_caliper_space(self)

    def set_fit_constraint(self, fit_constraint):
        r"""
        set/get which ellipse fitting criteria will be used.
        :type fit_constraint: int
        :param fit_constraint:  please see 'FitConstraint'
        """
        return _pyaqcv.FindEllipse_set_fit_constraint(self, fit_constraint)

    def get_fit_constraint(self):
        return _pyaqcv.FindEllipse_get_fit_constraint(self)

    def set_expected_orientation(self, expected_orientation):
        r"""
        set/get expected orientation.
        :type expected_orientation: :py:class:`Radian`
        :param expected_orientation: the orientation angle that the ellipse will be constrained to
            if set_fit_constraint(kExpectedOrientation)
        """
        return _pyaqcv.FindEllipse_set_expected_orientation(self, expected_orientation)

    def get_expected_orientation(self):
        return _pyaqcv.FindEllipse_get_expected_orientation(self)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.FindEllipse_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.FindEllipse_get_mask_region(self)

    def execute(self, img, res):
        r"""
         execute find ellipse process
        :type img: :py:class:`Mat`
        :param img: the image where to search
        :type res: :py:class:`Ellipse2f`
        :param res: the result ellipse
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindEllipse_execute(self, img, res)

    def get_edge_points(self, edge_points):
        r"""
        get edge points found by calipers
        :type edge_points: :py:class:`MultiPoint2f`
        :param edge_points: edge points
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindEllipse_get_edge_points(self, edge_points)

    def get_caliper_rects(self):
        r"""
        get caliper sampling rois
        :rtype: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :return: all calipers' sampling roi rectangles
        """
        return _pyaqcv.FindEllipse_get_caliper_rects(self)

# Register FindEllipse in _pyaqcv:
_pyaqcv.FindEllipse_swigregister(FindEllipse)
class FindEdgePair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profile_caliperset):
        _pyaqcv.FindEdgePair_swiginit(self, _pyaqcv.new_FindEdgePair(profile_caliperset))
    __swig_destroy__ = _pyaqcv.delete_FindEdgePair

    def set_profile_caliperset(self, profile_caliperset):
        r"""
        Set the profile caliperset object, line pair will be detected for line segments profile,arc pair for arc profile
        :type profile_caliperset: :py:class:`ProfileCaliperSet`
        :param profile_caliperset: multiple calipers combined to form a profile
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindEdgePair_set_profile_caliperset(self, profile_caliperset)

    def get_profile_caliperset(self, profile_caliperset):
        return _pyaqcv.FindEdgePair_get_profile_caliperset(self, profile_caliperset)

    def enable_pair_size(self, pair_size_enabled):
        r"""
        Enables or disables the pair size. Default false.
        :type pair_size_enabled: boolean
        :param pair_size_enabled:
        """
        return _pyaqcv.FindEdgePair_enable_pair_size(self, pair_size_enabled)

    def get_pair_size_enabled(self):
        r"""
        Get current state of the first edge.
        :rtype: boolean
        :return: true if enabled
        """
        return _pyaqcv.FindEdgePair_get_pair_size_enabled(self)

    def set_pair_size(self, pair_size):
        r"""
        Set expect line pair distance.
        :type pair_size: float
        :param pair_size: specifies the edge pair size at which the highest score is achieved
        :rtype: boolean
        :return: true if successed
        Notes: if "first_edge", "strongest_edge", "pair_size" are set to true, the score is calculated as the geometric average.
        """
        return _pyaqcv.FindEdgePair_set_pair_size(self, pair_size)

    def get_pair_size(self):
        r"""Get expect line pair distance size."""
        return _pyaqcv.FindEdgePair_get_pair_size(self)

    def set_find_direction(self, find_direction):
        r"""
        Set the find direction object
        :type find_direction: int
        :param find_direction: the direction of detect edges, FindDirectionType
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindEdgePair_set_find_direction(self, find_direction)

    def get_find_direction(self):
        r"""
        Get the find direction object
        :rtype: int
        :return: FindDirectionType
        """
        return _pyaqcv.FindEdgePair_get_find_direction(self)

    def set_contrast_percent_threshold(self, contrast_percent_threshold):
        r"""
        Set the caliper contrast percent threshold object
        :type contrast_percent_threshold: float
        :param contrast_percent_threshold: the minimum percent contrast transition to be considered as an edge, value range is [0,1]
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindEdgePair_set_contrast_percent_threshold(self, contrast_percent_threshold)

    def get_contrast_percent_threshold(self):
        r"""Get the caliper contrast percent threshold object"""
        return _pyaqcv.FindEdgePair_get_contrast_percent_threshold(self)

    def set_edge_polarity(self, edge_polarity_edge1, edge_polarity_edge2):
        r"""
        Set edge polarity.
        :type edge_polarity_edge1: int
        :param edge_polarity_edge1:  desired polarity of the edge, please see 'EdgePolarityType'
        :type edge_polarity_edge2: int
        :param edge_polarity_edge2:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.FindEdgePair_set_edge_polarity(self, edge_polarity_edge1, edge_polarity_edge2)

    def get_edge1_polarity(self):
        r"""
        Get edge polarity.
        See also: set_edge_polarity.
        """
        return _pyaqcv.FindEdgePair_get_edge1_polarity(self)

    def get_edge2_polarity(self):
        return _pyaqcv.FindEdgePair_get_edge2_polarity(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold: the minimum greyscale contrast transition to be considered as an edge
        """
        return _pyaqcv.FindEdgePair_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.FindEdgePair_get_contrast_threshold(self)

    def set_filter_half_size(self, filter_half_size):
        r"""
        Set filter half size.
        :type filter_half_size: int
        :param filter_half_size: filter half size in pixels
        """
        return _pyaqcv.FindEdgePair_set_filter_half_size(self, filter_half_size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.FindEdgePair_get_filter_half_size(self)

    def set_outlier_ratio(self, max_distance):
        r"""
        set outlier of shape fit distance threshold.
        See also: set_filter_half_size
        """
        return _pyaqcv.FindEdgePair_set_outlier_ratio(self, max_distance)

    def get_outlier_ratio(self):
        return _pyaqcv.FindEdgePair_get_outlier_ratio(self)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.FindEdgePair_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.FindEdgePair_get_mask_region(self)

    def execute(self, img):
        return _pyaqcv.FindEdgePair_execute(self, img)

    def get_caliper_rects(self):
        r"""
        get caliper sampling rois
        :rtype: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :return: all calipers' sampling roi rectangles
        """
        return _pyaqcv.FindEdgePair_get_caliper_rects(self)

    def get_edge1_points(self, edge_points, used_mask):
        r"""
        Get the caliper result of edge1 object
        :param caliper_id: caliper index
        :param caliper_edge1: a caliper of edge1 CaliperSingleEdgeResultSet
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.FindEdgePair_get_edge1_points(self, edge_points, used_mask)

    def get_edge2_points(self, edge_points, used_mask):
        return _pyaqcv.FindEdgePair_get_edge2_points(self, edge_points, used_mask)

    def get_line_edge_pair(self, seg1, seg2):
        r"""get shape(line or arc) pair"""
        return _pyaqcv.FindEdgePair_get_line_edge_pair(self, seg1, seg2)

    def get_arc_edge_pair(self, arc1, arc2):
        return _pyaqcv.FindEdgePair_get_arc_edge_pair(self, arc1, arc2)

# Register FindEdgePair in _pyaqcv:
_pyaqcv.FindEdgePair_swigregister(FindEdgePair)
class CaliperEdgeSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CaliperEdgeSet_swiginit(self, _pyaqcv.new_CaliperEdgeSet())
    __swig_destroy__ = _pyaqcv.delete_CaliperEdgeSet

    def clear(self):
        return _pyaqcv.CaliperEdgeSet_clear(self)
    caplier_results = property(_pyaqcv.CaliperEdgeSet_caplier_results_get, _pyaqcv.CaliperEdgeSet_caplier_results_set)
    estimate_pts = property(_pyaqcv.CaliperEdgeSet_estimate_pts_get, _pyaqcv.CaliperEdgeSet_estimate_pts_set)
    fit_pts = property(_pyaqcv.CaliperEdgeSet_fit_pts_get, _pyaqcv.CaliperEdgeSet_fit_pts_set)

# Register CaliperEdgeSet in _pyaqcv:
_pyaqcv.CaliperEdgeSet_swigregister(CaliperEdgeSet)
class SingleEdgeInspectResultBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_SingleEdgeInspectResultBase

    def clear(self):
        return _pyaqcv.SingleEdgeInspectResultBase_clear(self)
    edges = property(_pyaqcv.SingleEdgeInspectResultBase_edges_get, _pyaqcv.SingleEdgeInspectResultBase_edges_set)
    defects = property(_pyaqcv.SingleEdgeInspectResultBase_defects_get, _pyaqcv.SingleEdgeInspectResultBase_defects_set)
    gaps = property(_pyaqcv.SingleEdgeInspectResultBase_gaps_get, _pyaqcv.SingleEdgeInspectResultBase_gaps_set)

# Register SingleEdgeInspectResultBase in _pyaqcv:
_pyaqcv.SingleEdgeInspectResultBase_swigregister(SingleEdgeInspectResultBase)
class SingleEdgeInspect(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profile_caliperset):
        _pyaqcv.SingleEdgeInspect_swiginit(self, _pyaqcv.new_SingleEdgeInspect(profile_caliperset))
    __swig_destroy__ = _pyaqcv.delete_SingleEdgeInspect

    def set_profile_caliperset(self, profile_caliperset):
        r"""
        Set the profile caliperset object
        :type profile_caliperset: :py:class:`ProfileCaliperSet`
        :param profile_caliperset: multiple calipers combined to form a profile
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_set_profile_caliperset(self, profile_caliperset)

    def get_profile_caliperset(self, profile_caliperset):
        r"""Get the profile caliperset object"""
        return _pyaqcv.SingleEdgeInspect_get_profile_caliperset(self, profile_caliperset)

    def get_find_direction(self):
        r"""
        Get the find direction object
        :rtype: int
        :return: FindDirectionType
        """
        return _pyaqcv.SingleEdgeInspect_get_find_direction(self)

    def set_find_direction(self, find_direction):
        r"""
        Set the find direction object
        :type find_direction: int
        :param find_direction: the direction of detect edges, FindDirectionType
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_set_find_direction(self, find_direction)

    def set_edge_polarity(self, edge_polarity):
        r"""
        Set edge polarity.
        :type edge_polarity: int
        :param edge_polarity:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.SingleEdgeInspect_set_edge_polarity(self, edge_polarity)

    def get_edge_polarity(self):
        r"""
        Get edge polarity.
        See also: set_edge_polarity.
        """
        return _pyaqcv.SingleEdgeInspect_get_edge_polarity(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold: the minimum greyscale contrast transition to be considered as an edge
        """
        return _pyaqcv.SingleEdgeInspect_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.SingleEdgeInspect_get_contrast_threshold(self)

    def set_filter_half_size(self, filter_half_size):
        r"""
        Set filter half size.
        :type filter_half_size: int
        :param filter_half_size: filter half size in pixels
        """
        return _pyaqcv.SingleEdgeInspect_set_filter_half_size(self, filter_half_size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.SingleEdgeInspect_get_filter_half_size(self)

    def set_edge_score_param(self, param):
        r"""
        Set the edge score param object
        :type param: :py:class:`SingleEdgeScoreParams`
        :param param:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_set_edge_score_param(self, param)

    def get_edge_score_param(self):
        r"""
        Get the edge score param object
        :rtype: :py:class:`SingleEdgeScoreParams`
        :return: SingleEdgeScoreParams
        """
        return _pyaqcv.SingleEdgeInspect_get_edge_score_param(self)

    def enable_edge_fit(self, enable):
        r"""
        Enables or disables the edge fitting.
        :type enable: boolean
        :param enable: true if enabled
        """
        return _pyaqcv.SingleEdgeInspect_enable_edge_fit(self, enable)

    def get_edge_fit_enabled(self):
        r"""
        Get the edge fit enabled object
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_get_edge_fit_enabled(self)

    def set_edge_base_model(self, base_model):
        r"""
        Set the edge base object
        :type base_model: :py:class:`IGeometry`
        :param base_model:
        :rtype: boolean
        :return: true if successed
        Notes: only support Line2f and Circle2f
        """
        return _pyaqcv.SingleEdgeInspect_set_edge_base_model(self, base_model)

    def get_edge_base_model(self, base_model):
        r"""
        Get the edge base object
        :type base_model: :py:class:`IGeometry`
        :param base_model:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_get_edge_base_model(self, base_model)

    def set_edge_fit_param(self, param):
        r"""
        Set the edge fit param object
        :type param: :py:class:`EdgeFitParams`
        :param param:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_set_edge_fit_param(self, param)

    def get_edge_fit_param(self):
        r"""
        Get the edge fit param object
        :rtype: :py:class:`EdgeFitParams`
        :return: EdgeFitParams
        """
        return _pyaqcv.SingleEdgeInspect_get_edge_fit_param(self)

    def set_defect_params(self, param):
        r"""
        Set the defect params object
        :type param: :py:class:`EdgePositionDefectParams`
        :param param: EdgePositionDefectParams
        :rtype: boolean
        :return: true if success
        """
        return _pyaqcv.SingleEdgeInspect_set_defect_params(self, param)

    def get_defect_params(self):
        r"""
        Get the defect params object
        :rtype: :py:class:`EdgePositionDefectParams`
        :return: EdgePositionDefectParams
        """
        return _pyaqcv.SingleEdgeInspect_get_defect_params(self)

    def set_gap_params(self, param):
        r"""
        Set the gap params object
        :type param: :py:class:`EdgeGapParams`
        :param param: EdgeGapParams
        :rtype: boolean
        :return: true if success
        """
        return _pyaqcv.SingleEdgeInspect_set_gap_params(self, param)

    def get_gap_params(self):
        r"""
        Get the gap params object
        :rtype: :py:class:`EdgeGapParams`
        :return: EdgeGapParams
        """
        return _pyaqcv.SingleEdgeInspect_get_gap_params(self)

    def execute(self, img):
        r"""
        execute edge inspect process
        :type img: :py:class:`Mat`
        :param img: input image, only support AQ_8UC1
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_execute(self, img)

    def get_inspect_result(self, res):
        r"""
        Get the inspect result object
        :type res: :py:class:`SingleEdgeInspectResultBase`
        :param res: SingleEdgeInspectResult
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.SingleEdgeInspect_get_inspect_result(self, res)

# Register SingleEdgeInspect in _pyaqcv:
_pyaqcv.SingleEdgeInspect_swigregister(SingleEdgeInspect)
class CaliperDualEdgeSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.CaliperDualEdgeSet_swiginit(self, _pyaqcv.new_CaliperDualEdgeSet())
    __swig_destroy__ = _pyaqcv.delete_CaliperDualEdgeSet

    def clear(self):
        return _pyaqcv.CaliperDualEdgeSet_clear(self)
    caliper_edges = property(_pyaqcv.CaliperDualEdgeSet_caliper_edges_get, _pyaqcv.CaliperDualEdgeSet_caliper_edges_set)
    estimate_pts = property(_pyaqcv.CaliperDualEdgeSet_estimate_pts_get, _pyaqcv.CaliperDualEdgeSet_estimate_pts_set)
    fit_pts_edge1 = property(_pyaqcv.CaliperDualEdgeSet_fit_pts_edge1_get, _pyaqcv.CaliperDualEdgeSet_fit_pts_edge1_set)
    fit_pts_edge2 = property(_pyaqcv.CaliperDualEdgeSet_fit_pts_edge2_get, _pyaqcv.CaliperDualEdgeSet_fit_pts_edge2_set)

# Register CaliperDualEdgeSet in _pyaqcv:
_pyaqcv.CaliperDualEdgeSet_swigregister(CaliperDualEdgeSet)
class DualEdgeInspectResultBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_DualEdgeInspectResultBase

    def clear(self):
        return _pyaqcv.DualEdgeInspectResultBase_clear(self)
    edges = property(_pyaqcv.DualEdgeInspectResultBase_edges_get, _pyaqcv.DualEdgeInspectResultBase_edges_set)
    defects_edge1 = property(_pyaqcv.DualEdgeInspectResultBase_defects_edge1_get, _pyaqcv.DualEdgeInspectResultBase_defects_edge1_set)
    defects_edge2 = property(_pyaqcv.DualEdgeInspectResultBase_defects_edge2_get, _pyaqcv.DualEdgeInspectResultBase_defects_edge2_set)
    gaps = property(_pyaqcv.DualEdgeInspectResultBase_gaps_get, _pyaqcv.DualEdgeInspectResultBase_gaps_set)

# Register DualEdgeInspectResultBase in _pyaqcv:
_pyaqcv.DualEdgeInspectResultBase_swigregister(DualEdgeInspectResultBase)
class DualEdgeInspect(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profile):
        _pyaqcv.DualEdgeInspect_swiginit(self, _pyaqcv.new_DualEdgeInspect(profile))
    __swig_destroy__ = _pyaqcv.delete_DualEdgeInspect

    def set_profile_caliperset(self, profile_caliperset):
        r"""
        Set the profile caliperset object
        :type profile_caliperset: :py:class:`ProfileCaliperSet`
        :param profile_caliperset: multiple calipers combined to form a profile
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_set_profile_caliperset(self, profile_caliperset)

    def get_profile_caliperset(self, profile_caliperset):
        r"""Get the profile caliperset object"""
        return _pyaqcv.DualEdgeInspect_get_profile_caliperset(self, profile_caliperset)

    def get_find_direction(self):
        return _pyaqcv.DualEdgeInspect_get_find_direction(self)

    def set_find_direction(self, find_direction):
        r"""
        Set the find direction object
        :type find_direction: int
        :param find_direction: the direction of detect edges, FindDirectionType
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_set_find_direction(self, find_direction)

    def set_edge_polarity(self, edge_polarity_edge1, edge_polarity_edge2):
        r"""
        Set edge polarity.
        :type edge_polarity_edge1: int
        :param edge_polarity_edge1:  desired polarity of the edge, please see 'EdgePolarityType'
        :type edge_polarity_edge2: int
        :param edge_polarity_edge2:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.DualEdgeInspect_set_edge_polarity(self, edge_polarity_edge1, edge_polarity_edge2)

    def get_edge1_polarity(self):
        r"""
        Get edge polarity.
        See also: set_edge_polarity.
        """
        return _pyaqcv.DualEdgeInspect_get_edge1_polarity(self)

    def get_edge2_polarity(self):
        return _pyaqcv.DualEdgeInspect_get_edge2_polarity(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold: the minimum greyscale contrast transition to be considered as an edge
        """
        return _pyaqcv.DualEdgeInspect_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.DualEdgeInspect_get_contrast_threshold(self)

    def set_filter_half_size(self, filter_half_size):
        r"""
        Set filter half size.
        :type filter_half_size: int
        :param filter_half_size: filter half size in pixels
        """
        return _pyaqcv.DualEdgeInspect_set_filter_half_size(self, filter_half_size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.DualEdgeInspect_get_filter_half_size(self)

    def set_edge_score_param(self, param):
        r"""
        Set the edge score param object
        :type param: :py:class:`DualEdgeScoreParams`
        :param param:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_set_edge_score_param(self, param)

    def get_edge_score_param(self):
        r"""
        Get the edge score param object
        :rtype: :py:class:`DualEdgeScoreParams`
        :return: DualEdgeScoreParams
        """
        return _pyaqcv.DualEdgeInspect_get_edge_score_param(self)

    def enable_edge_fit(self, enable):
        r"""
        :type enable: boolean
        :param enable:
        """
        return _pyaqcv.DualEdgeInspect_enable_edge_fit(self, enable)

    def get_edge_fit_enabled(self):
        r"""
        Get the edge fit enabled object
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_get_edge_fit_enabled(self)

    def set_edge_base_model(self, base_model_edge1, base_model_edge2):
        r"""
        Set the edge base object
        :type base_model_edge1: :py:class:`IGeometry`
        :param base_model_edge1:
        :type base_model_edge2: :py:class:`IGeometry`
        :param base_model_edge2:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_set_edge_base_model(self, base_model_edge1, base_model_edge2)

    def get_edge_base_model(self, base_model_edge1, base_model_edge2):
        r"""
        Get the edge base object
        :type base_model_edge1: :py:class:`IGeometry`
        :param base_model_edge1:
        :type base_model_edge2: :py:class:`IGeometry`
        :param base_model_edge2:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_get_edge_base_model(self, base_model_edge1, base_model_edge2)

    def set_edge_fit_param(self, param):
        r"""
        Set the edge fit param object
        :type param: :py:class:`EdgeFitParams`
        :param param:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_set_edge_fit_param(self, param)

    def get_edge_fit_param(self):
        r"""
        Get the edge fit param object
        :rtype: :py:class:`EdgeFitParams`
        :return: EdgeFitParams
        """
        return _pyaqcv.DualEdgeInspect_get_edge_fit_param(self)

    def set_defect_params(self, param):
        r"""
        Set the defect params object
        :type param: :py:class:`EdgePositionDefectParams`
        :param param: EdgePositionDefectParams
        :rtype: boolean
        :return: true if success
        """
        return _pyaqcv.DualEdgeInspect_set_defect_params(self, param)

    def get_defect_params(self):
        r"""
        Get the defect params object
        :rtype: :py:class:`EdgePositionDefectParams`
        :return: EdgePositionDefectParams
        """
        return _pyaqcv.DualEdgeInspect_get_defect_params(self)

    def set_gap_params(self, param):
        r"""
        Set the gap params object
        :type param: :py:class:`EdgeGapParams`
        :param param: EdgeGapParams
        :rtype: boolean
        :return: true if success
        """
        return _pyaqcv.DualEdgeInspect_set_gap_params(self, param)

    def get_gap_params(self):
        r"""
        Get the gap params object
        :rtype: :py:class:`EdgeGapParams`
        :return: EdgeGapParams
        """
        return _pyaqcv.DualEdgeInspect_get_gap_params(self)

    def execute(self, img):
        r"""
        execute edge inspect process
        :type img: :py:class:`Mat`
        :param img: input image, only support AQ_8UC1
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_execute(self, img)

    def get_inspect_result(self, res):
        r"""
        Get the inspect result object
        :type res: :py:class:`DualEdgeInspectResultBase`
        :param res: SingleEdgeInspectResult
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.DualEdgeInspect_get_inspect_result(self, res)

# Register DualEdgeInspect in _pyaqcv:
_pyaqcv.DualEdgeInspect_swigregister(DualEdgeInspect)
class EdgeWidth(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width_seg = property(_pyaqcv.EdgeWidth_width_seg_get, _pyaqcv.EdgeWidth_width_seg_set)
    width = property(_pyaqcv.EdgeWidth_width_get, _pyaqcv.EdgeWidth_width_set)

    def __init__(self):
        _pyaqcv.EdgeWidth_swiginit(self, _pyaqcv.new_EdgeWidth())
    __swig_destroy__ = _pyaqcv.delete_EdgeWidth

# Register EdgeWidth in _pyaqcv:
_pyaqcv.EdgeWidth_swigregister(EdgeWidth)
class EdgeWidthMeasureResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def clear(self):
        return _pyaqcv.EdgeWidthMeasureResult_clear(self)
    edges_points = property(_pyaqcv.EdgeWidthMeasureResult_edges_points_get, _pyaqcv.EdgeWidthMeasureResult_edges_points_set)
    edges_width = property(_pyaqcv.EdgeWidthMeasureResult_edges_width_get, _pyaqcv.EdgeWidthMeasureResult_edges_width_set)
    max_width_id = property(_pyaqcv.EdgeWidthMeasureResult_max_width_id_get, _pyaqcv.EdgeWidthMeasureResult_max_width_id_set)
    min_width_id = property(_pyaqcv.EdgeWidthMeasureResult_min_width_id_get, _pyaqcv.EdgeWidthMeasureResult_min_width_id_set)

    def __init__(self):
        _pyaqcv.EdgeWidthMeasureResult_swiginit(self, _pyaqcv.new_EdgeWidthMeasureResult())
    __swig_destroy__ = _pyaqcv.delete_EdgeWidthMeasureResult

# Register EdgeWidthMeasureResult in _pyaqcv:
_pyaqcv.EdgeWidthMeasureResult_swigregister(EdgeWidthMeasureResult)
class EdgeWidthMeasure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, profile_caliperset):
        _pyaqcv.EdgeWidthMeasure_swiginit(self, _pyaqcv.new_EdgeWidthMeasure(profile_caliperset))
    __swig_destroy__ = _pyaqcv.delete_EdgeWidthMeasure

    def set_dual_edge_type(self, dual_edge_type):
        return _pyaqcv.EdgeWidthMeasure_set_dual_edge_type(self, dual_edge_type)

    def get_dual_edge_type(self):
        return _pyaqcv.EdgeWidthMeasure_get_dual_edge_type(self)

    def set_profile_caliperset(self, profile_caliperset):
        return _pyaqcv.EdgeWidthMeasure_set_profile_caliperset(self, profile_caliperset)

    def get_profile_caliperset(self, profile_caliperset):
        return _pyaqcv.EdgeWidthMeasure_get_profile_caliperset(self, profile_caliperset)

    def set_find_direction(self, find_direction):
        return _pyaqcv.EdgeWidthMeasure_set_find_direction(self, find_direction)

    def get_find_direction(self):
        return _pyaqcv.EdgeWidthMeasure_get_find_direction(self)

    def set_edge_polarity(self, edge_polarity_edge1, edge_polarity_edge2):
        r"""
        Set edge polarity.
        :type edge_polarity_edge1: int
        :param edge_polarity_edge1:  desired polarity of the edge, please see 'EdgePolarityType'
        :type edge_polarity_edge2: int
        :param edge_polarity_edge2:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.EdgeWidthMeasure_set_edge_polarity(self, edge_polarity_edge1, edge_polarity_edge2)

    def get_edge1_polarity(self):
        r"""
        Get edge polarity.
        See also: set_edge_polarity.
        """
        return _pyaqcv.EdgeWidthMeasure_get_edge1_polarity(self)

    def get_edge2_polarity(self):
        return _pyaqcv.EdgeWidthMeasure_get_edge2_polarity(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold: the minimum greyscale contrast transition to be considered as an edge
        """
        return _pyaqcv.EdgeWidthMeasure_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.EdgeWidthMeasure_get_contrast_threshold(self)

    def set_sensitivity_threshold(self, sensitivity_threshold):
        r"""
        Set sensitivity threshold.
        :type sensitivity_threshold: float
        :param sensitivity_threshold:  minimum sensitivity required for an edge
        """
        return _pyaqcv.EdgeWidthMeasure_set_sensitivity_threshold(self, sensitivity_threshold)

    def get_sensitivity_threshold(self):
        r"""
        Get sensitivity threshold.
        See also: set_sensitivity_threshold
        """
        return _pyaqcv.EdgeWidthMeasure_get_sensitivity_threshold(self)

    def set_filter_half_size(self, filter_half_size):
        r"""
        Set filter half size.
        :type filter_half_size: int
        :param filter_half_size: filter half size in pixels
        """
        return _pyaqcv.EdgeWidthMeasure_set_filter_half_size(self, filter_half_size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.EdgeWidthMeasure_get_filter_half_size(self)

    def set_edge_score_param(self, param):
        r"""
        Set the edge score param object
        :type param: :py:class:`DualEdgeScoreParams`
        :param param:
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.EdgeWidthMeasure_set_edge_score_param(self, param)

    def get_edge_score_param(self):
        r"""
        Get the edge score param object
        :rtype: :py:class:`DualEdgeScoreParams`
        :return: DualEdgeScoreParams
        """
        return _pyaqcv.EdgeWidthMeasure_get_edge_score_param(self)

    def set_edge_width_range(self, min_width, max_width):
        r"""
        Set the edge width range object, valid edges between min_width and max_width
        :type min_width: float
        :param min_width: the minimum width value allowed.
        :type max_width: float
        :param max_width: the maximum width value allowed.
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.EdgeWidthMeasure_set_edge_width_range(self, min_width, max_width)

    def get_edge_width_range(self, min_width, max_width):
        r"""
        Get the edge width range object
        :type min_width: float
        :param min_width:
        :type max_width: float
        :param max_width:
        See also: set_edge_width_range
        """
        return _pyaqcv.EdgeWidthMeasure_get_edge_width_range(self, min_width, max_width)

    def execute(self, img):
        r"""
        execute edge inspect process
        :type img: :py:class:`Mat`
        :param img: input image, only support AQ_8UC1
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.EdgeWidthMeasure_execute(self, img)

    def get_measure_result(self, res):
        r"""
        Get the inspect result object
        :type res: :py:class:`EdgeWidthMeasureResult`
        :param res: SingleEdgeMeasureResult
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.EdgeWidthMeasure_get_measure_result(self, res)

# Register EdgeWidthMeasure in _pyaqcv:
_pyaqcv.EdgeWidthMeasure_swigregister(EdgeWidthMeasure)
class AnnularEdgeWidthMeasureResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width = property(_pyaqcv.AnnularEdgeWidthMeasureResult_width_get, _pyaqcv.AnnularEdgeWidthMeasureResult_width_set)
    edge_angles = property(_pyaqcv.AnnularEdgeWidthMeasureResult_edge_angles_get, _pyaqcv.AnnularEdgeWidthMeasureResult_edge_angles_set)

    def __init__(self):
        _pyaqcv.AnnularEdgeWidthMeasureResult_swiginit(self, _pyaqcv.new_AnnularEdgeWidthMeasureResult())
    __swig_destroy__ = _pyaqcv.delete_AnnularEdgeWidthMeasureResult

# Register AnnularEdgeWidthMeasureResult in _pyaqcv:
_pyaqcv.AnnularEdgeWidthMeasureResult_swigregister(AnnularEdgeWidthMeasureResult)
class AnnularEdgeWidthMeasure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.AnnularEdgeWidthMeasure_swiginit(self, _pyaqcv.new_AnnularEdgeWidthMeasure())
    __swig_destroy__ = _pyaqcv.delete_AnnularEdgeWidthMeasure

    def set_edge_polarity(self, edge_polarity):
        r"""
        Set edge polarity.
        :type edge_polarity: int
        :param edge_polarity:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_set_edge_polarity(self, edge_polarity)

    def get_edge_polarity(self):
        r"""
        Get edge polarity.
        See also: set_edge_polarity.
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_get_edge_polarity(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold: the minimum greyscale contrast transition to be considered as an edge
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_get_contrast_threshold(self)

    def set_sensitivity_threshold(self, sensitivity_threshold):
        r"""
        Set sensitivity threshold.
        :type sensitivity_threshold: float
        :param sensitivity_threshold:  minimum sensitivity required for an edge.The parameters range is [0,1]
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_set_sensitivity_threshold(self, sensitivity_threshold)

    def get_sensitivity_threshold(self):
        r"""
        Get sensitivity threshold.
        See also: set_sensitivity_threshold
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_get_sensitivity_threshold(self)

    def set_filter_half_size(self, filter_half_size):
        r"""
        Set filter half size.
        :type filter_half_size: int
        :param filter_half_size: filter half size in pixels
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_set_filter_half_size(self, filter_half_size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_get_filter_half_size(self)

    def execute(self, image, roi, radius_end):
        r"""
        Apply the caliper to the given image.
        :type image: :py:class:`Mat`
        :param image:  input image.Only  support AQ_8UC1.
        :type roi: :py:class:`Arc2f`
        :param roi: the inner arc of the roi
        :type radius_end: float
        :param radius_end: outer diameter of the roi
        :rtype: boolean
        :return: true if success, false otherwise.
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_execute(self, image, roi, radius_end)

    def get_edges_num(self):
        r"""
        Get edges number of this execute.
        :rtype: int
        :return: edges number
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_get_edges_num(self)

    def get_width(self, dual_edge_type, result):
        r"""
        Get specifies edges dimension. Specifies the two edges of the indexes
        :type dual_edge_type: int
        :param dual_edge_type: outside dimensions or inside dimension
        :type result: :py:class:`AnnularEdgeWidthMeasureResult`
        :param result: The distance between these two edges
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_get_width(self, dual_edge_type, result)

    def get_specifies_edges_width(self, index1, index2, result):
        r"""
        Get specifies edges dimension. Specifies the two edges of the indexes
        :type index1: int
        :param index1: The start edge index
        :type index2: int
        :param index2:  The  end edge index
        :param results:  The distance between these two edges
        :rtype: boolean
        :return: true if ok
        """
        return _pyaqcv.AnnularEdgeWidthMeasure_get_specifies_edges_width(self, index1, index2, result)

# Register AnnularEdgeWidthMeasure in _pyaqcv:
_pyaqcv.AnnularEdgeWidthMeasure_swigregister(AnnularEdgeWidthMeasure)
class TipPositionResults(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    edge_pts = property(_pyaqcv.TipPositionResults_edge_pts_get, _pyaqcv.TipPositionResults_edge_pts_set, doc=r"""edge points""")
    offsets = property(_pyaqcv.TipPositionResults_offsets_get, _pyaqcv.TipPositionResults_offsets_set, doc=r"""offset of each point in the direction of ROI""")
    caliper_indexs = property(_pyaqcv.TipPositionResults_caliper_indexs_get, _pyaqcv.TipPositionResults_caliper_indexs_set, doc=r"""caliper index for every edge_pts and offsets""")
    max_offset_idx = property(_pyaqcv.TipPositionResults_max_offset_idx_get, _pyaqcv.TipPositionResults_max_offset_idx_set, doc=r"""maximum offset point index, -1 indicates invalid""")
    min_offset_idx = property(_pyaqcv.TipPositionResults_min_offset_idx_get, _pyaqcv.TipPositionResults_min_offset_idx_set, doc=r"""minimum offset point index, -1 indicates invalid""")

    def __init__(self):
        _pyaqcv.TipPositionResults_swiginit(self, _pyaqcv.new_TipPositionResults())
    __swig_destroy__ = _pyaqcv.delete_TipPositionResults

# Register TipPositionResults in _pyaqcv:
_pyaqcv.TipPositionResults_swigregister(TipPositionResults)
class TipPosition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.TipPosition_swiginit(self, _pyaqcv.new_TipPosition(*args))
    __swig_destroy__ = _pyaqcv.delete_TipPosition

    def set_roi(self, roi):
        r"""
        set the line search region
        :type roi: :py:class:`RotateRect2f`
        :param roi:  the region where to find a line, it's x direction should be almost paraller to the line wantted to be found
                          and it's y direction is the caliper search direction and line order direction
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.TipPosition_set_roi(self, roi)

    def get_roi(self):
        r"""get roi"""
        return _pyaqcv.TipPosition_get_roi(self)

    def set_edge_polarity(self, polarity):
        r"""
        set(get) preferred edge polarity type
        :type polarity: int
        :param polarity: expect edge polarity
        """
        return _pyaqcv.TipPosition_set_edge_polarity(self, polarity)

    def get_edge_polarity(self):
        r"""get current edge polarity"""
        return _pyaqcv.TipPosition_get_edge_polarity(self)

    def set_edge_threshold(self, thresh):
        r"""
        set(get) preferred edge contrast threshold
        :type thresh: float
        :param thresh:  edge contrast threshold(contrast lower than thresh will be ignored). range: (0, 255]
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.TipPosition_set_edge_threshold(self, thresh)

    def get_edge_threshold(self):
        r"""get current edge threshold"""
        return _pyaqcv.TipPosition_get_edge_threshold(self)

    def set_edge_order(self, type):
        r"""
        set which edge is perferred
        :type type: int
        :param type: perferred edge order type, Notes: default is kFirstEdge
        """
        return _pyaqcv.TipPosition_set_edge_order(self, type)

    def get_edge_order(self):
        r"""get perferred edge order type"""
        return _pyaqcv.TipPosition_get_edge_order(self)

    def set_filter_half_size(self, edge_width):
        r"""
        set perferred edge width
        :type edge_width: int
        :param edge_width: width of expect edge,usefull when edge is blur
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.TipPosition_set_filter_half_size(self, edge_width)

    def get_filter_half_size(self):
        return _pyaqcv.TipPosition_get_filter_half_size(self)

    def set_caliper_auto(self, enable=True):
        r"""
        whether to set calipers with default setting
        :type enable: boolean, optional
        :param enable: whether enable caliper params to set with auto settings.
        """
        return _pyaqcv.TipPosition_set_caliper_auto(self, enable)

    def is_caliper_auto(self):
        return _pyaqcv.TipPosition_is_caliper_auto(self)

    def set_caliper_width(self, width):
        r"""set/get caliper regions' width and space between neightboors, only valid in non-auto caliper mode."""
        return _pyaqcv.TipPosition_set_caliper_width(self, width)

    def get_caliper_width(self):
        return _pyaqcv.TipPosition_get_caliper_width(self)

    def set_caliper_space(self, space):
        r"""set/get space(in pixel) between adjacent calipers"""
        return _pyaqcv.TipPosition_set_caliper_space(self, space)

    def get_caliper_space(self):
        return _pyaqcv.TipPosition_get_caliper_space(self)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.TipPosition_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.TipPosition_get_mask_region(self)

    def execute(self, img, res):
        r"""
        find line
        :type img: :py:class:`Mat`
        :param img: the image to search
        :type res: :py:class:`TipPositionResults`
        :param res: the result line(represented by line segment,it's endpoints it the cross points of line and ROI boundary)
        :param rms: optional error(root of mean square)
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.TipPosition_execute(self, img, res)

    def get_caliper_rects(self):
        r"""
        get caliper sampling rois
        :rtype: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :return: all calipers' sampling roi rectangles
        """
        return _pyaqcv.TipPosition_get_caliper_rects(self)

# Register TipPosition in _pyaqcv:
_pyaqcv.TipPosition_swigregister(TipPosition)
kBarTypeNone = _pyaqcv.kBarTypeNone
r"""set all BarType ; if docode fail ,result type set kBarTypeNone"""
kBarTypeCode128 = _pyaqcv.kBarTypeCode128
r"""code 128"""
kBarTypeCode39 = _pyaqcv.kBarTypeCode39
r"""code 39"""
kBarTypeCode93 = _pyaqcv.kBarTypeCode93
r"""code 93"""
kBarTypeEAN13 = _pyaqcv.kBarTypeEAN13
r"""EAN-13"""
kBarTypeEAN8 = _pyaqcv.kBarTypeEAN8
r"""EAN-8"""
kBarTypeUPCA = _pyaqcv.kBarTypeUPCA
r"""UPC-A"""
kBarTypeUPCE = _pyaqcv.kBarTypeUPCE
r"""UPC-E"""
kBarDecodeModelTypeAdvance = _pyaqcv.kBarDecodeModelTypeAdvance
r"""advance decode mode.it is suitable for complicate scenarios"""
kBarDecodeModelTypeFast = _pyaqcv.kBarDecodeModelTypeFast
r"""fast decode mode.it is suitable for simple scenarios and faster than standard methods"""
kBarDecodeModelTypeStandard = _pyaqcv.kBarDecodeModelTypeStandard
r"""standard decode mode.it is suitable for general scenarios"""
kBarCheckSumTypeCheckNone = _pyaqcv.kBarCheckSumTypeCheckNone
r"""No check"""
kBarCheckSumTypeVerify = _pyaqcv.kBarCheckSumTypeVerify
r"""chack and remove chack character"""
kBarCheckSumTypeVerifyAndTransmit = _pyaqcv.kBarCheckSumTypeVerifyAndTransmit
r"""chack and transmit chack character"""
class BarDecodeParam(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarDecodeParam_swiginit(self, _pyaqcv.new_BarDecodeParam())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParam
    type = property(_pyaqcv.BarDecodeParam_type_get, _pyaqcv.BarDecodeParam_type_set)
    enable_quiet_zone = property(_pyaqcv.BarDecodeParam_enable_quiet_zone_get, _pyaqcv.BarDecodeParam_enable_quiet_zone_set)

# Register BarDecodeParam in _pyaqcv:
_pyaqcv.BarDecodeParam_swigregister(BarDecodeParam)
class BarDecodeParamCode128(BarDecodeParam):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarDecodeParamCode128_swiginit(self, _pyaqcv.new_BarDecodeParamCode128())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParamCode128

# Register BarDecodeParamCode128 in _pyaqcv:
_pyaqcv.BarDecodeParamCode128_swigregister(BarDecodeParamCode128)
class BarDecodeParamCode39(BarDecodeParam):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    check_sum_character = property(_pyaqcv.BarDecodeParamCode39_check_sum_character_get, _pyaqcv.BarDecodeParamCode39_check_sum_character_set)
    full_ascii = property(_pyaqcv.BarDecodeParamCode39_full_ascii_get, _pyaqcv.BarDecodeParamCode39_full_ascii_set)

    def __init__(self):
        _pyaqcv.BarDecodeParamCode39_swiginit(self, _pyaqcv.new_BarDecodeParamCode39())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParamCode39

# Register BarDecodeParamCode39 in _pyaqcv:
_pyaqcv.BarDecodeParamCode39_swigregister(BarDecodeParamCode39)
class BarDecodeParamCode93(BarDecodeParam):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarDecodeParamCode93_swiginit(self, _pyaqcv.new_BarDecodeParamCode93())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParamCode93

# Register BarDecodeParamCode93 in _pyaqcv:
_pyaqcv.BarDecodeParamCode93_swigregister(BarDecodeParamCode93)
class BarDecodeParamEAN13(BarDecodeParam):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarDecodeParamEAN13_swiginit(self, _pyaqcv.new_BarDecodeParamEAN13())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParamEAN13

# Register BarDecodeParamEAN13 in _pyaqcv:
_pyaqcv.BarDecodeParamEAN13_swigregister(BarDecodeParamEAN13)
class BarDecodeParamEAN8(BarDecodeParam):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarDecodeParamEAN8_swiginit(self, _pyaqcv.new_BarDecodeParamEAN8())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParamEAN8

# Register BarDecodeParamEAN8 in _pyaqcv:
_pyaqcv.BarDecodeParamEAN8_swigregister(BarDecodeParamEAN8)
class BarDecodeParamUPCA(BarDecodeParam):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarDecodeParamUPCA_swiginit(self, _pyaqcv.new_BarDecodeParamUPCA())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParamUPCA

# Register BarDecodeParamUPCA in _pyaqcv:
_pyaqcv.BarDecodeParamUPCA_swigregister(BarDecodeParamUPCA)
class BarDecodeParamUPCE(BarDecodeParam):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarDecodeParamUPCE_swiginit(self, _pyaqcv.new_BarDecodeParamUPCE())
    __swig_destroy__ = _pyaqcv.delete_BarDecodeParamUPCE

# Register BarDecodeParamUPCE in _pyaqcv:
_pyaqcv.BarDecodeParamUPCE_swigregister(BarDecodeParamUPCE)
class BarcodeResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarcodeResult_swiginit(self, _pyaqcv.new_BarcodeResult())
    score = property(_pyaqcv.BarcodeResult_score_get, _pyaqcv.BarcodeResult_score_set)
    code_string = property(_pyaqcv.BarcodeResult_code_string_get, _pyaqcv.BarcodeResult_code_string_set)
    error_msg = property(_pyaqcv.BarcodeResult_error_msg_get, _pyaqcv.BarcodeResult_error_msg_set)
    barcode_type = property(_pyaqcv.BarcodeResult_barcode_type_get, _pyaqcv.BarcodeResult_barcode_type_set)
    region = property(_pyaqcv.BarcodeResult_region_get, _pyaqcv.BarcodeResult_region_set)
    __swig_destroy__ = _pyaqcv.delete_BarcodeResult

# Register BarcodeResult in _pyaqcv:
_pyaqcv.BarcodeResult_swigregister(BarcodeResult)
class BarcodeReader(object):
    r"""barcode recognition reader,include detection and decoding."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BarcodeReader_swiginit(self, _pyaqcv.new_BarcodeReader())

    def set_barcode_types(self, barcode_types):
        r"""
        set barcode types which will be tried to decode.
                if not set or any element is set to kBarTypeNone, the vector is set to all types.
                The decoder only decodes the types in the vector.
        :type barcode_types: std::vector< aqcv::BarType,std::allocator< aqcv::BarType > >
        :param barcode_types: barcode types.
        """
        return _pyaqcv.BarcodeReader_set_barcode_types(self, barcode_types)

    def get_barcode_types(self):
        r"""
        get barcode types
        See also: set_barcode_types
        """
        return _pyaqcv.BarcodeReader_get_barcode_types(self)

    def set_decode_param(self, decode_param):
        r"""
        set decode param for specific code type.for example code39 requires BarDecodeParamCode39 to be set.
        :type decode_param: :py:class:`BarDecodeParam`
        :param decode_param: decode param see BarDecodeParam.
        """
        return _pyaqcv.BarcodeReader_set_decode_param(self, decode_param)

    def get_decode_param(self, barcode_type):
        r"""
        get decode param.
        See also: set_decode_param.
        """
        return _pyaqcv.BarcodeReader_get_decode_param(self, barcode_type)

    def set_decode_model_type(self, decode_model_type):
        r"""
        set decode model type.
        :type decode_model_type: int
        :param decode_model_type: deocde model type
        """
        return _pyaqcv.BarcodeReader_set_decode_model_type(self, decode_model_type)

    def get_decode_model_type(self):
        r"""
        get decode model type.
        See also: set_decode_model_type.
        """
        return _pyaqcv.BarcodeReader_get_decode_model_type(self)

    def set_num_scanlines(self, num_scanning):
        r"""
        set scanning line number
        :type num_scanning: int
        :param num_scanning: scanning line number.
        :rtype: boolean
        :return: true if success, false otherwise.
        """
        return _pyaqcv.BarcodeReader_set_num_scanlines(self, num_scanning)

    def get_num_scanlines(self):
        r"""
        get scanning line number
        See also: set_num_scanlines
        """
        return _pyaqcv.BarcodeReader_get_num_scanlines(self)

    def detect(self, image, regions):
        r"""
        the location of all barcodes in the image is detected, and the barcode type is not filtered.
        :type image: :py:class:`Mat`
        :param image: input image for detect barcode.support AQ_8U only.
        :type regions: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :param regions: detect result list.
        :rtype: boolean
        :return: true if ok.
        """
        return _pyaqcv.BarcodeReader_detect(self, image, regions)

    def decode(self, image, region, result):
        r"""
        decode barcode
        :type image: :py:class:`Mat`
        :param image: input image which is same with detecting.support AQ_8U only.
        :type region: :py:class:`RotateRect2f`
        :param region: barcode region
        :type result: :py:class:`BarcodeResult`
        :param result: decode result, It corresponds to the regions.
                         only the barcode types of the set is decoded. for example, if only code128 is set but code39 is entered, decoding fails.
                         If all the set types fail to decode , the barcode_type of the result is kBarTypeNone.
        :rtype: boolean
        :return: true if ok.
        """
        return _pyaqcv.BarcodeReader_decode(self, image, region, result)

    def detect_and_decode(self, image, results, keep_all_detections):
        r"""
        detect and decode barcode.
        :type image: :py:class:`Mat`
        :param image: input image.support AQ_8U only.
        :type results: std::vector< aqcv::BarcodeResult,std::allocator< aqcv::BarcodeResult > >
        :param results: decode result list.
        :type keep_all_detections: boolean
        :param keep_all_detections: if it is true, all results are kept, otherwise the ones with failed decoding are removed
        :rtype: boolean
        :return: true if ok.
        """
        return _pyaqcv.BarcodeReader_detect_and_decode(self, image, results, keep_all_detections)
    __swig_destroy__ = _pyaqcv.delete_BarcodeReader

# Register BarcodeReader in _pyaqcv:
_pyaqcv.BarcodeReader_swigregister(BarcodeReader)
Code2DModelType_kAnyType = _pyaqcv.Code2DModelType_kAnyType
Code2DModelType_kDMECC200 = _pyaqcv.Code2DModelType_kDMECC200
Code2DModelType_kQR = _pyaqcv.Code2DModelType_kQR
Code2DModelType_kQRM1 = _pyaqcv.Code2DModelType_kQRM1
Code2DModelType_kQRM2 = _pyaqcv.Code2DModelType_kQRM2
Code2DModelType_kMicroQR = _pyaqcv.Code2DModelType_kMicroQR
Code2DPolarity_kAnyPolarity = _pyaqcv.Code2DPolarity_kAnyPolarity
r"""symbol polarity is unkown"""
Code2DPolarity_kLightInDark = _pyaqcv.Code2DPolarity_kLightInDark
r"""light modules in dark background"""
Code2DPolarity_kDarkInLight = _pyaqcv.Code2DPolarity_kDarkInLight
r"""dark modules in light background"""
Code2DPreProcessControlBit_kOnlyBinary = _pyaqcv.Code2DPreProcessControlBit_kOnlyBinary
Code2DPreProcessControlBit_kWhole = _pyaqcv.Code2DPreProcessControlBit_kWhole
Code2DPreProcessControlBit_kbyDeepNet = _pyaqcv.Code2DPreProcessControlBit_kbyDeepNet
r"""reserved option for new operator"""
Code2DReaderInfos_kSuccess = _pyaqcv.Code2DReaderInfos_kSuccess
Code2DReaderInfos_kDecodeFailure = _pyaqcv.Code2DReaderInfos_kDecodeFailure
Code2DReaderInfos_kTimeout = _pyaqcv.Code2DReaderInfos_kTimeout
Code2DReaderInfos_kExistEmptyParameter = _pyaqcv.Code2DReaderInfos_kExistEmptyParameter
Code2DReaderInfos_kInvalidImageType = _pyaqcv.Code2DReaderInfos_kInvalidImageType
Code2DReaderInfos_kInvalidROI = _pyaqcv.Code2DReaderInfos_kInvalidROI
Code2DTrainInfos_kImageInvaild = _pyaqcv.Code2DTrainInfos_kImageInvaild
Code2DTrainInfos_kTimeout = _pyaqcv.Code2DTrainInfos_kTimeout
Code2DTrainInfos_kNotTraining = _pyaqcv.Code2DTrainInfos_kNotTraining
Code2DTrainInfos_kSuccess = _pyaqcv.Code2DTrainInfos_kSuccess
Code2DTrainInfos_kFailureToEnhance = _pyaqcv.Code2DTrainInfos_kFailureToEnhance
Code2DTrainInfos_kFailureToBinary = _pyaqcv.Code2DTrainInfos_kFailureToBinary
Code2DTrainInfos_kFailureToCorrection = _pyaqcv.Code2DTrainInfos_kFailureToCorrection
Code2DTrainInfos_kFailureToFindVersion = _pyaqcv.Code2DTrainInfos_kFailureToFindVersion
Code2DTrainInfos_kFailureToReconstruct = _pyaqcv.Code2DTrainInfos_kFailureToReconstruct
Code2DTrainInfos_kFailureToDecode = _pyaqcv.Code2DTrainInfos_kFailureToDecode
Code2DErrorCorrrectLevel_kGradeUnkown = _pyaqcv.Code2DErrorCorrrectLevel_kGradeUnkown
Code2DErrorCorrrectLevel_kGradeL = _pyaqcv.Code2DErrorCorrrectLevel_kGradeL
Code2DErrorCorrrectLevel_kGradeM = _pyaqcv.Code2DErrorCorrrectLevel_kGradeM
Code2DErrorCorrrectLevel_kGradeQ = _pyaqcv.Code2DErrorCorrrectLevel_kGradeQ
Code2DErrorCorrrectLevel_kGradeH = _pyaqcv.Code2DErrorCorrrectLevel_kGradeH
class ECB(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    number_total_codewords = property(_pyaqcv.ECB_number_total_codewords_get, _pyaqcv.ECB_number_total_codewords_set)
    number_data_codewords = property(_pyaqcv.ECB_number_data_codewords_get, _pyaqcv.ECB_number_data_codewords_set)
    capacity_correctable_error = property(_pyaqcv.ECB_capacity_correctable_error_get, _pyaqcv.ECB_capacity_correctable_error_set)
    p_value = property(_pyaqcv.ECB_p_value_get, _pyaqcv.ECB_p_value_set)

    def __init__(self, *args):
        _pyaqcv.ECB_swiginit(self, _pyaqcv.new_ECB(*args))
    __swig_destroy__ = _pyaqcv.delete_ECB

# Register ECB in _pyaqcv:
_pyaqcv.ECB_swigregister(ECB)
class Code2DDecoderParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    same_class_count = property(_pyaqcv.Code2DDecoderParameter_same_class_count_get, _pyaqcv.Code2DDecoderParameter_same_class_count_set, doc=r"""reserved option, to support the multi-source training set with diffirent feature in the future""")
    version = property(_pyaqcv.Code2DDecoderParameter_version_get, _pyaqcv.Code2DDecoderParameter_version_set, doc=r"""symbol version""")
    polarity = property(_pyaqcv.Code2DDecoderParameter_polarity_get, _pyaqcv.Code2DDecoderParameter_polarity_set, doc=r"""symbol polarity""")
    module_width_range = property(_pyaqcv.Code2DDecoderParameter_module_width_range_get, _pyaqcv.Code2DDecoderParameter_module_width_range_set, doc=r"""width range of DM symbol module""")
    control_bit = property(_pyaqcv.Code2DDecoderParameter_control_bit_get, _pyaqcv.Code2DDecoderParameter_control_bit_set, doc=r"""image preprocess control bits""")
    increment = property(_pyaqcv.Code2DDecoderParameter_increment_get, _pyaqcv.Code2DDecoderParameter_increment_set, doc=r"""wellner-operator weight increment""")
    mirrory = property(_pyaqcv.Code2DDecoderParameter_mirrory_get, _pyaqcv.Code2DDecoderParameter_mirrory_set, doc=r"""symbol mirrory""")
    amplification = property(_pyaqcv.Code2DDecoderParameter_amplification_get, _pyaqcv.Code2DDecoderParameter_amplification_set, doc=r"""image amplification ratio""")
    reduction = property(_pyaqcv.Code2DDecoderParameter_reduction_get, _pyaqcv.Code2DDecoderParameter_reduction_set, doc=r"""image reduction ratio""")

    def __init__(self):
        _pyaqcv.Code2DDecoderParameter_swiginit(self, _pyaqcv.new_Code2DDecoderParameter())
    __swig_destroy__ = _pyaqcv.delete_Code2DDecoderParameter

# Register Code2DDecoderParameter in _pyaqcv:
_pyaqcv.Code2DDecoderParameter_swigregister(Code2DDecoderParameter)
class Code2DResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    valid = property(_pyaqcv.Code2DResult_valid_get, _pyaqcv.Code2DResult_valid_set, doc=r"""decoding successful bit""")
    info = property(_pyaqcv.Code2DResult_info_get, _pyaqcv.Code2DResult_info_set, doc=r"""decode result infos""")
    code_string = property(_pyaqcv.Code2DResult_code_string_get, _pyaqcv.Code2DResult_code_string_set, doc=r"""local explain""")
    raw_result = property(_pyaqcv.Code2DResult_raw_result_get, _pyaqcv.Code2DResult_raw_result_set, doc=r"""source byte stream""")
    boundary = property(_pyaqcv.Code2DResult_boundary_get, _pyaqcv.Code2DResult_boundary_set, doc=r"""boundary of relocalization""")

    def __init__(self, *args):
        _pyaqcv.Code2DResult_swiginit(self, _pyaqcv.new_Code2DResult(*args))
    __swig_destroy__ = _pyaqcv.delete_Code2DResult

# Register Code2DResult in _pyaqcv:
_pyaqcv.Code2DResult_swigregister(Code2DResult)
class Code2DDecoderBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_Code2DDecoderBase

    def set_module_width_range(self, min_val, max_val):
        r"""set width scale of DM symbol module"""
        return _pyaqcv.Code2DDecoderBase_set_module_width_range(self, min_val, max_val)

    def get_module_width_range(self, min_val, max_val):
        r"""get width range of DM symbol module"""
        return _pyaqcv.Code2DDecoderBase_get_module_width_range(self, min_val, max_val)

    def set_polarity(self, polarity):
        r"""set symbol polarity"""
        return _pyaqcv.Code2DDecoderBase_set_polarity(self, polarity)

    def get_polarity(self):
        r"""get symbol polarity"""
        return _pyaqcv.Code2DDecoderBase_get_polarity(self)

    def set_time_limit(self, time_limit_millisecond):
        r"""
        Set time limit(ms) for function execute.
        :type time_limit_millisecond: int
        :param time_limit_millisecond:  Time limit as millisecond. When val <= 0, time-limit function is invalid.
        """
        return _pyaqcv.Code2DDecoderBase_set_time_limit(self, time_limit_millisecond)

    def get_time_limit(self):
        r"""
        Get time limit(ms) for function execute.
        :rtype: int
        :return: The integer for time limit(ms).
        """
        return _pyaqcv.Code2DDecoderBase_get_time_limit(self)

    def train(self, datasets_img, datasets_regions, training_infos):
        r"""
        it will train a 2D code decoder which only supports DataMatrix(DM). You should detect 2d codes by
        other tools(TemplateMatch or any tools else) currently for the reason no detecting feture in this decoder. The
        adjustable parameters contain 'symbol version', 'symbol polarity', 'symbol mirrory', 'min module width',
        'max module width', 'image preprocess operator control bits',  'image amplify ratio', 'image reduction',
        'ratio in guide filter', and 'increment of wellner operator global weight'.
        :type datasets_img: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
        :param datasets_img:  input image sets(only support AQ_8UC1, AQ_8UC3). Each image only contains one DM's region.
        :type datasets_regions: std::vector< visionflow::geometry::Ring2f,std::allocator< visionflow::geometry::Ring2f > >
        :param datasets_regions:  input DM' region sets. Each DM' region is represented by a Ring2f(must be four points),
                                     distance between DM code edges and Reing2f edges should be less than one module width.
        :type training_infos: std::vector< std::string,std::allocator< std::string > >
        :param training_infos:  output training error informations for every barcode. empty (indicating success decoded
                            the corresponding code) or failure information.
        :rtype: boolean
        :return: true if training processing succeed.
        """
        return _pyaqcv.Code2DDecoderBase_train(self, datasets_img, datasets_regions, training_infos)

    def reset_trained_params(self):
        return _pyaqcv.Code2DDecoderBase_reset_trained_params(self)

    def execute(self, img, regions, results):
        r"""
         2D code decoder, only support DM. You should detect 2d codes by other tools(TemplateMatch or any tools
        else) currently for the reason no detecting feture in this decoder.
        :type img: :py:class:`Mat`
        :param img:  input image sets(only support AQ_8UC1, AQ_8UC3). The image contains at least one Data Matrix Code's
                        region.
        :type regions: std::vector< visionflow::geometry::Ring2f,std::allocator< visionflow::geometry::Ring2f > >
        :param regions:  input DM' region sets. Each  DM' region is represented by a Ring2f(must be four points), distance
                            between DM symbol edges and Reing2f edges should be less than one module width.
        :type results: std::vector< aqcv::Code2DResult,std::allocator< aqcv::Code2DResult > >
        :param results:  output decoding results, same count with regions, coresponding to the resions one by one. Result
                            maybe invalid if regions invalid or DM code was destoryed(checking valid property of Code2DResult).
        :rtype: boolean
        :return: true if decoder processing succeed(not indicating decoded results valid or not).
        """
        return _pyaqcv.Code2DDecoderBase_execute(self, img, regions, results)

# Register Code2DDecoderBase in _pyaqcv:
_pyaqcv.Code2DDecoderBase_swigregister(Code2DDecoderBase)
class DMCodeDecoder(Code2DDecoderBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.DMCodeDecoder_swiginit(self, _pyaqcv.new_DMCodeDecoder())
    __swig_destroy__ = _pyaqcv.delete_DMCodeDecoder

# Register DMCodeDecoder in _pyaqcv:
_pyaqcv.DMCodeDecoder_swigregister(DMCodeDecoder)
class QRCodeDecoder(Code2DDecoderBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.QRCodeDecoder_swiginit(self, _pyaqcv.new_QRCodeDecoder())
    __swig_destroy__ = _pyaqcv.delete_QRCodeDecoder

    def set_model_type(self, mode_type):
        return _pyaqcv.QRCodeDecoder_set_model_type(self, mode_type)

# Register QRCodeDecoder in _pyaqcv:
_pyaqcv.QRCodeDecoder_swigregister(QRCodeDecoder)
class ROIArray(object):
    r"""generate an array of ROI."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def gen_rrect_array(self, roi_range, row, col, width, height, angle, res):
        r"""
        generate rotated rect ROI array.
        :type roi_range: :py:class:`RotateRect2f`
        :param roi_range: a rotated rect range to generate ROI, all ROIs' center locate on the boundary of range.
        :type row: int
        :param row: row num of ROI array. If row = 1, the ROI locates on center of height, otherwise, all ROIs loacte
                   evenly on height direction.
        :type col: int
        :param col: col num of ROI array, distribution rules same as row but on width direction.
        :type width: int
        :param width: width of each ROI.
        :type height: int
        :param height: height of each ROI.
        :type angle: :py:class:`Radian`
        :param angle: angle of each ROI.
        :type res: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :param res: generated ROI array.
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.ROIArray_gen_rrect_array(self, roi_range, row, col, width, height, angle, res)

    def crop_image(self, rects, src, imgs, straight):
        r"""
        crop image using ROI array.
        :type rects: std::vector< visionflow::geometry::RotateRect2f,std::allocator< visionflow::geometry::RotateRect2f > >
        :param rects: ROI array.
        :type src: :py:class:`Mat`
        :param src: source image.
        :type imgs: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
        :param imgs: croped images, each image is croped from minimum bounding rect of each ROI. The region out of the
                   ROI or image will be filled by 0.
        :type straight: boolean
        :param straight: if true, ROI will be rotated straight.
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.ROIArray_crop_image(self, rects, src, imgs, straight)

    def __init__(self):
        _pyaqcv.ROIArray_swiginit(self, _pyaqcv.new_ROIArray())
    __swig_destroy__ = _pyaqcv.delete_ROIArray

# Register ROIArray in _pyaqcv:
_pyaqcv.ROIArray_swigregister(ROIArray)
class RegionLogicOperation(object):
    r"""calculate logical opeartion between regions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RegionLogicOperation_swiginit(self, _pyaqcv.new_RegionLogicOperation())
    __swig_destroy__ = _pyaqcv.delete_RegionLogicOperation
    kUnion = _pyaqcv.RegionLogicOperation_kUnion
    kIntersection = _pyaqcv.RegionLogicOperation_kIntersection
    kDifference = _pyaqcv.RegionLogicOperation_kDifference
    kSymmetricDifference = _pyaqcv.RegionLogicOperation_kSymmetricDifference

    def set_region1(self, *args):
        r"""
        set first region.
        :type region1: :py:class:`MultiPolygon2i`
        :param region1: region to set.
        :rtype: boolean
        :return: true if region's area larger than 0.
        """
        return _pyaqcv.RegionLogicOperation_set_region1(self, *args)

    def set_region2(self, *args):
        r"""
        set second region.
        :type region2: :py:class:`MultiPolygon2i`
        :param region2: region to set.
        :rtype: boolean
        :return: true if region's area larger than 0.
        """
        return _pyaqcv.RegionLogicOperation_set_region2(self, *args)

    def set_operation(self, op):
        r"""
        set operation.
        :type op: int
        :param op: region logical operator, see #OperatorType.
        """
        return _pyaqcv.RegionLogicOperation_set_operation(self, op)

    def set_crop_image(self, crop=True):
        r"""
        set if crop image.
        :type crop: boolean, optional
        :param crop: if true, crop image after operation.
        """
        return _pyaqcv.RegionLogicOperation_set_crop_image(self, crop)

    def set_keep_image_size(self, keep=True):
        r"""
        set if keep image size.
        :type keep: boolean, optional
        :param keep: if true, keep image size when croping image, otherwise shrink to min size enclosing the region.
                        (only used when set crop_image = true)
        """
        return _pyaqcv.RegionLogicOperation_set_keep_image_size(self, keep)

    def set_fill_color(self, color):
        r"""
        set color of background if crop image.
        :type color: :py:class:`Scalar`
        :param color: color to set, default is 0 for all channels.
        """
        return _pyaqcv.RegionLogicOperation_set_fill_color(self, color)

    def execute(self, src, dst, region, affine):
        r"""
        execute region logical opeartion tool.
        :type src: :py:class:`Mat`
        :param src: input image.
        :type dst: :py:class:`Mat`
        :param dst: croped image, empty when crop_image = false.
        :type region: :py:class:`MultiPolygon2i`
        :param region: result region after logical opeartion.
        :type affine: :py:class:`Mat`
        :param affine: 2 x 3 AQ_64F affine mat from src to dst (only translate).
        :rtype: boolean
        :return: true if set crop_image = false, or the area of result region larger than 0, or crop image with keep_size = ture.
        """
        return _pyaqcv.RegionLogicOperation_execute(self, src, dst, region, affine)

# Register RegionLogicOperation in _pyaqcv:
_pyaqcv.RegionLogicOperation_swigregister(RegionLogicOperation)
class AqvBarcodeReader(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.AqvBarcodeReader_swiginit(self, _pyaqcv.new_AqvBarcodeReader())
    __swig_destroy__ = _pyaqcv.delete_AqvBarcodeReader

    def set_barcode_type(self, bar_type):
        r"""
        set barcode type which will be tried to decode.defult: kBarTypeCode128.
        if set kBarTypeNone,it will return false.
        :param barcode_type: barcode type.
        """
        return _pyaqcv.AqvBarcodeReader_set_barcode_type(self, bar_type)

    def get_barcode_type(self):
        r"""
        get barcode type
        See also: set_barcode_type
        """
        return _pyaqcv.AqvBarcodeReader_get_barcode_type(self)

    def set_enable_quiet_zone(self, enable):
        r"""
        set enable quiet zone.if true the startand end positions of the barcode need to have 10 static zones of unit length.
        :type enable: boolean
        :param enable: whether enable quiet zone.
        """
        return _pyaqcv.AqvBarcodeReader_set_enable_quiet_zone(self, enable)

    def get_enable_quiet_zone(self):
        r"""
        get enable quiet zone
        See also: set_enable_quiet_zone
        """
        return _pyaqcv.AqvBarcodeReader_get_enable_quiet_zone(self)

    def decode(self, image, region, result):
        r"""
        decode barcode
        :type image: :py:class:`Mat`
        :param image: input image which is same with detecting.support AQ_8U only.
        :type region: :py:class:`RotateRect2f`
        :param region: barcode region.only a single barcode should be included in the region,
            and the background area should be minimized to avoid the influence of noise on decoding.
        :type result: :py:class:`BarcodeResult`
        :param result: decode result. only the barcode type of the set is decoded.
            for example, if only code128 is set but code39 is entered, decoding fails.
        :rtype: boolean
        :return: true if ok.
        """
        return _pyaqcv.AqvBarcodeReader_decode(self, image, region, result)

# Register AqvBarcodeReader in _pyaqcv:
_pyaqcv.AqvBarcodeReader_swigregister(AqvBarcodeReader)
class AqvCode2DDecoder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.AqvCode2DDecoder_swiginit(self, _pyaqcv.new_AqvCode2DDecoder())
    __swig_destroy__ = _pyaqcv.delete_AqvCode2DDecoder

    def set_module_width_range(self, min_val, max_val):
        r"""set width scale of DM symbol module. Range: 1 <= min_val <= max_val <= 100"""
        return _pyaqcv.AqvCode2DDecoder_set_module_width_range(self, min_val, max_val)

    def get_module_width_range(self, min_val, max_val):
        r"""get width range of DM symbol module"""
        return _pyaqcv.AqvCode2DDecoder_get_module_width_range(self, min_val, max_val)

    def set_polarity(self, polarity):
        r"""set symbol polarity"""
        return _pyaqcv.AqvCode2DDecoder_set_polarity(self, polarity)

    def get_polarity(self):
        r"""get symbol polarity"""
        return _pyaqcv.AqvCode2DDecoder_get_polarity(self)

    def train(self, datasets_img, datasets_regions, training_infos):
        r"""
        it will train a 2D code decoder which only supports DataMatrix(DM). You should detect 2d codes by
        other tools(TemplateMatch or any tools else) currently for the reason no detecting feature in this decoder. The
        adjustable parameters contain 'symbol version', 'symbol polarity', 'symbol mirrory', 'min module width',
        'max module width', 'image preprocess operator control bits',  'image amplify ratio', 'image reduction',
        'ratio in guide filter', and 'increment of wellner operator global weight'.
        By training the samples, the best range of parameters can be found, so that the time-consuming caused by
        searching parameters can be reduced when decoding. When decoding takes too long to perform directly,
        training ahead of time may reduce the decoding time.
        :type datasets_img: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
        :param datasets_img:  input image sets(only support AQ_8UC1, AQ_8UC3). Each image only contains one DM's region.
        :type datasets_regions: std::vector< visionflow::geometry::Ring2f,std::allocator< visionflow::geometry::Ring2f > >
        :param datasets_regions:  input DM' region sets. Each DM' region is represented by a Ring2f(must be four points),
                                     distance between DM code edges and Reing2f edges should be less than one module width.
        :type training_infos: std::vector< std::string,std::allocator< std::string > >
        :param training_infos:  output training error informations for every barcode. empty (indicating success decoded
                            the corresponding code) or failure information.
        :rtype: boolean
        :return: true if training processing succeed.
        """
        return _pyaqcv.AqvCode2DDecoder_train(self, datasets_img, datasets_regions, training_infos)

    def reset_trained_params(self):
        return _pyaqcv.AqvCode2DDecoder_reset_trained_params(self)

    def set_time_limit(self, time_limit_millisecond):
        r"""
        Set time limit(ms) for function execute.
        :type time_limit_millisecond: int
        :param time_limit_millisecond:  Time limit as millisecond. When val <= 0, time constraints are not enabled.
        """
        return _pyaqcv.AqvCode2DDecoder_set_time_limit(self, time_limit_millisecond)

    def get_time_limit(self):
        r"""
        Get time limit(ms) for function execute.
        :rtype: int
        :return: The integer for time limit(ms).
        """
        return _pyaqcv.AqvCode2DDecoder_get_time_limit(self)

    def execute(self, img, regions, results):
        r"""
         2D code decoder, only support DM. You should detect 2d codes by other tools(TemplateMatch or any tools
        else) currently for the reason no detecting feature in this decoder.
        :type img: :py:class:`Mat`
        :param img:  input image sets(only support AQ_8UC1, AQ_8UC3). The image contains at least one Data Matrix Code's
                        region.
        :type regions: std::vector< visionflow::geometry::Ring2f,std::allocator< visionflow::geometry::Ring2f > >
        :param regions:  input DM' region sets. Each  DM' region is represented by a Ring2f(must be four points), distance
                            between DM symbol edges and Reing2f edges should be less than one module width.
        :type results: std::vector< aqcv::Code2DResult,std::allocator< aqcv::Code2DResult > >
        :param results:  output decoding results, same count with regions, coresponding to the resions one by one. Result
                            maybe invalid if regions invalid or DM code was destoryed(checking valid property of Code2DResult).
        :rtype: boolean
        :return: true if decoder processing succeed(not indicating decoded results valid or not).
        """
        return _pyaqcv.AqvCode2DDecoder_execute(self, img, regions, results)

# Register AqvCode2DDecoder in _pyaqcv:
_pyaqcv.AqvCode2DDecoder_swigregister(AqvCode2DDecoder)

def crop_roi(img, roi, cropped_img, affine_mat, invert=False, keep_size=False, straight=False, fill_up_border=False):
    r"""
    Crop roi from image.
    :type img: :py:class:`Mat`
    :param img: Input image for croping.
    :type roi: :py:class:`IGeometry`
    :param roi: ROI to crop, must inside or intersect with img.
                   Support type : Rect2f/RotateRect2f/Circle2f/Ellipse2f/MultiPolygon2f (ONLY 2f!)
    :type cropped_img: :py:class:`Mat`
    :param cropped_img: Output croped roi img.
    :type affine_mat: :py:class:`Mat`
    :param affine_mat: 2x3 affine mat in AQ_64F.
    :type invert: boolean, optional
    :param invert: If true, get the same size cropped_img with input img, whose region outside ROI will be cropped.
               (only used when keep_size is true)
    :type keep_size: boolean, optional
    :param keep_size: If keep size with input img (ignore straight/fill_up_border).
    :type straight: boolean, optional
    :param straight: If true, ROI will be rotated straight (only used when roi is RotateRect).
    :type fill_up_border: boolean, optional
    :param fill_up_border: If true, fill up zero on outside region, otherwise roi will shrink into img.
    :rtype: boolean
    :return: true if successed.
    """
    return _pyaqcv.crop_roi(img, roi, cropped_img, affine_mat, invert, keep_size, straight, fill_up_border)
class CaliperMeasurePairsResults(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    edge1_pts = property(_pyaqcv.CaliperMeasurePairsResults_edge1_pts_get, _pyaqcv.CaliperMeasurePairsResults_edge1_pts_set, doc=r"""first edge point of pairs""")
    edge1_contrasts = property(_pyaqcv.CaliperMeasurePairsResults_edge1_contrasts_get, _pyaqcv.CaliperMeasurePairsResults_edge1_contrasts_set, doc=r"""first edges' contrasts""")
    edge1_polarities = property(_pyaqcv.CaliperMeasurePairsResults_edge1_polarities_get, _pyaqcv.CaliperMeasurePairsResults_edge1_polarities_set, doc=r"""first edges' polarities""")
    edge2_pts = property(_pyaqcv.CaliperMeasurePairsResults_edge2_pts_get, _pyaqcv.CaliperMeasurePairsResults_edge2_pts_set, doc=r"""second edge point of pairs""")
    edge2_contrasts = property(_pyaqcv.CaliperMeasurePairsResults_edge2_contrasts_get, _pyaqcv.CaliperMeasurePairsResults_edge2_contrasts_set, doc=r"""second edges' contrasts""")
    edge2_polarities = property(_pyaqcv.CaliperMeasurePairsResults_edge2_polarities_get, _pyaqcv.CaliperMeasurePairsResults_edge2_polarities_set, doc=r"""second edges' polarities""")
    center_pts = property(_pyaqcv.CaliperMeasurePairsResults_center_pts_get, _pyaqcv.CaliperMeasurePairsResults_center_pts_set, doc=r"""center points of edge pairs""")
    intral_distances = property(_pyaqcv.CaliperMeasurePairsResults_intral_distances_get, _pyaqcv.CaliperMeasurePairsResults_intral_distances_set, doc=r"""width of each pairs: | <-pair1-> |   | <-pair2-> |""")
    inter_distances = property(_pyaqcv.CaliperMeasurePairsResults_inter_distances_get, _pyaqcv.CaliperMeasurePairsResults_inter_distances_set, doc=r"""distance of neighbor pairs:| pair1 | <-inter-> | pair2 |""")
    center_distances = property(_pyaqcv.CaliperMeasurePairsResults_center_distances_get, _pyaqcv.CaliperMeasurePairsResults_center_distances_set, doc=r"""distance of neightbor center""")

    def __init__(self):
        _pyaqcv.CaliperMeasurePairsResults_swiginit(self, _pyaqcv.new_CaliperMeasurePairsResults())
    __swig_destroy__ = _pyaqcv.delete_CaliperMeasurePairsResults

# Register CaliperMeasurePairsResults in _pyaqcv:
_pyaqcv.CaliperMeasurePairsResults_swigregister(CaliperMeasurePairsResults)
class CaliperMeasurePairs(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SelectType_kAll = _pyaqcv.CaliperMeasurePairs_SelectType_kAll
    r"""keep all edge pairs"""
    SelectType_kFirstOnly = _pyaqcv.CaliperMeasurePairs_SelectType_kFirstOnly
    r"""only keep the first edge pair in search direction"""
    SelectType_kLastOnly = _pyaqcv.CaliperMeasurePairs_SelectType_kLastOnly
    r"""only keep the last edge pair in search direction"""

    def __init__(self):
        _pyaqcv.CaliperMeasurePairs_swiginit(self, _pyaqcv.new_CaliperMeasurePairs())
    __swig_destroy__ = _pyaqcv.delete_CaliperMeasurePairs

    def set_edge_polarity(self, edge1_polarity, edge2_polarity):
        r"""
        Set edge polarity.
        :param edge_polarity:  desired polarity of the edge, please see 'EdgePolarityType'
        """
        return _pyaqcv.CaliperMeasurePairs_set_edge_polarity(self, edge1_polarity, edge2_polarity)

    def get_edge1_polarity(self):
        return _pyaqcv.CaliperMeasurePairs_get_edge1_polarity(self)

    def get_edge2_polarity(self):
        return _pyaqcv.CaliperMeasurePairs_get_edge2_polarity(self)

    def set_contrast_threshold(self, contrast_threshold):
        r"""
        Set constrast threshold.
        :type contrast_threshold: float
        :param contrast_threshold:  minimum contrast required for an edge to be considered
        """
        return _pyaqcv.CaliperMeasurePairs_set_contrast_threshold(self, contrast_threshold)

    def get_contrast_threshold(self):
        r"""
        Get constrast threshold.
        See also: set_contrast_threshold
        """
        return _pyaqcv.CaliperMeasurePairs_get_contrast_threshold(self)

    def set_filter_half_size(self, size):
        r"""
        Set filter half size.
        :type size: int
        :param size:  filter half size in pixels
        """
        return _pyaqcv.CaliperMeasurePairs_set_filter_half_size(self, size)

    def get_filter_half_size(self):
        r"""
        Get filter half size.
        See also: set_filter_half_size
        """
        return _pyaqcv.CaliperMeasurePairs_get_filter_half_size(self)

    def set_select_type(self, select_type):
        r"""
        Set pair selection type.
        :type select_type: int
        :param select_type: selction type.
        """
        return _pyaqcv.CaliperMeasurePairs_set_select_type(self, select_type)

    def get_select_type(self):
        r"""
        get pair selection type.
        See also: SelectType
        """
        return _pyaqcv.CaliperMeasurePairs_get_select_type(self)

    def set_mask_region(self, mask_region):
        r"""set/get mask region. edges in masked region will be ignored."""
        return _pyaqcv.CaliperMeasurePairs_set_mask_region(self, mask_region)

    def get_mask_region(self):
        return _pyaqcv.CaliperMeasurePairs_get_mask_region(self)

    def execute(self, image, roi, results):
        r"""
        Apply the caliper to the given image.
        :type image: :py:class:`Mat`
        :param image:  input image
        :type roi: :py:class:`RotateRect2f`
        :param roi: sample region
        :param edge_pts1: first edges of edge pairs
        :param edge_pts2: second edges of edge pairs
        :param contrasts: first edge contrast(po)
        :rtype: boolean
        :return: true if success, false otherwise.
        """
        return _pyaqcv.CaliperMeasurePairs_execute(self, image, roi, results)

# Register CaliperMeasurePairs in _pyaqcv:
_pyaqcv.CaliperMeasurePairs_swigregister(CaliperMeasurePairs)
class Geometry3DBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kUnkown = _pyaqcv.Geometry3DBase_kUnkown
    kPlane3D = _pyaqcv.Geometry3DBase_kPlane3D
    kSphere3D = _pyaqcv.Geometry3DBase_kSphere3D
    kLine3D = _pyaqcv.Geometry3DBase_kLine3D
    kLineSeg3D = _pyaqcv.Geometry3DBase_kLineSeg3D
    kCircle3D = _pyaqcv.Geometry3DBase_kCircle3D
    kAlignedBox3D = _pyaqcv.Geometry3DBase_kAlignedBox3D
    kBox3D = _pyaqcv.Geometry3DBase_kBox3D
    kCylinder3D = _pyaqcv.Geometry3DBase_kCylinder3D

    def __init__(self):
        _pyaqcv.Geometry3DBase_swiginit(self, _pyaqcv.new_Geometry3DBase())
    __swig_destroy__ = _pyaqcv.delete_Geometry3DBase

    def geometry_type(self):
        return _pyaqcv.Geometry3DBase_geometry_type(self)

# Register Geometry3DBase in _pyaqcv:
_pyaqcv.Geometry3DBase_swigregister(Geometry3DBase)
class Plane3D(Geometry3DBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, norm=(0,0,1),pt=(0,0,0)

        |

        *Overload 2:*
         constructor
        :type pt: :py:class:`Point3d`
        :param pt: a point on the plane
        :type normal: :py:class:`Vec3d`
        :param normal: the normal vector of the plane

        |

        *Overload 3:*
         constructor, the plane will be degenerate if pt1, pt2 and pt3 colliner.
        For a non-degenerate plane, the normal direction of the plane is defined as the
        cross product of (pt2-pt1) and (pt3 - pt1)
        :type pt1: :py:class:`Point3d`
        :param pt1: first point
        :type pt2: :py:class:`Point3d`
        :param pt2: second point
        :type pt3: :py:class:`Point3d`
        :param pt3: third point
        """
        _pyaqcv.Plane3D_swiginit(self, _pyaqcv.new_Plane3D(*args))
    __swig_destroy__ = _pyaqcv.delete_Plane3D

    def update(self, pt, normal):
        r"""
         update the parameters of the plane
        :type pt: :py:class:`Point3d`
        :param pt: a point on the new plane
        :type normal: :py:class:`Vec3d`
        :param normal: the normal vector of the new plane
        """
        return _pyaqcv.Plane3D_update(self, pt, normal)

    def valid(self):
        r"""
         check plane is valid
        :rtype: boolean
        :return: true if valid,false if invalid(when norm's magnitude is zero)
        """
        return _pyaqcv.Plane3D_valid(self)

    def distance(self, pt):
        r"""
         compute vertical distance from point to the plane
        :rtype: float
        :return: distance from point to plane, positive means pt at the normal direction side,
                      negative indicate on the other side.
        """
        return _pyaqcv.Plane3D_distance(self, pt)

    def axis_aligned_distance(self, pt):
        r"""
         axis aligned distance from point to the plane
        :rtype: :py:class:`Vec3d`
        :return: distance in the 3 axis(xyz) direction from point to plane.
               Distance will be infinity if plane parallel to that dimention.
        """
        return _pyaqcv.Plane3D_axis_aligned_distance(self, pt)

    def perpendicular_foot(self, pt):
        r"""perpendicular foot from point to plane"""
        return _pyaqcv.Plane3D_perpendicular_foot(self, pt)

    def tilt(self):
        r"""angle between normal and z axis(0~180)"""
        return _pyaqcv.Plane3D_tilt(self)

    def rotation(self):
        r"""the angle between x axis and vector projected by normal vector on xy plane (-180 ~ 180)"""
        return _pyaqcv.Plane3D_rotation(self)

    def offset(self):
        r"""distance between original(0,0,0) and the plane"""
        return _pyaqcv.Plane3D_offset(self)

    def norm(self):
        r"""plane's normal"""
        return _pyaqcv.Plane3D_norm(self)

    def reverse_norm(self):
        r"""plane's reverse normal"""
        return _pyaqcv.Plane3D_reverse_norm(self)

    def plane_point(self):
        r"""plane's point"""
        return _pyaqcv.Plane3D_plane_point(self)

    @staticmethod
    def plane_angle(plane1, plane2):
        r"""angle between two plane(0~180)"""
        return _pyaqcv.Plane3D_plane_angle(plane1, plane2)

# Register Plane3D in _pyaqcv:
_pyaqcv.Plane3D_swigregister(Plane3D)
class Sphere3D(Geometry3DBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, center=(0,0,0), radius=1

        |

        *Overload 2:*
         constructor
        :type center: :py:class:`Point3d`
        :param center: the center of the sphere
        :type radius: float
        :param radius: radius of the sphere

        |

        *Overload 3:*
         constructor, the sphere will be degenerate if pt1, pt2, pt3 and pt4 colliner.
        :type pt1: :py:class:`Point3d`
        :param pt1: first point
        :type pt2: :py:class:`Point3d`
        :param pt2: second point
        :type pt3: :py:class:`Point3d`
        :param pt3: third point
        :type pt4: :py:class:`Point3d`
        :param pt4: forth point
        """
        _pyaqcv.Sphere3D_swiginit(self, _pyaqcv.new_Sphere3D(*args))
    __swig_destroy__ = _pyaqcv.delete_Sphere3D

    def radius(self):
        r"""get radius of the sphere"""
        return _pyaqcv.Sphere3D_radius(self)

    def center(self):
        r"""get center of sphere"""
        return _pyaqcv.Sphere3D_center(self)

    def update(self, center, radius):
        r"""update sphere's parameters"""
        return _pyaqcv.Sphere3D_update(self, center, radius)

    def valid(self):
        r"""
         whether parameters are valid
        :rtype: boolean
        :return: true if valid, false indicates invalid(when radius <=0)
        """
        return _pyaqcv.Sphere3D_valid(self)

    def distance(self, pt):
        r"""
         distance between given point and sphere surface
        :rtype: float
        :return: distance, positive indicates outside the sphere, negative on the opposite
        """
        return _pyaqcv.Sphere3D_distance(self, pt)

    def axis_aligned_distance(self, pt):
        r"""
         axis aligned distance from point to the sphere surface
        :rtype: :py:class:`Vec3d`
        :return: distance in the 3 axis(xyz) direction from point to positive half sphere surface.
               Distance will be infinity if axis aligned line from given pt do not have intersection with sphere.
        """
        return _pyaqcv.Sphere3D_axis_aligned_distance(self, pt)

# Register Sphere3D in _pyaqcv:
_pyaqcv.Sphere3D_swigregister(Sphere3D)
class Line3D(Geometry3DBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, pt=(0,0,0), direction=(0,0,1)

        |

        *Overload 2:*
         constructor
        :type pt: :py:class:`Point3d`
        :param pt: point on the line
        :type direct: :py:class:`Vec3d`
        :param direct: direction of the line

        |

        *Overload 3:*
         constructor line with two points.
        :type pt1: :py:class:`Point3d`
        :param pt1: first point on the line
        :type pt2: :py:class:`Point3d`
        :param pt2: second point on the line
        """
        _pyaqcv.Line3D_swiginit(self, _pyaqcv.new_Line3D(*args))
    __swig_destroy__ = _pyaqcv.delete_Line3D

    def norm(self):
        r"""get direction of the line"""
        return _pyaqcv.Line3D_norm(self)

    def point(self):
        r"""get point on the line"""
        return _pyaqcv.Line3D_point(self)

    def update(self, pt, direction):
        r"""update line's parameters"""
        return _pyaqcv.Line3D_update(self, pt, direction)

    def valid(self):
        r"""
         whether parameters are valid
        :rtype: boolean
        :return: true if valid, false indicates invalid(when magnitude of normal<=FLT_EPSILON)
        """
        return _pyaqcv.Line3D_valid(self)

    def distance(self, pt):
        r"""
         distance between given point and line
        :rtype: float
        :return: distance
        """
        return _pyaqcv.Line3D_distance(self, pt)

    def perpendicular_foot(self, pt):
        r"""
         perpendicular foot of given point to the line
        :rtype: :py:class:`Point3d`
        :return: perpendicular foot point
        """
        return _pyaqcv.Line3D_perpendicular_foot(self, pt)

# Register Line3D in _pyaqcv:
_pyaqcv.Line3D_swigregister(Line3D)
class LineSeg3D(Geometry3DBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, pt1=(0,0,0), pt2=(0,0,1)

        |

        *Overload 2:*
         constructor
        :type pt: :py:class:`Point3d`
        :param pt: point on the line
        :type direct: :py:class:`Vec3d`
        :param direct: direction of the line segment
        :type length: float
        :param length: length of line segment

        |

        *Overload 3:*
         constructor line segment with two points.
        :type pt1: :py:class:`Point3d`
        :param pt1: first point on the line segment
        :type pt2: :py:class:`Point3d`
        :param pt2: second point on the line segment
        """
        _pyaqcv.LineSeg3D_swiginit(self, _pyaqcv.new_LineSeg3D(*args))
    __swig_destroy__ = _pyaqcv.delete_LineSeg3D

    def norm(self):
        r"""get direction of the line, from pt1 to pt2.Notes: compute at runtime"""
        return _pyaqcv.LineSeg3D_norm(self)

    def point1(self):
        r"""get first point on the line"""
        return _pyaqcv.LineSeg3D_point1(self)

    def point2(self):
        r"""get second point on the line"""
        return _pyaqcv.LineSeg3D_point2(self)

    def length(self):
        r"""return current line segment length"""
        return _pyaqcv.LineSeg3D_length(self)

    def update(self, pt1, pt2):
        r"""update line's parameters"""
        return _pyaqcv.LineSeg3D_update(self, pt1, pt2)

    def valid(self):
        r"""
         whether parameters are valid
        :rtype: boolean
        :return: true if valid, false indicates invalid(when length of normal<=FLT_EPSILON)
        """
        return _pyaqcv.LineSeg3D_valid(self)

# Register LineSeg3D in _pyaqcv:
_pyaqcv.LineSeg3D_swigregister(LineSeg3D)
class Circle3D(Geometry3DBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, normal=(0,0,1),pt=(0,0,0), radius=1

        |

        *Overload 2:*
         constructor
        :type center: :py:class:`Point3d`
        :param center: center of the circle
        :type normal: :py:class:`Vec3d`
        :param normal: the normal vector of the circle plane
        :type radius: float
        :param radius: radius of the circle
        """
        _pyaqcv.Circle3D_swiginit(self, _pyaqcv.new_Circle3D(*args))
    __swig_destroy__ = _pyaqcv.delete_Circle3D

    def update(self, center, normal, radius):
        r"""
         update the parameters of the circle
        :type center: :py:class:`Point3d`
        :param center: center of the circle
        :type normal: :py:class:`Vec3d`
        :param normal: the normal vector of the circle plane
        :type radius: float
        :param radius: radius of the circle
        """
        return _pyaqcv.Circle3D_update(self, center, normal, radius)

    def valid(self):
        r"""
         check circle is valid
        :rtype: boolean
        :return: true if valid,false if invalid(when norm's magnitude is zero)
        """
        return _pyaqcv.Circle3D_valid(self)

    def norm(self):
        r"""
         compute vertical distance from point to the circle ring
        :rtype: :py:class:`Vec3d`
        :return: distance.
             circle's normal
        """
        return _pyaqcv.Circle3D_norm(self)

    def center(self):
        r"""radius's point"""
        return _pyaqcv.Circle3D_center(self)

    def radius(self):
        r"""get circle's radius"""
        return _pyaqcv.Circle3D_radius(self)

# Register Circle3D in _pyaqcv:
_pyaqcv.Circle3D_swigregister(Circle3D)
class AlignedBox3D(Geometry3DBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, center=(0,0,0),size=(1,1,1)

        |

        *Overload 2:*
         constructor
        :type center: :py:class:`Point3d`
        :param center: center of the axis aligned box
        :type size: :py:class:`Vec3d`
        :param size: the size(x y and z) of the AlignedBox3D

        |

        *Overload 3:*
         constructor
        :type po: :py:class:`Point3d`
        :param po: one vertex point  of the axis aligned box
        :type p_opp: :py:class:`Point3d`
        :param p_opp: point at opposite vertex of the aligned box
        """
        _pyaqcv.AlignedBox3D_swiginit(self, _pyaqcv.new_AlignedBox3D(*args))
    __swig_destroy__ = _pyaqcv.delete_AlignedBox3D

    def update(self, center, size):
        r"""
         update the parameters of the AlignedBox3D
        :type center: :py:class:`Point3d`
        :param center: center of the AlignedBox3D
        :type size: :py:class:`Vec3d`
        :param size: the size(x y and z) of the AlignedBox3D
        """
        return _pyaqcv.AlignedBox3D_update(self, center, size)

    def valid(self):
        r"""
         check box is valid
        :rtype: boolean
        :return: true if valid, false if invalid(when volume smaller than FLT_EPSILON)
        """
        return _pyaqcv.AlignedBox3D_valid(self)

    def center(self):
        r"""
         distance from point to the aligned box surface
        :rtype: :py:class:`Point3d`
        :return: distance.
             aligned box's center point
        """
        return _pyaqcv.AlignedBox3D_center(self)

    def size(self):
        r"""get size of aligned box"""
        return _pyaqcv.AlignedBox3D_size(self)

# Register AlignedBox3D in _pyaqcv:
_pyaqcv.AlignedBox3D_swigregister(AlignedBox3D)
class Box3D(Geometry3DBase):
    r"""oriented 3d box"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, center=(0,0,0),size=(1,1,1) as a axis aligned box

        |

        *Overload 2:*
         constructor
        :type pose: :py:class:`Pose3DRT`
        :param pose: pose of the box
        :type size: :py:class:`Vec3d`
        :param size: the size(x y and z) of the box
        """
        _pyaqcv.Box3D_swiginit(self, _pyaqcv.new_Box3D(*args))
    __swig_destroy__ = _pyaqcv.delete_Box3D

    def update(self, pose, size):
        r"""
         update the parameters of the box
        :type pose: :py:class:`Pose3DRT`
        :param pose: pose of the box
        :type size: :py:class:`Vec3d`
        :param size: the size(x y and z) of the box
        """
        return _pyaqcv.Box3D_update(self, pose, size)

    def valid(self):
        r"""
         check box is valid
        :rtype: boolean
        :return: true if valid, false if invalid(when volume smaller than FLT_EPSILON)
        """
        return _pyaqcv.Box3D_valid(self)

    def pose(self):
        r"""
         distance from point to the box's surface
        :rtype: :py:class:`Pose3DRT`
        :return: distance.
             get pose of box
        """
        return _pyaqcv.Box3D_pose(self)

    def center(self):
        r"""get center of the box"""
        return _pyaqcv.Box3D_center(self)

    def size(self):
        r"""get size of box"""
        return _pyaqcv.Box3D_size(self)

# Register Box3D in _pyaqcv:
_pyaqcv.Box3D_swigregister(Box3D)
class Cylinder3D(Geometry3DBase):
    r"""
    oriented 3d cylinder

            -----------
          -             -
         -             -
          ------------  |
         |     z   y    |
         |     | /      |
         h     |/       |
         |      --->x   |
         |  center      |
         |              |
         -             -
          ------------

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         default constructor, center=(0,0,0),height=1,radius=1

        |

        *Overload 2:*
         constructor
        :type pose: :py:class:`Pose3DRT`
        :param pose: pose of the box
        :type radius: float
        :param radius: radius of circle
        :type height: float
        :param height: height of cylinder
        """
        _pyaqcv.Cylinder3D_swiginit(self, _pyaqcv.new_Cylinder3D(*args))
    __swig_destroy__ = _pyaqcv.delete_Cylinder3D

    def update(self, pose, radius, height):
        r"""
         update the parameters of the box
        :type pose: :py:class:`Pose3DRT`
        :param pose: pose of the box
        :type radius: float
        :param radius: radius of circle
        :type height: float
        :param height: height of cylinder
        """
        return _pyaqcv.Cylinder3D_update(self, pose, radius, height)

    def valid(self):
        r"""
         check box is valid
        :rtype: boolean
        :return: true if valid, false if invalid(when volume smaller than FLT_EPSILON)
        """
        return _pyaqcv.Cylinder3D_valid(self)

    def pose(self):
        r"""
         distance from point to surface
        :rtype: :py:class:`Pose3DRT`
        :return: distance.
             get pose of cylinder
        """
        return _pyaqcv.Cylinder3D_pose(self)

    def center(self):
        r"""get center of cylinder"""
        return _pyaqcv.Cylinder3D_center(self)

    def height(self):
        r"""get height of cylinder"""
        return _pyaqcv.Cylinder3D_height(self)

    def radius(self):
        r"""get radius of cylinder"""
        return _pyaqcv.Cylinder3D_radius(self)

# Register Cylinder3D in _pyaqcv:
_pyaqcv.Cylinder3D_swigregister(Cylinder3D)
class RangeImage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RangeImage_swiginit(self, _pyaqcv.new_RangeImage())
    __swig_destroy__ = _pyaqcv.delete_RangeImage

    def clone(self):
        r"""Clone range image, deep copy"""
        return _pyaqcv.RangeImage_clone(self)

    def empty(self):
        r"""
        Whether or not empty (Mat::data is NULL)
        :rtype: boolean
        :return: empty is true, not empty is false
        """
        return _pyaqcv.RangeImage_empty(self)

    def size(self):
        r"""
        Get size of range image
        :rtype: :py:class:`Size`
        :return: (width,height)
        """
        return _pyaqcv.RangeImage_size(self)

    def set_image_data(self, img, copy=False):
        r"""
        Set/Get range image pixel data
        :type img: :py:class:`Mat`
        :param img:  image pixel data
        :type copy: boolean, optional
        :param copy:  true-allocate memory, false-not
        """
        return _pyaqcv.RangeImage_set_image_data(self, img, copy)

    def get_image_data(self, *args):
        return _pyaqcv.RangeImage_get_image_data(self, *args)

    def set_offset(self, x_offset, y_offset, z_offset):
        r"""
        Set/Get offset
        :type x_offset: float
        :param x_offset:  x offset between pixel coordinate system and 3D Sensor coordinate system
        :type y_offset: float
        :param y_offset:  y offset between pixel coordinate system and 3D Sensor coordinate system
        :type z_offset: float
        :param z_offset:  z offset between pixel coordinate system and 3D Sensor coordinate system
        """
        return _pyaqcv.RangeImage_set_offset(self, x_offset, y_offset, z_offset)

    def get_offset(self, x_offset, y_offset, z_offset):
        return _pyaqcv.RangeImage_get_offset(self, x_offset, y_offset, z_offset)

    def set_resolution(self, x_resolution, y_resolution, z_resolution):
        r"""
        Set/Get resolution
        :type x_resolution: float
        :param x_resolution:  x resolution between pixel coordinate system and 3D Sensor coordinate system
        :type y_resolution: float
        :param y_resolution:  y resolution between pixel coordinate system and 3D Sensor coordinate system
        :type z_resolution: float
        :param z_resolution:  z resolution between pixel coordinate system and 3D Sensor coordinate system
        """
        return _pyaqcv.RangeImage_set_resolution(self, x_resolution, y_resolution, z_resolution)

    def get_resolution(self, x_resolution, y_resolution, z_resolution):
        return _pyaqcv.RangeImage_get_resolution(self, x_resolution, y_resolution, z_resolution)

# Register RangeImage in _pyaqcv:
_pyaqcv.RangeImage_swigregister(RangeImage)

def distance_3d(*args):
    r"""
    *Overload 1:*
     distance between two point

    |

    *Overload 2:*
     distance between point and line

    |

    *Overload 3:*
     distance between point and plane.
    Notes: distance will be positive if p is on the positive direction of
    the norm of plane, otherwise distance will be negative


    |

    *Overload 4:*
     distance between point and sphere
    :type p: :py:class:`Point3d`
    :param p: point
    :type sphere: :py:class:`Sphere3D`
    :param sphere: given sphere
    :rtype: float
    :return: distance(positive when p is out of sphere, negative when p in sphere)


    |

    *Overload 5:*
     distance between two Line
    """
    return _pyaqcv.distance_3d(*args)

def intersection_3d(*args):
    r"""
    *Overload 1:*
    compute line line intersection point
    :type line1: :py:class:`Line3D`
    :param line1: first line
    :type line2: :py:class:`Line3D`
    :param line2: second line
    :type cross_pt: :py:class:`Point3d`
    :param cross_pt: intersection point if line1 and line2 intersect, otherwise will keep unchanged.
    :rtype: boolean
    :return: true if the given lines intersect.


    |

    *Overload 2:*
     compute line and plane intersection point
    :type line: :py:class:`Line3D`
    :param line: line
    :type plane: :py:class:`Plane3D`
    :param plane: plane
    :type cross_pt: :py:class:`Point3d`
    :param cross_pt: intersection point if line and plane intersect, otherwise will keep unchanged.
    :rtype: boolean
    :return: true if line and plane have intersection


    |

    *Overload 3:*
     compute intersection line of two plane
    :type plane1: :py:class:`Plane3D`
    :param plane1: plane 1
    :type plane2: :py:class:`Plane3D`
    :param plane2: plane 2
    :type cross_line: :py:class:`Line3D`
    :param cross_line: intersection line if plane1 and plane2 not parallel, otherwise will keep unchanged.
    :rtype: boolean
    :return: true if plane1 and plane2 not parallel
    """
    return _pyaqcv.intersection_3d(*args)

def transform_3d(*args):
    r"""
     transform a 3d shapre with trans_pose
    :type src: :py:class:`Point3d`
    :param src: 3d point
    :type trans_pose: :py:class:`Pose3DRT`
    :param trans_pose: 3d pose,  :math:`res = trans\_pose * src = [RT]*src`
    :type res: :py:class:`Point3d`
    :param res: transformed 3d point.
    :rtype: boolean
    :return: true
    """
    return _pyaqcv.transform_3d(*args)

def get_affine_mat_3d(*args):
    r"""
    *Overload 1:*
     compute 3d affine mat from two point set
     :math:`dst = affine_mat * src`
    :type src: :py:class:`Mat`
    :param src: source 3d points
    :type dst: :py:class:`Mat`
    :param dst: destination 3d points
    :type affine_mat: :py:class:`Mat`
    :param affine_mat: result affine mat, 3x4, AQ_64FC1
    :rtype: boolean
    :return: true of ok
    Notes: This function assumes that there is no noise in the data.If there is noise in the data,
    the overload function can be used


    |

    *Overload 2:*
     estimating affine_mat from src to dst with ransac method
    :type src: :py:class:`Mat`
    :param src: source 3d points
    :type dst: :py:class:`Mat`
    :param dst: destination 3d points
    :type affine_mat: :py:class:`Mat`
    :param affine_mat: result affine matrix, 3x4, AQ_64FC1
    :type threshold: float
    :param threshold: inner threshold
    :type mask: std::vector< bool,std::allocator< bool > >
    :param mask: inner points mask, true means inner
    :type max_iter: int, optional
    :param max_iter: maximum iteration.
    :rtype: boolean
    :return: true if ok


    |

    *Overload 3:*
     estimating affine_mat from src to dst with ransac method
    :type src: :py:class:`Mat`
    :param src: source 3d points
    :type dst: :py:class:`Mat`
    :param dst: destination 3d points
    :type affine_mat: :py:class:`Mat`
    :param affine_mat: result affine matrix, 3x4, AQ_64FC1
    :type threshold: float
    :param threshold: inner threshold
    :type mask: std::vector< bool,std::allocator< bool > >
    :param mask: inner points mask, true means inner
    :param max_iter: maximum iteration.
    :rtype: boolean
    :return: true if ok
    """
    return _pyaqcv.get_affine_mat_3d(*args)
class HeightCalculator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kDisableHeightFilter = _pyaqcv.HeightCalculator_kDisableHeightFilter
    kIncludeValuesInRange = _pyaqcv.HeightCalculator_kIncludeValuesInRange
    kExcludeValuesInRange = _pyaqcv.HeightCalculator_kExcludeValuesInRange

    def __init__(self):
        _pyaqcv.HeightCalculator_swiginit(self, _pyaqcv.new_HeightCalculator())
    __swig_destroy__ = _pyaqcv.delete_HeightCalculator

    def set_mask(self, mask):
        r"""
        See also: Please see related member function of Plane3DEstimator
        Notes: mask is not deep copied
        """
        return _pyaqcv.HeightCalculator_set_mask(self, mask)

    def get_mask(self):
        return _pyaqcv.HeightCalculator_get_mask(self)

    def set_mask_offset(self, offset):
        r"""See also: Please see related member function of Plane3DEstimator"""
        return _pyaqcv.HeightCalculator_set_mask_offset(self, offset)

    def get_mask_offset(self):
        return _pyaqcv.HeightCalculator_get_mask_offset(self)

    def clear_mask(self):
        r"""See also: Please see related member function of Plane3DEstimator"""
        return _pyaqcv.HeightCalculator_clear_mask(self)

    def need_histogram(self, flag=True):
        r"""
        Whether or not need histogram
        Notes: true-need, false-not need
        """
        return _pyaqcv.HeightCalculator_need_histogram(self, flag)

    def get_need_histogram(self):
        return _pyaqcv.HeightCalculator_get_need_histogram(self)

    def set_tail_frac(self, low_tail_frac, high_tail_frac):
        r"""
        Set/Get tail fraction
        :type low_tail_frac: float
        :param low_tail_frac:  a value which controls how the low_tail property of the result is calculated.
        :type high_tail_frac: float
        :param high_tail_frac:  a value which controls how the high_tail property of the result is calculated.
        Notes: valid value range is [0,1)
        """
        return _pyaqcv.HeightCalculator_set_tail_frac(self, low_tail_frac, high_tail_frac)

    def get_tail_frac(self, low_tail_frac, high_tail_frac):
        return _pyaqcv.HeightCalculator_get_tail_frac(self, low_tail_frac, high_tail_frac)

    def set_height_range(self, low_height, high_height):
        r"""
        Set/Get height range
        :type low_height: float
        :param low_height:  the smallest height value to be included or excluded by the height range filter.
        :type high_height: float
        :param high_height:  the largest height value to be included or excluded by the height range filter.
        Notes: high_height >= low_height
        """
        return _pyaqcv.HeightCalculator_set_height_range(self, low_height, high_height)

    def get_height_range(self, low_height, high_height):
        return _pyaqcv.HeightCalculator_get_height_range(self, low_height, high_height)

    def set_height_filter_type(self, type):
        r"""Set/Get type of height filter"""
        return _pyaqcv.HeightCalculator_set_height_filter_type(self, type)

    def get_height_filter_type(self):
        return _pyaqcv.HeightCalculator_get_height_filter_type(self)

    def execute(self, range_img, region, plane):
        r"""
        Execute tool
        :type range_img: :py:class:`RangeImage`
        :param range_img:  input the range image surface data used in the height calculation.
        :type region: :py:class:`Rect2i`
        :param region:  input the 2D region of the range image which contains the
            pixels of interest. Only pixels contained within this region will be used to calculate the height.
        :type plane: :py:class:`Plane3D`
        :param plane:  input the calculated height is the distance of the range image pixels from this base plane
        """
        return _pyaqcv.HeightCalculator_execute(self, range_img, region, plane)

    def get_mean(self):
        r"""Statistical result"""
        return _pyaqcv.HeightCalculator_get_mean(self)

    def get_median(self):
        return _pyaqcv.HeightCalculator_get_median(self)

    def get_minimum(self):
        return _pyaqcv.HeightCalculator_get_minimum(self)

    def get_maximum(self):
        return _pyaqcv.HeightCalculator_get_maximum(self)

    def get_low_tail(self):
        return _pyaqcv.HeightCalculator_get_low_tail(self)

    def get_high_tail(self):
        return _pyaqcv.HeightCalculator_get_high_tail(self)

    def get_sigma(self):
        return _pyaqcv.HeightCalculator_get_sigma(self)

    def get_used_pixel_count(self):
        return _pyaqcv.HeightCalculator_get_used_pixel_count(self)

    def compute_histogram(self, bins, range_min, range_max, hist):
        r"""
        Compute histogram
        :type bins: int
        :param bins:  input size of hist
        :type range_min: float
        :param range_min:  input the minimum height value to be counted
        :type range_max: float
        :param range_max:  input the maximum height value to be counted
        :type hist: std::vector< unsigned long long,std::allocator< unsigned long long > >
        :param hist:  output histogram
        Notes: make true that histogram_flags_=true(please see need_histogram ),bufore call this function
        """
        return _pyaqcv.HeightCalculator_compute_histogram(self, bins, range_min, range_max, hist)

# Register HeightCalculator in _pyaqcv:
_pyaqcv.HeightCalculator_swigregister(HeightCalculator)
class Plane3DEstimator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kSinglePoint = _pyaqcv.Plane3DEstimator_kSinglePoint
    kNeighborhood = _pyaqcv.Plane3DEstimator_kNeighborhood
    kNeighborhoodMedian = _pyaqcv.Plane3DEstimator_kNeighborhoodMedian

    def __init__(self):
        _pyaqcv.Plane3DEstimator_swiginit(self, _pyaqcv.new_Plane3DEstimator())
    __swig_destroy__ = _pyaqcv.delete_Plane3DEstimator

    def set_keep_fit_points(self, flag=True):
        r"""Set/Get whether to keep the points involved in the fitting"""
        return _pyaqcv.Plane3DEstimator_set_keep_fit_points(self, flag)

    def keep_fit_points(self):
        return _pyaqcv.Plane3DEstimator_keep_fit_points(self)

    def set_points_sample_type(self, type):
        r"""
        Set/Get sample type of points. please see PointSampleType
        Notes: only need to set when call execute(const RangeImage &range_img, const std::vector<visionflow::geometry::Point2f> &pts, Plane3D &plane3d)
        """
        return _pyaqcv.Plane3DEstimator_set_points_sample_type(self, type)

    def get_points_sample_type(self):
        return _pyaqcv.Plane3DEstimator_get_points_sample_type(self)

    def set_neighbor_window(self, win_size):
        r"""
        Set/Get window size of neighborhood
        :type win_size: :py:class:`Size`
        :param win_size:  win_size(3,2) looks like:

                 .. math::

                     \begin{bmatrix}
                         (x-1,y-1) & (x,y-1) & (x+1,y-1) \\
                         (x-1,y) & (x,y) & (x+1,y)
                         \end{bmatrix}
        Notes: only need to set when call execute(const RangeImage &range_img, const std::vector<visionflow::geometry::Point2f> &pts, Plane3D &plane3d)
        """
        return _pyaqcv.Plane3DEstimator_set_neighbor_window(self, win_size)

    def get_neighbor_window(self):
        return _pyaqcv.Plane3DEstimator_get_neighbor_window(self)

    def set_mask(self, mask):
        r"""
        Set/Get mask
        :type mask: :py:class:`Mat`
        :param mask:  mask non-zero elements indicate which matrix
            elements need to be operated. The mask has to be of type Mat::kDepth_U8 and can have 1 channel
        Notes: mask is not deep copied
        """
        return _pyaqcv.Plane3DEstimator_set_mask(self, mask)

    def get_mask(self):
        return _pyaqcv.Plane3DEstimator_get_mask(self)

    def set_mask_offset(self, offset):
        r"""Set/Get mask offset"""
        return _pyaqcv.Plane3DEstimator_set_mask_offset(self, offset)

    def get_mask_offset(self):
        return _pyaqcv.Plane3DEstimator_get_mask_offset(self)

    def clear_mask(self):
        r"""No mask, operate on the whole image"""
        return _pyaqcv.Plane3DEstimator_clear_mask(self)

    def execute(self, *args):
        r"""
        Execute plane3d estimate process
        :type range_img: :py:class:`RangeImage`
        :param range_img:  input range image
        :type pts: std::vector< visionflow::geometry::Point2i,std::allocator< visionflow::geometry::Point2i > >
        :param pts:  input sample points
        :type plane3d: :py:class:`Plane3D`
        :param plane3d:  output plane3d
        """
        return _pyaqcv.Plane3DEstimator_execute(self, *args)

    def get_rms(self):
        r"""Get RMS error"""
        return _pyaqcv.Plane3DEstimator_get_rms(self)

    def get_fitted_points(self):
        r"""
        :rtype: std::vector< aqcv::Point3d,std::allocator< aqcv::Point3d > >
        :return: really points involved in the fitting
        """
        return _pyaqcv.Plane3DEstimator_get_fitted_points(self)

# Register Plane3DEstimator in _pyaqcv:
_pyaqcv.Plane3DEstimator_swigregister(Plane3DEstimator)
class RangeImageProcessor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kFillZero = _pyaqcv.RangeImageProcessor_kFillZero
    r"""fill value with zero(range image invalid value)"""
    kFillStaturatedTrunc = _pyaqcv.RangeImageProcessor_kFillStaturatedTrunc
    r"""fill value with max and min value"""
    kFillPlaneValues = _pyaqcv.RangeImageProcessor_kFillPlaneValues
    r"""fill value with base_plane value"""

    def __init__(self):
        _pyaqcv.RangeImageProcessor_swiginit(self, _pyaqcv.new_RangeImageProcessor())
    __swig_destroy__ = _pyaqcv.delete_RangeImageProcessor

    @staticmethod
    def transform_height(*args):
        r"""
        height transform based base_plane.
        :type src: :py:class:`RangeImage`
        :param src:  the range image surface data used in the height transform.
        :type dst: :py:class:`RangeImage`
        :param dst:  the range image surface data after the height transform.
        :type base_plane: :py:class:`Plane3D`
        :param base_plane:  the transform height is the distance of the range image pixels from this base plane.
        :type align_z: boolean, optional
        :param align_z:  whether distance between image 3d point and given plane is measured along z axis,
                           when set to false, distance will be measured along planes' normal direction.
        :type bias: float, optional
        :param bias:  translation along z axis, unit is mm.
        :type type: int, optional
        :param type:  value outof range(value<0||value>65535) should be filled, please see OuterFillType
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RangeImageProcessor_transform_height(*args)

    @staticmethod
    def range_filter(*args):
        r"""
        height filter based base_plane.
        :type src: :py:class:`RangeImage`
        :param src:  the range image surface data used in the height filter.
        :type dst: :py:class:`RangeImage`
        :param dst:  the range image surface data after the height filter.
        :type base_plane: :py:class:`Plane3D`
        :param base_plane:  the filter height is the distance of the range image pixels from this base plane.
        :type low_height: float
        :param low_height:  the smallest height value to be included or excluded by the height range filter. height define is related of align_z . unit is mm, zero is base_plane, positive is z axis positive.
        :type high_height: float
        :param high_height:  the largest height value to be included or excluded by the height range filter. height define is related of align_z . unit is mm, zero is base_plane, positive is z axis positive.
        :type keep_in_range: boolean, optional
        :param keep_in_range:  the type height range filter, true is represented including range, false is represented excluding range.
        :type align_z: boolean, optional
        :param align_z:  please see related param of transform_height
        :type type: int, optional
        :param type:  value outof range(user defined by low_height,high_height,keep_in_range) should be filled, please see OuterFillType
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RangeImageProcessor_range_filter(*args)

# Register RangeImageProcessor in _pyaqcv:
_pyaqcv.RangeImageProcessor_swigregister(RangeImageProcessor)
class PlaneFitModel(FitModelBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.PlaneFitModel_swiginit(self, _pyaqcv.new_PlaneFitModel())
    __swig_destroy__ = _pyaqcv.delete_PlaneFitModel

    def get_min_sample_num(self):
        r"""
        Get the minimum samples number of build plane.
        :rtype: int
        :return: value is three.
        """
        return _pyaqcv.PlaneFitModel_get_min_sample_num(self)

    def init_model(self, pts_mat, idxs):
        r"""
        Build plane with three samples.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  the channel is one. the depth is AQ_64F. the cols is three, indicating 3d points. the rows indicate numbers of samples.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participated in the build.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.PlaneFitModel_init_model(self, pts_mat, idxs)

    def fit(self, *args):
        r"""
        *Overload 1:*

        Fit plane.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in fitting, defaultly all points paticipate.
        :rtype: boolean
        :return: success is true, failure is false.

        |

        *Overload 2:*

        Fit plane.
        :type pts: std::vector< aqcv::Point3d,std::allocator< aqcv::Point3d > >
        :param pts:  points participate in fitting.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.PlaneFitModel_fit(self, *args)

    def distance(self, *args):
        r"""
        Calculate the distance between points and plane, along normal vector direction.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type distance_mat: :py:class:`Mat`
        :param distance_mat:  each row indicate one distance along idxs.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in calculating distance, defaultly all points paticipate.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.PlaneFitModel_distance(self, *args)

    def get_result(self):
        r"""
        Get the plane result.
        :rtype: :py:class:`Plane3D`
        :return: 'Plane3D'
        """
        return _pyaqcv.PlaneFitModel_get_result(self)

# Register PlaneFitModel in _pyaqcv:
_pyaqcv.PlaneFitModel_swigregister(PlaneFitModel)
class SphereFitModel(FitModelBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.SphereFitModel_swiginit(self, _pyaqcv.new_SphereFitModel())
    __swig_destroy__ = _pyaqcv.delete_SphereFitModel

    def get_min_sample_num(self):
        r"""
        Get the minimum samples number of build sphere.
        :rtype: int
        :return: value is four.
        """
        return _pyaqcv.SphereFitModel_get_min_sample_num(self)

    def init_model(self, pts_mat, idxs):
        r"""
        Build sphere with four samples.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  the channel is one. the depth is AQ_64F. the cols is three, indicating 3d points. the rows indicate numbers of samples.
        :type idxs: std::vector< int,std::allocator< int > >
        :param idxs:  index of points participated in the build.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.SphereFitModel_init_model(self, pts_mat, idxs)

    def fit(self, *args):
        r"""
        *Overload 1:*

        Fit sphere.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in fitting, defaultly all points paticipate.
        :rtype: boolean
        :return: success is true, failure is false.

        |

        *Overload 2:*

        Fit sphere.
        :type pts: std::vector< aqcv::Point3d,std::allocator< aqcv::Point3d > >
        :param pts:  points participate in fitting.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.SphereFitModel_fit(self, *args)

    def distance(self, *args):
        r"""
        Calculate the distance between points and sphere, along normal vector direction.
        :type pts_mat: :py:class:`Mat`
        :param pts_mat:  please see init_model() pts_mat param.
        :type distance_mat: :py:class:`Mat`
        :param distance_mat:  each row indicate one distance along idxs.
        :type idxs: std::vector< int,std::allocator< int > >, optional
        :param idxs:  index of points participate in calculating distance, defaultly all points paticipate.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.SphereFitModel_distance(self, *args)

    def get_result(self):
        r"""
        Get the sphere result.
        :rtype: :py:class:`Sphere3D`
        :return: 'Sphere3D'
        """
        return _pyaqcv.SphereFitModel_get_result(self)

# Register SphereFitModel in _pyaqcv:
_pyaqcv.SphereFitModel_swigregister(SphereFitModel)
class VolumeCalculator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.VolumeCalculator_swiginit(self, _pyaqcv.new_VolumeCalculator())
    __swig_destroy__ = _pyaqcv.delete_VolumeCalculator

    def set_mask(self, mask):
        r"""
        See also: please see related member function of Plane3DEstimator
        Notes: mask is not deep copied
        """
        return _pyaqcv.VolumeCalculator_set_mask(self, mask)

    def get_mask(self):
        return _pyaqcv.VolumeCalculator_get_mask(self)

    def set_mask_offset(self, offset):
        r"""See also: please see related member function of Plane3DEstimator"""
        return _pyaqcv.VolumeCalculator_set_mask_offset(self, offset)

    def get_mask_offset(self):
        return _pyaqcv.VolumeCalculator_get_mask_offset(self)

    def clear_mask(self):
        r"""See also: please see related member function of Plane3DEstimator"""
        return _pyaqcv.VolumeCalculator_clear_mask(self)

    def set_minimum_height(self, height_thresh):
        r"""
        Set/Get minimum height
        :type height_thresh: float
        :param height_thresh: the minimum height value(measured along the plane normal vector), in selected space 3D units, for each range image pixel in order to include that pixel in the volume computation.
        Notes: height_thresh >= 0
        """
        return _pyaqcv.VolumeCalculator_set_minimum_height(self, height_thresh)

    def get_minimum_height(self):
        return _pyaqcv.VolumeCalculator_get_minimum_height(self)

    def execute(self, range_img, region, plane, volume, used_pixel_count=None):
        r"""
        Execute tool
        :type range_img: :py:class:`RangeImage`
        :param range_img:  input the range image surface data used in the volume calculation. please see RangeImage .
        :type region: :py:class:`Rect2i`
        :param region:  input the 2D region within which to calculate the volume.
        :type plane: :py:class:`Plane3D`
        :param plane:  input the calculated volume is the volume bounded by the range image surface and this base plane.
        :type volume: float
        :param volume:  output the calculated volume between the 3D surface defined by the range image pixels and the specified base plane, measured along the z axis.
        :type used_pixel_count: int, optional
        :param used_pixel_count:  output result information which identifies the number of used pixels in the range image.
        """
        return _pyaqcv.VolumeCalculator_execute(self, range_img, region, plane, volume, used_pixel_count)

# Register VolumeCalculator in _pyaqcv:
_pyaqcv.VolumeCalculator_swigregister(VolumeCalculator)
class TemplateMatchResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.TemplateMatchResult_swiginit(self, _pyaqcv.new_TemplateMatchResult())
    __swig_destroy__ = _pyaqcv.delete_TemplateMatchResult

    def get_size_x(self):
        r"""
        Get the length of "X" side of the result rectangle.
        :rtype: float
        :return: A real number of the length.
        """
        return _pyaqcv.TemplateMatchResult_get_size_x(self)

    def get_size_y(self):
        r"""
        Get the length of "Y" side of the result rectangle.
        :rtype: float
        :return: A real number of the length.
        """
        return _pyaqcv.TemplateMatchResult_get_size_y(self)

    def get_rotation(self):
        r"""
        Get the rotation angle of the result rectangle.
        :rtype: :py:class:`Radian`
        :return: A real number of the rotation angle in radian.
        """
        return _pyaqcv.TemplateMatchResult_get_rotation(self)

    def get_aspect(self):
        r"""
        Get the length of "Y" side of the result rectangle.
        :rtype: float
        :return: A real number of the length.
        """
        return _pyaqcv.TemplateMatchResult_get_aspect(self)

    def get_shear_angle(self):
        r"""
        Get the length of "Y" side of the result rectangle.
        :rtype: float
        :return: A real number of the length.
        """
        return _pyaqcv.TemplateMatchResult_get_shear_angle(self)

    def get_score(self):
        r"""
        Get the score of the result. If the template fits well with the object in input image, this score will be high.
        :rtype: float
        :return: A real number of the score. Greater than 0 and less than 1.
        """
        return _pyaqcv.TemplateMatchResult_get_score(self)

    def get_contrast(self):
        r"""
        Get the contrast of result image patch. The value is the median of gradient histogram of the region.
        :rtype: float
        :return: A real number of the contrast. Greater than 0.
        """
        return _pyaqcv.TemplateMatchResult_get_contrast(self)

    def match_rect(self):
        r"""
        The non-rotating bounding box of the result rectangle.
        :rtype: :py:class:`Rect2f`
        :return: The rectangle of the bounding box.
        """
        return _pyaqcv.TemplateMatchResult_match_rect(self)

    def match_region(self):
        r"""
        Get the result rectangle as a 2x3 matrix. It projects unit square {[0,0][0,1][1,1][1,0]} to the result rectangle region.
        :rtype: :py:class:`Mat`
        :return: The 2x3 affine matrix(64F) which descripts the rectangle region.
        """
        return _pyaqcv.TemplateMatchResult_match_region(self)

    def get_weighted_score(self):
        r"""
        Get weighted score. This score is weighted by clutter, coverage, fit-error and so on. Only effective on mode "Fine" and "RobustFine"
        :rtype: float
        :return: The number of weighted score. -1 if the search mode is "Quick".
        """
        return _pyaqcv.TemplateMatchResult_get_weighted_score(self)

    def get_eval(self):
        r"""
        Get the score which evaluates keypoint matches. For feature point pair, we calculate a similarity score by their gradient direction
               and magnitude, and then figure out the average of these score. Only effective on mode "Fine" and "RobustFine"
        :rtype: float
        :return: The number of match evaluation score. -1 if the search mode is "Quick".
        """
        return _pyaqcv.TemplateMatchResult_get_eval(self)

    def get_clutter(self):
        r"""
        Get the score which evaluates the number of features in the result which is not appeared in the template. For example, it will be high
               if the detected object has much noise. Only effective on mode "Fine" and "RobustFine"
        :rtype: float
        :return: The number of clutter score. -1 if the search mode is "Quick". For mode "Fine", it ranges from 0 to +inf.
        """
        return _pyaqcv.TemplateMatchResult_get_clutter(self)

    def get_coverage(self):
        r"""
        Get the score which evaluates the number of features in the template which is matched in the runtime image.
        :rtype: float
        :return: The number of clutter score. -1 if the search mode is "Quick". For mode "Fine", it ranges from 0 to 1.
        """
        return _pyaqcv.TemplateMatchResult_get_coverage(self)

    def get_fit_error(self):
        r"""
        Get the score which evaluates position error of feature point pairs.
        :rtype: float
        :return: The number of fit error. -1 if the search mode is "Quick". For mode "Fine", it ranges from 0 to +inf.
        """
        return _pyaqcv.TemplateMatchResult_get_fit_error(self)

    def accepted(self):
        r"""
        Get whether the result is accepted under some conditions defined runtime.
        :rtype: boolean
        :return: True if the result is accepted. False if not.
        """
        return _pyaqcv.TemplateMatchResult_accepted(self)

    def is_fine_stage(self):
        r"""
        Get whether the result is refined or not.
        :rtype: boolean
        :return: False if the search mode is "Quick". True if the search mode is "Fine" or "RobustFine".
        """
        return _pyaqcv.TemplateMatchResult_is_fine_stage(self)

    def get_model_index(self):
        r"""
        Get the ID of trained model which matches the result.
        :rtype: int
        :return: The integer of model ID.
        """
        return _pyaqcv.TemplateMatchResult_get_model_index(self)

    def get_dof_index(self):
        r"""
        Get the ID of DOF which matches the result.
        :rtype: int
        :return: The integer of DOF ID.
        """
        return _pyaqcv.TemplateMatchResult_get_dof_index(self)

    def get_transform(self):
        r"""
        Get the transformation matrix of the result. It projects template keypoints to keypoints on the runtime image.
        :rtype: :py:class:`Mat`
        :return: The 2x3 transformation matrix(64F).
        """
        return _pyaqcv.TemplateMatchResult_get_transform(self)

    def get_auxiliary_model_origin1(self):
        r"""
        Get the 1st auxiliary point on the model.
        :rtype: :py:class:`Point2f`
        :return: The point.
        """
        return _pyaqcv.TemplateMatchResult_get_auxiliary_model_origin1(self)

    def get_auxiliary_model_origin2(self):
        r"""
        Get the 2nd auxiliary point on the model.
        :rtype: :py:class:`Point2f`
        :return: The point.
        """
        return _pyaqcv.TemplateMatchResult_get_auxiliary_model_origin2(self)

    def get_feature(self, trainfeature):
        r"""
        Get feature points of the result. It is transformed by train feature.
        :type trainfeature: :py:class:`PointFeatArraySet`
        :param trainfeature:  Feature points in template.
        :rtype: :py:class:`PointFeatArraySet`
        :return: The list of all feature points in the result.
        """
        return _pyaqcv.TemplateMatchResult_get_feature(self, trainfeature)

# Register TemplateMatchResult in _pyaqcv:
_pyaqcv.TemplateMatchResult_swigregister(TemplateMatchResult)
class TemplateMatchResultSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.TemplateMatchResultSet_swiginit(self, _pyaqcv.new_TemplateMatchResultSet())
    __swig_destroy__ = _pyaqcv.delete_TemplateMatchResultSet

    def reset(self):
        r"""Reset the result set to an empty set."""
        return _pyaqcv.TemplateMatchResultSet_reset(self)

    def get_results_num(self):
        r"""
        Get the number of results in the set.
        :rtype: int
        :return: The number of results.
        """
        return _pyaqcv.TemplateMatchResultSet_get_results_num(self)

    def get_results(self):
        r"""
        Get all results in the set.
        :rtype: std::vector< aqcv::TemplateMatchResult,std::allocator< aqcv::TemplateMatchResult > >
        :return: The list of all results in the set.
        """
        return _pyaqcv.TemplateMatchResultSet_get_results(self)

    def get_result(self, index):
        r"""
        Get the i-th result in the set.
        :type index: int
        :param index:  The query index
        :rtype: :py:class:`TemplateMatchResult`
        :return: The i-th result
        """
        return _pyaqcv.TemplateMatchResultSet_get_result(self, index)

# Register TemplateMatchResultSet in _pyaqcv:
_pyaqcv.TemplateMatchResultSet_swigregister(TemplateMatchResultSet)
class TemplateMatchDof(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.TemplateMatchDof_swiginit(self, _pyaqcv.new_TemplateMatchDof())
    __swig_destroy__ = _pyaqcv.delete_TemplateMatchDof

    def set_nominal_rotate(self, rotate=0.0):
        r"""
        Set rotate range of the DOF.
        :type rotate: :py:class:`Radian`, optional
        :param rotate:  The range of rotation. Assuming that the parameter is R, the range is from -R degree to R degree.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_nominal_rotate(self, rotate)

    def set_zone_rotate(self, low=0.0, high=0.0, dup_range=6.283185307179586476925286766559):
        r"""
        Set rotate range of the DOF.
        :type low: :py:class:`Radian`, optional
        :param low:  Lower bound of the range.
        :type high: :py:class:`Radian`, optional
        :param high:  Upper bound of the range.
        :type dup_range: :py:class:`Radian`, optional
        :param dup_range:  For judging if two results are duplicated or not.
                              If the absolute value of difference of two results' rotation azimuth is less than dup_range, they are "duplicated".
                              Note that two results are "duplicated" if and only if all attributes(rotation, size_x, size_y) are "duplicated".
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_zone_rotate(self, low, high, dup_range)

    def set_nominal_size(self, size=1.0):
        r"""
        Set scale range of the DOF. Usage is similar to set_nominal_rotate.
        :param rotate:  The range of scale.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_nominal_size(self, size)

    def set_zone_size(self, low=1.0, high=1.0, dup_range=1.4):
        r"""
        Set scale range of the DOF. Usage is similar to set_zone_rotate.
        :type low: float, optional
        :param low:  Lower bound of the range.
        :type high: float, optional
        :param high:  Upper bound of the range.
        :type dup_range: float, optional
        :param dup_range:  For judging if two results are duplicated or not.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_zone_size(self, low, high, dup_range)

    def set_nominal_size_x(self, size_x=1.0):
        r"""
        Set scale range on X-axis direction of the DOF. Usage is similar to set_nominal_rotate.
        :type size_x: float, optional
        :param size_x:  The range of scale.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_nominal_size_x(self, size_x)

    def set_zone_size_x(self, low=1.0, high=1.0, dup_range=1.4):
        r"""
        Set scale range on X-axis direction of the DOF. Usage is similar to set_zone_rotate.
        :type low: float, optional
        :param low:  Lower bound of the range.
        :type high: float, optional
        :param high:  Upper bound of the range.
        :type dup_range: float, optional
        :param dup_range:  For judging if two results are duplicated or not.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_zone_size_x(self, low, high, dup_range)

    def set_nominal_size_y(self, size_y=1.0):
        r"""
        Set scale range on Y-axis direction of the DOF. Usage is similar to set_nominal_rotate.
        :type size_y: float, optional
        :param size_y:  The range of scale.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_nominal_size_y(self, size_y)

    def set_zone_size_y(self, low=1.0, high=1.0, dup_range=1.4):
        r"""
        Set scale range on Y-axis direction of the DOF. Usage is similar to set_zone_rotate.
        :type low: float, optional
        :param low:  Lower bound of the range.
        :type high: float, optional
        :param high:  Upper bound of the range.
        :type dup_range: float, optional
        :param dup_range:  For judging if two results are duplicated or not.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_set_zone_size_y(self, low, high, dup_range)

    def get_rotate(self, low, high, dup_range):
        r"""
        Get the searching range of rotation.
        :type low: :py:class:`Radian`, out
        :param low:  Lower bound of range.
        :type high: :py:class:`Radian`, out
        :param high:  Upper bound of the range.
        :type dup_range: :py:class:`Radian`, out
        :param dup_range:  Duplicate threshold.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_get_rotate(self, low, high, dup_range)

    def get_size(self, low, high, dup_range):
        r"""
        Get the searching range of scale.
        :type low: float, out
        :param low:  Lower bound of range.
        :type high: float, out
        :param high:  Upper bound of the range.
        :type dup_range: float, out
        :param dup_range:  Duplicate threshold.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_get_size(self, low, high, dup_range)

    def get_size_x(self, low, high, dup_range):
        r"""
        Get the searching range of scale on X-axis.
        :type low: float, out
        :param low:  Lower bound of range.
        :type high: float, out
        :param high:  Upper bound of the range.
        :type dup_range: float, out
        :param dup_range:  Duplicate threshold.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_get_size_x(self, low, high, dup_range)

    def get_size_y(self, low, high, dup_range):
        r"""
        Get the searching range of scale on Y-axis.
        :type low: float, out
        :param low:  Lower bound of range.
        :type high: float, out
        :param high:  Upper bound of the range.
        :type dup_range: float, out
        :param dup_range:  Duplicate threshold.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchDof_get_size_y(self, low, high, dup_range)

# Register TemplateMatchDof in _pyaqcv:
_pyaqcv.TemplateMatchDof_swigregister(TemplateMatchDof)
class TemplateMatchModel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.TemplateMatchModel_swiginit(self, _pyaqcv.new_TemplateMatchModel())
    __swig_destroy__ = _pyaqcv.delete_TemplateMatchModel

    def set_granularity(self, granularity=2.0):
        r"""
        Set granularity
        :type granularity: float, optional
        :param granularity:  The value of granularity to set.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_granularity(self, granularity)

    def get_granularity(self):
        r"""
        Get granularity parameter.
        :rtype: float
        :return: The value of granularity.
        """
        return _pyaqcv.TemplateMatchModel_get_granularity(self)

    def set_granularity_fine(self, granularity_fine=1.0):
        r"""
        Set granularity for refine stage.
        :type granularity_fine: float, optional
        :param granularity_fine:  The value of granularity for refine stage.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_granularity_fine(self, granularity_fine)

    def get_granularity_fine(self):
        r"""
        Get granularity_fine parameter.
        :rtype: float
        :return: The value of granularity_fine.
        """
        return _pyaqcv.TemplateMatchModel_get_granularity_fine(self)

    def set_downsample_ratio(self, dScale=1):
        r"""
        Set downsample ratio. High downsample ratio will lead to low time cost and low location precision.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_downsample_ratio(self, dScale)

    def get_downsample_ratio(self):
        r"""
        Get downsample ratio.
        :rtype: float
        :return: The value of scale ratio.
        """
        return _pyaqcv.TemplateMatchModel_get_downsample_ratio(self)

    def set_dataset_width_height_fixed(self, dataset_img_width, dataset_img_height):
        r"""
        Set dataset resolution, which will affect the auto selected downsample ratio.
               Should be set as the resolution of the image for training is different from infering.
               If not set, the downsample ratio will calculate by the resolution of input image for training.
        @ param dataset_img_width  Width of images when infering
        @ param dataset_img_height  Height of images when infering
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_dataset_width_height_fixed(self, dataset_img_width, dataset_img_height)

    def set_dataset_width_height_unfixed(self):
        r"""
        Disable fixed resolution on the whole dataset.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_dataset_width_height_unfixed(self)

    def set_noise_thre(self, noise_thre=10):
        r"""
        Set noise threshold.
        :type noise_thre: unsigned char, optional
        :param noise_thre:  The value of noise threshold
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_noise_thre(self, noise_thre)

    def get_noise_thre(self):
        r"""
        Get noise threshold parameter.
        :rtype: int
        :return: The value of noise threshold.
        """
        return _pyaqcv.TemplateMatchModel_get_noise_thre(self)

    def set_total_grad_mag_thre(self, total_grad_mag_thre=500):
        r"""
        Set total gradient magnitude threshold for feature chains.
        :type total_grad_mag_thre: int, optional
        :param total_grad_mag_thre:  The value of total gradient magnitude
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_total_grad_mag_thre(self, total_grad_mag_thre)

    def get_total_grad_mag_thre(self):
        r"""
        Get total gradient magnitude parameter.
        :rtype: int
        :return: The value of total gradient magnitude.
        """
        return _pyaqcv.TemplateMatchModel_get_total_grad_mag_thre(self)

    def set_total_grad_mag_relative_thre(self, total_grad_mag_relative_thre=0.1):
        r"""
        Set relative total gradient magnitude threshold for feature chains.
                    The actual threshold will be max length of chains * relative threshold
        :type total_grad_mag_relative_thre: float, optional
        :param total_grad_mag_relative_thre:  The value of total gradient magnitude
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_set_total_grad_mag_relative_thre(self, total_grad_mag_relative_thre)

    def get_total_grad_mag_relative_thre(self):
        r"""
        Get relative total gradient magnitude parameter.
        :rtype: float
        :return: The value of total gradient magnitude.
        """
        return _pyaqcv.TemplateMatchModel_get_total_grad_mag_relative_thre(self)

    def set_auto_select_granularity(self, Auto=True):
        r"""
        Set if granularity parameter is set automatically or not. Note that if it's true, the value set by the set-function has no effect.
        :type Auto: boolean, optional
        :param Auto:  Whether automatic parameter selection is enabled or not.
        """
        return _pyaqcv.TemplateMatchModel_set_auto_select_granularity(self, Auto)

    def get_auto_select_granularity(self):
        r"""
        Get if automatic parameter selection for granularity is enabled currently.
        :rtype: boolean
        :return: True if automatic parameter selection is enabled.
        """
        return _pyaqcv.TemplateMatchModel_get_auto_select_granularity(self)

    def set_auto_select_downsample_ratio(self, Auto=True):
        r"""
        Set if scale parameter is set automatically or not. Note that if it's true, the value set by the set-function has no effect.
        :type Auto: boolean, optional
        :param Auto:  Whether automatic parameter selection is enabled or not.
        """
        return _pyaqcv.TemplateMatchModel_set_auto_select_downsample_ratio(self, Auto)

    def get_auto_select_downsample_ratio(self):
        r"""
        Get if automatic parameter selection for scale is enabled currently.
        :rtype: boolean
        :return: True if automatic parameter selection is enabled.
        """
        return _pyaqcv.TemplateMatchModel_get_auto_select_downsample_ratio(self)

    def set_auto_select_noiseThre(self, Auto=True):
        r"""
        Set if noise threshold parameter is set automatically or not. Note that if it's true, the value set by the set-function has no effect.
        :type Auto: boolean, optional
        :param Auto:  Whether automatic parameter selection is enabled or not.
        """
        return _pyaqcv.TemplateMatchModel_set_auto_select_noiseThre(self, Auto)

    def get_auto_select_noiseThre(self):
        r"""
        Get if automatic parameter selection for noise threshold is enabled currently.
        :rtype: boolean
        :return: True if automatic parameter selection is enabled.
        """
        return _pyaqcv.TemplateMatchModel_get_auto_select_noiseThre(self)

    def set_auto_select_total_grad_mag_thre(self, Auto=True):
        r"""
        Set if total gradient magnitude parameter is set automatically or not.
               Note that if it's true, the value set by the set-function has no effect.
        :type Auto: boolean, optional
        :param Auto:  Whether automatic parameter selection for total gradient magnitude is enabled or not.
        """
        return _pyaqcv.TemplateMatchModel_set_auto_select_total_grad_mag_thre(self, Auto)

    def get_auto_select_total_grad_mag_thre(self):
        r"""
        Get if automatic parameter selection for total gradient magnitude is enabled currently.
        :rtype: boolean
        :return: True if automatic parameter selection is enabled.
        """
        return _pyaqcv.TemplateMatchModel_get_auto_select_total_grad_mag_thre(self)

    def train(self, *args):
        r"""
        *Overload 1:*

        Train the model from a template image.
        :type image: :py:class:`Mat`
        :param image:  Image for training.
        :type affine: :py:class:`Mat`
        :param affine:  ROI for training. It is a 3x3 matrix project a unit square to four corners of the ROI.
        :type model_origin_X: float
        :param model_origin_X:  X coordinate of origin point of the model.
        :type model_origin_Y: float
        :param model_origin_Y:  Y coordinate of origin point of the model.
        :rtype: boolean
        :return: True if it is successful.

        |

        *Overload 2:*

        Train the model from a template image.
        :type image: :py:class:`Mat`
        :param image:  Image for training.
        :type roi: :py:class:`RotateRect2f`
        :param roi:  Rectangle ROI for training.
        :type model_origin_X: float
        :param model_origin_X:  X coordinate of origin point of the model.
        :type model_origin_Y: float
        :param model_origin_Y:  Y coordinate of origin point of the model.
        :rtype: boolean
        :return: True if it is successful.

        |

        *Overload 3:*

        Train the model from a template image.
        :type image: :py:class:`Mat`
        :param image:  Image for training.
        :type mask: :py:class:`Mat`
        :param mask:  Mask for training.
        :type affine: :py:class:`Mat`
        :param affine:  ROI for training. It is a 3x3 matrix project a unit square to four corners of the ROI.
        :type model_origin_X: float
        :param model_origin_X:  X coordinate of origin point of the model.
        :type model_origin_Y: float
        :param model_origin_Y:  Y coordinate of origin point of the model.
        :rtype: boolean
        :return: True if it is successful.


        |

        *Overload 4:*

        Train the model from a template image.
        :type image: :py:class:`Mat`
        :param image:  Image for training.
        :type mask: :py:class:`Mat`
        :param mask:  Mask for training.
        :type roi: :py:class:`RotateRect2f`
        :param roi:  Rectangle ROI for training.
        :type model_origin_X: float
        :param model_origin_X:  X coordinate of origin point of the model.
        :type model_origin_Y: float
        :param model_origin_Y:  Y coordinate of origin point of the model.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_train(self, *args)

    def untrain(self):
        r"""Reset the model as untrained."""
        return _pyaqcv.TemplateMatchModel_untrain(self)

    def is_trained(self):
        r"""
        Check if the model is trained.
        :rtype: boolean
        :return: True if the model is trained, otherwise False.
        """
        return _pyaqcv.TemplateMatchModel_is_trained(self)

    def get_train_features(self, quick, low, high, pattern_coordinate=True):
        r"""
        Get feature chains on the template image.
        :type quick: :py:class:`PointFeatArraySet`, out
        :param quick:  Feature points found out by quick search.
        :type low: :py:class:`PointFeatArraySet`, out
        :param low:  Feature points found out on low resolution img.
        :type high: :py:class:`PointFeatArraySet`, out
        :param high:  Feature points found out on high resolution img.
        :type pattern_coordinate: boolean, optional
        :param pattern_coordinate:  If feature points are on the template image coordinate.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_get_train_features(self, quick, low, high, pattern_coordinate)

    def get_model_origin(self, origin):
        r"""
        Get the origin point of the model.
        :type origin: :py:class:`Point2f`, out
        :param origin:  Output origin point.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_get_model_origin(self, origin)

    def get_train_src_image(self, img):
        r"""
        Get the source training image.
        :type img: :py:class:`Mat`, out
        :param img:  Output origin source training image.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_get_train_src_image(self, img)

    def get_train_result_image(self, img):
        r"""
        Get the result image with feature points generated in training process.
        :type img: :py:class:`Mat`, out
        :param img:  Output model image.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_get_train_result_image(self, img)

    def get_train_model_image(self, img):
        r"""
        Get the model image used in training process.
        :type img: :py:class:`Mat`, out
        :param img:  Output model image.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_get_train_model_image(self, img)

    def get_train_mask_image(self, img):
        r"""
        Get the mask image.
        :type img: :py:class:`Mat`, out
        :param img:  Output mask image.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchModel_get_train_mask_image(self, img)

    def get_train_affine_from_unit_sq(self):
        r"""
        Get the training region(ROI). It is descripted as a 3x3 matrix projecting unit square to 4 corners of the rectangle region.
        :rtype: :py:class:`Mat`
        :return: The 3x3 transformation matrix.
        """
        return _pyaqcv.TemplateMatchModel_get_train_affine_from_unit_sq(self)

    def get_train_info(self):
        r"""
        Get training information.
        :rtype: string
        :return: The string of information.
        """
        return _pyaqcv.TemplateMatchModel_get_train_info(self)

    def get_train_info_ID(self):
        r"""
        Get ID of training information. Each ID corresponds to a information string.
        :rtype: int
        :return: The integer of ID of information.
        """
        return _pyaqcv.TemplateMatchModel_get_train_info_ID(self)

# Register TemplateMatchModel in _pyaqcv:
_pyaqcv.TemplateMatchModel_swigregister(TemplateMatchModel)
class TemplateMatchRuntime(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.TemplateMatchRuntime_swiginit(self, _pyaqcv.new_TemplateMatchRuntime())
    __swig_destroy__ = _pyaqcv.delete_TemplateMatchRuntime
    kQuick = _pyaqcv.TemplateMatchRuntime_kQuick
    kFine = _pyaqcv.TemplateMatchRuntime_kFine
    r"""High precision"""
    kRobustFine = _pyaqcv.TemplateMatchRuntime_kRobustFine
    r"""High precision and robust, try to use it when there are repeated similar patterns"""

    def set_accept_threshold(self, accept=0.8):
        r"""
        Set accept threshold. Delete results whose score is lower than the threshold.
        :type accept: float, optional
        :param accept:  The value of accept threshold
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchRuntime_set_accept_threshold(self, accept)

    def get_accept_threshold(self):
        r"""
        Get the accept threshold.
        :rtype: float
        :return: The value of accept threshold.
        """
        return _pyaqcv.TemplateMatchRuntime_get_accept_threshold(self)

    def set_num_to_find(self, num=1):
        r"""
        Set the number of output results.
        :type num: int, optional
        :param num:  The value of number of output results.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchRuntime_set_num_to_find(self, num)

    def get_num_to_find(self):
        r"""
        Get the number of output results.
        :rtype: int
        :return: The max number of results to find.
        """
        return _pyaqcv.TemplateMatchRuntime_get_num_to_find(self)

    def set_ignore_polarity(self, ignore=False):
        r"""
        Set whether to ignore polarity
        :type ignore: boolean, optional
        :param ignore:  True if you need ignoring polarity
        """
        return _pyaqcv.TemplateMatchRuntime_set_ignore_polarity(self, ignore)

    def get_ignore_polarity(self):
        r"""
        Get whether to ignore polarity
        :rtype: boolean
        :return: True if polarity is ignored
        """
        return _pyaqcv.TemplateMatchRuntime_get_ignore_polarity(self)

    def set_iou_threshold(self, iou_th):
        r"""
        Set IOU(Intersection over Union) threshold for removing overlapped objects.
        :type iou_th: float
        :param iou_th:  The value of IOU threshold in [0, 1]. Set minus value to disable this filter.
        :rtype: boolean
        :return: If this filter is enabled.
        """
        return _pyaqcv.TemplateMatchRuntime_set_iou_threshold(self, iou_th)

    def get_iou_threshold(self):
        r"""
        Get IOU threshold
        :rtype: float
        :return: The Value of IOU threshold. -1 if the filter is disabled.
        """
        return _pyaqcv.TemplateMatchRuntime_get_iou_threshold(self)

    def set_model(self, model):
        r"""
        Set (trained) model for runtime search. Should be called before Execute().
        :type model: :py:class:`TemplateMatchModel`
        :param model:  The model.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchRuntime_set_model(self, model)

    def set_dof(self, *args):
        r"""
        Set DOF for runtime search. Should be called before Execute().
        :type dof: :py:class:`TemplateMatchDof`, optional
        :param dof:  The dof for searching.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchRuntime_set_dof(self, *args)

    def set_search_mode(self, mode):
        r"""
        Set search mode. There are 3 choices: Quick, Fine, RobustFine
        :type mode: int
        :param mode:  Selected mode.
        """
        return _pyaqcv.TemplateMatchRuntime_set_search_mode(self, mode)

    def get_search_mode(self):
        r"""
        Get search mode. There are 3 choices: Quick, Fine, RobustFine
        :rtype: int
        :return: The integer representing the mode. Quick = 0, Fine = 1, RobustFine = 2.
        """
        return _pyaqcv.TemplateMatchRuntime_get_search_mode(self)

    def set_time_limit(self, time_limit_millisecond):
        r"""
        Set time limit(ms) for function execute.
        :type time_limit_millisecond: int
        :param time_limit_millisecond:   Time limit as millisecond
        """
        return _pyaqcv.TemplateMatchRuntime_set_time_limit(self, time_limit_millisecond)

    def get_time_limit(self):
        r"""
        Get time limit(ms) for function execute.
        :rtype: int
        :return: The integer for time limit(ms).
        """
        return _pyaqcv.TemplateMatchRuntime_get_time_limit(self)

    def execute(self, *args):
        r"""
        *Overload 1:*

        Execute search on CPU.
        :type image: :py:class:`Mat`
        :param image:  Image to be analyzed.
        :type roi: :py:class:`Rect2f`
        :param roi:  Search ROI (a rectangle).
        :rtype: boolean
        :return: True if it is successful.

        |

        *Overload 2:*

        Execute search on CPU.
        :type image: :py:class:`Mat`
        :param image:  Image to be analyzed.
        :type roi: :py:class:`MultiPolygon2f`
        :param roi:  Search ROI (a MultiPolygon2f that can describe any shape).
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchRuntime_execute(self, *args)

    def execute_GPU(self, image, roi):
        r"""
        Execute search on GPU.
        :type image: :py:class:`Mat`
        :param image:  Image to be analyzed.
        :type roi: :py:class:`Rect2f`
        :param roi:  Search ROI (a rectangle).
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.TemplateMatchRuntime_execute_GPU(self, image, roi)

    def get_result_set(self):
        r"""
        Get search result set.
        :rtype: :py:class:`TemplateMatchResultSet`
        :return: The result set after search.
        """
        return _pyaqcv.TemplateMatchRuntime_get_result_set(self)

# Register TemplateMatchRuntime in _pyaqcv:
_pyaqcv.TemplateMatchRuntime_swigregister(TemplateMatchRuntime)
class RegionSearchResult(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RegionSearchResult_swiginit(self, _pyaqcv.new_RegionSearchResult())
    __swig_destroy__ = _pyaqcv.delete_RegionSearchResult

    def get_position(self):
        r"""
        Get the top left corner point of the result.
        :rtype: :py:class:`Point2f`
        :return: The top left point.
        """
        return _pyaqcv.RegionSearchResult_get_position(self)

    def get_rotate(self):
        r"""
        Get the rotate angle of the result.
        :rtype: :py:class:`Radian`
        :return: A real number of the angle.
        """
        return _pyaqcv.RegionSearchResult_get_rotate(self)

    def get_size(self):
        r"""
        Get the scale of the result.
        :rtype: float
        :return: A real number of the scale.
        """
        return _pyaqcv.RegionSearchResult_get_size(self)

    def get_score(self):
        r"""
        Get the score of the result.
        :rtype: float
        :return: A real number of the score.
        """
        return _pyaqcv.RegionSearchResult_get_score(self)

    def get_match_region(self):
        r"""
        Get the affine matrtix of the matching affine rectangle
        :rtype: :py:class:`Mat`
        :return: A 3x3 matrix of the affine rectangle.
        """
        return _pyaqcv.RegionSearchResult_get_match_region(self)

    def get_transform(self):
        r"""
        Get the transformation matrtix projecting from train image to quest image.
        :rtype: :py:class:`Mat`
        :return: A 3x3 transformation matrix.
        """
        return _pyaqcv.RegionSearchResult_get_transform(self)

    def is_accepted(self):
        r"""
        Get whether the result is accepted or not.
        :rtype: boolean
        :return: True if accepted.
        """
        return _pyaqcv.RegionSearchResult_is_accepted(self)

# Register RegionSearchResult in _pyaqcv:
_pyaqcv.RegionSearchResult_swigregister(RegionSearchResult)
class RegionSearchResultSet(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RegionSearchResultSet_swiginit(self, _pyaqcv.new_RegionSearchResultSet())
    __swig_destroy__ = _pyaqcv.delete_RegionSearchResultSet

    def reset(self):
        r"""Reset the result set to an empty set."""
        return _pyaqcv.RegionSearchResultSet_reset(self)

    def get_results_num(self):
        r"""
        Get the number of results in the set.
        :rtype: int
        :return: The number of results.
        """
        return _pyaqcv.RegionSearchResultSet_get_results_num(self)

    def get_results(self):
        r"""
        Get all results in the set.
        :rtype: std::vector< aqcv::RegionSearchResult,std::allocator< aqcv::RegionSearchResult > >
        :return: The list of all results in the set.
        """
        return _pyaqcv.RegionSearchResultSet_get_results(self)

    def get_result(self, index):
        r"""
        Get the i-th result in the set.
        :type index: int
        :param index:  The query index
        :rtype: :py:class:`RegionSearchResult`
        :return: The i-th result
        """
        return _pyaqcv.RegionSearchResultSet_get_result(self, index)

    def order_by_score(self):
        r"""Sort result list by score."""
        return _pyaqcv.RegionSearchResultSet_order_by_score(self)

    def order_by_positonX(self):
        r"""Sort result list by x."""
        return _pyaqcv.RegionSearchResultSet_order_by_positonX(self)

    def order_by_positonY(self):
        r"""Sort result list by y."""
        return _pyaqcv.RegionSearchResultSet_order_by_positonY(self)

    def order_by_angle(self):
        r"""Sort result list by angle."""
        return _pyaqcv.RegionSearchResultSet_order_by_angle(self)

    def order_by_size(self):
        r"""Sort result list by size."""
        return _pyaqcv.RegionSearchResultSet_order_by_size(self)

# Register RegionSearchResultSet in _pyaqcv:
_pyaqcv.RegionSearchResultSet_swigregister(RegionSearchResultSet)
class RegionSearch(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RegionSearch_swiginit(self, _pyaqcv.new_RegionSearch())
    __swig_destroy__ = _pyaqcv.delete_RegionSearch
    AccuracyVeryFine = _pyaqcv.RegionSearch_AccuracyVeryFine
    AccuracyFine = _pyaqcv.RegionSearch_AccuracyFine
    AccuracyCoarse = _pyaqcv.RegionSearch_AccuracyCoarse
    AlgorithmLinearSearch = _pyaqcv.RegionSearch_AlgorithmLinearSearch
    AlgorithmLinearCNLPAS = _pyaqcv.RegionSearch_AlgorithmLinearCNLPAS

    def set_algorithm(self, algo):
        r"""
        Set algorithm
        :type algo: int
        :param algo:  Algorithm type as enum value
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_algorithm(self, algo)

    def get_algorithm(self):
        r"""
        Get algorithm.
        :rtype: int
        :return: Enum value of algorithm type.
        """
        return _pyaqcv.RegionSearch_get_algorithm(self)

    def set_accuracy(self, accu):
        r"""
        Set accuracy mode.
        :type accu: int
        :param accu:  Accuracy mode
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_accuracy(self, accu)

    def get_accuracy(self):
        r"""
        Get accuracy mode.
        :rtype: int
        :return: Enum value of accuracy mode.
        """
        return _pyaqcv.RegionSearch_get_accuracy(self)

    def set_pyramid_layers(self, layers):
        r"""
        Set number of pyramid layers
        :type layers: int
        :param layers:  Number of pyramid layers
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_pyramid_layers(self, layers)

    def get_pyramid_layers(self):
        r"""
        Get number of pyramid layers
        :rtype: int
        :return: Number of pyramid layers
        """
        return _pyaqcv.RegionSearch_get_pyramid_layers(self)

    def set_auto_pyramid_layers(self, Auto=True):
        r"""
        Set if "pyramid_layers" parameter is set automatically or not. Note that if it's true, the value set by the set-function has no effect.
        :type Auto: boolean, optional
        :param Auto:  Whether automatic parameter selection is enabled or not.
        """
        return _pyaqcv.RegionSearch_set_auto_pyramid_layers(self, Auto)

    def get_auto_pyramid_layers(self):
        r"""
        Get if automatic parameter selection for "pyramid_layers" is enabled currently.
        :rtype: boolean
        :return: True if automatic parameter selection is enabled.
        """
        return _pyaqcv.RegionSearch_get_auto_pyramid_layers(self)

    def set_rotate_extent(self, low=0.0, high=0.0):
        r"""
        Set rotation range for searching.
        :type low: :py:class:`Radian`, optional
        :param low:  Lower bound of the range.
        :type high: :py:class:`Radian`, optional
        :param high:  Upper bound of the range.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_rotate_extent(self, low, high)

    def get_rotate_extent(self, low, high):
        r"""
        Get the searching range of rotation.
        :type low: :py:class:`Radian`, out
        :param low:  Lower bound of range.
        :type high: :py:class:`Radian`, out
        :param high:  Upper bound of the range.
        """
        return _pyaqcv.RegionSearch_get_rotate_extent(self, low, high)

    def set_rotate_step(self, step):
        r"""
        Set rotation step for searching.
        :type step: :py:class:`Radian`
        :param step:  The value of searching step.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_rotate_step(self, step)

    def get_rotate_step(self):
        r"""
        Get the searching step of rotation.
        :rtype: :py:class:`Radian`
        :return: A real number of searching rotation step.
        """
        return _pyaqcv.RegionSearch_get_rotate_step(self)

    def set_auto_rotate_step(self, Auto=True):
        r"""
        Set if "rotate_step" parameter is set automatically or not. Note that if it's true, the value set by the set-function has no effect.
        :type Auto: boolean, optional
        :param Auto:  Whether automatic parameter selection is enabled or not.
        """
        return _pyaqcv.RegionSearch_set_auto_rotate_step(self, Auto)

    def get_auto_rotate_step(self):
        r"""
        Get if automatic parameter selection for "rotate_step" is enabled currently.
        :rtype: boolean
        :return: True if automatic parameter selection is enabled.
        """
        return _pyaqcv.RegionSearch_get_auto_rotate_step(self)

    def set_scale_enabled(self, enable=True):
        r"""
        Set whether to search target with different scales.
        :type enable: boolean, optional
        :param enable:  If it is true, results with different scales than the template will be detected, but it will cost a bit more time.
        """
        return _pyaqcv.RegionSearch_set_scale_enabled(self, enable)

    def get_scale_enabled(self):
        r"""
        Get whether to search target with different scales.
        :rtype: boolean
        :return: True if searching different scales is enabled.
        """
        return _pyaqcv.RegionSearch_get_scale_enabled(self)

    def set_scale_step(self, step):
        r"""
        Set scale step for searching.
        :type step: float
        :param step:  The value of searching step.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_scale_step(self, step)

    def get_scale_step(self):
        r"""
        Get the searching step of scale.
        :rtype: float
        :return: A real number of searching scale step.
        """
        return _pyaqcv.RegionSearch_get_scale_step(self)

    def set_auto_scale_step(self, Auto=True):
        r"""
        Set if "scale_step" parameter is set automatically or not. Note that if it's true, the value set by the set-function has no effect.
        :type Auto: boolean, optional
        :param Auto:  Whether automatic parameter selection is enabled or not.
        """
        return _pyaqcv.RegionSearch_set_auto_scale_step(self, Auto)

    def get_auto_scale_step(self):
        r"""
        Get if automatic parameter selection for "scale_step" is enabled currently.
        :rtype: boolean
        :return: True if automatic parameter selection is enabled.
        """
        return _pyaqcv.RegionSearch_get_auto_scale_step(self)

    def train(self, *args):
        r"""
        *Overload 1:*

        Train the model from a template image with ROI.
        :type image: :py:class:`Mat`
        :param image:  Image for training.
        :type roi: :py:class:`Rect`
        :param roi:  Rectangle ROI for training.
        :type origin: :py:class:`Point2f`
        :param origin:  Origin point of the model.
        :rtype: boolean
        :return: True if it is successful.


        |

        *Overload 2:*

        Train the model from a template image with ROI and mask.
        :type image: :py:class:`Mat`
        :param image:  Image for training.
        :type mask: :py:class:`Mat`
        :param mask:  Mask on the template image.
        :type roi: :py:class:`Rect`
        :param roi:  Rectangle ROI for training.
        :type origin: :py:class:`Point2f`
        :param origin:  Origin point of the model.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_train(self, *args)

    def untrain(self):
        r"""Reset the model as untrained."""
        return _pyaqcv.RegionSearch_untrain(self)

    def is_trained(self):
        r"""
        Check if the model is trained.
        :rtype: boolean
        :return: True if the model is trained, otherwise False.
        """
        return _pyaqcv.RegionSearch_is_trained(self)

    def get_model_origin(self, origin):
        r"""
        Get the origin point of the model.
        :type origin: :py:class:`Point2f`, out
        :param origin:  Output origin point.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_get_model_origin(self, origin)

    def get_train_src_image(self, img):
        r"""
        Get the source training image.
        :type img: :py:class:`Mat`, out
        :param img:  Output origin source training image.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_get_train_src_image(self, img)

    def get_train_model_image(self, img):
        r"""
        Get the model image used in training process.
        :type img: :py:class:`Mat`, out
        :param img:  Output model image.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_get_train_model_image(self, img)

    def get_train_mask_image(self, img):
        r"""
        Get the mask image.
        :type img: :py:class:`Mat`, out
        :param img:  Output mask image.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_get_train_mask_image(self, img)

    def get_train_rect_region(self, rect):
        r"""
        Get the rectangle trained region on source image.
        :type rect: :py:class:`Rect`, out
        :param rect:  Output rectangle region.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_get_train_rect_region(self, rect)

    def set_accept_threshold(self, accept=0.8):
        r"""
        Set accept threshold. Delete results whose score is lower than the threshold.
        :type accept: float, optional
        :param accept:  The value of accept threshold
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_accept_threshold(self, accept)

    def get_accept_threshold(self):
        r"""
        Get the accept threshold.
        :rtype: float
        :return: The value of accept threshold.
        """
        return _pyaqcv.RegionSearch_get_accept_threshold(self)

    def set_num_to_find(self, num=1):
        r"""
        Set the number of output results.
        :type num: int, optional
        :param num:  The value of number of output results.
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_num_to_find(self, num)

    def get_num_to_find(self):
        r"""
        Set the number of output results.
        :param num:  The value of number of output results.
        :rtype: int
        :return: The max number of results to find.
        """
        return _pyaqcv.RegionSearch_get_num_to_find(self)

    def set_confusion_threshold(self, conf_thre=1.0):
        r"""
        Set confusion threshold. Confusion score is the highest score of wrong pattern in the quest image.
               If "num_to_find" is set, and we have detected enough result, the progress will be stopped immediately to save time.
        :type conf_thre: float, optional
        :param conf_thre:  The value of confusion threshold
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_confusion_threshold(self, conf_thre)

    def get_confusion_threshold(self):
        r"""
        Get the confusion threshold.
        :rtype: float
        :return: The value of confusion threshold.
        """
        return _pyaqcv.RegionSearch_get_confusion_threshold(self)

    def set_overlap_threshold(self, overlap=0.6):
        r"""
        Set overlap threshold. If two results overlapped and the overlap-area-ratio is higher than the threshold, one of them will be dropped.
        :type overlap: float, optional
        :param overlap:  The value of overlap threshold
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_set_overlap_threshold(self, overlap)

    def get_overlap_threshold(self):
        r"""
        Get the overlap threshold.
        :rtype: float
        :return: The value of overlap threshold.
        """
        return _pyaqcv.RegionSearch_get_overlap_threshold(self)

    def set_ignore_polarity(self, ignore=True):
        r"""
        Set whether to ignore polarity
        :type ignore: boolean, optional
        :param ignore:  True if you need ignoring polarity
        """
        return _pyaqcv.RegionSearch_set_ignore_polarity(self, ignore)

    def get_ignore_polarity(self):
        r"""
        Get whether to ignore polarity
        :rtype: boolean
        :return: True if polarity is ignored
        """
        return _pyaqcv.RegionSearch_get_ignore_polarity(self)

    def enable_full_image(self, enable=True):
        r"""
        Set whether to search whole image.
        :type enable: boolean, optional
        :param enable:  True if you need searching whole image
        """
        return _pyaqcv.RegionSearch_enable_full_image(self, enable)

    def get_is_full_image(self):
        r"""
        Get whether to search whole image
        :rtype: boolean
        :return: True if searching whole image
        """
        return _pyaqcv.RegionSearch_get_is_full_image(self)

    def get_search_rect(self):
        r"""
        Get ROI used in searching
        :rtype: :py:class:`Rect`
        :return: Rectangle of ROI
        """
        return _pyaqcv.RegionSearch_get_search_rect(self)

    def execute(self, img, roi):
        r"""
        Execute search on query image.
        :type img: :py:class:`Mat`
        :param img:  Image to be analyzed.
        :type roi: :py:class:`Rect`
        :param roi:  Search ROI (a rectangle).
        :rtype: boolean
        :return: True if it is successful.
        """
        return _pyaqcv.RegionSearch_execute(self, img, roi)

    def get_result_num(self):
        r"""
        Get number of detected results.
        :rtype: int
        :return: Number of detected results.
        """
        return _pyaqcv.RegionSearch_get_result_num(self)

    def get_result_set(self):
        r"""
        Get search result set.
        :rtype: :py:class:`RegionSearchResultSet`
        :return: Result set of searching.
        """
        return _pyaqcv.RegionSearch_get_result_set(self)

# Register RegionSearch in _pyaqcv:
_pyaqcv.RegionSearch_swigregister(RegionSearch)
class KeyPoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    point_feat = property(_pyaqcv.KeyPoint_point_feat_get, _pyaqcv.KeyPoint_point_feat_set, doc=r"""KeyPoint feature""")
    name = property(_pyaqcv.KeyPoint_name_get, _pyaqcv.KeyPoint_name_set, doc=r"""name of the key point""")
    ext_info = property(_pyaqcv.KeyPoint_ext_info_get, _pyaqcv.KeyPoint_ext_info_set, doc=r"""optional extend informations""")

    def __init__(self):
        _pyaqcv.KeyPoint_swiginit(self, _pyaqcv.new_KeyPoint())
    __swig_destroy__ = _pyaqcv.delete_KeyPoint

# Register KeyPoint in _pyaqcv:
_pyaqcv.KeyPoint_swigregister(KeyPoint)
class LabelRegion(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    polygon = property(_pyaqcv.LabelRegion_polygon_get, _pyaqcv.LabelRegion_polygon_set, doc=r"""region area""")
    angle = property(_pyaqcv.LabelRegion_angle_get, _pyaqcv.LabelRegion_angle_set, doc=r"""angle of the region,it's unit dependent on aidi""")
    score = property(_pyaqcv.LabelRegion_score_get, _pyaqcv.LabelRegion_score_set, doc=r"""socre of the region.""")
    key_points = property(_pyaqcv.LabelRegion_key_points_get, _pyaqcv.LabelRegion_key_points_set, doc=r"""key points of the regions""")
    name = property(_pyaqcv.LabelRegion_name_get, _pyaqcv.LabelRegion_name_set, doc=r"""region's name""")
    ext_info = property(_pyaqcv.LabelRegion_ext_info_get, _pyaqcv.LabelRegion_ext_info_set, doc=r"""optional extend informations""")

    def __init__(self):
        _pyaqcv.LabelRegion_swiginit(self, _pyaqcv.new_LabelRegion())
    __swig_destroy__ = _pyaqcv.delete_LabelRegion

# Register LabelRegion in _pyaqcv:
_pyaqcv.LabelRegion_swigregister(LabelRegion)
class Label(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kUnknown = _pyaqcv.Label_kUnknown
    r"""Unkown"""
    kSegment = _pyaqcv.Label_kSegment
    r"""Supervised and Unsupervised segmentation"""
    kDetection = _pyaqcv.Label_kDetection
    r"""Detection and FastDetection"""
    kClassify = _pyaqcv.Label_kClassify
    r"""Classification"""
    kLocation = _pyaqcv.Label_kLocation
    r"""Location"""

    def __init__(self):
        _pyaqcv.Label_swiginit(self, _pyaqcv.new_Label())
    __swig_destroy__ = _pyaqcv.delete_Label

    def parse_from_file(self, file_path):
        r"""
        parse from a .aqlabel file
        :type file_path: string
        :param file_path: label file path
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.Label_parse_from_file(self, file_path)

    def parse_from_data(self, *args):
        r"""
        *Overload 1:*
        parse aqlabel data from memory
        :type label_data: string
        :param label_data: pointer of data
        :type size: int
        :param size: label length in byte
        :rtype: boolean
        :return: true if successed

        |

        *Overload 2:*
        This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        :type label_data: string
        :param label_data: label's binary string data
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.Label_parse_from_data(self, *args)

    def save_to_file(self, file_path):
        r"""
        save current label to a .aqlabel file
        :type file_path: string
        :param file_path: path to save
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.Label_save_to_file(self, file_path)

    def serialize_to_string(self):
        r"""
        serialize label to string
        :rtype: string
        :return: serialized string result
        """
        return _pyaqcv.Label_serialize_to_string(self)
    dataset_type = property(_pyaqcv.Label_dataset_type_get, _pyaqcv.Label_dataset_type_set, doc=r"""dataset type 'DataSetType'""")
    img_size = property(_pyaqcv.Label_img_size_get, _pyaqcv.Label_img_size_set, doc=r"""the size of image corresponding to current label""")
    name = property(_pyaqcv.Label_name_get, _pyaqcv.Label_name_set, doc=r"""image type, unused currently""")
    score = property(_pyaqcv.Label_score_get, _pyaqcv.Label_score_set)
    regions = property(_pyaqcv.Label_regions_get, _pyaqcv.Label_regions_set, doc=r"""normal label region""")
    masks = property(_pyaqcv.Label_masks_get, _pyaqcv.Label_masks_set, doc=r"""single image mask region""")
    hardcases = property(_pyaqcv.Label_hardcases_get, _pyaqcv.Label_hardcases_set, doc=r"""difficult areas that require special attention during training""")
    origin_result = property(_pyaqcv.Label_origin_result_get, _pyaqcv.Label_origin_result_set, doc=r"""orignal inference result""")
    ext_info = property(_pyaqcv.Label_ext_info_get, _pyaqcv.Label_ext_info_set, doc=r"""extend field, used as a temporary or partial extension""")

# Register Label in _pyaqcv:
_pyaqcv.Label_swigregister(Label)
class AqImage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.AqImage_swiginit(self, _pyaqcv.new_AqImage())
    __swig_destroy__ = _pyaqcv.delete_AqImage

    def parse_from_file(self, file_path):
        r"""
        parse from a .aqimg file
        :type file_path: string
        :param file_path: aqimg file path
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.AqImage_parse_from_file(self, file_path)

    def save_to_file(self, file_path):
        r"""
        save current AqImage to a .aqimg file
        :type file_path: string
        :param file_path: file path to save
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.AqImage_save_to_file(self, file_path)

    def parse_from_string(self, buffer):
        r"""
        parse AqImage from string buffer
        :type buffer: string
        :param buffer: AqImage binary data
        :rtype: boolean
        :return: true if successed
        """
        return _pyaqcv.AqImage_parse_from_string(self, buffer)

    def serialize_to_string(self):
        r"""
        serialize current AqImage to string
        :rtype: string
        :return: serialized string
        """
        return _pyaqcv.AqImage_serialize_to_string(self)

    def get_images(self):
        r"""
        get image vectors
        :rtype: std::vector< aqcv::Mat,std::allocator< aqcv::Mat > >
        :return: images save in the AqImage
        """
        return _pyaqcv.AqImage_get_images(self)

    def set_images(self, images):
        r"""
        update images
        :param images,all: image should have same channel, depth, and size
        :rtype: boolean
        :return: true if given images valid.
        """
        return _pyaqcv.AqImage_set_images(self, images)

    def clone(self):
        r"""
        deep copy of this AqImage
        :rtype: :py:class:`AqImage`
        :return: cloned AqImage
        """
        return _pyaqcv.AqImage_clone(self)

# Register AqImage in _pyaqcv:
_pyaqcv.AqImage_swigregister(AqImage)
class Buffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         construct Buffer with given data (deep copy)
        :type buffer: string
        :param buffer: point address of given data
        :type count: int
        :param count: byte size of given data

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        _pyaqcv.Buffer_swiginit(self, _pyaqcv.new_Buffer(*args))
    __swig_destroy__ = _pyaqcv.delete_Buffer

    def byte_size(self):
        r"""get current datas' byte size"""
        return _pyaqcv.Buffer_byte_size(self)

    def data(self, *args):
        r"""
        *Overload 1:*
         get current datas' byte size

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        return _pyaqcv.Buffer_data(self, *args)

    def dump_data(self, *args):
        r"""
         get some data from current buffer
        :type buffer: string
        :param buffer: output data address
        :type offset: int
        :param offset: offset from the begining of buffer data
        :type count: int
        :param count: byte size that you want to get
        :rtype: boolean
        :return: true if current buffer count not less than count
        """
        return _pyaqcv.Buffer_dump_data(self, *args)

    def append(self, *args):
        r"""
        *Overload 1:*
         append some data into current buffer
        :type buffer: string
        :param buffer: input data address
        :type count: int
        :param count: byte size of buffer

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        return _pyaqcv.Buffer_append(self, *args)

    def empty(self):
        r"""where current buffer if empty"""
        return _pyaqcv.Buffer_empty(self)

# Register Buffer in _pyaqcv:
_pyaqcv.Buffer_swigregister(Buffer)
class BinaryOutputArchive(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.BinaryOutputArchive_swiginit(self, _pyaqcv.new_BinaryOutputArchive())
    __swig_destroy__ = _pyaqcv.delete_BinaryOutputArchive

    def pop_buffer(self):
        r"""pop all buffer(Notes: inner buffer will be cleared)"""
        return _pyaqcv.BinaryOutputArchive_pop_buffer(self)

    def __and__(self, *args):
        return _pyaqcv.BinaryOutputArchive___and__(self, *args)

    def write(self, *args):
        r"""
        *Overload 1:*
        serialize binary data into current archive

        |

        *Overload 2:*
        serialize Buffer in to current archive
        """
        return _pyaqcv.BinaryOutputArchive_write(self, *args)

    def clear(self):
        r"""clear all data of current archive"""
        return _pyaqcv.BinaryOutputArchive_clear(self)

# Register BinaryOutputArchive in _pyaqcv:
_pyaqcv.BinaryOutputArchive_swigregister(BinaryOutputArchive)
class BinaryInputArchive(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""construct with given buffer"""
        _pyaqcv.BinaryInputArchive_swiginit(self, _pyaqcv.new_BinaryInputArchive(*args))
    __swig_destroy__ = _pyaqcv.delete_BinaryInputArchive

    def byte_size(self):
        r"""byte size of current data"""
        return _pyaqcv.BinaryInputArchive_byte_size(self)

    def __and__(self, *args):
        return _pyaqcv.BinaryInputArchive___and__(self, *args)

    def read(self, *args):
        r"""
        *Overload 1:*
         read some data
        :type buffer: string
        :param buffer: output data address(must be prealloced with enough memory)
        :type count: int
        :param count: byte size that you want to get

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        return _pyaqcv.BinaryInputArchive_read(self, *args)

    def reset_buffer(self, *args):
        r"""
        *Overload 1:*
         reset current archive with given data

        |

        *Overload 2:*
         This is an overloaded member function, provided for convenience.
        It differs from the above function only in what argument(s) it accepts.
        """
        return _pyaqcv.BinaryInputArchive_reset_buffer(self, *args)

# Register BinaryInputArchive in _pyaqcv:
_pyaqcv.BinaryInputArchive_swigregister(BinaryInputArchive)
class AqSize(object):
    r"""
     Template class for specifying the size of an image or rectangle.

    The class includes two members called width and height. The same set of arithmetic and comparison
    operations as for Point is available.

    aqcv defines the following Size_<> aliases:

    .. code-block:: c++

            typedef Size_<int> Size2i;
            typedef Size2i Size;
            typedef Size_<float> Size2f;
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqSize_swiginit(self, _pyaqcv.new_AqSize(*args))

    def area(self):
        r"""the area (width*height)"""
        return _pyaqcv.AqSize_area(self)

    def aspect_ratio(self):
        r"""aspect ratio (width/height)"""
        return _pyaqcv.AqSize_aspect_ratio(self)

    def empty(self):
        r"""true if empty"""
        return _pyaqcv.AqSize_empty(self)
    width = property(_pyaqcv.AqSize_width_get, _pyaqcv.AqSize_width_set, doc=r"""the width""")
    height = property(_pyaqcv.AqSize_height_get, _pyaqcv.AqSize_height_set, doc=r"""the height""")
    __swig_destroy__ = _pyaqcv.delete_AqSize

# Register AqSize in _pyaqcv:
_pyaqcv.AqSize_swigregister(AqSize)
class AqSize2f(object):
    r"""
     Template class for specifying the size of an image or rectangle.

    The class includes two members called width and height. The same set of arithmetic and comparison
    operations as for Point is available.

    aqcv defines the following Size_<> aliases:

    .. code-block:: c++

            typedef Size_<int> Size2i;
            typedef Size2i Size;
            typedef Size_<float> Size2f;
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqSize2f_swiginit(self, _pyaqcv.new_AqSize2f(*args))

    def area(self):
        r"""the area (width*height)"""
        return _pyaqcv.AqSize2f_area(self)

    def aspect_ratio(self):
        r"""aspect ratio (width/height)"""
        return _pyaqcv.AqSize2f_aspect_ratio(self)

    def empty(self):
        r"""true if empty"""
        return _pyaqcv.AqSize2f_empty(self)
    width = property(_pyaqcv.AqSize2f_width_get, _pyaqcv.AqSize2f_width_set, doc=r"""the width""")
    height = property(_pyaqcv.AqSize2f_height_get, _pyaqcv.AqSize2f_height_set, doc=r"""the height""")
    __swig_destroy__ = _pyaqcv.delete_AqSize2f

# Register AqSize2f in _pyaqcv:
_pyaqcv.AqSize2f_swigregister(AqSize2f)
class AqSize2d(object):
    r"""
     Template class for specifying the size of an image or rectangle.

    The class includes two members called width and height. The same set of arithmetic and comparison
    operations as for Point is available.

    aqcv defines the following Size_<> aliases:

    .. code-block:: c++

            typedef Size_<int> Size2i;
            typedef Size2i Size;
            typedef Size_<float> Size2f;
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqSize2d_swiginit(self, _pyaqcv.new_AqSize2d(*args))

    def area(self):
        r"""the area (width*height)"""
        return _pyaqcv.AqSize2d_area(self)

    def aspect_ratio(self):
        r"""aspect ratio (width/height)"""
        return _pyaqcv.AqSize2d_aspect_ratio(self)

    def empty(self):
        r"""true if empty"""
        return _pyaqcv.AqSize2d_empty(self)
    width = property(_pyaqcv.AqSize2d_width_get, _pyaqcv.AqSize2d_width_set, doc=r"""the width""")
    height = property(_pyaqcv.AqSize2d_height_get, _pyaqcv.AqSize2d_height_set, doc=r"""the height""")
    __swig_destroy__ = _pyaqcv.delete_AqSize2d

# Register AqSize2d in _pyaqcv:
_pyaqcv.AqSize2d_swigregister(AqSize2d)
class AqRect(object):
    r"""
     Template class for 2D rectangles

    described by the following parameters:
    -   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y
        in aqcv. Though, in your algorithms you may count x and y from the bottom-left corner.
    -   Rectangle width and height.

    aqcv typically assumes that the top and left boundary of the rectangle are inclusive, while the
    right and bottom boundaries are not. For example, the method Rect_::contains returns true if

     .. math::

         x  \leq pt.x < x+width, y  \leq pt.y < y+height

    Virtually every loop over an image ROI in aqcv (where ROI is specified by Rect_<int> ) is
    implemented as:

    .. code-block:: c++

            for(int y = roi.y; y < roi.y + roi.height; y++)
                for(int x = roi.x; x < roi.x + roi.width; x++)
                {
        ...
                }
    In addition to the class members, the following operations on rectangles are implemented:
    -    :math:`\texttt{rect} = \texttt{rect} \pm \texttt{point}`  (shifting a rectangle by a certain offset)
    -    :math:`\texttt{rect} = \texttt{rect} \pm \texttt{size}`  (expanding or shrinking a rectangle by a
        certain amount)
    -   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)
    -   rect = rect1 & rect2 (rectangle intersection)
    -   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )
    -   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)
    -   rect == rect1, rect != rect1 (rectangle comparison)

    This is an example how the partial ordering on rectangles can be established (rect1  :math:`\subseteq`
    rect2):

    .. code-block:: c++

            template<typename _Tp> inline bool
            operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)
            {
                return (r1 & r2) == r1;
            }
    For your convenience, the Rect_<> alias is available: aqcv::Rect
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqRect_swiginit(self, _pyaqcv.new_AqRect(*args))

    def tl(self):
        r"""the top-left corner"""
        return _pyaqcv.AqRect_tl(self)

    def br(self):
        r"""the bottom-right corner"""
        return _pyaqcv.AqRect_br(self)

    def size(self):
        r"""size (width, height) of the rectangle"""
        return _pyaqcv.AqRect_size(self)

    def area(self):
        r"""area (width*height) of the rectangle"""
        return _pyaqcv.AqRect_area(self)

    def empty(self):
        r"""true if empty"""
        return _pyaqcv.AqRect_empty(self)

    def contains(self, pt):
        r"""checks whether the rectangle contains the point"""
        return _pyaqcv.AqRect_contains(self, pt)
    x = property(_pyaqcv.AqRect_x_get, _pyaqcv.AqRect_x_set, doc=r"""x coordinate of the top-left corner""")
    y = property(_pyaqcv.AqRect_y_get, _pyaqcv.AqRect_y_set, doc=r"""y coordinate of the top-left corner""")
    width = property(_pyaqcv.AqRect_width_get, _pyaqcv.AqRect_width_set, doc=r"""width of the rectangle""")
    height = property(_pyaqcv.AqRect_height_get, _pyaqcv.AqRect_height_set, doc=r"""height of the rectangle""")
    __swig_destroy__ = _pyaqcv.delete_AqRect

# Register AqRect in _pyaqcv:
_pyaqcv.AqRect_swigregister(AqRect)
class AqRect2f(object):
    r"""
     Template class for 2D rectangles

    described by the following parameters:
    -   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y
        in aqcv. Though, in your algorithms you may count x and y from the bottom-left corner.
    -   Rectangle width and height.

    aqcv typically assumes that the top and left boundary of the rectangle are inclusive, while the
    right and bottom boundaries are not. For example, the method Rect_::contains returns true if

     .. math::

         x  \leq pt.x < x+width, y  \leq pt.y < y+height

    Virtually every loop over an image ROI in aqcv (where ROI is specified by Rect_<int> ) is
    implemented as:

    .. code-block:: c++

            for(int y = roi.y; y < roi.y + roi.height; y++)
                for(int x = roi.x; x < roi.x + roi.width; x++)
                {
        ...
                }
    In addition to the class members, the following operations on rectangles are implemented:
    -    :math:`\texttt{rect} = \texttt{rect} \pm \texttt{point}`  (shifting a rectangle by a certain offset)
    -    :math:`\texttt{rect} = \texttt{rect} \pm \texttt{size}`  (expanding or shrinking a rectangle by a
        certain amount)
    -   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)
    -   rect = rect1 & rect2 (rectangle intersection)
    -   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )
    -   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)
    -   rect == rect1, rect != rect1 (rectangle comparison)

    This is an example how the partial ordering on rectangles can be established (rect1  :math:`\subseteq`
    rect2):

    .. code-block:: c++

            template<typename _Tp> inline bool
            operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)
            {
                return (r1 & r2) == r1;
            }
    For your convenience, the Rect_<> alias is available: aqcv::Rect
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqRect2f_swiginit(self, _pyaqcv.new_AqRect2f(*args))

    def tl(self):
        r"""the top-left corner"""
        return _pyaqcv.AqRect2f_tl(self)

    def br(self):
        r"""the bottom-right corner"""
        return _pyaqcv.AqRect2f_br(self)

    def size(self):
        r"""size (width, height) of the rectangle"""
        return _pyaqcv.AqRect2f_size(self)

    def area(self):
        r"""area (width*height) of the rectangle"""
        return _pyaqcv.AqRect2f_area(self)

    def empty(self):
        r"""true if empty"""
        return _pyaqcv.AqRect2f_empty(self)

    def contains(self, pt):
        r"""checks whether the rectangle contains the point"""
        return _pyaqcv.AqRect2f_contains(self, pt)
    x = property(_pyaqcv.AqRect2f_x_get, _pyaqcv.AqRect2f_x_set, doc=r"""x coordinate of the top-left corner""")
    y = property(_pyaqcv.AqRect2f_y_get, _pyaqcv.AqRect2f_y_set, doc=r"""y coordinate of the top-left corner""")
    width = property(_pyaqcv.AqRect2f_width_get, _pyaqcv.AqRect2f_width_set, doc=r"""width of the rectangle""")
    height = property(_pyaqcv.AqRect2f_height_get, _pyaqcv.AqRect2f_height_set, doc=r"""height of the rectangle""")
    __swig_destroy__ = _pyaqcv.delete_AqRect2f

# Register AqRect2f in _pyaqcv:
_pyaqcv.AqRect2f_swigregister(AqRect2f)
class AqRect2d(object):
    r"""
     Template class for 2D rectangles

    described by the following parameters:
    -   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y
        in aqcv. Though, in your algorithms you may count x and y from the bottom-left corner.
    -   Rectangle width and height.

    aqcv typically assumes that the top and left boundary of the rectangle are inclusive, while the
    right and bottom boundaries are not. For example, the method Rect_::contains returns true if

     .. math::

         x  \leq pt.x < x+width, y  \leq pt.y < y+height

    Virtually every loop over an image ROI in aqcv (where ROI is specified by Rect_<int> ) is
    implemented as:

    .. code-block:: c++

            for(int y = roi.y; y < roi.y + roi.height; y++)
                for(int x = roi.x; x < roi.x + roi.width; x++)
                {
        ...
                }
    In addition to the class members, the following operations on rectangles are implemented:
    -    :math:`\texttt{rect} = \texttt{rect} \pm \texttt{point}`  (shifting a rectangle by a certain offset)
    -    :math:`\texttt{rect} = \texttt{rect} \pm \texttt{size}`  (expanding or shrinking a rectangle by a
        certain amount)
    -   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)
    -   rect = rect1 & rect2 (rectangle intersection)
    -   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )
    -   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)
    -   rect == rect1, rect != rect1 (rectangle comparison)

    This is an example how the partial ordering on rectangles can be established (rect1  :math:`\subseteq`
    rect2):

    .. code-block:: c++

            template<typename _Tp> inline bool
            operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)
            {
                return (r1 & r2) == r1;
            }
    For your convenience, the Rect_<> alias is available: aqcv::Rect
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqRect2d_swiginit(self, _pyaqcv.new_AqRect2d(*args))

    def tl(self):
        r"""the top-left corner"""
        return _pyaqcv.AqRect2d_tl(self)

    def br(self):
        r"""the bottom-right corner"""
        return _pyaqcv.AqRect2d_br(self)

    def size(self):
        r"""size (width, height) of the rectangle"""
        return _pyaqcv.AqRect2d_size(self)

    def area(self):
        r"""area (width*height) of the rectangle"""
        return _pyaqcv.AqRect2d_area(self)

    def empty(self):
        r"""true if empty"""
        return _pyaqcv.AqRect2d_empty(self)

    def contains(self, pt):
        r"""checks whether the rectangle contains the point"""
        return _pyaqcv.AqRect2d_contains(self, pt)
    x = property(_pyaqcv.AqRect2d_x_get, _pyaqcv.AqRect2d_x_set, doc=r"""x coordinate of the top-left corner""")
    y = property(_pyaqcv.AqRect2d_y_get, _pyaqcv.AqRect2d_y_set, doc=r"""y coordinate of the top-left corner""")
    width = property(_pyaqcv.AqRect2d_width_get, _pyaqcv.AqRect2d_width_set, doc=r"""width of the rectangle""")
    height = property(_pyaqcv.AqRect2d_height_get, _pyaqcv.AqRect2d_height_set, doc=r"""height of the rectangle""")
    __swig_destroy__ = _pyaqcv.delete_AqRect2d

# Register AqRect2d in _pyaqcv:
_pyaqcv.AqRect2d_swigregister(AqRect2d)
class AqPoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqPoint_swiginit(self, _pyaqcv.new_AqPoint(*args))

    def dot(self, pt):
        r"""dot product"""
        return _pyaqcv.AqPoint_dot(self, pt)

    def ddot(self, pt):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqPoint_ddot(self, pt)

    def cross(self, pt):
        r"""cross-product"""
        return _pyaqcv.AqPoint_cross(self, pt)

    def inside(self, r):
        r"""checks whether the point is inside the specified rectangle"""
        return _pyaqcv.AqPoint_inside(self, r)
    x = property(_pyaqcv.AqPoint_x_get, _pyaqcv.AqPoint_x_set, doc=r"""x coordinate of the point""")
    y = property(_pyaqcv.AqPoint_y_get, _pyaqcv.AqPoint_y_set, doc=r"""y coordinate of the point""")
    __swig_destroy__ = _pyaqcv.delete_AqPoint

# Register AqPoint in _pyaqcv:
_pyaqcv.AqPoint_swigregister(AqPoint)
class AqPoint2f(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqPoint2f_swiginit(self, _pyaqcv.new_AqPoint2f(*args))

    def dot(self, pt):
        r"""dot product"""
        return _pyaqcv.AqPoint2f_dot(self, pt)

    def ddot(self, pt):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqPoint2f_ddot(self, pt)

    def cross(self, pt):
        r"""cross-product"""
        return _pyaqcv.AqPoint2f_cross(self, pt)

    def inside(self, r):
        r"""checks whether the point is inside the specified rectangle"""
        return _pyaqcv.AqPoint2f_inside(self, r)
    x = property(_pyaqcv.AqPoint2f_x_get, _pyaqcv.AqPoint2f_x_set, doc=r"""x coordinate of the point""")
    y = property(_pyaqcv.AqPoint2f_y_get, _pyaqcv.AqPoint2f_y_set, doc=r"""y coordinate of the point""")
    __swig_destroy__ = _pyaqcv.delete_AqPoint2f

# Register AqPoint2f in _pyaqcv:
_pyaqcv.AqPoint2f_swigregister(AqPoint2f)
class AqPoint2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqPoint2d_swiginit(self, _pyaqcv.new_AqPoint2d(*args))

    def dot(self, pt):
        r"""dot product"""
        return _pyaqcv.AqPoint2d_dot(self, pt)

    def ddot(self, pt):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqPoint2d_ddot(self, pt)

    def cross(self, pt):
        r"""cross-product"""
        return _pyaqcv.AqPoint2d_cross(self, pt)

    def inside(self, r):
        r"""checks whether the point is inside the specified rectangle"""
        return _pyaqcv.AqPoint2d_inside(self, r)
    x = property(_pyaqcv.AqPoint2d_x_get, _pyaqcv.AqPoint2d_x_set, doc=r"""x coordinate of the point""")
    y = property(_pyaqcv.AqPoint2d_y_get, _pyaqcv.AqPoint2d_y_set, doc=r"""y coordinate of the point""")
    __swig_destroy__ = _pyaqcv.delete_AqPoint2d

# Register AqPoint2d in _pyaqcv:
_pyaqcv.AqPoint2d_swigregister(AqPoint2d)
class AqPoint3(object):
    r"""Template class for 3D points specified by its coordinates `x`, `y` and `z`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqPoint3_swiginit(self, _pyaqcv.new_AqPoint3(*args))

    def dot(self, pt):
        r"""dot product"""
        return _pyaqcv.AqPoint3_dot(self, pt)

    def ddot(self, pt):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqPoint3_ddot(self, pt)

    def cross(self, pt):
        r"""cross product of the 2 3D points"""
        return _pyaqcv.AqPoint3_cross(self, pt)
    x = property(_pyaqcv.AqPoint3_x_get, _pyaqcv.AqPoint3_x_set, doc=r"""x coordinate of the 3D point""")
    y = property(_pyaqcv.AqPoint3_y_get, _pyaqcv.AqPoint3_y_set, doc=r"""y coordinate of the 3D point""")
    z = property(_pyaqcv.AqPoint3_z_get, _pyaqcv.AqPoint3_z_set, doc=r"""z coordinate of the 3D point""")
    __swig_destroy__ = _pyaqcv.delete_AqPoint3

# Register AqPoint3 in _pyaqcv:
_pyaqcv.AqPoint3_swigregister(AqPoint3)
class AqPoint3f(object):
    r"""Template class for 3D points specified by its coordinates `x`, `y` and `z`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqPoint3f_swiginit(self, _pyaqcv.new_AqPoint3f(*args))

    def dot(self, pt):
        r"""dot product"""
        return _pyaqcv.AqPoint3f_dot(self, pt)

    def ddot(self, pt):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqPoint3f_ddot(self, pt)

    def cross(self, pt):
        r"""cross product of the 2 3D points"""
        return _pyaqcv.AqPoint3f_cross(self, pt)
    x = property(_pyaqcv.AqPoint3f_x_get, _pyaqcv.AqPoint3f_x_set, doc=r"""x coordinate of the 3D point""")
    y = property(_pyaqcv.AqPoint3f_y_get, _pyaqcv.AqPoint3f_y_set, doc=r"""y coordinate of the 3D point""")
    z = property(_pyaqcv.AqPoint3f_z_get, _pyaqcv.AqPoint3f_z_set, doc=r"""z coordinate of the 3D point""")
    __swig_destroy__ = _pyaqcv.delete_AqPoint3f

# Register AqPoint3f in _pyaqcv:
_pyaqcv.AqPoint3f_swigregister(AqPoint3f)
class AqPoint3d(object):
    r"""Template class for 3D points specified by its coordinates `x`, `y` and `z`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqPoint3d_swiginit(self, _pyaqcv.new_AqPoint3d(*args))

    def dot(self, pt):
        r"""dot product"""
        return _pyaqcv.AqPoint3d_dot(self, pt)

    def ddot(self, pt):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqPoint3d_ddot(self, pt)

    def cross(self, pt):
        r"""cross product of the 2 3D points"""
        return _pyaqcv.AqPoint3d_cross(self, pt)
    x = property(_pyaqcv.AqPoint3d_x_get, _pyaqcv.AqPoint3d_x_set, doc=r"""x coordinate of the 3D point""")
    y = property(_pyaqcv.AqPoint3d_y_get, _pyaqcv.AqPoint3d_y_set, doc=r"""y coordinate of the 3D point""")
    z = property(_pyaqcv.AqPoint3d_z_get, _pyaqcv.AqPoint3d_z_set, doc=r"""z coordinate of the 3D point""")
    __swig_destroy__ = _pyaqcv.delete_AqPoint3d

# Register AqPoint3d in _pyaqcv:
_pyaqcv.AqPoint3d_swigregister(AqPoint3d)
class AqMatx11d(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx11d_rows
    cols = _pyaqcv.AqMatx11d_cols
    channels = _pyaqcv.AqMatx11d_channels
    shortdim = _pyaqcv.AqMatx11d_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx11d_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx11d_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx11d_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx11d_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx11d_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx11d_randn(a, b)

    def dot(self, v):
        r"""dot product computed with the default precision"""
        return _pyaqcv.AqMatx11d_dot(self, v)

    def ddot(self, v):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqMatx11d_ddot(self, v)

    def row(self, i):
        r"""extract the matrix row"""
        return _pyaqcv.AqMatx11d_row(self, i)

    def col(self, i):
        r"""extract the matrix column"""
        return _pyaqcv.AqMatx11d_col(self, i)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx11d_diag(self, *args)

    def t(self):
        r"""transpose the matrix"""
        return _pyaqcv.AqMatx11d_t(self)

    def inv(self, *args):
        r"""invert the matrix"""
        return _pyaqcv.AqMatx11d_inv(self, *args)

    def solve(self, rhs, method):
        return _pyaqcv.AqMatx11d_solve(self, rhs, method)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx11d_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx11d_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx11d___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx11d_swiginit(self, _pyaqcv.new_AqMatx11d(*args))
    val = property(_pyaqcv.AqMatx11d_val_get, _pyaqcv.AqMatx11d_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx11d

# Register AqMatx11d in _pyaqcv:
_pyaqcv.AqMatx11d_swigregister(AqMatx11d)
class AqMatx21d(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx21d_rows
    cols = _pyaqcv.AqMatx21d_cols
    channels = _pyaqcv.AqMatx21d_channels
    shortdim = _pyaqcv.AqMatx21d_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx21d_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx21d_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx21d_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx21d_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx21d_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx21d_randn(a, b)

    def dot(self, v):
        r"""dot product computed with the default precision"""
        return _pyaqcv.AqMatx21d_dot(self, v)

    def ddot(self, v):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqMatx21d_ddot(self, v)

    def row(self, i):
        r"""extract the matrix row"""
        return _pyaqcv.AqMatx21d_row(self, i)

    def col(self, i):
        r"""extract the matrix column"""
        return _pyaqcv.AqMatx21d_col(self, i)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx21d_diag(self, *args)

    def t(self):
        r"""transpose the matrix"""
        return _pyaqcv.AqMatx21d_t(self)

    def inv(self, *args):
        r"""invert the matrix"""
        return _pyaqcv.AqMatx21d_inv(self, *args)

    def solve(self, rhs, method):
        return _pyaqcv.AqMatx21d_solve(self, rhs, method)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx21d_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx21d_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx21d___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx21d_swiginit(self, _pyaqcv.new_AqMatx21d(*args))
    val = property(_pyaqcv.AqMatx21d_val_get, _pyaqcv.AqMatx21d_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx21d

# Register AqMatx21d in _pyaqcv:
_pyaqcv.AqMatx21d_swigregister(AqMatx21d)
class AqMatx31d(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx31d_rows
    cols = _pyaqcv.AqMatx31d_cols
    channels = _pyaqcv.AqMatx31d_channels
    shortdim = _pyaqcv.AqMatx31d_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx31d_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx31d_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx31d_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx31d_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx31d_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx31d_randn(a, b)

    def dot(self, v):
        r"""dot product computed with the default precision"""
        return _pyaqcv.AqMatx31d_dot(self, v)

    def ddot(self, v):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqMatx31d_ddot(self, v)

    def row(self, i):
        r"""extract the matrix row"""
        return _pyaqcv.AqMatx31d_row(self, i)

    def col(self, i):
        r"""extract the matrix column"""
        return _pyaqcv.AqMatx31d_col(self, i)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx31d_diag(self, *args)

    def t(self):
        r"""transpose the matrix"""
        return _pyaqcv.AqMatx31d_t(self)

    def inv(self, *args):
        r"""invert the matrix"""
        return _pyaqcv.AqMatx31d_inv(self, *args)

    def solve(self, rhs, method):
        return _pyaqcv.AqMatx31d_solve(self, rhs, method)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx31d_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx31d_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx31d___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx31d_swiginit(self, _pyaqcv.new_AqMatx31d(*args))
    val = property(_pyaqcv.AqMatx31d_val_get, _pyaqcv.AqMatx31d_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx31d

# Register AqMatx31d in _pyaqcv:
_pyaqcv.AqMatx31d_swigregister(AqMatx31d)
class AqMatx41d(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx41d_rows
    cols = _pyaqcv.AqMatx41d_cols
    channels = _pyaqcv.AqMatx41d_channels
    shortdim = _pyaqcv.AqMatx41d_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx41d_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx41d_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx41d_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx41d_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx41d_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx41d_randn(a, b)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx41d_diag(self, *args)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx41d_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx41d_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx41d___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx41d_swiginit(self, _pyaqcv.new_AqMatx41d(*args))
    val = property(_pyaqcv.AqMatx41d_val_get, _pyaqcv.AqMatx41d_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx41d

# Register AqMatx41d in _pyaqcv:
_pyaqcv.AqMatx41d_swigregister(AqMatx41d)
class AqMatx11f(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx11f_rows
    cols = _pyaqcv.AqMatx11f_cols
    channels = _pyaqcv.AqMatx11f_channels
    shortdim = _pyaqcv.AqMatx11f_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx11f_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx11f_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx11f_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx11f_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx11f_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx11f_randn(a, b)

    def dot(self, v):
        r"""dot product computed with the default precision"""
        return _pyaqcv.AqMatx11f_dot(self, v)

    def ddot(self, v):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqMatx11f_ddot(self, v)

    def row(self, i):
        r"""extract the matrix row"""
        return _pyaqcv.AqMatx11f_row(self, i)

    def col(self, i):
        r"""extract the matrix column"""
        return _pyaqcv.AqMatx11f_col(self, i)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx11f_diag(self, *args)

    def t(self):
        r"""transpose the matrix"""
        return _pyaqcv.AqMatx11f_t(self)

    def inv(self, *args):
        r"""invert the matrix"""
        return _pyaqcv.AqMatx11f_inv(self, *args)

    def solve(self, rhs, method):
        return _pyaqcv.AqMatx11f_solve(self, rhs, method)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx11f_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx11f_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx11f___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx11f_swiginit(self, _pyaqcv.new_AqMatx11f(*args))
    val = property(_pyaqcv.AqMatx11f_val_get, _pyaqcv.AqMatx11f_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx11f

# Register AqMatx11f in _pyaqcv:
_pyaqcv.AqMatx11f_swigregister(AqMatx11f)
class AqMatx21f(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx21f_rows
    cols = _pyaqcv.AqMatx21f_cols
    channels = _pyaqcv.AqMatx21f_channels
    shortdim = _pyaqcv.AqMatx21f_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx21f_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx21f_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx21f_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx21f_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx21f_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx21f_randn(a, b)

    def dot(self, v):
        r"""dot product computed with the default precision"""
        return _pyaqcv.AqMatx21f_dot(self, v)

    def ddot(self, v):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqMatx21f_ddot(self, v)

    def row(self, i):
        r"""extract the matrix row"""
        return _pyaqcv.AqMatx21f_row(self, i)

    def col(self, i):
        r"""extract the matrix column"""
        return _pyaqcv.AqMatx21f_col(self, i)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx21f_diag(self, *args)

    def t(self):
        r"""transpose the matrix"""
        return _pyaqcv.AqMatx21f_t(self)

    def inv(self, *args):
        r"""invert the matrix"""
        return _pyaqcv.AqMatx21f_inv(self, *args)

    def solve(self, rhs, method):
        return _pyaqcv.AqMatx21f_solve(self, rhs, method)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx21f_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx21f_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx21f___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx21f_swiginit(self, _pyaqcv.new_AqMatx21f(*args))
    val = property(_pyaqcv.AqMatx21f_val_get, _pyaqcv.AqMatx21f_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx21f

# Register AqMatx21f in _pyaqcv:
_pyaqcv.AqMatx21f_swigregister(AqMatx21f)
class AqMatx31f(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx31f_rows
    cols = _pyaqcv.AqMatx31f_cols
    channels = _pyaqcv.AqMatx31f_channels
    shortdim = _pyaqcv.AqMatx31f_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx31f_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx31f_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx31f_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx31f_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx31f_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx31f_randn(a, b)

    def dot(self, v):
        r"""dot product computed with the default precision"""
        return _pyaqcv.AqMatx31f_dot(self, v)

    def ddot(self, v):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqMatx31f_ddot(self, v)

    def row(self, i):
        r"""extract the matrix row"""
        return _pyaqcv.AqMatx31f_row(self, i)

    def col(self, i):
        r"""extract the matrix column"""
        return _pyaqcv.AqMatx31f_col(self, i)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx31f_diag(self, *args)

    def t(self):
        r"""transpose the matrix"""
        return _pyaqcv.AqMatx31f_t(self)

    def inv(self, *args):
        r"""invert the matrix"""
        return _pyaqcv.AqMatx31f_inv(self, *args)

    def solve(self, rhs, method):
        return _pyaqcv.AqMatx31f_solve(self, rhs, method)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx31f_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx31f_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx31f___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx31f_swiginit(self, _pyaqcv.new_AqMatx31f(*args))
    val = property(_pyaqcv.AqMatx31f_val_get, _pyaqcv.AqMatx31f_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx31f

# Register AqMatx31f in _pyaqcv:
_pyaqcv.AqMatx31f_swigregister(AqMatx31f)
class AqMatx41f(object):
    r"""
     Template class for small matrices whose type and size are known at compilation time

    If you need a more flexible type, use Mat . The elements of the matrix M are accessible using the
    M(i,j) notation. Most of the common matrix operations (see also 'MatrixExpressions' ) are
    available. To do an operation on Matx that is not implemented, you can easily convert the matrix to
    Mat and backwards:

    .. code-block:: c++

            Matx33f m(1, 2, 3,
                      4, 5, 6,
                      7, 8, 9);
            cout << sum(Mat(m*m.t())) << endl;
    Except of the plain constructor which takes a list of elements, Matx can be initialized from a C-array:

    .. code-block:: c++

            float values[] = { 1, 2, 3};
            Matx31f m(values);
    In case if C++11 features are available, std::initializer_list can be also used to initialize Matx:

    .. code-block:: c++

            Matx31f m = { 1, 2, 3};
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _pyaqcv.AqMatx41f_rows
    cols = _pyaqcv.AqMatx41f_cols
    channels = _pyaqcv.AqMatx41f_channels
    shortdim = _pyaqcv.AqMatx41f_shortdim

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqMatx41f_all(alpha)

    @staticmethod
    def zeros():
        return _pyaqcv.AqMatx41f_zeros()

    @staticmethod
    def ones():
        return _pyaqcv.AqMatx41f_ones()

    @staticmethod
    def eye():
        return _pyaqcv.AqMatx41f_eye()

    @staticmethod
    def randu(a, b):
        r"""
        Generates uniformly distributed random numbers
           :type a: float
           :param a: Range boundary.
           :type b: float
           :param b: The other range boundary (boundaries don't have to be ordered, the lower boundary is inclusive,
               the upper one is exclusive).
        """
        return _pyaqcv.AqMatx41f_randu(a, b)

    @staticmethod
    def randn(a, b):
        r"""
        Generates normally distributed random numbers
           :type a: float
           :param a: Mean value.
           :type b: float
           :param b: Standard deviation.
        """
        return _pyaqcv.AqMatx41f_randn(a, b)

    def dot(self, v):
        r"""dot product computed with the default precision"""
        return _pyaqcv.AqMatx41f_dot(self, v)

    def ddot(self, v):
        r"""dot product computed in double-precision arithmetics"""
        return _pyaqcv.AqMatx41f_ddot(self, v)

    def row(self, i):
        r"""extract the matrix row"""
        return _pyaqcv.AqMatx41f_row(self, i)

    def col(self, i):
        r"""extract the matrix column"""
        return _pyaqcv.AqMatx41f_col(self, i)

    def diag(self, *args):
        r"""extract the matrix diagonal"""
        return _pyaqcv.AqMatx41f_diag(self, *args)

    def t(self):
        r"""transpose the matrix"""
        return _pyaqcv.AqMatx41f_t(self)

    def inv(self, *args):
        r"""invert the matrix"""
        return _pyaqcv.AqMatx41f_inv(self, *args)

    def solve(self, rhs, method):
        return _pyaqcv.AqMatx41f_solve(self, rhs, method)

    def mul(self, a):
        r"""multiply two matrices element-wise"""
        return _pyaqcv.AqMatx41f_mul(self, a)

    def div(self, a):
        r"""divide two matrices element-wise"""
        return _pyaqcv.AqMatx41f_div(self, a)

    def __call__(self, *args):
        r"""
        *Overload 1:*
        element access

        |

        *Overload 2:*
        1D element access
        """
        return _pyaqcv.AqMatx41f___call__(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1x1 matrix

        |

        *Overload 3:*
        1x2 or 2x1 matrix

        |

        *Overload 4:*
        1x3 or 3x1 matrix

        |

        *Overload 5:*
        1x4, 2x2 or 4x1 matrix

        |

        *Overload 6:*
        1x5 or 5x1 matrix

        |

        *Overload 7:*
        1x6, 2x3, 3x2 or 6x1 matrix

        |

        *Overload 8:*
        1x7 or 7x1 matrix

        |

        *Overload 9:*
        1x8, 2x4, 4x2 or 8x1 matrix

        |

        *Overload 10:*
        1x9, 3x3 or 9x1 matrix

        |

        *Overload 11:*
        1x10, 2x5 or 5x2 or 10x1 matrix

        |

        *Overload 12:*
        1x12, 2x6, 3x4, 4x3, 6x2 or 12x1 matrix

        |

        *Overload 13:*
        1x14, 2x7, 7x2 or 14x1 matrix

        |

        *Overload 14:*
        1x16, 4x4 or 16x1 matrix

        |

        *Overload 15:*
        initialize from a plain array

        |

        *Overload 16:*
        initialize from an initializer list
        """
        _pyaqcv.AqMatx41f_swiginit(self, _pyaqcv.new_AqMatx41f(*args))
    val = property(_pyaqcv.AqMatx41f_val_get, _pyaqcv.AqMatx41f_val_set)
    __swig_destroy__ = _pyaqcv.delete_AqMatx41f

# Register AqMatx41f in _pyaqcv:
_pyaqcv.AqMatx41f_swigregister(AqMatx41f)
class AqVec1b(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec1b_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec1b__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec1b_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec1b_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec1b_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec1b_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec1b___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec1b___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec1b___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec1b_swiginit(self, _pyaqcv.new_AqVec1b(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec1b

# Register AqVec1b in _pyaqcv:
_pyaqcv.AqVec1b_swigregister(AqVec1b)
class AqVec2b(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec2b_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec2b__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec2b_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec2b_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec2b_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec2b_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec2b___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec2b___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec2b___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec2b_swiginit(self, _pyaqcv.new_AqVec2b(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec2b

# Register AqVec2b in _pyaqcv:
_pyaqcv.AqVec2b_swigregister(AqVec2b)
class AqVec3b(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec3b_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec3b__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec3b_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec3b_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec3b_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec3b_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec3b___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec3b___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec3b___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec3b_swiginit(self, _pyaqcv.new_AqVec3b(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec3b

# Register AqVec3b in _pyaqcv:
_pyaqcv.AqVec3b_swigregister(AqVec3b)
class AqVec4b(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec4b_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec4b__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec4b_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec4b_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec4b_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec4b_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec4b___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec4b___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec4b___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec4b_swiginit(self, _pyaqcv.new_AqVec4b(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec4b

# Register AqVec4b in _pyaqcv:
_pyaqcv.AqVec4b_swigregister(AqVec4b)
class AqVec1c(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec1c_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec1c__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec1c_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec1c_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec1c_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec1c_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec1c___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec1c___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec1c___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec1c_swiginit(self, _pyaqcv.new_AqVec1c(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec1c

# Register AqVec1c in _pyaqcv:
_pyaqcv.AqVec1c_swigregister(AqVec1c)
class AqVec2c(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec2c_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec2c__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec2c_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec2c_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec2c_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec2c_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec2c___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec2c___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec2c___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec2c_swiginit(self, _pyaqcv.new_AqVec2c(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec2c

# Register AqVec2c in _pyaqcv:
_pyaqcv.AqVec2c_swigregister(AqVec2c)
class AqVec3c(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec3c_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec3c__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec3c_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec3c_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec3c_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec3c_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec3c___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec3c___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec3c___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec3c_swiginit(self, _pyaqcv.new_AqVec3c(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec3c

# Register AqVec3c in _pyaqcv:
_pyaqcv.AqVec3c_swigregister(AqVec3c)
class AqVec4c(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec4c_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec4c__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec4c_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec4c_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec4c_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec4c_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec4c___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec4c___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec4c___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec4c_swiginit(self, _pyaqcv.new_AqVec4c(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec4c

# Register AqVec4c in _pyaqcv:
_pyaqcv.AqVec4c_swigregister(AqVec4c)
class AqVec1s(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec1s_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec1s__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec1s_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec1s_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec1s_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec1s_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec1s___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec1s___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec1s___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec1s_swiginit(self, _pyaqcv.new_AqVec1s(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec1s

# Register AqVec1s in _pyaqcv:
_pyaqcv.AqVec1s_swigregister(AqVec1s)
class AqVec2s(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec2s_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec2s__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec2s_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec2s_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec2s_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec2s_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec2s___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec2s___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec2s___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec2s_swiginit(self, _pyaqcv.new_AqVec2s(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec2s

# Register AqVec2s in _pyaqcv:
_pyaqcv.AqVec2s_swigregister(AqVec2s)
class AqVec3s(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec3s_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec3s__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec3s_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec3s_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec3s_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec3s_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec3s___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec3s___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec3s___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec3s_swiginit(self, _pyaqcv.new_AqVec3s(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec3s

# Register AqVec3s in _pyaqcv:
_pyaqcv.AqVec3s_swigregister(AqVec3s)
class AqVec4s(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec4s_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec4s__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec4s_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec4s_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec4s_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec4s_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec4s___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec4s___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec4s___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec4s_swiginit(self, _pyaqcv.new_AqVec4s(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec4s

# Register AqVec4s in _pyaqcv:
_pyaqcv.AqVec4s_swigregister(AqVec4s)
class AqVec1w(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec1w_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec1w__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec1w_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec1w_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec1w_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec1w_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec1w___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec1w___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec1w___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec1w_swiginit(self, _pyaqcv.new_AqVec1w(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec1w

# Register AqVec1w in _pyaqcv:
_pyaqcv.AqVec1w_swigregister(AqVec1w)
class AqVec2w(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec2w_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec2w__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec2w_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec2w_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec2w_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec2w_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec2w___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec2w___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec2w___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec2w_swiginit(self, _pyaqcv.new_AqVec2w(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec2w

# Register AqVec2w in _pyaqcv:
_pyaqcv.AqVec2w_swigregister(AqVec2w)
class AqVec3w(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec3w_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec3w__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec3w_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec3w_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec3w_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec3w_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec3w___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec3w___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec3w___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec3w_swiginit(self, _pyaqcv.new_AqVec3w(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec3w

# Register AqVec3w in _pyaqcv:
_pyaqcv.AqVec3w_swigregister(AqVec3w)
class AqVec4w(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec4w_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec4w__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec4w_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec4w_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec4w_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec4w_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec4w___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec4w___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec4w___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec4w_swiginit(self, _pyaqcv.new_AqVec4w(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec4w

# Register AqVec4w in _pyaqcv:
_pyaqcv.AqVec4w_swigregister(AqVec4w)
class AqVec1i(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec1i_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec1i__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec1i_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec1i_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec1i_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec1i_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec1i___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec1i___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec1i___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec1i_swiginit(self, _pyaqcv.new_AqVec1i(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec1i

# Register AqVec1i in _pyaqcv:
_pyaqcv.AqVec1i_swigregister(AqVec1i)
class AqVec2i(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec2i_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec2i__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec2i_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec2i_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec2i_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec2i_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec2i___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec2i___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec2i___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec2i_swiginit(self, _pyaqcv.new_AqVec2i(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec2i

# Register AqVec2i in _pyaqcv:
_pyaqcv.AqVec2i_swigregister(AqVec2i)
class AqVec3i(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec3i_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec3i__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec3i_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec3i_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec3i_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec3i_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec3i___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec3i___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec3i___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec3i_swiginit(self, _pyaqcv.new_AqVec3i(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec3i

# Register AqVec3i in _pyaqcv:
_pyaqcv.AqVec3i_swigregister(AqVec3i)
class AqVec4i(object):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec4i_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec4i__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec4i_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec4i_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec4i_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec4i_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec4i___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec4i___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec4i___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec4i_swiginit(self, _pyaqcv.new_AqVec4i(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec4i

# Register AqVec4i in _pyaqcv:
_pyaqcv.AqVec4i_swigregister(AqVec4i)
class AqVec1f(AqMatx11f):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec1f_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec1f__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec1f_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec1f_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec1f_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec1f_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec1f___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec1f___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec1f___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec1f_swiginit(self, _pyaqcv.new_AqVec1f(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec1f

# Register AqVec1f in _pyaqcv:
_pyaqcv.AqVec1f_swigregister(AqVec1f)
class AqVec2f(AqMatx21f):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec2f_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec2f__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec2f_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec2f_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec2f_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec2f_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec2f___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec2f___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec2f___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec2f_swiginit(self, _pyaqcv.new_AqVec2f(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec2f

# Register AqVec2f in _pyaqcv:
_pyaqcv.AqVec2f_swigregister(AqVec2f)
class AqVec3f(AqMatx31f):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec3f_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec3f__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec3f_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec3f_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec3f_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec3f_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec3f___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec3f___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec3f___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec3f_swiginit(self, _pyaqcv.new_AqVec3f(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec3f

# Register AqVec3f in _pyaqcv:
_pyaqcv.AqVec3f_swigregister(AqVec3f)
class AqVec4f(AqMatx41f):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec4f_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec4f__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec4f_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec4f_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec4f_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec4f_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec4f___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec4f___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec4f___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec4f_swiginit(self, _pyaqcv.new_AqVec4f(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec4f

# Register AqVec4f in _pyaqcv:
_pyaqcv.AqVec4f_swigregister(AqVec4f)
class AqVec1d(AqMatx11d):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec1d_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec1d__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec1d_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec1d_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec1d_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec1d_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec1d___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec1d___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec1d___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec1d_swiginit(self, _pyaqcv.new_AqVec1d(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec1d

# Register AqVec1d in _pyaqcv:
_pyaqcv.AqVec1d_swigregister(AqVec1d)
class AqVec2d(AqMatx21d):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec2d_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec2d__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec2d_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec2d_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec2d_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec2d_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec2d___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec2d___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec2d___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec2d_swiginit(self, _pyaqcv.new_AqVec2d(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec2d

# Register AqVec2d in _pyaqcv:
_pyaqcv.AqVec2d_swigregister(AqVec2d)
class AqVec3d(AqMatx31d):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec3d_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec3d__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec3d_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec3d_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec3d_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec3d_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec3d___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec3d___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec3d___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec3d_swiginit(self, _pyaqcv.new_AqVec3d(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec3d

# Register AqVec3d in _pyaqcv:
_pyaqcv.AqVec3d_swigregister(AqVec3d)
class AqVec4d(AqMatx41d):
    r"""
     Template class for short numerical vectors, a partial case of Matx

    This template class represents short numerical vectors (of 1, 2, 3, 4 ... elements) on which you
    can perform basic arithmetical operations, access individual elements using [] operator etc. The
    vectors are allocated on stack, as opposite to std::valarray, std::vector, aqcv::Mat etc., which
    elements are dynamically allocated in the heap.

    The template takes 2 parameters:
    :param _Tp: element type
    :param cn: the number of elements

    In addition to the universal notation like Vec<float, 3>, you can use shorter aliases
    for the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.

    All the expected vector operations are also implemented:
    -   v1 = v2 + v3
    -   v1 = v2 - v3
    -   v1 = v2 * scale
    -   v1 = scale * v2
    -   v1 = -v2
    -   v1 += v2 and other augmenting operations
    -   v1 == v2, v1 != v2
    -   norm(v1) (euclidean norm)
    The Vec class is commonly used to describe pixel types of multi-channel arrays. See Mat for details.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _pyaqcv.AqVec4d_channels
    _dummy_enum_finalizer = _pyaqcv.AqVec4d__dummy_enum_finalizer

    @staticmethod
    def all(alpha):
        return _pyaqcv.AqVec4d_all(alpha)

    def mul(self, v):
        r"""per-element multiplication"""
        return _pyaqcv.AqVec4d_mul(self, v)

    def conj(self):
        r"""conjugation (makes sense for complex numbers and quaternions,nonsense for uchar and ushort)"""
        return _pyaqcv.AqVec4d_conj(self)

    def cross(self, v):
        r"""
        cross product of the two 3D vectors.

        For other dimensionalities the exception is raised
        """
        return _pyaqcv.AqVec4d_cross(self, v)

    def __call__(self, *args):
        return _pyaqcv.AqVec4d___call__(self, *args)

    def __getitem__(self, i):
        return _pyaqcv.AqVec4d___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqVec4d___setitem__(self, i, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        default constructor

        |

        *Overload 2:*
        1-element vector constructor

        |

        *Overload 3:*
        2-element vector constructor

        |

        *Overload 4:*
        3-element vector constructor

        |

        *Overload 5:*
        4-element vector constructor

        |

        *Overload 6:*
        5-element vector constructor

        |

        *Overload 7:*
        6-element vector constructor

        |

        *Overload 8:*
        7-element vector constructor

        |

        *Overload 9:*
        8-element vector constructor

        |

        *Overload 10:*
        9-element vector constructor

        |

        *Overload 11:*
        10-element vector constructor

        |

        *Overload 12:*
        14-element vector constructor
        """
        _pyaqcv.AqVec4d_swiginit(self, _pyaqcv.new_AqVec4d(*args))
    __swig_destroy__ = _pyaqcv.delete_AqVec4d

# Register AqVec4d in _pyaqcv:
_pyaqcv.AqVec4d_swigregister(AqVec4d)
class AqScalar(AqVec4d):
    r"""
     Template class for a 4-element vector derived from Vec.

    Being derived from Vec<_Tp, 4> , Scalar_ and Scalar can be used just as typical 4-element
    vectors. In addition, they can be converted to/from Scalar . The type Scalar is widely used in
    aqcv to pass pixel values.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""default constructor"""
        _pyaqcv.AqScalar_swiginit(self, _pyaqcv.new_AqScalar(*args))

    def __getitem__(self, i):
        return _pyaqcv.AqScalar___getitem__(self, i)

    def __setitem__(self, i, val):
        return _pyaqcv.AqScalar___setitem__(self, i, val)

    @staticmethod
    def all(v0):
        r"""returns a scalar with all elements set to v0"""
        return _pyaqcv.AqScalar_all(v0)

    def mul(self, a, scale=1):
        r"""per-element product"""
        return _pyaqcv.AqScalar_mul(self, a, scale)

    def conj(self):
        r"""returns (v0, -v1, -v2, -v3)"""
        return _pyaqcv.AqScalar_conj(self)

    def is_real(self):
        r"""returns true if v1 == v2 == v3 == 0"""
        return _pyaqcv.AqScalar_is_real(self)
    __swig_destroy__ = _pyaqcv.delete_AqScalar

# Register AqScalar in _pyaqcv:
_pyaqcv.AqScalar_swigregister(AqScalar)
class RansacFitLine(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RansacFitLine_swiginit(self, _pyaqcv.new_RansacFitLine())
    __swig_destroy__ = _pyaqcv.delete_RansacFitLine

    def set_inner_thresh(self, inner_thresh):
        r"""
        Set inner_thresh.
        :type inner_thresh: float
        :param inner_thresh: inner points distance to model threshold, value >= 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitLine_set_inner_thresh(self, inner_thresh)

    def get_inner_thresh(self):
        r"""
        Get inner_thresh.
        :rtype: float
        :return: inner_thresh.
        """
        return _pyaqcv.RansacFitLine_get_inner_thresh(self)

    def set_iter_num(self, iter_num):
        r"""
        Set number of iterations.
        :type iter_num: int
        :param iter_num:  number of iterations,value > 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitLine_set_iter_num(self, iter_num)

    def get_iter_num(self):
        r"""
        Get number of iterations.
        :rtype: int
        :return: number of iterations
        """
        return _pyaqcv.RansacFitLine_get_iter_num(self)

    def execute(self, data):
        r"""
        Execute ransac fitting.
        :type data: :py:class:`Mat`
        :param data:  the channel is one. the depth is AQ_64F. the cols indicate dimension of sample. the rows indicate numbers of samples.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitLine_execute(self, data)

    def set_fit_model(self, model):
        r"""
        Set fit model.
        :type model: :py:class:`LineFitModel`
        :param model:  must derived from 'FitModelBase'
        """
        return _pyaqcv.RansacFitLine_set_fit_model(self, model)

    def get_fitted_model(self):
        r"""
        Get fitted model.
        :rtype: :py:class:`LineFitModel`
        :return: please see set_fit_model() model param.
        """
        return _pyaqcv.RansacFitLine_get_fitted_model(self)

# Register RansacFitLine in _pyaqcv:
_pyaqcv.RansacFitLine_swigregister(RansacFitLine)
class RansacFitCircle(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RansacFitCircle_swiginit(self, _pyaqcv.new_RansacFitCircle())
    __swig_destroy__ = _pyaqcv.delete_RansacFitCircle

    def set_inner_thresh(self, inner_thresh):
        r"""
        Set inner_thresh.
        :type inner_thresh: float
        :param inner_thresh: inner points distance to model threshold, value >= 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitCircle_set_inner_thresh(self, inner_thresh)

    def get_inner_thresh(self):
        r"""
        Get inner_thresh.
        :rtype: float
        :return: inner_thresh.
        """
        return _pyaqcv.RansacFitCircle_get_inner_thresh(self)

    def set_iter_num(self, iter_num):
        r"""
        Set number of iterations.
        :type iter_num: int
        :param iter_num:  number of iterations,value > 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitCircle_set_iter_num(self, iter_num)

    def get_iter_num(self):
        r"""
        Get number of iterations.
        :rtype: int
        :return: number of iterations
        """
        return _pyaqcv.RansacFitCircle_get_iter_num(self)

    def execute(self, data):
        r"""
        Execute ransac fitting.
        :type data: :py:class:`Mat`
        :param data:  the channel is one. the depth is AQ_64F. the cols indicate dimension of sample. the rows indicate numbers of samples.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitCircle_execute(self, data)

    def set_fit_model(self, model):
        r"""
        Set fit model.
        :type model: :py:class:`CircleFitModel`
        :param model:  must derived from 'FitModelBase'
        """
        return _pyaqcv.RansacFitCircle_set_fit_model(self, model)

    def get_fitted_model(self):
        r"""
        Get fitted model.
        :rtype: :py:class:`CircleFitModel`
        :return: please see set_fit_model() model param.
        """
        return _pyaqcv.RansacFitCircle_get_fitted_model(self)

# Register RansacFitCircle in _pyaqcv:
_pyaqcv.RansacFitCircle_swigregister(RansacFitCircle)
class RansacFitEllipse(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RansacFitEllipse_swiginit(self, _pyaqcv.new_RansacFitEllipse())
    __swig_destroy__ = _pyaqcv.delete_RansacFitEllipse

    def set_inner_thresh(self, inner_thresh):
        r"""
        Set inner_thresh.
        :type inner_thresh: float
        :param inner_thresh: inner points distance to model threshold, value >= 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitEllipse_set_inner_thresh(self, inner_thresh)

    def get_inner_thresh(self):
        r"""
        Get inner_thresh.
        :rtype: float
        :return: inner_thresh.
        """
        return _pyaqcv.RansacFitEllipse_get_inner_thresh(self)

    def set_iter_num(self, iter_num):
        r"""
        Set number of iterations.
        :type iter_num: int
        :param iter_num:  number of iterations,value > 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitEllipse_set_iter_num(self, iter_num)

    def get_iter_num(self):
        r"""
        Get number of iterations.
        :rtype: int
        :return: number of iterations
        """
        return _pyaqcv.RansacFitEllipse_get_iter_num(self)

    def execute(self, data):
        r"""
        Execute ransac fitting.
        :type data: :py:class:`Mat`
        :param data:  the channel is one. the depth is AQ_64F. the cols indicate dimension of sample. the rows indicate numbers of samples.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitEllipse_execute(self, data)

    def set_fit_model(self, model):
        r"""
        Set fit model.
        :type model: :py:class:`EllipseFitModel`
        :param model:  must derived from 'FitModelBase'
        """
        return _pyaqcv.RansacFitEllipse_set_fit_model(self, model)

    def get_fitted_model(self):
        r"""
        Get fitted model.
        :rtype: :py:class:`EllipseFitModel`
        :return: please see set_fit_model() model param.
        """
        return _pyaqcv.RansacFitEllipse_get_fitted_model(self)

# Register RansacFitEllipse in _pyaqcv:
_pyaqcv.RansacFitEllipse_swigregister(RansacFitEllipse)
class RansacFitPlane(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RansacFitPlane_swiginit(self, _pyaqcv.new_RansacFitPlane())
    __swig_destroy__ = _pyaqcv.delete_RansacFitPlane

    def set_inner_thresh(self, inner_thresh):
        r"""
        Set inner_thresh.
        :type inner_thresh: float
        :param inner_thresh: inner points distance to model threshold, value >= 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitPlane_set_inner_thresh(self, inner_thresh)

    def get_inner_thresh(self):
        r"""
        Get inner_thresh.
        :rtype: float
        :return: inner_thresh.
        """
        return _pyaqcv.RansacFitPlane_get_inner_thresh(self)

    def set_iter_num(self, iter_num):
        r"""
        Set number of iterations.
        :type iter_num: int
        :param iter_num:  number of iterations,value > 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitPlane_set_iter_num(self, iter_num)

    def get_iter_num(self):
        r"""
        Get number of iterations.
        :rtype: int
        :return: number of iterations
        """
        return _pyaqcv.RansacFitPlane_get_iter_num(self)

    def execute(self, data):
        r"""
        Execute ransac fitting.
        :type data: :py:class:`Mat`
        :param data:  the channel is one. the depth is AQ_64F. the cols indicate dimension of sample. the rows indicate numbers of samples.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitPlane_execute(self, data)

    def set_fit_model(self, model):
        r"""
        Set fit model.
        :type model: :py:class:`PlaneFitModel`
        :param model:  must derived from 'FitModelBase'
        """
        return _pyaqcv.RansacFitPlane_set_fit_model(self, model)

    def get_fitted_model(self):
        r"""
        Get fitted model.
        :rtype: :py:class:`PlaneFitModel`
        :return: please see set_fit_model() model param.
        """
        return _pyaqcv.RansacFitPlane_get_fitted_model(self)

# Register RansacFitPlane in _pyaqcv:
_pyaqcv.RansacFitPlane_swigregister(RansacFitPlane)
class RansacFitSphere(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pyaqcv.RansacFitSphere_swiginit(self, _pyaqcv.new_RansacFitSphere())
    __swig_destroy__ = _pyaqcv.delete_RansacFitSphere

    def set_inner_thresh(self, inner_thresh):
        r"""
        Set inner_thresh.
        :type inner_thresh: float
        :param inner_thresh: inner points distance to model threshold, value >= 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitSphere_set_inner_thresh(self, inner_thresh)

    def get_inner_thresh(self):
        r"""
        Get inner_thresh.
        :rtype: float
        :return: inner_thresh.
        """
        return _pyaqcv.RansacFitSphere_get_inner_thresh(self)

    def set_iter_num(self, iter_num):
        r"""
        Set number of iterations.
        :type iter_num: int
        :param iter_num:  number of iterations,value > 0
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitSphere_set_iter_num(self, iter_num)

    def get_iter_num(self):
        r"""
        Get number of iterations.
        :rtype: int
        :return: number of iterations
        """
        return _pyaqcv.RansacFitSphere_get_iter_num(self)

    def execute(self, data):
        r"""
        Execute ransac fitting.
        :type data: :py:class:`Mat`
        :param data:  the channel is one. the depth is AQ_64F. the cols indicate dimension of sample. the rows indicate numbers of samples.
        :rtype: boolean
        :return: success is true, failure is false.
        """
        return _pyaqcv.RansacFitSphere_execute(self, data)

    def set_fit_model(self, model):
        r"""
        Set fit model.
        :type model: :py:class:`SphereFitModel`
        :param model:  must derived from 'FitModelBase'
        """
        return _pyaqcv.RansacFitSphere_set_fit_model(self, model)

    def get_fitted_model(self):
        r"""
        Get fitted model.
        :rtype: :py:class:`SphereFitModel`
        :return: please see set_fit_model() model param.
        """
        return _pyaqcv.RansacFitSphere_get_fitted_model(self)

# Register RansacFitSphere in _pyaqcv:
_pyaqcv.RansacFitSphere_swigregister(RansacFitSphere)
class LineSingleEdgeInspectResult(SingleEdgeInspectResultBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_LineSingleEdgeInspectResult

    def clear(self):
        return _pyaqcv.LineSingleEdgeInspectResult_clear(self)
    fit_result = property(_pyaqcv.LineSingleEdgeInspectResult_fit_result_get, _pyaqcv.LineSingleEdgeInspectResult_fit_result_set)
    defect_regions = property(_pyaqcv.LineSingleEdgeInspectResult_defect_regions_get, _pyaqcv.LineSingleEdgeInspectResult_defect_regions_set)
    gap_regions = property(_pyaqcv.LineSingleEdgeInspectResult_gap_regions_get, _pyaqcv.LineSingleEdgeInspectResult_gap_regions_set)

    def __init__(self):
        _pyaqcv.LineSingleEdgeInspectResult_swiginit(self, _pyaqcv.new_LineSingleEdgeInspectResult())

# Register LineSingleEdgeInspectResult in _pyaqcv:
_pyaqcv.LineSingleEdgeInspectResult_swigregister(LineSingleEdgeInspectResult)
class CircleSingleEdgeInspectResult(SingleEdgeInspectResultBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_CircleSingleEdgeInspectResult

    def clear(self):
        return _pyaqcv.CircleSingleEdgeInspectResult_clear(self)
    fit_result = property(_pyaqcv.CircleSingleEdgeInspectResult_fit_result_get, _pyaqcv.CircleSingleEdgeInspectResult_fit_result_set)
    defect_regions = property(_pyaqcv.CircleSingleEdgeInspectResult_defect_regions_get, _pyaqcv.CircleSingleEdgeInspectResult_defect_regions_set)
    gap_regions = property(_pyaqcv.CircleSingleEdgeInspectResult_gap_regions_get, _pyaqcv.CircleSingleEdgeInspectResult_gap_regions_set)

    def __init__(self):
        _pyaqcv.CircleSingleEdgeInspectResult_swiginit(self, _pyaqcv.new_CircleSingleEdgeInspectResult())

# Register CircleSingleEdgeInspectResult in _pyaqcv:
_pyaqcv.CircleSingleEdgeInspectResult_swigregister(CircleSingleEdgeInspectResult)
class LineDualEdgeInspectResult(DualEdgeInspectResultBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_LineDualEdgeInspectResult

    def clear(self):
        return _pyaqcv.LineDualEdgeInspectResult_clear(self)
    fit_result_edge1 = property(_pyaqcv.LineDualEdgeInspectResult_fit_result_edge1_get, _pyaqcv.LineDualEdgeInspectResult_fit_result_edge1_set)
    fit_result_edge2 = property(_pyaqcv.LineDualEdgeInspectResult_fit_result_edge2_get, _pyaqcv.LineDualEdgeInspectResult_fit_result_edge2_set)
    defect_regions_edge1 = property(_pyaqcv.LineDualEdgeInspectResult_defect_regions_edge1_get, _pyaqcv.LineDualEdgeInspectResult_defect_regions_edge1_set)
    defect_regions_edge2 = property(_pyaqcv.LineDualEdgeInspectResult_defect_regions_edge2_get, _pyaqcv.LineDualEdgeInspectResult_defect_regions_edge2_set)
    gap_regions = property(_pyaqcv.LineDualEdgeInspectResult_gap_regions_get, _pyaqcv.LineDualEdgeInspectResult_gap_regions_set)

    def __init__(self):
        _pyaqcv.LineDualEdgeInspectResult_swiginit(self, _pyaqcv.new_LineDualEdgeInspectResult())

# Register LineDualEdgeInspectResult in _pyaqcv:
_pyaqcv.LineDualEdgeInspectResult_swigregister(LineDualEdgeInspectResult)
class CircleDualEdgeInspectResult(DualEdgeInspectResultBase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pyaqcv.delete_CircleDualEdgeInspectResult

    def clear(self):
        return _pyaqcv.CircleDualEdgeInspectResult_clear(self)
    fit_result_edge1 = property(_pyaqcv.CircleDualEdgeInspectResult_fit_result_edge1_get, _pyaqcv.CircleDualEdgeInspectResult_fit_result_edge1_set)
    fit_result_edge2 = property(_pyaqcv.CircleDualEdgeInspectResult_fit_result_edge2_get, _pyaqcv.CircleDualEdgeInspectResult_fit_result_edge2_set)
    defect_regions_edge1 = property(_pyaqcv.CircleDualEdgeInspectResult_defect_regions_edge1_get, _pyaqcv.CircleDualEdgeInspectResult_defect_regions_edge1_set)
    defect_regions_edge2 = property(_pyaqcv.CircleDualEdgeInspectResult_defect_regions_edge2_get, _pyaqcv.CircleDualEdgeInspectResult_defect_regions_edge2_set)
    gap_regions = property(_pyaqcv.CircleDualEdgeInspectResult_gap_regions_get, _pyaqcv.CircleDualEdgeInspectResult_gap_regions_set)

    def __init__(self):
        _pyaqcv.CircleDualEdgeInspectResult_swiginit(self, _pyaqcv.new_CircleDualEdgeInspectResult())

# Register CircleDualEdgeInspectResult in _pyaqcv:
_pyaqcv.CircleDualEdgeInspectResult_swigregister(CircleDualEdgeInspectResult)
class Point2iVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Point2iVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Point2iVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Point2iVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Point2iVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Point2iVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Point2iVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Point2iVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Point2iVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Point2iVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Point2iVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Point2iVec_pop(self)

    def append(self, x):
        return _pyaqcv.Point2iVec_append(self, x)

    def empty(self):
        return _pyaqcv.Point2iVec_empty(self)

    def size(self):
        return _pyaqcv.Point2iVec_size(self)

    def swap(self, v):
        return _pyaqcv.Point2iVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Point2iVec_begin(self)

    def end(self):
        return _pyaqcv.Point2iVec_end(self)

    def rbegin(self):
        return _pyaqcv.Point2iVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Point2iVec_rend(self)

    def clear(self):
        return _pyaqcv.Point2iVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Point2iVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Point2iVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Point2iVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Point2iVec_swiginit(self, _pyaqcv.new_Point2iVec(*args))

    def push_back(self, x):
        return _pyaqcv.Point2iVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Point2iVec_front(self)

    def back(self):
        return _pyaqcv.Point2iVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Point2iVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Point2iVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Point2iVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Point2iVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Point2iVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Point2iVec

# Register Point2iVec in _pyaqcv:
_pyaqcv.Point2iVec_swigregister(Point2iVec)
class Point2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Point2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Point2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Point2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Point2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Point2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Point2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Point2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Point2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Point2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Point2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Point2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.Point2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.Point2fVec_empty(self)

    def size(self):
        return _pyaqcv.Point2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.Point2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Point2fVec_begin(self)

    def end(self):
        return _pyaqcv.Point2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.Point2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Point2fVec_rend(self)

    def clear(self):
        return _pyaqcv.Point2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Point2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Point2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Point2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Point2fVec_swiginit(self, _pyaqcv.new_Point2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.Point2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Point2fVec_front(self)

    def back(self):
        return _pyaqcv.Point2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Point2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Point2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Point2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Point2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Point2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Point2fVec

# Register Point2fVec in _pyaqcv:
_pyaqcv.Point2fVec_swigregister(Point2fVec)
class Point2iVecVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Point2iVecVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Point2iVecVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Point2iVecVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Point2iVecVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Point2iVecVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Point2iVecVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Point2iVecVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Point2iVecVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Point2iVecVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Point2iVecVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Point2iVecVec_pop(self)

    def append(self, x):
        return _pyaqcv.Point2iVecVec_append(self, x)

    def empty(self):
        return _pyaqcv.Point2iVecVec_empty(self)

    def size(self):
        return _pyaqcv.Point2iVecVec_size(self)

    def swap(self, v):
        return _pyaqcv.Point2iVecVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Point2iVecVec_begin(self)

    def end(self):
        return _pyaqcv.Point2iVecVec_end(self)

    def rbegin(self):
        return _pyaqcv.Point2iVecVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Point2iVecVec_rend(self)

    def clear(self):
        return _pyaqcv.Point2iVecVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Point2iVecVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Point2iVecVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Point2iVecVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Point2iVecVec_swiginit(self, _pyaqcv.new_Point2iVecVec(*args))

    def push_back(self, x):
        return _pyaqcv.Point2iVecVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Point2iVecVec_front(self)

    def back(self):
        return _pyaqcv.Point2iVecVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Point2iVecVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Point2iVecVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Point2iVecVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Point2iVecVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Point2iVecVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Point2iVecVec

# Register Point2iVecVec in _pyaqcv:
_pyaqcv.Point2iVecVec_swigregister(Point2iVecVec)
class Point2fPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Point2fPair_swiginit(self, _pyaqcv.new_Point2fPair(*args))
    first = property(_pyaqcv.Point2fPair_first_get, _pyaqcv.Point2fPair_first_set)
    second = property(_pyaqcv.Point2fPair_second_get, _pyaqcv.Point2fPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyaqcv.delete_Point2fPair

# Register Point2fPair in _pyaqcv:
_pyaqcv.Point2fPair_swigregister(Point2fPair)
class Point2iPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.Point2iPair_swiginit(self, _pyaqcv.new_Point2iPair(*args))
    first = property(_pyaqcv.Point2iPair_first_get, _pyaqcv.Point2iPair_first_set)
    second = property(_pyaqcv.Point2iPair_second_get, _pyaqcv.Point2iPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyaqcv.delete_Point2iPair

# Register Point2iPair in _pyaqcv:
_pyaqcv.Point2iPair_swigregister(Point2iPair)
class RadianPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.RadianPair_swiginit(self, _pyaqcv.new_RadianPair(*args))
    first = property(_pyaqcv.RadianPair_first_get, _pyaqcv.RadianPair_first_set)
    second = property(_pyaqcv.RadianPair_second_get, _pyaqcv.RadianPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _pyaqcv.delete_RadianPair

# Register RadianPair in _pyaqcv:
_pyaqcv.RadianPair_swigregister(RadianPair)
class Polygon2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Polygon2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Polygon2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Polygon2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Polygon2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Polygon2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Polygon2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Polygon2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Polygon2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Polygon2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Polygon2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Polygon2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.Polygon2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.Polygon2fVec_empty(self)

    def size(self):
        return _pyaqcv.Polygon2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.Polygon2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Polygon2fVec_begin(self)

    def end(self):
        return _pyaqcv.Polygon2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.Polygon2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Polygon2fVec_rend(self)

    def clear(self):
        return _pyaqcv.Polygon2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Polygon2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Polygon2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Polygon2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Polygon2fVec_swiginit(self, _pyaqcv.new_Polygon2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.Polygon2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Polygon2fVec_front(self)

    def back(self):
        return _pyaqcv.Polygon2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Polygon2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Polygon2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Polygon2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Polygon2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Polygon2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Polygon2fVec

# Register Polygon2fVec in _pyaqcv:
_pyaqcv.Polygon2fVec_swigregister(Polygon2fVec)
class Polygon2iVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Polygon2iVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Polygon2iVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Polygon2iVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Polygon2iVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Polygon2iVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Polygon2iVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Polygon2iVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Polygon2iVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Polygon2iVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Polygon2iVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Polygon2iVec_pop(self)

    def append(self, x):
        return _pyaqcv.Polygon2iVec_append(self, x)

    def empty(self):
        return _pyaqcv.Polygon2iVec_empty(self)

    def size(self):
        return _pyaqcv.Polygon2iVec_size(self)

    def swap(self, v):
        return _pyaqcv.Polygon2iVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Polygon2iVec_begin(self)

    def end(self):
        return _pyaqcv.Polygon2iVec_end(self)

    def rbegin(self):
        return _pyaqcv.Polygon2iVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Polygon2iVec_rend(self)

    def clear(self):
        return _pyaqcv.Polygon2iVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Polygon2iVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Polygon2iVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Polygon2iVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Polygon2iVec_swiginit(self, _pyaqcv.new_Polygon2iVec(*args))

    def push_back(self, x):
        return _pyaqcv.Polygon2iVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Polygon2iVec_front(self)

    def back(self):
        return _pyaqcv.Polygon2iVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Polygon2iVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Polygon2iVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Polygon2iVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Polygon2iVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Polygon2iVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Polygon2iVec

# Register Polygon2iVec in _pyaqcv:
_pyaqcv.Polygon2iVec_swigregister(Polygon2iVec)
class Ring2iVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Ring2iVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Ring2iVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Ring2iVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Ring2iVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Ring2iVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Ring2iVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Ring2iVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Ring2iVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Ring2iVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Ring2iVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Ring2iVec_pop(self)

    def append(self, x):
        return _pyaqcv.Ring2iVec_append(self, x)

    def empty(self):
        return _pyaqcv.Ring2iVec_empty(self)

    def size(self):
        return _pyaqcv.Ring2iVec_size(self)

    def swap(self, v):
        return _pyaqcv.Ring2iVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Ring2iVec_begin(self)

    def end(self):
        return _pyaqcv.Ring2iVec_end(self)

    def rbegin(self):
        return _pyaqcv.Ring2iVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Ring2iVec_rend(self)

    def clear(self):
        return _pyaqcv.Ring2iVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Ring2iVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Ring2iVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Ring2iVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Ring2iVec_swiginit(self, _pyaqcv.new_Ring2iVec(*args))

    def push_back(self, x):
        return _pyaqcv.Ring2iVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Ring2iVec_front(self)

    def back(self):
        return _pyaqcv.Ring2iVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Ring2iVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Ring2iVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Ring2iVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Ring2iVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Ring2iVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Ring2iVec

# Register Ring2iVec in _pyaqcv:
_pyaqcv.Ring2iVec_swigregister(Ring2iVec)
class Ring2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Ring2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Ring2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Ring2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Ring2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Ring2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Ring2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Ring2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Ring2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Ring2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Ring2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Ring2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.Ring2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.Ring2fVec_empty(self)

    def size(self):
        return _pyaqcv.Ring2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.Ring2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Ring2fVec_begin(self)

    def end(self):
        return _pyaqcv.Ring2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.Ring2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Ring2fVec_rend(self)

    def clear(self):
        return _pyaqcv.Ring2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Ring2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Ring2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Ring2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Ring2fVec_swiginit(self, _pyaqcv.new_Ring2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.Ring2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Ring2fVec_front(self)

    def back(self):
        return _pyaqcv.Ring2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Ring2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Ring2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Ring2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Ring2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Ring2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Ring2fVec

# Register Ring2fVec in _pyaqcv:
_pyaqcv.Ring2fVec_swigregister(Ring2fVec)
class RadianVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.RadianVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.RadianVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.RadianVec___bool__(self)

    def __len__(self):
        return _pyaqcv.RadianVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.RadianVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.RadianVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.RadianVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.RadianVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.RadianVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.RadianVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.RadianVec_pop(self)

    def append(self, x):
        return _pyaqcv.RadianVec_append(self, x)

    def empty(self):
        return _pyaqcv.RadianVec_empty(self)

    def size(self):
        return _pyaqcv.RadianVec_size(self)

    def swap(self, v):
        return _pyaqcv.RadianVec_swap(self, v)

    def begin(self):
        return _pyaqcv.RadianVec_begin(self)

    def end(self):
        return _pyaqcv.RadianVec_end(self)

    def rbegin(self):
        return _pyaqcv.RadianVec_rbegin(self)

    def rend(self):
        return _pyaqcv.RadianVec_rend(self)

    def clear(self):
        return _pyaqcv.RadianVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.RadianVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.RadianVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.RadianVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.RadianVec_swiginit(self, _pyaqcv.new_RadianVec(*args))

    def push_back(self, x):
        return _pyaqcv.RadianVec_push_back(self, x)

    def front(self):
        return _pyaqcv.RadianVec_front(self)

    def back(self):
        return _pyaqcv.RadianVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.RadianVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.RadianVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.RadianVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.RadianVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.RadianVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_RadianVec

# Register RadianVec in _pyaqcv:
_pyaqcv.RadianVec_swigregister(RadianVec)
class RotateRect2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.RotateRect2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.RotateRect2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.RotateRect2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.RotateRect2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.RotateRect2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.RotateRect2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.RotateRect2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.RotateRect2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.RotateRect2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.RotateRect2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.RotateRect2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.RotateRect2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.RotateRect2fVec_empty(self)

    def size(self):
        return _pyaqcv.RotateRect2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.RotateRect2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.RotateRect2fVec_begin(self)

    def end(self):
        return _pyaqcv.RotateRect2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.RotateRect2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.RotateRect2fVec_rend(self)

    def clear(self):
        return _pyaqcv.RotateRect2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.RotateRect2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.RotateRect2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.RotateRect2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.RotateRect2fVec_swiginit(self, _pyaqcv.new_RotateRect2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.RotateRect2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.RotateRect2fVec_front(self)

    def back(self):
        return _pyaqcv.RotateRect2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.RotateRect2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.RotateRect2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.RotateRect2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.RotateRect2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.RotateRect2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_RotateRect2fVec

# Register RotateRect2fVec in _pyaqcv:
_pyaqcv.RotateRect2fVec_swigregister(RotateRect2fVec)
class Segment2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Segment2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Segment2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Segment2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Segment2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Segment2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Segment2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Segment2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Segment2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Segment2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Segment2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Segment2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.Segment2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.Segment2fVec_empty(self)

    def size(self):
        return _pyaqcv.Segment2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.Segment2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Segment2fVec_begin(self)

    def end(self):
        return _pyaqcv.Segment2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.Segment2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Segment2fVec_rend(self)

    def clear(self):
        return _pyaqcv.Segment2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Segment2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Segment2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Segment2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Segment2fVec_swiginit(self, _pyaqcv.new_Segment2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.Segment2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Segment2fVec_front(self)

    def back(self):
        return _pyaqcv.Segment2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Segment2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Segment2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Segment2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Segment2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Segment2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Segment2fVec

# Register Segment2fVec in _pyaqcv:
_pyaqcv.Segment2fVec_swigregister(Segment2fVec)
class MultiSegment2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.MultiSegment2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.MultiSegment2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.MultiSegment2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.MultiSegment2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.MultiSegment2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.MultiSegment2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.MultiSegment2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.MultiSegment2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.MultiSegment2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.MultiSegment2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.MultiSegment2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.MultiSegment2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.MultiSegment2fVec_empty(self)

    def size(self):
        return _pyaqcv.MultiSegment2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.MultiSegment2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.MultiSegment2fVec_begin(self)

    def end(self):
        return _pyaqcv.MultiSegment2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.MultiSegment2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.MultiSegment2fVec_rend(self)

    def clear(self):
        return _pyaqcv.MultiSegment2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.MultiSegment2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.MultiSegment2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.MultiSegment2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.MultiSegment2fVec_swiginit(self, _pyaqcv.new_MultiSegment2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.MultiSegment2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.MultiSegment2fVec_front(self)

    def back(self):
        return _pyaqcv.MultiSegment2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.MultiSegment2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.MultiSegment2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.MultiSegment2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.MultiSegment2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.MultiSegment2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_MultiSegment2fVec

# Register MultiSegment2fVec in _pyaqcv:
_pyaqcv.MultiSegment2fVec_swigregister(MultiSegment2fVec)
class LineString2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.LineString2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.LineString2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.LineString2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.LineString2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.LineString2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.LineString2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.LineString2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.LineString2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.LineString2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.LineString2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.LineString2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.LineString2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.LineString2fVec_empty(self)

    def size(self):
        return _pyaqcv.LineString2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.LineString2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.LineString2fVec_begin(self)

    def end(self):
        return _pyaqcv.LineString2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.LineString2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.LineString2fVec_rend(self)

    def clear(self):
        return _pyaqcv.LineString2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.LineString2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.LineString2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.LineString2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.LineString2fVec_swiginit(self, _pyaqcv.new_LineString2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.LineString2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.LineString2fVec_front(self)

    def back(self):
        return _pyaqcv.LineString2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.LineString2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.LineString2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.LineString2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.LineString2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.LineString2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_LineString2fVec

# Register LineString2fVec in _pyaqcv:
_pyaqcv.LineString2fVec_swigregister(LineString2fVec)
class LineString2iVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.LineString2iVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.LineString2iVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.LineString2iVec___bool__(self)

    def __len__(self):
        return _pyaqcv.LineString2iVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.LineString2iVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.LineString2iVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.LineString2iVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.LineString2iVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.LineString2iVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.LineString2iVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.LineString2iVec_pop(self)

    def append(self, x):
        return _pyaqcv.LineString2iVec_append(self, x)

    def empty(self):
        return _pyaqcv.LineString2iVec_empty(self)

    def size(self):
        return _pyaqcv.LineString2iVec_size(self)

    def swap(self, v):
        return _pyaqcv.LineString2iVec_swap(self, v)

    def begin(self):
        return _pyaqcv.LineString2iVec_begin(self)

    def end(self):
        return _pyaqcv.LineString2iVec_end(self)

    def rbegin(self):
        return _pyaqcv.LineString2iVec_rbegin(self)

    def rend(self):
        return _pyaqcv.LineString2iVec_rend(self)

    def clear(self):
        return _pyaqcv.LineString2iVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.LineString2iVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.LineString2iVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.LineString2iVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.LineString2iVec_swiginit(self, _pyaqcv.new_LineString2iVec(*args))

    def push_back(self, x):
        return _pyaqcv.LineString2iVec_push_back(self, x)

    def front(self):
        return _pyaqcv.LineString2iVec_front(self)

    def back(self):
        return _pyaqcv.LineString2iVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.LineString2iVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.LineString2iVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.LineString2iVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.LineString2iVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.LineString2iVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_LineString2iVec

# Register LineString2iVec in _pyaqcv:
_pyaqcv.LineString2iVec_swigregister(LineString2iVec)
class MultiPoint2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.MultiPoint2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.MultiPoint2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.MultiPoint2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.MultiPoint2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.MultiPoint2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.MultiPoint2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.MultiPoint2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.MultiPoint2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.MultiPoint2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.MultiPoint2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.MultiPoint2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.MultiPoint2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.MultiPoint2fVec_empty(self)

    def size(self):
        return _pyaqcv.MultiPoint2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.MultiPoint2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.MultiPoint2fVec_begin(self)

    def end(self):
        return _pyaqcv.MultiPoint2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.MultiPoint2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.MultiPoint2fVec_rend(self)

    def clear(self):
        return _pyaqcv.MultiPoint2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.MultiPoint2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.MultiPoint2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.MultiPoint2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.MultiPoint2fVec_swiginit(self, _pyaqcv.new_MultiPoint2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.MultiPoint2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.MultiPoint2fVec_front(self)

    def back(self):
        return _pyaqcv.MultiPoint2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.MultiPoint2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.MultiPoint2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.MultiPoint2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.MultiPoint2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.MultiPoint2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_MultiPoint2fVec

# Register MultiPoint2fVec in _pyaqcv:
_pyaqcv.MultiPoint2fVec_swigregister(MultiPoint2fVec)
class Rect2iVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Rect2iVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Rect2iVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Rect2iVec___bool__(self)

    def __len__(self):
        return _pyaqcv.Rect2iVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Rect2iVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Rect2iVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Rect2iVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Rect2iVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Rect2iVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Rect2iVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Rect2iVec_pop(self)

    def append(self, x):
        return _pyaqcv.Rect2iVec_append(self, x)

    def empty(self):
        return _pyaqcv.Rect2iVec_empty(self)

    def size(self):
        return _pyaqcv.Rect2iVec_size(self)

    def swap(self, v):
        return _pyaqcv.Rect2iVec_swap(self, v)

    def begin(self):
        return _pyaqcv.Rect2iVec_begin(self)

    def end(self):
        return _pyaqcv.Rect2iVec_end(self)

    def rbegin(self):
        return _pyaqcv.Rect2iVec_rbegin(self)

    def rend(self):
        return _pyaqcv.Rect2iVec_rend(self)

    def clear(self):
        return _pyaqcv.Rect2iVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.Rect2iVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Rect2iVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Rect2iVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Rect2iVec_swiginit(self, _pyaqcv.new_Rect2iVec(*args))

    def push_back(self, x):
        return _pyaqcv.Rect2iVec_push_back(self, x)

    def front(self):
        return _pyaqcv.Rect2iVec_front(self)

    def back(self):
        return _pyaqcv.Rect2iVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.Rect2iVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Rect2iVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Rect2iVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.Rect2iVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.Rect2iVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_Rect2iVec

# Register Rect2iVec in _pyaqcv:
_pyaqcv.Rect2iVec_swigregister(Rect2iVec)
class Point2iList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Point2iList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Point2iList___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Point2iList___bool__(self)

    def __len__(self):
        return _pyaqcv.Point2iList___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Point2iList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Point2iList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Point2iList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Point2iList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Point2iList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Point2iList___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Point2iList_pop(self)

    def append(self, x):
        return _pyaqcv.Point2iList_append(self, x)

    def empty(self):
        return _pyaqcv.Point2iList_empty(self)

    def size(self):
        return _pyaqcv.Point2iList_size(self)

    def swap(self, v):
        return _pyaqcv.Point2iList_swap(self, v)

    def begin(self):
        return _pyaqcv.Point2iList_begin(self)

    def end(self):
        return _pyaqcv.Point2iList_end(self)

    def rbegin(self):
        return _pyaqcv.Point2iList_rbegin(self)

    def rend(self):
        return _pyaqcv.Point2iList_rend(self)

    def clear(self):
        return _pyaqcv.Point2iList_clear(self)

    def get_allocator(self):
        return _pyaqcv.Point2iList_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Point2iList_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Point2iList_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Point2iList_swiginit(self, _pyaqcv.new_Point2iList(*args))

    def push_back(self, x):
        return _pyaqcv.Point2iList_push_back(self, x)

    def front(self):
        return _pyaqcv.Point2iList_front(self)

    def back(self):
        return _pyaqcv.Point2iList_back(self)

    def assign(self, n, x):
        return _pyaqcv.Point2iList_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Point2iList_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Point2iList_insert(self, *args)

    def pop_front(self):
        return _pyaqcv.Point2iList_pop_front(self)

    def push_front(self, x):
        return _pyaqcv.Point2iList_push_front(self, x)

    def reverse(self):
        return _pyaqcv.Point2iList_reverse(self)
    __swig_destroy__ = _pyaqcv.delete_Point2iList

# Register Point2iList in _pyaqcv:
_pyaqcv.Point2iList_swigregister(Point2iList)
class Point2fList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.Point2fList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.Point2fList___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.Point2fList___bool__(self)

    def __len__(self):
        return _pyaqcv.Point2fList___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.Point2fList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.Point2fList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.Point2fList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.Point2fList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.Point2fList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.Point2fList___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.Point2fList_pop(self)

    def append(self, x):
        return _pyaqcv.Point2fList_append(self, x)

    def empty(self):
        return _pyaqcv.Point2fList_empty(self)

    def size(self):
        return _pyaqcv.Point2fList_size(self)

    def swap(self, v):
        return _pyaqcv.Point2fList_swap(self, v)

    def begin(self):
        return _pyaqcv.Point2fList_begin(self)

    def end(self):
        return _pyaqcv.Point2fList_end(self)

    def rbegin(self):
        return _pyaqcv.Point2fList_rbegin(self)

    def rend(self):
        return _pyaqcv.Point2fList_rend(self)

    def clear(self):
        return _pyaqcv.Point2fList_clear(self)

    def get_allocator(self):
        return _pyaqcv.Point2fList_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.Point2fList_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.Point2fList_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.Point2fList_swiginit(self, _pyaqcv.new_Point2fList(*args))

    def push_back(self, x):
        return _pyaqcv.Point2fList_push_back(self, x)

    def front(self):
        return _pyaqcv.Point2fList_front(self)

    def back(self):
        return _pyaqcv.Point2fList_back(self)

    def assign(self, n, x):
        return _pyaqcv.Point2fList_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.Point2fList_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.Point2fList_insert(self, *args)

    def pop_front(self):
        return _pyaqcv.Point2fList_pop_front(self)

    def push_front(self, x):
        return _pyaqcv.Point2fList_push_front(self, x)

    def reverse(self):
        return _pyaqcv.Point2fList_reverse(self)
    __swig_destroy__ = _pyaqcv.delete_Point2fList

# Register Point2fList in _pyaqcv:
_pyaqcv.Point2fList_swigregister(Point2fList)
class AqPointVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPointVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPointVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPointVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPointVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPointVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPointVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPointVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPointVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPointVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPointVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPointVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPointVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPointVec_empty(self)

    def size(self):
        return _pyaqcv.AqPointVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPointVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPointVec_begin(self)

    def end(self):
        return _pyaqcv.AqPointVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPointVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPointVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPointVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPointVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPointVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPointVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPointVec_swiginit(self, _pyaqcv.new_AqPointVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPointVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPointVec_front(self)

    def back(self):
        return _pyaqcv.AqPointVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPointVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPointVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPointVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPointVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPointVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPointVec

# Register AqPointVec in _pyaqcv:
_pyaqcv.AqPointVec_swigregister(AqPointVec)
class AqPoint2fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPoint2fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPoint2fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPoint2fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPoint2fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPoint2fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPoint2fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPoint2fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPoint2fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPoint2fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPoint2fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPoint2fVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPoint2fVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPoint2fVec_empty(self)

    def size(self):
        return _pyaqcv.AqPoint2fVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPoint2fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPoint2fVec_begin(self)

    def end(self):
        return _pyaqcv.AqPoint2fVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPoint2fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPoint2fVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPoint2fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPoint2fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPoint2fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPoint2fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPoint2fVec_swiginit(self, _pyaqcv.new_AqPoint2fVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPoint2fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPoint2fVec_front(self)

    def back(self):
        return _pyaqcv.AqPoint2fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPoint2fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPoint2fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPoint2fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPoint2fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPoint2fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPoint2fVec

# Register AqPoint2fVec in _pyaqcv:
_pyaqcv.AqPoint2fVec_swigregister(AqPoint2fVec)
class AqPoint2dVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPoint2dVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPoint2dVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPoint2dVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPoint2dVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPoint2dVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPoint2dVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPoint2dVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPoint2dVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPoint2dVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPoint2dVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPoint2dVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPoint2dVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPoint2dVec_empty(self)

    def size(self):
        return _pyaqcv.AqPoint2dVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPoint2dVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPoint2dVec_begin(self)

    def end(self):
        return _pyaqcv.AqPoint2dVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPoint2dVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPoint2dVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPoint2dVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPoint2dVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPoint2dVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPoint2dVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPoint2dVec_swiginit(self, _pyaqcv.new_AqPoint2dVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPoint2dVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPoint2dVec_front(self)

    def back(self):
        return _pyaqcv.AqPoint2dVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPoint2dVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPoint2dVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPoint2dVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPoint2dVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPoint2dVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPoint2dVec

# Register AqPoint2dVec in _pyaqcv:
_pyaqcv.AqPoint2dVec_swigregister(AqPoint2dVec)
class AqMatVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqMatVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqMatVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqMatVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqMatVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqMatVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqMatVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqMatVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqMatVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqMatVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqMatVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqMatVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqMatVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqMatVec_empty(self)

    def size(self):
        return _pyaqcv.AqMatVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqMatVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqMatVec_begin(self)

    def end(self):
        return _pyaqcv.AqMatVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqMatVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqMatVec_rend(self)

    def clear(self):
        return _pyaqcv.AqMatVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqMatVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqMatVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqMatVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqMatVec_swiginit(self, _pyaqcv.new_AqMatVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqMatVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqMatVec_front(self)

    def back(self):
        return _pyaqcv.AqMatVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqMatVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqMatVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqMatVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqMatVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqMatVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqMatVec

# Register AqMatVec in _pyaqcv:
_pyaqcv.AqMatVec_swigregister(AqMatVec)
class AqRangeVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqRangeVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqRangeVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqRangeVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqRangeVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqRangeVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqRangeVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqRangeVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqRangeVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqRangeVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqRangeVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqRangeVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqRangeVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqRangeVec_empty(self)

    def size(self):
        return _pyaqcv.AqRangeVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqRangeVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqRangeVec_begin(self)

    def end(self):
        return _pyaqcv.AqRangeVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqRangeVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqRangeVec_rend(self)

    def clear(self):
        return _pyaqcv.AqRangeVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqRangeVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqRangeVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqRangeVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqRangeVec_swiginit(self, _pyaqcv.new_AqRangeVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqRangeVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqRangeVec_front(self)

    def back(self):
        return _pyaqcv.AqRangeVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqRangeVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqRangeVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqRangeVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqRangeVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqRangeVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqRangeVec

# Register AqRangeVec in _pyaqcv:
_pyaqcv.AqRangeVec_swigregister(AqRangeVec)
class AqPoint3fVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPoint3fVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPoint3fVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPoint3fVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPoint3fVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPoint3fVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPoint3fVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPoint3fVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPoint3fVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPoint3fVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPoint3fVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPoint3fVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPoint3fVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPoint3fVec_empty(self)

    def size(self):
        return _pyaqcv.AqPoint3fVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPoint3fVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPoint3fVec_begin(self)

    def end(self):
        return _pyaqcv.AqPoint3fVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPoint3fVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPoint3fVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPoint3fVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPoint3fVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPoint3fVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPoint3fVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPoint3fVec_swiginit(self, _pyaqcv.new_AqPoint3fVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPoint3fVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPoint3fVec_front(self)

    def back(self):
        return _pyaqcv.AqPoint3fVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPoint3fVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPoint3fVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPoint3fVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPoint3fVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPoint3fVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPoint3fVec

# Register AqPoint3fVec in _pyaqcv:
_pyaqcv.AqPoint3fVec_swigregister(AqPoint3fVec)
class AqPoint3dVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPoint3dVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPoint3dVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPoint3dVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPoint3dVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPoint3dVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPoint3dVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPoint3dVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPoint3dVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPoint3dVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPoint3dVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPoint3dVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPoint3dVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPoint3dVec_empty(self)

    def size(self):
        return _pyaqcv.AqPoint3dVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPoint3dVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPoint3dVec_begin(self)

    def end(self):
        return _pyaqcv.AqPoint3dVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPoint3dVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPoint3dVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPoint3dVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPoint3dVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPoint3dVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPoint3dVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPoint3dVec_swiginit(self, _pyaqcv.new_AqPoint3dVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPoint3dVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPoint3dVec_front(self)

    def back(self):
        return _pyaqcv.AqPoint3dVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPoint3dVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPoint3dVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPoint3dVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPoint3dVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPoint3dVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPoint3dVec

# Register AqPoint3dVec in _pyaqcv:
_pyaqcv.AqPoint3dVec_swigregister(AqPoint3dVec)
class AqVec4iVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqVec4iVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqVec4iVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqVec4iVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqVec4iVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqVec4iVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqVec4iVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqVec4iVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqVec4iVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqVec4iVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqVec4iVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqVec4iVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqVec4iVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqVec4iVec_empty(self)

    def size(self):
        return _pyaqcv.AqVec4iVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqVec4iVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqVec4iVec_begin(self)

    def end(self):
        return _pyaqcv.AqVec4iVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqVec4iVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqVec4iVec_rend(self)

    def clear(self):
        return _pyaqcv.AqVec4iVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqVec4iVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqVec4iVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqVec4iVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqVec4iVec_swiginit(self, _pyaqcv.new_AqVec4iVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqVec4iVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqVec4iVec_front(self)

    def back(self):
        return _pyaqcv.AqVec4iVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqVec4iVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqVec4iVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqVec4iVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqVec4iVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqVec4iVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqVec4iVec

# Register AqVec4iVec in _pyaqcv:
_pyaqcv.AqVec4iVec_swigregister(AqVec4iVec)
class AqRegionVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqRegionVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqRegionVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqRegionVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqRegionVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqRegionVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqRegionVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqRegionVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqRegionVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqRegionVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqRegionVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqRegionVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqRegionVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqRegionVec_empty(self)

    def size(self):
        return _pyaqcv.AqRegionVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqRegionVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqRegionVec_begin(self)

    def end(self):
        return _pyaqcv.AqRegionVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqRegionVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqRegionVec_rend(self)

    def clear(self):
        return _pyaqcv.AqRegionVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqRegionVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqRegionVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqRegionVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqRegionVec_swiginit(self, _pyaqcv.new_AqRegionVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqRegionVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqRegionVec_front(self)

    def back(self):
        return _pyaqcv.AqRegionVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqRegionVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqRegionVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqRegionVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqRegionVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqRegionVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqRegionVec

# Register AqRegionVec in _pyaqcv:
_pyaqcv.AqRegionVec_swigregister(AqRegionVec)
class AqRegionSelectFeatureVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqRegionSelectFeatureVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqRegionSelectFeatureVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqRegionSelectFeatureVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqRegionSelectFeatureVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqRegionSelectFeatureVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqRegionSelectFeatureVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqRegionSelectFeatureVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqRegionSelectFeatureVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqRegionSelectFeatureVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqRegionSelectFeatureVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqRegionSelectFeatureVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqRegionSelectFeatureVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqRegionSelectFeatureVec_empty(self)

    def size(self):
        return _pyaqcv.AqRegionSelectFeatureVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqRegionSelectFeatureVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqRegionSelectFeatureVec_begin(self)

    def end(self):
        return _pyaqcv.AqRegionSelectFeatureVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqRegionSelectFeatureVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqRegionSelectFeatureVec_rend(self)

    def clear(self):
        return _pyaqcv.AqRegionSelectFeatureVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqRegionSelectFeatureVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqRegionSelectFeatureVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqRegionSelectFeatureVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqRegionSelectFeatureVec_swiginit(self, _pyaqcv.new_AqRegionSelectFeatureVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqRegionSelectFeatureVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqRegionSelectFeatureVec_front(self)

    def back(self):
        return _pyaqcv.AqRegionSelectFeatureVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqRegionSelectFeatureVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqRegionSelectFeatureVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqRegionSelectFeatureVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqRegionSelectFeatureVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqRegionSelectFeatureVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqRegionSelectFeatureVec

# Register AqRegionSelectFeatureVec in _pyaqcv:
_pyaqcv.AqRegionSelectFeatureVec_swigregister(AqRegionSelectFeatureVec)
class AqIntPose3DRTMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqIntPose3DRTMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqIntPose3DRTMap___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqIntPose3DRTMap___bool__(self)

    def __len__(self):
        return _pyaqcv.AqIntPose3DRTMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _pyaqcv.AqIntPose3DRTMap___getitem__(self, key)

    def __delitem__(self, key):
        return _pyaqcv.AqIntPose3DRTMap___delitem__(self, key)

    def has_key(self, key):
        return _pyaqcv.AqIntPose3DRTMap_has_key(self, key)

    def keys(self):
        return _pyaqcv.AqIntPose3DRTMap_keys(self)

    def values(self):
        return _pyaqcv.AqIntPose3DRTMap_values(self)

    def items(self):
        return _pyaqcv.AqIntPose3DRTMap_items(self)

    def __contains__(self, key):
        return _pyaqcv.AqIntPose3DRTMap___contains__(self, key)

    def key_iterator(self):
        return _pyaqcv.AqIntPose3DRTMap_key_iterator(self)

    def value_iterator(self):
        return _pyaqcv.AqIntPose3DRTMap_value_iterator(self)

    def __setitem__(self, *args):
        return _pyaqcv.AqIntPose3DRTMap___setitem__(self, *args)

    def asdict(self):
        return _pyaqcv.AqIntPose3DRTMap_asdict(self)

    def __init__(self, *args):
        _pyaqcv.AqIntPose3DRTMap_swiginit(self, _pyaqcv.new_AqIntPose3DRTMap(*args))

    def empty(self):
        return _pyaqcv.AqIntPose3DRTMap_empty(self)

    def size(self):
        return _pyaqcv.AqIntPose3DRTMap_size(self)

    def swap(self, v):
        return _pyaqcv.AqIntPose3DRTMap_swap(self, v)

    def begin(self):
        return _pyaqcv.AqIntPose3DRTMap_begin(self)

    def end(self):
        return _pyaqcv.AqIntPose3DRTMap_end(self)

    def rbegin(self):
        return _pyaqcv.AqIntPose3DRTMap_rbegin(self)

    def rend(self):
        return _pyaqcv.AqIntPose3DRTMap_rend(self)

    def clear(self):
        return _pyaqcv.AqIntPose3DRTMap_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqIntPose3DRTMap_get_allocator(self)

    def count(self, x):
        return _pyaqcv.AqIntPose3DRTMap_count(self, x)

    def erase(self, *args):
        return _pyaqcv.AqIntPose3DRTMap_erase(self, *args)

    def find(self, x):
        return _pyaqcv.AqIntPose3DRTMap_find(self, x)

    def lower_bound(self, x):
        return _pyaqcv.AqIntPose3DRTMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _pyaqcv.AqIntPose3DRTMap_upper_bound(self, x)
    __swig_destroy__ = _pyaqcv.delete_AqIntPose3DRTMap

# Register AqIntPose3DRTMap in _pyaqcv:
_pyaqcv.AqIntPose3DRTMap_swigregister(AqIntPose3DRTMap)
class AqPointFeatVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPointFeatVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPointFeatVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPointFeatVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPointFeatVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPointFeatVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPointFeatVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPointFeatVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPointFeatVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPointFeatVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPointFeatVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPointFeatVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPointFeatVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPointFeatVec_empty(self)

    def size(self):
        return _pyaqcv.AqPointFeatVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPointFeatVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPointFeatVec_begin(self)

    def end(self):
        return _pyaqcv.AqPointFeatVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPointFeatVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPointFeatVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPointFeatVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPointFeatVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPointFeatVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPointFeatVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPointFeatVec_swiginit(self, _pyaqcv.new_AqPointFeatVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPointFeatVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPointFeatVec_front(self)

    def back(self):
        return _pyaqcv.AqPointFeatVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPointFeatVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPointFeatVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPointFeatVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPointFeatVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPointFeatVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPointFeatVec

# Register AqPointFeatVec in _pyaqcv:
_pyaqcv.AqPointFeatVec_swigregister(AqPointFeatVec)
class AqPointFeatVecVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPointFeatVecVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPointFeatVecVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPointFeatVecVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPointFeatVecVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPointFeatVecVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPointFeatVecVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPointFeatVecVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPointFeatVecVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPointFeatVecVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPointFeatVecVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPointFeatVecVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPointFeatVecVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPointFeatVecVec_empty(self)

    def size(self):
        return _pyaqcv.AqPointFeatVecVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPointFeatVecVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPointFeatVecVec_begin(self)

    def end(self):
        return _pyaqcv.AqPointFeatVecVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPointFeatVecVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPointFeatVecVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPointFeatVecVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPointFeatVecVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPointFeatVecVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPointFeatVecVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPointFeatVecVec_swiginit(self, _pyaqcv.new_AqPointFeatVecVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPointFeatVecVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPointFeatVecVec_front(self)

    def back(self):
        return _pyaqcv.AqPointFeatVecVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPointFeatVecVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPointFeatVecVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPointFeatVecVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPointFeatVecVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPointFeatVecVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPointFeatVecVec

# Register AqPointFeatVecVec in _pyaqcv:
_pyaqcv.AqPointFeatVecVec_swigregister(AqPointFeatVecVec)
class AqChainInfoVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqChainInfoVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqChainInfoVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqChainInfoVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqChainInfoVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqChainInfoVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqChainInfoVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqChainInfoVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqChainInfoVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqChainInfoVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqChainInfoVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqChainInfoVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqChainInfoVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqChainInfoVec_empty(self)

    def size(self):
        return _pyaqcv.AqChainInfoVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqChainInfoVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqChainInfoVec_begin(self)

    def end(self):
        return _pyaqcv.AqChainInfoVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqChainInfoVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqChainInfoVec_rend(self)

    def clear(self):
        return _pyaqcv.AqChainInfoVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqChainInfoVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqChainInfoVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqChainInfoVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqChainInfoVec_swiginit(self, _pyaqcv.new_AqChainInfoVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqChainInfoVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqChainInfoVec_front(self)

    def back(self):
        return _pyaqcv.AqChainInfoVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqChainInfoVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqChainInfoVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqChainInfoVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqChainInfoVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqChainInfoVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqChainInfoVec

# Register AqChainInfoVec in _pyaqcv:
_pyaqcv.AqChainInfoVec_swigregister(AqChainInfoVec)
class AqIntDoubleMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqIntDoubleMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqIntDoubleMap___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqIntDoubleMap___bool__(self)

    def __len__(self):
        return _pyaqcv.AqIntDoubleMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _pyaqcv.AqIntDoubleMap___getitem__(self, key)

    def __delitem__(self, key):
        return _pyaqcv.AqIntDoubleMap___delitem__(self, key)

    def has_key(self, key):
        return _pyaqcv.AqIntDoubleMap_has_key(self, key)

    def keys(self):
        return _pyaqcv.AqIntDoubleMap_keys(self)

    def values(self):
        return _pyaqcv.AqIntDoubleMap_values(self)

    def items(self):
        return _pyaqcv.AqIntDoubleMap_items(self)

    def __contains__(self, key):
        return _pyaqcv.AqIntDoubleMap___contains__(self, key)

    def key_iterator(self):
        return _pyaqcv.AqIntDoubleMap_key_iterator(self)

    def value_iterator(self):
        return _pyaqcv.AqIntDoubleMap_value_iterator(self)

    def __setitem__(self, *args):
        return _pyaqcv.AqIntDoubleMap___setitem__(self, *args)

    def asdict(self):
        return _pyaqcv.AqIntDoubleMap_asdict(self)

    def __init__(self, *args):
        _pyaqcv.AqIntDoubleMap_swiginit(self, _pyaqcv.new_AqIntDoubleMap(*args))

    def empty(self):
        return _pyaqcv.AqIntDoubleMap_empty(self)

    def size(self):
        return _pyaqcv.AqIntDoubleMap_size(self)

    def swap(self, v):
        return _pyaqcv.AqIntDoubleMap_swap(self, v)

    def begin(self):
        return _pyaqcv.AqIntDoubleMap_begin(self)

    def end(self):
        return _pyaqcv.AqIntDoubleMap_end(self)

    def rbegin(self):
        return _pyaqcv.AqIntDoubleMap_rbegin(self)

    def rend(self):
        return _pyaqcv.AqIntDoubleMap_rend(self)

    def clear(self):
        return _pyaqcv.AqIntDoubleMap_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqIntDoubleMap_get_allocator(self)

    def count(self, x):
        return _pyaqcv.AqIntDoubleMap_count(self, x)

    def erase(self, *args):
        return _pyaqcv.AqIntDoubleMap_erase(self, *args)

    def find(self, x):
        return _pyaqcv.AqIntDoubleMap_find(self, x)

    def lower_bound(self, x):
        return _pyaqcv.AqIntDoubleMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _pyaqcv.AqIntDoubleMap_upper_bound(self, x)
    __swig_destroy__ = _pyaqcv.delete_AqIntDoubleMap

# Register AqIntDoubleMap in _pyaqcv:
_pyaqcv.AqIntDoubleMap_swigregister(AqIntDoubleMap)
class AqCameraModelVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqCameraModelVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqCameraModelVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqCameraModelVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqCameraModelVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqCameraModelVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqCameraModelVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqCameraModelVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqCameraModelVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqCameraModelVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqCameraModelVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqCameraModelVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqCameraModelVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqCameraModelVec_empty(self)

    def size(self):
        return _pyaqcv.AqCameraModelVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqCameraModelVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqCameraModelVec_begin(self)

    def end(self):
        return _pyaqcv.AqCameraModelVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqCameraModelVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqCameraModelVec_rend(self)

    def clear(self):
        return _pyaqcv.AqCameraModelVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqCameraModelVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqCameraModelVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqCameraModelVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqCameraModelVec_swiginit(self, _pyaqcv.new_AqCameraModelVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqCameraModelVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqCameraModelVec_front(self)

    def back(self):
        return _pyaqcv.AqCameraModelVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqCameraModelVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqCameraModelVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqCameraModelVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqCameraModelVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqCameraModelVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqCameraModelVec

# Register AqCameraModelVec in _pyaqcv:
_pyaqcv.AqCameraModelVec_swigregister(AqCameraModelVec)
class AqIntCameraViewFeaturesMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap___bool__(self)

    def __len__(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _pyaqcv.AqIntCameraViewFeaturesMap___getitem__(self, key)

    def __delitem__(self, key):
        return _pyaqcv.AqIntCameraViewFeaturesMap___delitem__(self, key)

    def has_key(self, key):
        return _pyaqcv.AqIntCameraViewFeaturesMap_has_key(self, key)

    def keys(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_keys(self)

    def values(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_values(self)

    def items(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_items(self)

    def __contains__(self, key):
        return _pyaqcv.AqIntCameraViewFeaturesMap___contains__(self, key)

    def key_iterator(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_key_iterator(self)

    def value_iterator(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_value_iterator(self)

    def __setitem__(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMap___setitem__(self, *args)

    def asdict(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_asdict(self)

    def __init__(self, *args):
        _pyaqcv.AqIntCameraViewFeaturesMap_swiginit(self, _pyaqcv.new_AqIntCameraViewFeaturesMap(*args))

    def empty(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_empty(self)

    def size(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_size(self)

    def swap(self, v):
        return _pyaqcv.AqIntCameraViewFeaturesMap_swap(self, v)

    def begin(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_begin(self)

    def end(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_end(self)

    def rbegin(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_rbegin(self)

    def rend(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_rend(self)

    def clear(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqIntCameraViewFeaturesMap_get_allocator(self)

    def count(self, x):
        return _pyaqcv.AqIntCameraViewFeaturesMap_count(self, x)

    def erase(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMap_erase(self, *args)

    def find(self, x):
        return _pyaqcv.AqIntCameraViewFeaturesMap_find(self, x)

    def lower_bound(self, x):
        return _pyaqcv.AqIntCameraViewFeaturesMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _pyaqcv.AqIntCameraViewFeaturesMap_upper_bound(self, x)
    __swig_destroy__ = _pyaqcv.delete_AqIntCameraViewFeaturesMap

# Register AqIntCameraViewFeaturesMap in _pyaqcv:
_pyaqcv.AqIntCameraViewFeaturesMap_swigregister(AqIntCameraViewFeaturesMap)
class AqIntCameraViewFeaturesMapVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_empty(self)

    def size(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_begin(self)

    def end(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_rend(self)

    def clear(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqIntCameraViewFeaturesMapVec_swiginit(self, _pyaqcv.new_AqIntCameraViewFeaturesMapVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_front(self)

    def back(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqIntCameraViewFeaturesMapVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqIntCameraViewFeaturesMapVec

# Register AqIntCameraViewFeaturesMapVec in _pyaqcv:
_pyaqcv.AqIntCameraViewFeaturesMapVec_swigregister(AqIntCameraViewFeaturesMapVec)
class AqBlobVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqBlobVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqBlobVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqBlobVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqBlobVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqBlobVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqBlobVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqBlobVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqBlobVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqBlobVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqBlobVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqBlobVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqBlobVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqBlobVec_empty(self)

    def size(self):
        return _pyaqcv.AqBlobVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqBlobVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqBlobVec_begin(self)

    def end(self):
        return _pyaqcv.AqBlobVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqBlobVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqBlobVec_rend(self)

    def clear(self):
        return _pyaqcv.AqBlobVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqBlobVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqBlobVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqBlobVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqBlobVec_swiginit(self, _pyaqcv.new_AqBlobVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqBlobVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqBlobVec_front(self)

    def back(self):
        return _pyaqcv.AqBlobVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqBlobVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqBlobVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqBlobVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqBlobVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqBlobVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqBlobVec

# Register AqBlobVec in _pyaqcv:
_pyaqcv.AqBlobVec_swigregister(AqBlobVec)
class AqBlobExcVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqBlobExcVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqBlobExcVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqBlobExcVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqBlobExcVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqBlobExcVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqBlobExcVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqBlobExcVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqBlobExcVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqBlobExcVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqBlobExcVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqBlobExcVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqBlobExcVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqBlobExcVec_empty(self)

    def size(self):
        return _pyaqcv.AqBlobExcVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqBlobExcVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqBlobExcVec_begin(self)

    def end(self):
        return _pyaqcv.AqBlobExcVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqBlobExcVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqBlobExcVec_rend(self)

    def clear(self):
        return _pyaqcv.AqBlobExcVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqBlobExcVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqBlobExcVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqBlobExcVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqBlobExcVec_swiginit(self, _pyaqcv.new_AqBlobExcVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqBlobExcVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqBlobExcVec_front(self)

    def back(self):
        return _pyaqcv.AqBlobExcVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqBlobExcVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqBlobExcVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqBlobExcVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqBlobExcVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqBlobExcVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqBlobExcVec

# Register AqBlobExcVec in _pyaqcv:
_pyaqcv.AqBlobExcVec_swigregister(AqBlobExcVec)
class AqBlobMorphOpTypeVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqBlobMorphOpTypeVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqBlobMorphOpTypeVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqBlobMorphOpTypeVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqBlobMorphOpTypeVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqBlobMorphOpTypeVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqBlobMorphOpTypeVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqBlobMorphOpTypeVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqBlobMorphOpTypeVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqBlobMorphOpTypeVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqBlobMorphOpTypeVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_empty(self)

    def size(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqBlobMorphOpTypeVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_begin(self)

    def end(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_rend(self)

    def clear(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqBlobMorphOpTypeVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqBlobMorphOpTypeVec_swiginit(self, _pyaqcv.new_AqBlobMorphOpTypeVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqBlobMorphOpTypeVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_front(self)

    def back(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqBlobMorphOpTypeVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqBlobMorphOpTypeVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqBlobMorphOpTypeVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqBlobMorphOpTypeVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqBlobMorphOpTypeVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqBlobMorphOpTypeVec

# Register AqBlobMorphOpTypeVec in _pyaqcv:
_pyaqcv.AqBlobMorphOpTypeVec_swigregister(AqBlobMorphOpTypeVec)
class AqTemplateMatchResultVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqTemplateMatchResultVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqTemplateMatchResultVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqTemplateMatchResultVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqTemplateMatchResultVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqTemplateMatchResultVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqTemplateMatchResultVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqTemplateMatchResultVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqTemplateMatchResultVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqTemplateMatchResultVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqTemplateMatchResultVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqTemplateMatchResultVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqTemplateMatchResultVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqTemplateMatchResultVec_empty(self)

    def size(self):
        return _pyaqcv.AqTemplateMatchResultVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqTemplateMatchResultVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqTemplateMatchResultVec_begin(self)

    def end(self):
        return _pyaqcv.AqTemplateMatchResultVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqTemplateMatchResultVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqTemplateMatchResultVec_rend(self)

    def clear(self):
        return _pyaqcv.AqTemplateMatchResultVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqTemplateMatchResultVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqTemplateMatchResultVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqTemplateMatchResultVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqTemplateMatchResultVec_swiginit(self, _pyaqcv.new_AqTemplateMatchResultVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqTemplateMatchResultVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqTemplateMatchResultVec_front(self)

    def back(self):
        return _pyaqcv.AqTemplateMatchResultVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqTemplateMatchResultVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqTemplateMatchResultVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqTemplateMatchResultVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqTemplateMatchResultVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqTemplateMatchResultVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqTemplateMatchResultVec

# Register AqTemplateMatchResultVec in _pyaqcv:
_pyaqcv.AqTemplateMatchResultVec_swigregister(AqTemplateMatchResultVec)
class AqRegionMatchResultVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqRegionMatchResultVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqRegionMatchResultVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqRegionMatchResultVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqRegionMatchResultVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqRegionMatchResultVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqRegionMatchResultVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqRegionMatchResultVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqRegionMatchResultVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqRegionMatchResultVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqRegionMatchResultVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqRegionMatchResultVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqRegionMatchResultVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqRegionMatchResultVec_empty(self)

    def size(self):
        return _pyaqcv.AqRegionMatchResultVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqRegionMatchResultVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqRegionMatchResultVec_begin(self)

    def end(self):
        return _pyaqcv.AqRegionMatchResultVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqRegionMatchResultVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqRegionMatchResultVec_rend(self)

    def clear(self):
        return _pyaqcv.AqRegionMatchResultVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqRegionMatchResultVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqRegionMatchResultVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqRegionMatchResultVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqRegionMatchResultVec_swiginit(self, _pyaqcv.new_AqRegionMatchResultVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqRegionMatchResultVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqRegionMatchResultVec_front(self)

    def back(self):
        return _pyaqcv.AqRegionMatchResultVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqRegionMatchResultVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqRegionMatchResultVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqRegionMatchResultVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqRegionMatchResultVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqRegionMatchResultVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqRegionMatchResultVec

# Register AqRegionMatchResultVec in _pyaqcv:
_pyaqcv.AqRegionMatchResultVec_swigregister(AqRegionMatchResultVec)
class AqPhotometricResultTypeVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqPhotometricResultTypeVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqPhotometricResultTypeVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqPhotometricResultTypeVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqPhotometricResultTypeVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqPhotometricResultTypeVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqPhotometricResultTypeVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqPhotometricResultTypeVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqPhotometricResultTypeVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqPhotometricResultTypeVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqPhotometricResultTypeVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqPhotometricResultTypeVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqPhotometricResultTypeVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqPhotometricResultTypeVec_empty(self)

    def size(self):
        return _pyaqcv.AqPhotometricResultTypeVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqPhotometricResultTypeVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqPhotometricResultTypeVec_begin(self)

    def end(self):
        return _pyaqcv.AqPhotometricResultTypeVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqPhotometricResultTypeVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqPhotometricResultTypeVec_rend(self)

    def clear(self):
        return _pyaqcv.AqPhotometricResultTypeVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqPhotometricResultTypeVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqPhotometricResultTypeVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqPhotometricResultTypeVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqPhotometricResultTypeVec_swiginit(self, _pyaqcv.new_AqPhotometricResultTypeVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqPhotometricResultTypeVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqPhotometricResultTypeVec_front(self)

    def back(self):
        return _pyaqcv.AqPhotometricResultTypeVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqPhotometricResultTypeVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqPhotometricResultTypeVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqPhotometricResultTypeVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqPhotometricResultTypeVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqPhotometricResultTypeVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqPhotometricResultTypeVec

# Register AqPhotometricResultTypeVec in _pyaqcv:
_pyaqcv.AqPhotometricResultTypeVec_swigregister(AqPhotometricResultTypeVec)
class AqKeyPointVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqKeyPointVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqKeyPointVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqKeyPointVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqKeyPointVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqKeyPointVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqKeyPointVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqKeyPointVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqKeyPointVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqKeyPointVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqKeyPointVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqKeyPointVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqKeyPointVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqKeyPointVec_empty(self)

    def size(self):
        return _pyaqcv.AqKeyPointVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqKeyPointVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqKeyPointVec_begin(self)

    def end(self):
        return _pyaqcv.AqKeyPointVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqKeyPointVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqKeyPointVec_rend(self)

    def clear(self):
        return _pyaqcv.AqKeyPointVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqKeyPointVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqKeyPointVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqKeyPointVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqKeyPointVec_swiginit(self, _pyaqcv.new_AqKeyPointVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqKeyPointVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqKeyPointVec_front(self)

    def back(self):
        return _pyaqcv.AqKeyPointVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqKeyPointVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqKeyPointVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqKeyPointVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqKeyPointVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqKeyPointVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqKeyPointVec

# Register AqKeyPointVec in _pyaqcv:
_pyaqcv.AqKeyPointVec_swigregister(AqKeyPointVec)
class AqLabelRegionVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqLabelRegionVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqLabelRegionVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqLabelRegionVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqLabelRegionVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqLabelRegionVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqLabelRegionVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqLabelRegionVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqLabelRegionVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqLabelRegionVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqLabelRegionVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqLabelRegionVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqLabelRegionVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqLabelRegionVec_empty(self)

    def size(self):
        return _pyaqcv.AqLabelRegionVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqLabelRegionVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqLabelRegionVec_begin(self)

    def end(self):
        return _pyaqcv.AqLabelRegionVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqLabelRegionVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqLabelRegionVec_rend(self)

    def clear(self):
        return _pyaqcv.AqLabelRegionVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqLabelRegionVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqLabelRegionVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqLabelRegionVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqLabelRegionVec_swiginit(self, _pyaqcv.new_AqLabelRegionVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqLabelRegionVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqLabelRegionVec_front(self)

    def back(self):
        return _pyaqcv.AqLabelRegionVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqLabelRegionVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqLabelRegionVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqLabelRegionVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqLabelRegionVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqLabelRegionVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqLabelRegionVec

# Register AqLabelRegionVec in _pyaqcv:
_pyaqcv.AqLabelRegionVec_swigregister(AqLabelRegionVec)
class AqEdgeFlawVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqEdgeFlawVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqEdgeFlawVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqEdgeFlawVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqEdgeFlawVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqEdgeFlawVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqEdgeFlawVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqEdgeFlawVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqEdgeFlawVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqEdgeFlawVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqEdgeFlawVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqEdgeFlawVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqEdgeFlawVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqEdgeFlawVec_empty(self)

    def size(self):
        return _pyaqcv.AqEdgeFlawVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqEdgeFlawVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqEdgeFlawVec_begin(self)

    def end(self):
        return _pyaqcv.AqEdgeFlawVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqEdgeFlawVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqEdgeFlawVec_rend(self)

    def clear(self):
        return _pyaqcv.AqEdgeFlawVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqEdgeFlawVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqEdgeFlawVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqEdgeFlawVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqEdgeFlawVec_swiginit(self, _pyaqcv.new_AqEdgeFlawVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqEdgeFlawVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqEdgeFlawVec_front(self)

    def back(self):
        return _pyaqcv.AqEdgeFlawVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqEdgeFlawVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqEdgeFlawVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqEdgeFlawVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqEdgeFlawVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqEdgeFlawVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqEdgeFlawVec

# Register AqEdgeFlawVec in _pyaqcv:
_pyaqcv.AqEdgeFlawVec_swigregister(AqEdgeFlawVec)
class AqCaliperSingleEdgeResultVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_empty(self)

    def size(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_begin(self)

    def end(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_rend(self)

    def clear(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqCaliperSingleEdgeResultVec_swiginit(self, _pyaqcv.new_AqCaliperSingleEdgeResultVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_front(self)

    def back(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqCaliperSingleEdgeResultVec

# Register AqCaliperSingleEdgeResultVec in _pyaqcv:
_pyaqcv.AqCaliperSingleEdgeResultVec_swigregister(AqCaliperSingleEdgeResultVec)
class AqCaliperSingleEdgeResultVecVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_empty(self)

    def size(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_begin(self)

    def end(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_rend(self)

    def clear(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqCaliperSingleEdgeResultVecVec_swiginit(self, _pyaqcv.new_AqCaliperSingleEdgeResultVecVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_front(self)

    def back(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqCaliperSingleEdgeResultVecVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqCaliperSingleEdgeResultVecVec

# Register AqCaliperSingleEdgeResultVecVec in _pyaqcv:
_pyaqcv.AqCaliperSingleEdgeResultVecVec_swigregister(AqCaliperSingleEdgeResultVecVec)
class AqCaliperDualEdgeResultVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqCaliperDualEdgeResultVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqCaliperDualEdgeResultVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqCaliperDualEdgeResultVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_empty(self)

    def size(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqCaliperDualEdgeResultVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_begin(self)

    def end(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_rend(self)

    def clear(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqCaliperDualEdgeResultVec_swiginit(self, _pyaqcv.new_AqCaliperDualEdgeResultVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqCaliperDualEdgeResultVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_front(self)

    def back(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqCaliperDualEdgeResultVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqCaliperDualEdgeResultVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqCaliperDualEdgeResultVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqCaliperDualEdgeResultVec

# Register AqCaliperDualEdgeResultVec in _pyaqcv:
_pyaqcv.AqCaliperDualEdgeResultVec_swigregister(AqCaliperDualEdgeResultVec)
class AqCaliperDualEdgeResultVecVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_empty(self)

    def size(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_begin(self)

    def end(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_rend(self)

    def clear(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqCaliperDualEdgeResultVecVec_swiginit(self, _pyaqcv.new_AqCaliperDualEdgeResultVecVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_front(self)

    def back(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqCaliperDualEdgeResultVecVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqCaliperDualEdgeResultVecVec

# Register AqCaliperDualEdgeResultVecVec in _pyaqcv:
_pyaqcv.AqCaliperDualEdgeResultVecVec_swigregister(AqCaliperDualEdgeResultVecVec)
class AqCircularAnnulusSectionVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqCircularAnnulusSectionVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqCircularAnnulusSectionVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqCircularAnnulusSectionVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqCircularAnnulusSectionVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqCircularAnnulusSectionVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqCircularAnnulusSectionVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqCircularAnnulusSectionVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqCircularAnnulusSectionVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqCircularAnnulusSectionVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqCircularAnnulusSectionVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_empty(self)

    def size(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqCircularAnnulusSectionVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_begin(self)

    def end(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_rend(self)

    def clear(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqCircularAnnulusSectionVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqCircularAnnulusSectionVec_swiginit(self, _pyaqcv.new_AqCircularAnnulusSectionVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqCircularAnnulusSectionVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_front(self)

    def back(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqCircularAnnulusSectionVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqCircularAnnulusSectionVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqCircularAnnulusSectionVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqCircularAnnulusSectionVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqCircularAnnulusSectionVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqCircularAnnulusSectionVec

# Register AqCircularAnnulusSectionVec in _pyaqcv:
_pyaqcv.AqCircularAnnulusSectionVec_swigregister(AqCircularAnnulusSectionVec)
class AqEdgeWidthVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqEdgeWidthVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqEdgeWidthVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqEdgeWidthVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqEdgeWidthVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqEdgeWidthVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqEdgeWidthVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqEdgeWidthVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqEdgeWidthVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqEdgeWidthVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqEdgeWidthVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqEdgeWidthVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqEdgeWidthVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqEdgeWidthVec_empty(self)

    def size(self):
        return _pyaqcv.AqEdgeWidthVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqEdgeWidthVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqEdgeWidthVec_begin(self)

    def end(self):
        return _pyaqcv.AqEdgeWidthVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqEdgeWidthVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqEdgeWidthVec_rend(self)

    def clear(self):
        return _pyaqcv.AqEdgeWidthVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqEdgeWidthVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqEdgeWidthVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqEdgeWidthVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqEdgeWidthVec_swiginit(self, _pyaqcv.new_AqEdgeWidthVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqEdgeWidthVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqEdgeWidthVec_front(self)

    def back(self):
        return _pyaqcv.AqEdgeWidthVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqEdgeWidthVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqEdgeWidthVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqEdgeWidthVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqEdgeWidthVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqEdgeWidthVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqEdgeWidthVec

# Register AqEdgeWidthVec in _pyaqcv:
_pyaqcv.AqEdgeWidthVec_swigregister(AqEdgeWidthVec)
class AqEdgeWidthVecVev(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqEdgeWidthVecVev_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqEdgeWidthVecVev___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqEdgeWidthVecVev___bool__(self)

    def __len__(self):
        return _pyaqcv.AqEdgeWidthVecVev___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqEdgeWidthVecVev___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqEdgeWidthVecVev___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqEdgeWidthVecVev___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqEdgeWidthVecVev___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqEdgeWidthVecVev___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqEdgeWidthVecVev___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqEdgeWidthVecVev_pop(self)

    def append(self, x):
        return _pyaqcv.AqEdgeWidthVecVev_append(self, x)

    def empty(self):
        return _pyaqcv.AqEdgeWidthVecVev_empty(self)

    def size(self):
        return _pyaqcv.AqEdgeWidthVecVev_size(self)

    def swap(self, v):
        return _pyaqcv.AqEdgeWidthVecVev_swap(self, v)

    def begin(self):
        return _pyaqcv.AqEdgeWidthVecVev_begin(self)

    def end(self):
        return _pyaqcv.AqEdgeWidthVecVev_end(self)

    def rbegin(self):
        return _pyaqcv.AqEdgeWidthVecVev_rbegin(self)

    def rend(self):
        return _pyaqcv.AqEdgeWidthVecVev_rend(self)

    def clear(self):
        return _pyaqcv.AqEdgeWidthVecVev_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqEdgeWidthVecVev_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqEdgeWidthVecVev_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqEdgeWidthVecVev_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqEdgeWidthVecVev_swiginit(self, _pyaqcv.new_AqEdgeWidthVecVev(*args))

    def push_back(self, x):
        return _pyaqcv.AqEdgeWidthVecVev_push_back(self, x)

    def front(self):
        return _pyaqcv.AqEdgeWidthVecVev_front(self)

    def back(self):
        return _pyaqcv.AqEdgeWidthVecVev_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqEdgeWidthVecVev_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqEdgeWidthVecVev_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqEdgeWidthVecVev_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqEdgeWidthVecVev_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqEdgeWidthVecVev_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqEdgeWidthVecVev

# Register AqEdgeWidthVecVev in _pyaqcv:
_pyaqcv.AqEdgeWidthVecVev_swigregister(AqEdgeWidthVecVev)
class AQEdgePolarityTypeVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AQEdgePolarityTypeVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AQEdgePolarityTypeVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AQEdgePolarityTypeVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AQEdgePolarityTypeVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AQEdgePolarityTypeVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AQEdgePolarityTypeVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AQEdgePolarityTypeVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AQEdgePolarityTypeVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AQEdgePolarityTypeVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AQEdgePolarityTypeVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AQEdgePolarityTypeVec_pop(self)

    def append(self, x):
        return _pyaqcv.AQEdgePolarityTypeVec_append(self, x)

    def empty(self):
        return _pyaqcv.AQEdgePolarityTypeVec_empty(self)

    def size(self):
        return _pyaqcv.AQEdgePolarityTypeVec_size(self)

    def swap(self, v):
        return _pyaqcv.AQEdgePolarityTypeVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AQEdgePolarityTypeVec_begin(self)

    def end(self):
        return _pyaqcv.AQEdgePolarityTypeVec_end(self)

    def rbegin(self):
        return _pyaqcv.AQEdgePolarityTypeVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AQEdgePolarityTypeVec_rend(self)

    def clear(self):
        return _pyaqcv.AQEdgePolarityTypeVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AQEdgePolarityTypeVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AQEdgePolarityTypeVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AQEdgePolarityTypeVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AQEdgePolarityTypeVec_swiginit(self, _pyaqcv.new_AQEdgePolarityTypeVec(*args))

    def push_back(self, x):
        return _pyaqcv.AQEdgePolarityTypeVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AQEdgePolarityTypeVec_front(self)

    def back(self):
        return _pyaqcv.AQEdgePolarityTypeVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AQEdgePolarityTypeVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AQEdgePolarityTypeVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AQEdgePolarityTypeVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AQEdgePolarityTypeVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AQEdgePolarityTypeVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AQEdgePolarityTypeVec

# Register AQEdgePolarityTypeVec in _pyaqcv:
_pyaqcv.AQEdgePolarityTypeVec_swigregister(AQEdgePolarityTypeVec)
class AqBarTypeVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqBarTypeVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqBarTypeVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqBarTypeVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqBarTypeVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqBarTypeVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqBarTypeVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqBarTypeVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqBarTypeVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqBarTypeVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqBarTypeVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqBarTypeVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqBarTypeVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqBarTypeVec_empty(self)

    def size(self):
        return _pyaqcv.AqBarTypeVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqBarTypeVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqBarTypeVec_begin(self)

    def end(self):
        return _pyaqcv.AqBarTypeVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqBarTypeVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqBarTypeVec_rend(self)

    def clear(self):
        return _pyaqcv.AqBarTypeVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqBarTypeVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqBarTypeVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqBarTypeVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqBarTypeVec_swiginit(self, _pyaqcv.new_AqBarTypeVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqBarTypeVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqBarTypeVec_front(self)

    def back(self):
        return _pyaqcv.AqBarTypeVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqBarTypeVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqBarTypeVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqBarTypeVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqBarTypeVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqBarTypeVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqBarTypeVec

# Register AqBarTypeVec in _pyaqcv:
_pyaqcv.AqBarTypeVec_swigregister(AqBarTypeVec)
class AqBarcodeResultVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqBarcodeResultVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqBarcodeResultVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqBarcodeResultVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqBarcodeResultVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqBarcodeResultVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqBarcodeResultVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqBarcodeResultVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqBarcodeResultVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqBarcodeResultVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqBarcodeResultVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqBarcodeResultVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqBarcodeResultVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqBarcodeResultVec_empty(self)

    def size(self):
        return _pyaqcv.AqBarcodeResultVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqBarcodeResultVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqBarcodeResultVec_begin(self)

    def end(self):
        return _pyaqcv.AqBarcodeResultVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqBarcodeResultVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqBarcodeResultVec_rend(self)

    def clear(self):
        return _pyaqcv.AqBarcodeResultVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqBarcodeResultVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqBarcodeResultVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqBarcodeResultVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqBarcodeResultVec_swiginit(self, _pyaqcv.new_AqBarcodeResultVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqBarcodeResultVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqBarcodeResultVec_front(self)

    def back(self):
        return _pyaqcv.AqBarcodeResultVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqBarcodeResultVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqBarcodeResultVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqBarcodeResultVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqBarcodeResultVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqBarcodeResultVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqBarcodeResultVec

# Register AqBarcodeResultVec in _pyaqcv:
_pyaqcv.AqBarcodeResultVec_swigregister(AqBarcodeResultVec)
class AqCode2DResultVec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _pyaqcv.AqCode2DResultVec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _pyaqcv.AqCode2DResultVec___nonzero__(self)

    def __bool__(self):
        return _pyaqcv.AqCode2DResultVec___bool__(self)

    def __len__(self):
        return _pyaqcv.AqCode2DResultVec___len__(self)

    def __getslice__(self, i, j):
        return _pyaqcv.AqCode2DResultVec___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _pyaqcv.AqCode2DResultVec___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _pyaqcv.AqCode2DResultVec___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _pyaqcv.AqCode2DResultVec___delitem__(self, *args)

    def __getitem__(self, *args):
        return _pyaqcv.AqCode2DResultVec___getitem__(self, *args)

    def __setitem__(self, *args):
        return _pyaqcv.AqCode2DResultVec___setitem__(self, *args)

    def pop(self):
        return _pyaqcv.AqCode2DResultVec_pop(self)

    def append(self, x):
        return _pyaqcv.AqCode2DResultVec_append(self, x)

    def empty(self):
        return _pyaqcv.AqCode2DResultVec_empty(self)

    def size(self):
        return _pyaqcv.AqCode2DResultVec_size(self)

    def swap(self, v):
        return _pyaqcv.AqCode2DResultVec_swap(self, v)

    def begin(self):
        return _pyaqcv.AqCode2DResultVec_begin(self)

    def end(self):
        return _pyaqcv.AqCode2DResultVec_end(self)

    def rbegin(self):
        return _pyaqcv.AqCode2DResultVec_rbegin(self)

    def rend(self):
        return _pyaqcv.AqCode2DResultVec_rend(self)

    def clear(self):
        return _pyaqcv.AqCode2DResultVec_clear(self)

    def get_allocator(self):
        return _pyaqcv.AqCode2DResultVec_get_allocator(self)

    def pop_back(self):
        return _pyaqcv.AqCode2DResultVec_pop_back(self)

    def erase(self, *args):
        return _pyaqcv.AqCode2DResultVec_erase(self, *args)

    def __init__(self, *args):
        _pyaqcv.AqCode2DResultVec_swiginit(self, _pyaqcv.new_AqCode2DResultVec(*args))

    def push_back(self, x):
        return _pyaqcv.AqCode2DResultVec_push_back(self, x)

    def front(self):
        return _pyaqcv.AqCode2DResultVec_front(self)

    def back(self):
        return _pyaqcv.AqCode2DResultVec_back(self)

    def assign(self, n, x):
        return _pyaqcv.AqCode2DResultVec_assign(self, n, x)

    def resize(self, *args):
        return _pyaqcv.AqCode2DResultVec_resize(self, *args)

    def insert(self, *args):
        return _pyaqcv.AqCode2DResultVec_insert(self, *args)

    def reserve(self, n):
        return _pyaqcv.AqCode2DResultVec_reserve(self, n)

    def capacity(self):
        return _pyaqcv.AqCode2DResultVec_capacity(self)
    __swig_destroy__ = _pyaqcv.delete_AqCode2DResultVec

# Register AqCode2DResultVec in _pyaqcv:
_pyaqcv.AqCode2DResultVec_swigregister(AqCode2DResultVec)
class IGeometry(object):
    r"""Common abstract base class for all plane geometry types"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    kRadian = _pyaqcv.IGeometry_kRadian
    kSize2f = _pyaqcv.IGeometry_kSize2f
    kSize2i = _pyaqcv.IGeometry_kSize2i
    kPoint2f = _pyaqcv.IGeometry_kPoint2f
    kPoint2i = _pyaqcv.IGeometry_kPoint2i
    kVector2f = _pyaqcv.IGeometry_kVector2f
    kVector2i = _pyaqcv.IGeometry_kVector2i
    kSegment2f = _pyaqcv.IGeometry_kSegment2f
    kSegment2i = _pyaqcv.IGeometry_kSegment2i
    kLine2f = _pyaqcv.IGeometry_kLine2f
    kRay2f = _pyaqcv.IGeometry_kRay2f
    kRay2i = _pyaqcv.IGeometry_kRay2i
    kRing2f = _pyaqcv.IGeometry_kRing2f
    kRing2i = _pyaqcv.IGeometry_kRing2i
    kRect2f = _pyaqcv.IGeometry_kRect2f
    kRect2i = _pyaqcv.IGeometry_kRect2i
    kPolygon2f = _pyaqcv.IGeometry_kPolygon2f
    kPolygon2i = _pyaqcv.IGeometry_kPolygon2i
    kRotateRect2f = _pyaqcv.IGeometry_kRotateRect2f
    kRotateRect2i = _pyaqcv.IGeometry_kRotateRect2i
    kArc2f = _pyaqcv.IGeometry_kArc2f
    kCircle2f = _pyaqcv.IGeometry_kCircle2f
    kCircle2i = _pyaqcv.IGeometry_kCircle2i
    kLineString2f = _pyaqcv.IGeometry_kLineString2f
    kLineString2i = _pyaqcv.IGeometry_kLineString2i
    kMultiPoint2f = _pyaqcv.IGeometry_kMultiPoint2f
    kMultiPoint2i = _pyaqcv.IGeometry_kMultiPoint2i
    kMultiPolygon2f = _pyaqcv.IGeometry_kMultiPolygon2f
    kMultiPolygon2i = _pyaqcv.IGeometry_kMultiPolygon2i
    kEllipse2f = _pyaqcv.IGeometry_kEllipse2f
    kMultiSegment2f = _pyaqcv.IGeometry_kMultiSegment2f
    kMultiLineString2f = _pyaqcv.IGeometry_kMultiLineString2f
    kMultiLineString2i = _pyaqcv.IGeometry_kMultiLineString2i

    def type(self):
        r"""
        Enumerate value of geometry types.

        :rtype: int
        :return: GeometryType
        """
        return _pyaqcv.IGeometry_type(self)

    def type_name(self):
        r"""
        Name of geometry types.

        :rtype: string
        :return: const char*
        """
        return _pyaqcv.IGeometry_type_name(self)
    __swig_destroy__ = _pyaqcv.delete_IGeometry

# Register IGeometry in _pyaqcv:
_pyaqcv.IGeometry_swigregister(IGeometry)
cvar = _pyaqcv.cvar
kPi = cvar.kPi
kEpsilon = cvar.kEpsilon

class Radian(IGeometry):
    r"""
    Can easily get the degree of the radian conversion.

    The direction from the positive direction of the x-axis to the
    positive direction of the y-axis is positive direction of the angle
    defination.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def FromDegree(degree):
        r"""
        Construct radian from degree.

        :type degree: float
        :param degree:
        :rtype: :py:class:`Radian`
        :return: Radian
        """
        return _pyaqcv.Radian_FromDegree(degree)

    def type(self):
        return _pyaqcv.Radian_type(self)

    def __init__(self, radian=0):
        r"""
        Construct a new Radian object.

        :type radian: float, optional
        :param radian: Radian.
        """
        _pyaqcv.Radian_swiginit(self, _pyaqcv.new_Radian(radian))

    def __eq__(self, rhs):
        r"""
        Check if two Radian are equal.

        :type rhs: :py:class:`Radian`
        :param rhs: Other Radian.
        :rtype: boolean
        :return: true if two Radian are equal.
        """
        return _pyaqcv.Radian___eq__(self, rhs)

    def __ne__(self, other):
        r"""
        Check if two Radian are not equal to each other.

        :type other: :py:class:`Radian`
        :param other:
        :rtype: boolean
        :return: true if not equal
        """
        return _pyaqcv.Radian___ne__(self, other)

    def __neg__(self):
        r"""
        Get negative Radian.

        :rtype: :py:class:`Radian`
        :return: Radian negative Radian.
        """
        return _pyaqcv.Radian___neg__(self)

    def __isub__(self, rhs):
        return _pyaqcv.Radian___isub__(self, rhs)

    def __iadd__(self, rhs):
        return _pyaqcv.Radian___iadd__(self, rhs)

    def __sub__(self, rhs):
        return _pyaqcv.Radian___sub__(self, rhs)

    def __add__(self, rhs):
        return _pyaqcv.Radian___add__(self, rhs)

    def norm(self, *args):
        r"""
        Normalize the radian into [0, mod)

        :type mod: float, optional
        :param mod: Divisor.
        :rtype: :py:class:`Radian`
        :return: NO_DISCARD Radian in [0, mod)
        """
        return _pyaqcv.Radian_norm(self, *args)

    def degree(self):
        r"""
        Get the degree of the radian conversion.

        :rtype: float
        :return: NO_DISCARD float degree.
        """
        return _pyaqcv.Radian_degree(self)

    def from_degree(self, degree):
        r"""
        Set the radian of the degree conversion.

        :type degree: float
        :param degree: Degree.
        :rtype: :py:class:`Radian`
        :return: Radian& reference to this object.
        """
        return _pyaqcv.Radian_from_degree(self, degree)

    def unit_vector(self):
        r"""
        Get Radian correspond to unit vector.

        The direction of the unit vector is the same as the direction of
        the Radian, i.e. from the positive direction of the x-axis to the positive
        direction of the y-axis is positive direction of the angle defination.
        :rtype: :py:class:`Vector2f`
        :return: NO_DISCARD Vector2f unit vector in the same direction as the
            Radian.
        """
        return _pyaqcv.Radian_unit_vector(self)
    radian = property(_pyaqcv.Radian_radian_get, _pyaqcv.Radian_radian_set, doc=r"""Radian data.""")
    __swig_destroy__ = _pyaqcv.delete_Radian

# Register Radian in _pyaqcv:
_pyaqcv.Radian_swigregister(Radian)
class Vector2f(IGeometry):
    r"""
    A floating-point vector with size and direction from the origin point
    (0, 0).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor,no initialization.

        |

        *Overload 2:*
        Constructor to set two values.

        |

        *Overload 3:*
        Constructor to set a Point.

        |

        *Overload 4:*
        Construct a new Vecotr with number type conversion.
        """
        _pyaqcv.Vector2f_swiginit(self, _pyaqcv.new_Vector2f(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Vector2f___eq__(self, rhs)

    def __neg__(self):
        r"""Inversion of vectors"""
        return _pyaqcv.Vector2f___neg__(self)

    def __add__(self, rhs):
        r"""Addition of vectors"""
        return _pyaqcv.Vector2f___add__(self, rhs)

    def __sub__(self, rhs):
        r"""Subtraction of vectors"""
        return _pyaqcv.Vector2f___sub__(self, rhs)

    def __truediv__(self, *args):
        return _pyaqcv.Vector2f___truediv__(self, *args)
    __div__ = __truediv__



    def __mul__(self, *args):
        r"""
        *Overload 1:*
        Amplification of vectors

        |

        *Overload 2:*
        vector product
        """
        return _pyaqcv.Vector2f___mul__(self, *args)

    def __iadd__(self, rhs):
        r"""Addition of vectors"""
        return _pyaqcv.Vector2f___iadd__(self, rhs)

    def __isub__(self, rhs):
        r"""Subtraction of vectors"""
        return _pyaqcv.Vector2f___isub__(self, rhs)

    def __imul__(self, rhs):
        r"""Amplification of vectors"""
        return _pyaqcv.Vector2f___imul__(self, rhs)

    def __itruediv__(self, *args):
        return _pyaqcv.Vector2f___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def type(self):
        return _pyaqcv.Vector2f_type(self)

    def azimuth(self):
        r"""
        Azimuth of vectors

        :rtype: :py:class:`Radian`
        :return: The radian of the rotation of the vector from the positive
            direction of the x-axis to the positive direction of the y-axis(±π).
        """
        return _pyaqcv.Vector2f_azimuth(self)

    def length(self):
        r"""
        Modulus of a vector

        :rtype: float
        :return: float Modulus length.
        """
        return _pyaqcv.Vector2f_length(self)
    x = property(_pyaqcv.Vector2f_x_get, _pyaqcv.Vector2f_x_set)
    y = property(_pyaqcv.Vector2f_y_get, _pyaqcv.Vector2f_y_set)
    __swig_destroy__ = _pyaqcv.delete_Vector2f

# Register Vector2f in _pyaqcv:
_pyaqcv.Vector2f_swigregister(Vector2f)
class Vector2i(IGeometry):
    r"""Integer vector with size and direction from the origin (0,0)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor.

        |

        *Overload 2:*
        Constructor to set two values.

        |

        *Overload 3:*
        Constructor to set a Point.
        """
        _pyaqcv.Vector2i_swiginit(self, _pyaqcv.new_Vector2i(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Vector2i___eq__(self, rhs)

    def __neg__(self):
        r"""Inversion of vectors"""
        return _pyaqcv.Vector2i___neg__(self)

    def __add__(self, rhs):
        r"""Addition of vectors"""
        return _pyaqcv.Vector2i___add__(self, rhs)

    def __sub__(self, rhs):
        r"""Subtraction of vectors"""
        return _pyaqcv.Vector2i___sub__(self, rhs)

    def __truediv__(self, *args):
        return _pyaqcv.Vector2i___truediv__(self, *args)
    __div__ = __truediv__



    def __mul__(self, *args):
        r"""
        *Overload 1:*
        Amplification of vectors

        |

        *Overload 2:*
        vector product
        """
        return _pyaqcv.Vector2i___mul__(self, *args)

    def __iadd__(self, rhs):
        r"""Addition of vectors"""
        return _pyaqcv.Vector2i___iadd__(self, rhs)

    def __isub__(self, rhs):
        r"""Subtraction of vectors"""
        return _pyaqcv.Vector2i___isub__(self, rhs)

    def __imul__(self, rhs):
        r"""Amplification of vectors"""
        return _pyaqcv.Vector2i___imul__(self, rhs)

    def __itruediv__(self, *args):
        return _pyaqcv.Vector2i___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def type(self):
        return _pyaqcv.Vector2i_type(self)

    def azimuth(self):
        r"""Azimuth of vectors"""
        return _pyaqcv.Vector2i_azimuth(self)

    def length(self):
        r"""
        Modulus of a vector

        :rtype: float
        :return: float Modulus length
        """
        return _pyaqcv.Vector2i_length(self)
    x = property(_pyaqcv.Vector2i_x_get, _pyaqcv.Vector2i_x_set)
    y = property(_pyaqcv.Vector2i_y_get, _pyaqcv.Vector2i_y_set)
    __swig_destroy__ = _pyaqcv.delete_Vector2i

# Register Vector2i in _pyaqcv:
_pyaqcv.Vector2i_swigregister(Vector2i)
class Point2f(IGeometry):
    r"""Floating point coordinate points"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor,no initialization.

        |

        *Overload 2:*
        Construct a new Point with number type conversion.

        |

        *Overload 3:*
        Constructor to set two values.

        |

        *Overload 4:*
        Constructor to set a Vector.
        """
        _pyaqcv.Point2f_swiginit(self, _pyaqcv.new_Point2f(*args))

    def __eq__(self, *args):
        r"""Numerical comparison with vectors of the same type."""
        return _pyaqcv.Point2f___eq__(self, *args)

    def __add__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2f___add__(self, rhs)

    def __sub__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2f___sub__(self, rhs)

    def __truediv__(self, *args):
        return _pyaqcv.Point2f___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2f___iadd__(self, rhs)

    def __isub__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2f___isub__(self, rhs)

    def __imul__(self, rhs):
        r"""Enlarge point coordinates"""
        return _pyaqcv.Point2f___imul__(self, rhs)

    def __itruediv__(self, *args):
        return _pyaqcv.Point2f___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __mul__(self, *args):
        r"""
        *Overload 1:*
        Enlarge point coordinates

        |

        *Overload 2:*
        点积
        """
        return _pyaqcv.Point2f___mul__(self, *args)

    def type(self):
        return _pyaqcv.Point2f_type(self)
    x = property(_pyaqcv.Point2f_x_get, _pyaqcv.Point2f_x_set)
    y = property(_pyaqcv.Point2f_y_get, _pyaqcv.Point2f_y_set)
    __swig_destroy__ = _pyaqcv.delete_Point2f

# Register Point2f in _pyaqcv:
_pyaqcv.Point2f_swigregister(Point2f)
class Point2i(IGeometry):
    r"""整型点"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor,no initialization.

        |

        *Overload 2:*
        Construct a new Point with number type conversion (round to the nearest integer number).

        |

        *Overload 3:*
        Constructor to set two values.

        |

        *Overload 4:*
        Constructor to set a Vector.
        """
        _pyaqcv.Point2i_swiginit(self, _pyaqcv.new_Point2i(*args))

    def __eq__(self, *args):
        r"""
        Numerical comparison with vectors of the same type.

        :type rhs: :py:class:`Vector`
        :param rhs: Vector to compare
        :rtype: boolean
        :return: true if equal
        :rtype: boolean
        :return: false
        """
        return _pyaqcv.Point2i___eq__(self, *args)

    def __add__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2i___add__(self, rhs)

    def __sub__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2i___sub__(self, rhs)

    def __truediv__(self, *args):
        return _pyaqcv.Point2i___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2i___iadd__(self, rhs)

    def __isub__(self, rhs):
        r"""Translation of points"""
        return _pyaqcv.Point2i___isub__(self, rhs)

    def __imul__(self, rhs):
        r"""Enlarge point coordinates"""
        return _pyaqcv.Point2i___imul__(self, rhs)

    def __itruediv__(self, *args):
        return _pyaqcv.Point2i___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __mul__(self, *args):
        r"""
        *Overload 1:*
        Enlarge point coordinates

        |

        *Overload 2:*
        dot product
        """
        return _pyaqcv.Point2i___mul__(self, *args)

    def type(self):
        return _pyaqcv.Point2i_type(self)
    x = property(_pyaqcv.Point2i_x_get, _pyaqcv.Point2i_x_set)
    y = property(_pyaqcv.Point2i_y_get, _pyaqcv.Point2i_y_set)
    __swig_destroy__ = _pyaqcv.delete_Point2i

# Register Point2i in _pyaqcv:
_pyaqcv.Point2i_swigregister(Point2i)
class Segment2f(Point2fPair, IGeometry):
    r"""Floating point line segments"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, no initialization.

        |

        *Overload 2:*
        Construct a new Segment with number type conversion.

        |

        *Overload 3:*
        Constructor to set two Points.

        |

        *Overload 4:*
        Constructor to set Point,direction Vector and distance.
        """
        _pyaqcv.Segment2f_swiginit(self, _pyaqcv.new_Segment2f(*args))

    def type(self):
        return _pyaqcv.Segment2f_type(self)

    def length(self):
        r"""Length of line segment."""
        return _pyaqcv.Segment2f_length(self)

    def in_line(self):
        r"""The line where the line segment is located."""
        return _pyaqcv.Segment2f_in_line(self)

    def azimuth(self):
        r"""Azimuth of a line segment."""
        return _pyaqcv.Segment2f_azimuth(self)

    def is_point(self):
        r"""
        Check if the Segment is equal to a Point.

        :rtype: boolean
        :return: NO_DISCARD true if the ends of Segment are the same.
        """
        return _pyaqcv.Segment2f_is_point(self)
    __swig_destroy__ = _pyaqcv.delete_Segment2f

# Register Segment2f in _pyaqcv:
_pyaqcv.Segment2f_swigregister(Segment2f)
class Segment2i(Point2iPair, IGeometry):
    r"""Integral line segments"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, no initialization.

        |

        *Overload 2:*
        Constructor to set two Points.

        |

        *Overload 3:*
        Constructor to set Point,direction Vector and distance.
        """
        _pyaqcv.Segment2i_swiginit(self, _pyaqcv.new_Segment2i(*args))

    def type(self):
        return _pyaqcv.Segment2i_type(self)

    def length(self):
        r"""Length of line segment."""
        return _pyaqcv.Segment2i_length(self)

    def in_line(self):
        r"""The line where the line segment is located."""
        return _pyaqcv.Segment2i_in_line(self)

    def azimuth(self):
        r"""Azimuth of a line segment."""
        return _pyaqcv.Segment2i_azimuth(self)

    def is_point(self):
        r"""
        Check if the Segment is equal to a Point.

        :rtype: boolean
        :return: NO_DISCARD true if the ends of Segment are the same.
        """
        return _pyaqcv.Segment2i_is_point(self)
    __swig_destroy__ = _pyaqcv.delete_Segment2i

# Register Segment2i in _pyaqcv:
_pyaqcv.Segment2i_swigregister(Segment2i)
class Line2f(IGeometry):
    r"""浮点型直线"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor to set ax+by+c=0.

        |

        *Overload 2:*
        Constructor to set two Points.

        |

        *Overload 3:*
        Constructor to set Point and direction Vector.

        |

        *Overload 4:*
        Constructor to set a Segment.

        |

        *Overload 5:*
        Constructor to set a Segment.
        """
        _pyaqcv.Line2f_swiginit(self, _pyaqcv.new_Line2f(*args))

    def type(self):
        return _pyaqcv.Line2f_type(self)

    def passing_point(self):
        r"""
        直线的经过点.

        优先返回y轴交点,其次返回x轴交点.
        :rtype: :py:class:`Point`
        :return: NO_DISCARD Point
        """
        return _pyaqcv.Line2f_passing_point(self)

    def azimuth(self):
        r"""直线的方位角."""
        return _pyaqcv.Line2f_azimuth(self)

    def intersection_by_y(self, value):
        r"""
        Intersection of a line parallel to the x-axis.


        - If there is no intersection it will return Point(INT_MIN, INT_MIN)
        - If there is a complete overlap it will return Point(0, value)
        :type value: float
        :param value: The line y = value.
        :rtype: :py:class:`Point`
        :return: NO_DISCARD Point the intersection.
        """
        return _pyaqcv.Line2f_intersection_by_y(self, value)

    def intersection_by_x(self, value):
        r"""
        Intersection of a line parallel to the y-axis.


        - If there is no intersection it will return Point(INT_MIN, INT_MIN)
        - If there is a complete overlap it will return Point(value, 0)
        :type value: float
        :param value: The line x = value.
        :rtype: :py:class:`Point`
        :return: NO_DISCARD Point the intersection.
        """
        return _pyaqcv.Line2f_intersection_by_x(self, value)
    a = property(_pyaqcv.Line2f_a_get, _pyaqcv.Line2f_a_set)
    b = property(_pyaqcv.Line2f_b_get, _pyaqcv.Line2f_b_set)
    c = property(_pyaqcv.Line2f_c_get, _pyaqcv.Line2f_c_set)
    __swig_destroy__ = _pyaqcv.delete_Line2f

# Register Line2f in _pyaqcv:
_pyaqcv.Line2f_swigregister(Line2f)
class Ray2f(IGeometry):
    r"""浮点型射线"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor to set Point and direction Vector.

        |

        *Overload 2:*
        Constructor to set two Points.
        """
        _pyaqcv.Ray2f_swiginit(self, _pyaqcv.new_Ray2f(*args))

    def type(self):
        return _pyaqcv.Ray2f_type(self)

    def azimuth(self):
        r"""射线的方位角."""
        return _pyaqcv.Ray2f_azimuth(self)

    def in_line(self):
        r"""射线所在直线."""
        return _pyaqcv.Ray2f_in_line(self)
    start = property(_pyaqcv.Ray2f_start_get, _pyaqcv.Ray2f_start_set, doc=r"""射线起始点.""")
    direction = property(_pyaqcv.Ray2f_direction_get, _pyaqcv.Ray2f_direction_set, doc=r"""射线对应的方向向量.""")
    __swig_destroy__ = _pyaqcv.delete_Ray2f

# Register Ray2f in _pyaqcv:
_pyaqcv.Ray2f_swigregister(Ray2f)
class Ray2i(IGeometry):
    r"""整型射线"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor to set Point and direction Vector.

        |

        *Overload 2:*
        Constructor to set two Points.
        """
        _pyaqcv.Ray2i_swiginit(self, _pyaqcv.new_Ray2i(*args))

    def type(self):
        return _pyaqcv.Ray2i_type(self)

    def azimuth(self):
        r"""射线的方位角."""
        return _pyaqcv.Ray2i_azimuth(self)

    def in_line(self):
        r"""射线所在直线."""
        return _pyaqcv.Ray2i_in_line(self)
    start = property(_pyaqcv.Ray2i_start_get, _pyaqcv.Ray2i_start_set, doc=r"""射线起始点.""")
    direction = property(_pyaqcv.Ray2i_direction_get, _pyaqcv.Ray2i_direction_set, doc=r"""射线对应的方向向量.""")
    __swig_destroy__ = _pyaqcv.delete_Ray2i

# Register Ray2i in _pyaqcv:
_pyaqcv.Ray2i_swigregister(Ray2i)
class LineString2f(Point2fVec, IGeometry):
    r"""
    浮点型线

    一条线被认为是一些点的集合(std::vector),且按一定顺序连接相邻两点形成折线段.
    Notes: 线可以是自交的,但这对于某些算法会产生错误的影响.可以通过 see
    is_simple() 检测是否自交等问题.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor,creating an empty LineString.

        |

        *Overload 2:*
         Construct a new LineString with number type conversion.

        |

        *Overload 3:*
        Constructor to set two Points.

        |

        *Overload 4:*
        Constructor taking std::initializer_list,filling the LineString.
        """
        _pyaqcv.LineString2f_swiginit(self, _pyaqcv.new_LineString2f(*args))

    def type(self):
        return _pyaqcv.LineString2f_type(self)

    def length(self):
        r"""折线段长度和"""
        return _pyaqcv.LineString2f_length(self)
    __swig_destroy__ = _pyaqcv.delete_LineString2f

# Register LineString2f in _pyaqcv:
_pyaqcv.LineString2f_swigregister(LineString2f)
class LineString2i(Point2iVec, IGeometry):
    r"""
    整型线

    一条线被认为是一些点的集合(std::vector),且按一定顺序形成折线段.
    Notes: 线可以是自交的,但这对于某些算法会产生错误的影响.可以通过 see
    is_simple() 检测是否自交等问题.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor,creating an empty LineString.

        |

        *Overload 2:*
        Constructor to set two Points.

        |

        *Overload 3:*
        Constructor taking std::initializer_list,filling the LineString.
        """
        _pyaqcv.LineString2i_swiginit(self, _pyaqcv.new_LineString2i(*args))

    def type(self):
        return _pyaqcv.LineString2i_type(self)

    def length(self):
        r"""折线段长度和"""
        return _pyaqcv.LineString2i_length(self)
    __swig_destroy__ = _pyaqcv.delete_LineString2i

# Register LineString2i in _pyaqcv:
_pyaqcv.LineString2i_swigregister(LineString2i)
class Ring2f(Point2fVec, IGeometry):
    r"""
    浮点型环

    环是一条不应自交的闭合线,即不带孔的多边形.
    应遵循从x轴正方向向y轴正方向描述环上的点,开包(第一点与最后一点不同).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,creating an empty Ring.

        |

        *Overload 2:*
         Construct a new Ring with number type conversion.

        |

        *Overload 3:*
        Constructor taking std::initializer_list,filling the Ring.
        """
        _pyaqcv.Ring2f_swiginit(self, _pyaqcv.new_Ring2f(*args))

    def type(self):
        return _pyaqcv.Ring2f_type(self)

    def area(self):
        r"""环面积"""
        return _pyaqcv.Ring2f_area(self)

    def perimeter(self):
        r"""环周长"""
        return _pyaqcv.Ring2f_perimeter(self)
    __swig_destroy__ = _pyaqcv.delete_Ring2f

# Register Ring2f in _pyaqcv:
_pyaqcv.Ring2f_swigregister(Ring2f)
class Ring2i(Point2iVec, IGeometry):
    r"""
    整型环

    环是一条不应自交的闭合线,即不带孔的多边形.
    应遵循从x轴正方向向y轴正方向描述环上的点,开包(第一点与最后一点不同).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,creating an empty Ring.

        |

        *Overload 2:*
        Constructor taking std::initializer_list,filling the Ring.
        """
        _pyaqcv.Ring2i_swiginit(self, _pyaqcv.new_Ring2i(*args))

    def type(self):
        return _pyaqcv.Ring2i_type(self)

    def area(self):
        r"""环面积"""
        return _pyaqcv.Ring2i_area(self)

    def perimeter(self):
        r"""环周长"""
        return _pyaqcv.Ring2i_perimeter(self)
    __swig_destroy__ = _pyaqcv.delete_Ring2i

# Register Ring2i in _pyaqcv:
_pyaqcv.Ring2i_swigregister(Ring2i)
class Size2f(IGeometry):
    r"""Specify rect or image size."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a new Point with number type conversion.

        |

        *Overload 2:*

        Construct a new Size 2f object.

        :type w: float
        :param w: Width (cols).
        :type h: float
        :param h: Height (rows).
        """
        _pyaqcv.Size2f_swiginit(self, _pyaqcv.new_Size2f(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Size2f___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Size2f_type(self)

    def __mul__(self, ratio):
        return _pyaqcv.Size2f___mul__(self, ratio)

    def __truediv__(self, *args):
        return _pyaqcv.Size2f___truediv__(self, *args)
    __div__ = __truediv__



    def __imul__(self, ratio):
        return _pyaqcv.Size2f___imul__(self, ratio)

    def __itruediv__(self, *args):
        return _pyaqcv.Size2f___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def area(self):
        return _pyaqcv.Size2f_area(self)
    w = property(_pyaqcv.Size2f_w_get, _pyaqcv.Size2f_w_set, doc=r"""Width (cols) and height (rows).""")
    h = property(_pyaqcv.Size2f_h_get, _pyaqcv.Size2f_h_set)
    __swig_destroy__ = _pyaqcv.delete_Size2f

# Register Size2f in _pyaqcv:
_pyaqcv.Size2f_swigregister(Size2f)
class Size2i(IGeometry):
    r"""Specify rect or image size."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a new Point with number type conversion (round to the nearest integer number).

        |

        *Overload 2:*

        Construct a new Size2i object.

        :type w: int
        :param w: Width (cols).
        :type h: int
        :param h: Height (rows).
        """
        _pyaqcv.Size2i_swiginit(self, _pyaqcv.new_Size2i(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Size2i___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Size2i_type(self)

    def area(self):
        return _pyaqcv.Size2i_area(self)
    w = property(_pyaqcv.Size2i_w_get, _pyaqcv.Size2i_w_set, doc=r"""Width and height.""")
    h = property(_pyaqcv.Size2i_h_get, _pyaqcv.Size2i_h_set)
    __swig_destroy__ = _pyaqcv.delete_Size2i

# Register Size2i in _pyaqcv:
_pyaqcv.Size2i_swigregister(Size2i)
class Rect2f(IGeometry):
    r"""
    浮点型矩形

    有一个角为直角的平行四边形,与坐标轴平行.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
         Construct a new Rect with number type conversion.

        |

        *Overload 3:*
         Construct Rect with min corner point and size.

        |

        *Overload 4:*
        矩形的最小顶点和矩形宽高描述矩形.

        |

        *Overload 5:*
        任意对角两点描述矩形.
        """
        _pyaqcv.Rect2f_swiginit(self, _pyaqcv.new_Rect2f(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Rect2f___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Rect2f_type(self)

    def xmin_ymin(self):
        r"""x最小,y最小顶点,同 see min_corner."""
        return _pyaqcv.Rect2f_xmin_ymin(self)

    def xmax_ymin(self):
        r"""x最大,y最小顶点."""
        return _pyaqcv.Rect2f_xmax_ymin(self)

    def xmax_ymax(self):
        r"""x最大,y最大顶点."""
        return _pyaqcv.Rect2f_xmax_ymax(self)

    def xmin_ymax(self):
        r"""x最小,y最大顶点."""
        return _pyaqcv.Rect2f_xmin_ymax(self)

    def area(self):
        r"""矩形面积"""
        return _pyaqcv.Rect2f_area(self)

    def perimeter(self):
        r"""矩形周长"""
        return _pyaqcv.Rect2f_perimeter(self)

    def long_side(self):
        r"""Convert the long side length of the rectangle."""
        return _pyaqcv.Rect2f_long_side(self)

    def short_side(self):
        r"""Convert the short side length of the rectangle."""
        return _pyaqcv.Rect2f_short_side(self)

    def to_ring(self):
        r"""Convert rectangle to ring."""
        return _pyaqcv.Rect2f_to_ring(self)
    min_corner = property(_pyaqcv.Rect2f_min_corner_get, _pyaqcv.Rect2f_min_corner_set, doc=r"""矩形的最小顶点.""")
    size = property(_pyaqcv.Rect2f_size_get, _pyaqcv.Rect2f_size_set, doc=r"""矩形的宽高.""")
    __swig_destroy__ = _pyaqcv.delete_Rect2f

# Register Rect2f in _pyaqcv:
_pyaqcv.Rect2f_swigregister(Rect2f)
class Rect2i(IGeometry):
    r"""
    整型矩形

    有一个角为直角的平行四边形,与坐标轴平行.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
         Construct Rect with min corner point and size.

        |

        *Overload 3:*
        矩形的最小顶点和矩形宽高描述矩形.

        |

        *Overload 4:*
        任意对角两点描述矩形.
        """
        _pyaqcv.Rect2i_swiginit(self, _pyaqcv.new_Rect2i(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Rect2i___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Rect2i_type(self)

    def xmin_ymin(self):
        r"""x最小,y最小顶点,同 see min_corner."""
        return _pyaqcv.Rect2i_xmin_ymin(self)

    def xmax_ymin(self):
        r"""x最大,y最小顶点."""
        return _pyaqcv.Rect2i_xmax_ymin(self)

    def xmax_ymax(self):
        r"""x最大,y最大顶点."""
        return _pyaqcv.Rect2i_xmax_ymax(self)

    def xmin_ymax(self):
        r"""x最小,y最大顶点."""
        return _pyaqcv.Rect2i_xmin_ymax(self)

    def area(self):
        r"""矩形面积"""
        return _pyaqcv.Rect2i_area(self)

    def perimeter(self):
        r"""矩形周长"""
        return _pyaqcv.Rect2i_perimeter(self)

    def long_side(self):
        r"""Convert the long side length of the rectangle."""
        return _pyaqcv.Rect2i_long_side(self)

    def short_side(self):
        r"""Convert the short side length of the rectangle."""
        return _pyaqcv.Rect2i_short_side(self)

    def to_ring(self):
        r"""Convert rectangle to ring."""
        return _pyaqcv.Rect2i_to_ring(self)
    min_corner = property(_pyaqcv.Rect2i_min_corner_get, _pyaqcv.Rect2i_min_corner_set, doc=r"""矩形的最小顶点.""")
    size = property(_pyaqcv.Rect2i_size_get, _pyaqcv.Rect2i_size_set, doc=r"""矩形的宽高.""")
    __swig_destroy__ = _pyaqcv.delete_Rect2i

# Register Rect2i in _pyaqcv:
_pyaqcv.Rect2i_swigregister(Rect2i)
class Polygon2f(IGeometry):
    r"""
    浮点型多边形


    多边形由一个外环和零个或多个内环组成,内环方向与外环相反,形成带孔或不带孔的多边形.
    应遵循从x轴正方向向y轴正方向描述外环上的点,开包(第一点与最后一点不同).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,creating an empty Polygon.

        |

        *Overload 2:*
         Construct a new Polygon with number type conversion.

        |

        *Overload 3:*
        Constructor taking std::initializer_list,filling the Polygon.
        """
        _pyaqcv.Polygon2f_swiginit(self, _pyaqcv.new_Polygon2f(*args))

    def type(self):
        return _pyaqcv.Polygon2f_type(self)

    def area(self):
        r"""
        多边形面积

        Warning: 
        如果内环描述不正确,如与外环相同方向,则计算面积时会重复计算内环面积.
        可以通过 see correct() 来修正几何图形,以得到正确的期望结果.
        内环相互相切或与外环相切时仍可以得到正确的多边形面积.
        """
        return _pyaqcv.Polygon2f_area(self)

    def perimeter(self):
        r"""
        多边形周长

        Warning: 如果内环互相相切,或与外环相切,则计算周长时会重复计算相切边长.
        """
        return _pyaqcv.Polygon2f_perimeter(self)
    outer = property(_pyaqcv.Polygon2f_outer_get, _pyaqcv.Polygon2f_outer_set, doc=r"""外环,从x轴正方向向y轴正方向描述各点,开包.""")
    inners = property(_pyaqcv.Polygon2f_inners_get, _pyaqcv.Polygon2f_inners_set, doc=r"""零个或多个内环,方向与外环相反.""")
    __swig_destroy__ = _pyaqcv.delete_Polygon2f

# Register Polygon2f in _pyaqcv:
_pyaqcv.Polygon2f_swigregister(Polygon2f)
class Polygon2i(IGeometry):
    r"""
    整型多边形


    多边形由一个外环和零个或多个内环组成,内环方向与外环相反,形成带孔或不带孔的多边形.
    应遵循从x轴正方向向y轴正方向描述外环上的点,开包(第一点与最后一点不同).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,creating an empty Polygon.

        |

        *Overload 2:*
        Constructor taking std::initializer_list,filling the Polygon.
        """
        _pyaqcv.Polygon2i_swiginit(self, _pyaqcv.new_Polygon2i(*args))

    def type(self):
        return _pyaqcv.Polygon2i_type(self)

    def area(self):
        r"""
        多边形面积

        Warning: 
        如果内环描述不正确,如与外环相同方向,则计算面积时会重复计算内环面积.
        可以通过 see correct() 来修正几何图形,以得到正确的期望结果.
        内环相互相切或与外环相切时仍可以得到正确的多边形面积.
        """
        return _pyaqcv.Polygon2i_area(self)

    def perimeter(self):
        r"""
        多边形周长

        Warning: 如果内环互相相切,或与外环相切,则计算周长时会重复计算相切边长.
        """
        return _pyaqcv.Polygon2i_perimeter(self)
    outer = property(_pyaqcv.Polygon2i_outer_get, _pyaqcv.Polygon2i_outer_set, doc=r"""外环,从x轴正方向向y轴正方向描述各点,开包.""")
    inners = property(_pyaqcv.Polygon2i_inners_get, _pyaqcv.Polygon2i_inners_set, doc=r"""零个或多个内环,方向与外环相反.""")
    __swig_destroy__ = _pyaqcv.delete_Polygon2i

# Register Polygon2i in _pyaqcv:
_pyaqcv.Polygon2i_swigregister(Polygon2i)
class RotateRect2f(IGeometry):
    r"""
    浮点型旋转矩形

    有一个角为直角的平行四边形,不一定与坐标轴平行.
    一个旋转矩形由其中心点center, 大小size 及指向角度radian所定义.

    拥有相同的覆盖范围，但指向角度不同的多个旋转矩形本质上是不同。
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
         Construct a new Point with number type conversion.

        |

        *Overload 3:*
        根据旋转矩形中心点，大小和方位角构造旋转矩形.

        |

        *Overload 4:*
        根据旋转矩形中心点，大小和方位角构造旋转矩形.

        |

        *Overload 5:*
        根据旋转矩形的原点、宽高及方向创建图形（仅为兼容，已不建议使用）

        |

        *Overload 6:*
        根据旋转矩形的原点、宽高及方向创建图形（仅为兼容，已不建议使用）
        """
        _pyaqcv.RotateRect2f_swiginit(self, _pyaqcv.new_RotateRect2f(*args))

    def __eq__(self, rhs):
        r"""任意对角两点描述平行矩形."""
        return _pyaqcv.RotateRect2f___eq__(self, rhs)

    def type(self):
        return _pyaqcv.RotateRect2f_type(self)

    def area(self):
        return _pyaqcv.RotateRect2f_area(self)

    def perimeter(self):
        return _pyaqcv.RotateRect2f_perimeter(self)

    def to_ring(self):
        r"""
        convert the rotate rectangle to ring. The order of the points is
        consistent with the order in which the rays from the center point are
        rotated in the positive direction and scanned in the positive direction.
        """
        return _pyaqcv.RotateRect2f_to_ring(self)

    def bounding_box(self):
        r"""Get the bounding box"""
        return _pyaqcv.RotateRect2f_bounding_box(self)

    def long_side(self):
        r"""Convert the long side length of the rectangle."""
        return _pyaqcv.RotateRect2f_long_side(self)

    def short_side(self):
        r"""Convert the short side length of the rectangle."""
        return _pyaqcv.RotateRect2f_short_side(self)

    def norm(self):
        r"""
        Normalize the radian into (0, kPi / 2].

        Width and height will be exchanged due to angle change.
        :rtype: :py:class:`RotateRect2f`
        :return: RotateRect2f with radian in (0, kPi / 2].
        """
        return _pyaqcv.RotateRect2f_norm(self)

    def norm_compatible_opencv(self):
        r"""
        Normalize the radian into (0, kPi / 2] like opencv.

        Width and height will be exchanged due to angle change.
        :rtype: :py:class:`RotateRect2f`
        :return: RotateRect2f with radian in (0, kPi / 2].
        """
        return _pyaqcv.RotateRect2f_norm_compatible_opencv(self)
    center = property(_pyaqcv.RotateRect2f_center_get, _pyaqcv.RotateRect2f_center_set, doc=r"""中心点.""")
    size = property(_pyaqcv.RotateRect2f_size_get, _pyaqcv.RotateRect2f_size_set)
    radian = property(_pyaqcv.RotateRect2f_radian_get, _pyaqcv.RotateRect2f_radian_set, doc=r"""偏转角度""")
    __swig_destroy__ = _pyaqcv.delete_RotateRect2f

# Register RotateRect2f in _pyaqcv:
_pyaqcv.RotateRect2f_swigregister(RotateRect2f)
class RotateRect2i(IGeometry):
    r"""
    整型旋转矩形

    有一个角为直角的平行四边形,不一定与坐标轴平行.
    一个旋转矩形由其中心点center, 大小size 及指向角度radian所定义.

    拥有相同的覆盖范围，但指向角度不同的多个旋转矩形本质上是不同。
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
        根据旋转矩形中心点，大小和方位角构造旋转矩形.

        |

        *Overload 3:*
        根据旋转矩形中心点，大小和方位角构造旋转矩形.

        |

        *Overload 4:*
        根据旋转矩形的原点、宽高及方向创建图形（仅为兼容，已不建议使用）

        |

        *Overload 5:*
        根据旋转矩形的原点、宽高及方向创建图形（仅为兼容，已不建议使用）
        """
        _pyaqcv.RotateRect2i_swiginit(self, _pyaqcv.new_RotateRect2i(*args))

    def __eq__(self, rhs):
        r"""任意对角两点描述平行矩形."""
        return _pyaqcv.RotateRect2i___eq__(self, rhs)

    def type(self):
        return _pyaqcv.RotateRect2i_type(self)

    def area(self):
        return _pyaqcv.RotateRect2i_area(self)

    def perimeter(self):
        return _pyaqcv.RotateRect2i_perimeter(self)

    def to_ring(self):
        r"""
        convert the rotate rectangle to ring. The order of the points is
        consistent with the order in which the rays from the center point are
        rotated in the positive direction and scanned in the positive direction.
        """
        return _pyaqcv.RotateRect2i_to_ring(self)

    def bounding_box(self):
        r"""Get the bounding box."""
        return _pyaqcv.RotateRect2i_bounding_box(self)

    def long_side(self):
        r"""Convert the long side length of the rectangle."""
        return _pyaqcv.RotateRect2i_long_side(self)

    def short_side(self):
        r"""Convert the short side length of the rectangle."""
        return _pyaqcv.RotateRect2i_short_side(self)
    center = property(_pyaqcv.RotateRect2i_center_get, _pyaqcv.RotateRect2i_center_set, doc=r"""中心点.""")
    size = property(_pyaqcv.RotateRect2i_size_get, _pyaqcv.RotateRect2i_size_set)
    radian = property(_pyaqcv.RotateRect2i_radian_get, _pyaqcv.RotateRect2i_radian_set, doc=r"""偏转角度""")
    __swig_destroy__ = _pyaqcv.delete_RotateRect2i

# Register RotateRect2i in _pyaqcv:
_pyaqcv.RotateRect2i_swigregister(RotateRect2i)
class Ellipse2f(IGeometry):
    r"""
    Float type ellipse.


    - An ellipse is a plane curve surrounding two focal points, such that for all
    points on the curve, the sum of the two distances to the focal points is a
    constant.
    - An ellipse is defined by its centre point, the axis of the major and minor
    semi-axes, and the rotation angle radian around the centre point.
    - Multiple ellipses with the same coverage, but rotation angle at different
    angles, are essentially different.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*

        Constructor to set centre point, major and minor semi-axes and
        rotation angle.


        An exception will be thrown if major_semi_axis or minor_semi_axis is not greater than 0
        :type center: :py:class:`Point`
        :param center: Centre point.
        :type major_semi_axis: float
        :param major_semi_axis: Major semi-axis.
        :type minor_semi_axis: float
        :param minor_semi_axis: Minor semi-axis.
        :type radian: :py:class:`Radian`, optional
        :param radian: Rotation angle around the centre point. same to major_semi_axis.
        :raises: visionflow::excepts::InvalidArgument if major_semi_axis or
            minor_semi_axis is not greater than 0.

        |

        *Overload 3:*

        Constructor to set centre point, major and minor semi-axes and
        rotation angle.


        An exception will be thrown if major_semi_axis or minor_semi_axis is not greater than 0
        :type center: :py:class:`Point`
        :param center: Centre point.
        :type major_semi_axis: float
        :param major_semi_axis: Major semi-axis.
        :type minor_semi_axis: float
        :param minor_semi_axis: Minor semi-axis.
        :param radian: Rotation angle around the centre point. same to major_semi_axis.
        :raises: visionflow::excepts::InvalidArgument if major_semi_axis or
            minor_semi_axis is not greater than 0.

        |

        *Overload 4:*

        根据两个焦点和椭圆上一点构建椭圆.

        :type focus1: :py:class:`Point`
        :param focus1: 椭圆其中一个焦点.
        :type focus2: :py:class:`Point`
        :param focus2: 椭圆另一个焦点.
        :type point: :py:class:`Point`
        :param point: 椭圆上一点.

        |

        *Overload 5:*

        根据椭圆标准方程构建椭圆.


        .. math::

            \frac{(x - center.x)^2}{a^2} + \frac{(y - center.y)^2}{b^2} = d (a \ge
            b \gt 0)
        :type a: float
        :param a: Major semi axis.
        :type b: float
        :param b: Minor semi axis.
        :type d: float, optional
        :param d: Scale.
        :type center: :py:class:`Point`, optional
        :param center: 中心点.

        |

        *Overload 6:*

        根据椭圆标准方程构建椭圆.


        .. math::

            \frac{(x - center.x)^2}{a^2} + \frac{(y - center.y)^2}{b^2} = d (a \ge
            b \gt 0)
        :type a: float
        :param a: Major semi axis.
        :type b: float
        :param b: Minor semi axis.
        :type d: float, optional
        :param d: Scale.
        :param center: 中心点.

        |

        *Overload 7:*

        根据椭圆标准方程构建椭圆.


        .. math::

            \frac{(x - center.x)^2}{a^2} + \frac{(y - center.y)^2}{b^2} = d (a \ge
            b \gt 0)
        :type a: float
        :param a: Major semi axis.
        :type b: float
        :param b: Minor semi axis.
        :param d: Scale.
        :param center: 中心点.
        """
        _pyaqcv.Ellipse2f_swiginit(self, _pyaqcv.new_Ellipse2f(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Ellipse2f___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Ellipse2f_type(self)

    def focus(self):
        r"""椭圆焦点."""
        return _pyaqcv.Ellipse2f_focus(self)

    def ecc(self):
        r"""椭圆离心率."""
        return _pyaqcv.Ellipse2f_ecc(self)

    def area(self):
        return _pyaqcv.Ellipse2f_area(self)

    def bounding_box(self):
        r"""Get the bounding box."""
        return _pyaqcv.Ellipse2f_bounding_box(self)

    def correct(self):
        return _pyaqcv.Ellipse2f_correct(self)
    center = property(_pyaqcv.Ellipse2f_center_get, _pyaqcv.Ellipse2f_center_set, doc=r"""中心点.""")
    axis = property(_pyaqcv.Ellipse2f_axis_get, _pyaqcv.Ellipse2f_axis_set, doc=r"""axis.w means major semi axis, axis.h means minor semi axis.""")
    radian = property(_pyaqcv.Ellipse2f_radian_get, _pyaqcv.Ellipse2f_radian_set, doc=r"""指向角度, major semi axis direction.""")
    __swig_destroy__ = _pyaqcv.delete_Ellipse2f

# Register Ellipse2f in _pyaqcv:
_pyaqcv.Ellipse2f_swigregister(Ellipse2f)
class Arc2f(IGeometry):
    r"""浮点型弧"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor,no initialization.

        |

        *Overload 2:*
        从x轴正方向向y轴正方向描述弧圆心,半径,起始弧度和终止弧度,.
        """
        _pyaqcv.Arc2f_swiginit(self, _pyaqcv.new_Arc2f(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Arc2f___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Arc2f_type(self)

    def angle(self):
        r"""Central angle."""
        return _pyaqcv.Arc2f_angle(self)

    def length(self):
        r"""Arc length."""
        return _pyaqcv.Arc2f_length(self)

    def norm(self, *args):
        r"""Normalized Arc radian."""
        return _pyaqcv.Arc2f_norm(self, *args)
    center = property(_pyaqcv.Arc2f_center_get, _pyaqcv.Arc2f_center_set, doc=r"""The centre of the circle corresponding to the arc.""")
    radius = property(_pyaqcv.Arc2f_radius_get, _pyaqcv.Arc2f_radius_set, doc=r"""The radius of the circle corresponding to the arc.""")
    start_angle = property(_pyaqcv.Arc2f_start_angle_get, _pyaqcv.Arc2f_start_angle_set, doc=r"""Arc start radian.""")
    end_angle = property(_pyaqcv.Arc2f_end_angle_get, _pyaqcv.Arc2f_end_angle_set, doc=r"""Arc end radian.""")
    __swig_destroy__ = _pyaqcv.delete_Arc2f

# Register Arc2f in _pyaqcv:
_pyaqcv.Arc2f_swigregister(Arc2f)
class Circle2f(IGeometry):
    r"""浮点型圆"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
        Constructor to set center and radius.
        """
        _pyaqcv.Circle2f_swiginit(self, _pyaqcv.new_Circle2f(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Circle2f___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Circle2f_type(self)

    def area(self):
        r"""圆面积"""
        return _pyaqcv.Circle2f_area(self)

    def perimeter(self):
        r"""圆周长"""
        return _pyaqcv.Circle2f_perimeter(self)
    center = property(_pyaqcv.Circle2f_center_get, _pyaqcv.Circle2f_center_set, doc=r"""圆心""")
    radius = property(_pyaqcv.Circle2f_radius_get, _pyaqcv.Circle2f_radius_set, doc=r"""半径""")
    __swig_destroy__ = _pyaqcv.delete_Circle2f

# Register Circle2f in _pyaqcv:
_pyaqcv.Circle2f_swigregister(Circle2f)
class Circle2i(IGeometry):
    r"""整型圆"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
        Constructor to set center and radius.
        """
        _pyaqcv.Circle2i_swiginit(self, _pyaqcv.new_Circle2i(*args))

    def __eq__(self, rhs):
        return _pyaqcv.Circle2i___eq__(self, rhs)

    def type(self):
        return _pyaqcv.Circle2i_type(self)

    def area(self):
        r"""圆面积"""
        return _pyaqcv.Circle2i_area(self)

    def perimeter(self):
        r"""圆周长"""
        return _pyaqcv.Circle2i_perimeter(self)
    center = property(_pyaqcv.Circle2i_center_get, _pyaqcv.Circle2i_center_set, doc=r"""圆心""")
    radius = property(_pyaqcv.Circle2i_radius_get, _pyaqcv.Circle2i_radius_set, doc=r"""半径""")
    __swig_destroy__ = _pyaqcv.delete_Circle2i

# Register Circle2i in _pyaqcv:
_pyaqcv.Circle2i_swigregister(Circle2i)
class MultiPoint2f(Point2fVec, IGeometry):
    r"""
    浮点型点集

    Warning: 算法实现中不会清空原有数据,导致结果产生错误.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def type(self):
        return _pyaqcv.MultiPoint2f_type(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
         Construct a new Point with number type conversion.

        |

        *Overload 3:*
        Constructor taking std::initializer_list,filling the MultiPoint.
        """
        _pyaqcv.MultiPoint2f_swiginit(self, _pyaqcv.new_MultiPoint2f(*args))
    __swig_destroy__ = _pyaqcv.delete_MultiPoint2f

# Register MultiPoint2f in _pyaqcv:
_pyaqcv.MultiPoint2f_swigregister(MultiPoint2f)
class MultiPoint2i(Point2iVec, IGeometry):
    r"""
    整型点集

    Warning: 算法实现中不会清空原有数据,导致结果产生错误.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def type(self):
        return _pyaqcv.MultiPoint2i_type(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
         Construct a new Point with number type conversion (round to the nearest integer number).

        |

        *Overload 3:*
        Constructor taking std::initializer_list,filling the MultiPoint.
        """
        _pyaqcv.MultiPoint2i_swiginit(self, _pyaqcv.new_MultiPoint2i(*args))
    __swig_destroy__ = _pyaqcv.delete_MultiPoint2i

# Register MultiPoint2i in _pyaqcv:
_pyaqcv.MultiPoint2i_swigregister(MultiPoint2i)
class MultiSegment2f(Segment2fVec, IGeometry):
    r"""Multiple line Segment2f."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, no initialization.

        |

        *Overload 2:*
        Constructor taking std::initializer_list, filling the MultiSegment.
        """
        _pyaqcv.MultiSegment2f_swiginit(self, _pyaqcv.new_MultiSegment2f(*args))

    def type(self):
        return _pyaqcv.MultiSegment2f_type(self)
    __swig_destroy__ = _pyaqcv.delete_MultiSegment2f

# Register MultiSegment2f in _pyaqcv:
_pyaqcv.MultiSegment2f_swigregister(MultiSegment2f)
class MultiLineString2f(LineString2fVec, IGeometry):
    r"""Multiple line LineString2f."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, no initialization.

        |

        *Overload 2:*
        Construct a new MultiLineString with number type conversion.

        |

        *Overload 3:*
        Constructor taking std::initializer_list, filling the MultiLineString.
        """
        _pyaqcv.MultiLineString2f_swiginit(self, _pyaqcv.new_MultiLineString2f(*args))

    def type(self):
        return _pyaqcv.MultiLineString2f_type(self)
    __swig_destroy__ = _pyaqcv.delete_MultiLineString2f

# Register MultiLineString2f in _pyaqcv:
_pyaqcv.MultiLineString2f_swigregister(MultiLineString2f)
class MultiLineString2i(LineString2iVec, IGeometry):
    r"""Multiple line LineString2i."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, no initialization.

        |

        *Overload 2:*
        Constructor taking std::initializer_list, filling the MultiLineString.
        """
        _pyaqcv.MultiLineString2i_swiginit(self, _pyaqcv.new_MultiLineString2i(*args))

    def type(self):
        return _pyaqcv.MultiLineString2i_type(self)
    __swig_destroy__ = _pyaqcv.delete_MultiLineString2i

# Register MultiLineString2i in _pyaqcv:
_pyaqcv.MultiLineString2i_swigregister(MultiLineString2i)
class MultiPolygon2f(Polygon2fVec, IGeometry):
    r"""
    浮点型多多边形

    Warning: 算法实现中不会清空原有数据,导致结果产生错误.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
         Construct a new MultiPolygon with number type conversion.

        |

        *Overload 3:*
        Constructor taking std::initializer_list,filling the MultiPolygon.
        """
        _pyaqcv.MultiPolygon2f_swiginit(self, _pyaqcv.new_MultiPolygon2f(*args))

    def type(self):
        return _pyaqcv.MultiPolygon2f_type(self)
    __swig_destroy__ = _pyaqcv.delete_MultiPolygon2f

# Register MultiPolygon2f in _pyaqcv:
_pyaqcv.MultiPolygon2f_swigregister(MultiPolygon2f)
class MultiPolygon2i(Polygon2iVec, IGeometry):
    r"""
    整型多多边形

    Warning: 算法实现中不会清空原有数据,导致结果产生错误.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Default constructor,no initialization.

        |

        *Overload 2:*
        Constructor taking std::initializer_list,filling the MultiPolygon.
        """
        _pyaqcv.MultiPolygon2i_swiginit(self, _pyaqcv.new_MultiPolygon2i(*args))

    def type(self):
        return _pyaqcv.MultiPolygon2i_type(self)
    __swig_destroy__ = _pyaqcv.delete_MultiPolygon2i

# Register MultiPolygon2i in _pyaqcv:
_pyaqcv.MultiPolygon2i_swigregister(MultiPolygon2i)

def append(*args):
    return _pyaqcv.append(*args)

def area(*args):
    r"""
    *Overload 1:*


    |

    *Overload 2:*
    """
    return _pyaqcv.area(*args)

def vector2f_eq_point2f(lhs, rhs):
    
    return _pyaqcv.vector2f_eq_point2f(lhs, rhs)

def vector2i_eq_point2i(lhs, rhs):
    return _pyaqcv.vector2i_eq_point2i(lhs, rhs)

def vector2f_add_point2f(lhs, rhs):
    
    return _pyaqcv.vector2f_add_point2f(lhs, rhs)

def vector2i_add_point2i(lhs, rhs):
    return _pyaqcv.vector2i_add_point2i(lhs, rhs)

def point2i_add_vector2f(lhs, rhs):
    
    return _pyaqcv.point2i_add_vector2f(lhs, rhs)

def vector2f_add_point2i(lhs, rhs):
    return _pyaqcv.vector2f_add_point2i(lhs, rhs)

def point2f_minus_point2f(lhs, rhs):
    
    return _pyaqcv.point2f_minus_point2f(lhs, rhs)

def point2i_minus_point2i(lhs, rhs):
    return _pyaqcv.point2i_minus_point2i(lhs, rhs)

def point2i_minus_vector2f(lhs, rhs):
    
    return _pyaqcv.point2i_minus_vector2f(lhs, rhs)

def Point2i_minus_point2f(lhs, rhs):
    
    return _pyaqcv.Point2i_minus_point2f(lhs, rhs)

def point2f_minus_Point2i(lhs, rhs):
    
    return _pyaqcv.point2f_minus_Point2i(lhs, rhs)

def float_mutiply_point2f(lhs, rhs):
    
    return _pyaqcv.float_mutiply_point2f(lhs, rhs)

def int32_mutiply_point2i(lhs, rhs):
    return _pyaqcv.int32_mutiply_point2i(lhs, rhs)

def float_mutiply_vector2f(lhs, rhs):
    return _pyaqcv.float_mutiply_vector2f(lhs, rhs)

def int32_mutiply_vector2i(lhs, rhs):
    return _pyaqcv.int32_mutiply_vector2i(lhs, rhs)

def point2i_mutiply_float(lhs, rhs):
    
    return _pyaqcv.point2i_mutiply_float(lhs, rhs)

def float_mutiply_point2i(lhs, rhs):
    return _pyaqcv.float_mutiply_point2i(lhs, rhs)

def vector2i_mutiply_float(lhs, rhs):
    
    return _pyaqcv.vector2i_mutiply_float(lhs, rhs)

def float_mutiply_vector2i(lhs, rhs):
    return _pyaqcv.float_mutiply_vector2i(lhs, rhs)

def add_point(*args):
    
    return _pyaqcv.add_point(*args)

def add_value(*args):
    
    return _pyaqcv.add_value(*args)

def cross_product(*args):
    
    return _pyaqcv.cross_product(*args)

def divide_point(*args):
    
    return _pyaqcv.divide_point(*args)

def divide_value(*args):
    
    return _pyaqcv.divide_value(*args)

def dot_product(*args):
    
    return _pyaqcv.dot_product(*args)

def multiply_point(*args):
    
    return _pyaqcv.multiply_point(*args)

def multiply_value(*args):
    
    return _pyaqcv.multiply_value(*args)

def subtract_point(*args):
    
    return _pyaqcv.subtract_point(*args)

def subtract_value(*args):
    
    return _pyaqcv.subtract_value(*args)

def azimuth(*args):
    r"""
    *Overload 1:*


    |

    *Overload 2:*
    """
    return _pyaqcv.azimuth(*args)

def center(*args):
    r"""
    *Overload 1:*


    |

    *Overload 2:*
    """
    return _pyaqcv.center(*args)

def centroid(*args):
    r"""
    *Overload 1:*


    |

    *Overload 2:*
    """
    return _pyaqcv.centroid(*args)

def clear(*args):
    
    return _pyaqcv.clear(*args)

def convert(*args):
    
    return _pyaqcv.convert(*args)
kRoundToNearestInt = _pyaqcv.kRoundToNearestInt
r"""Round to the nearest integer number."""
kRetainIntPart = _pyaqcv.kRetainIntPart
r"""Retain only the integer part."""

def convert_to_int(*args):
    return _pyaqcv.convert_to_int(*args)

def convex_hull(*args):
    return _pyaqcv.convex_hull(*args)

def return_convex_hull(*args):
    
    return _pyaqcv.return_convex_hull(*args)

def correct(*args):
    
    return _pyaqcv.correct(*args)

def return_correct(*args):
    
    return _pyaqcv.return_correct(*args)

def covered_by(*args):
    
    return _pyaqcv.covered_by(*args)

def crosses(*args):
    
    return _pyaqcv.crosses(*args)

def difference(*args):
    
    return _pyaqcv.difference(*args)

def discrete_frechet_distance(*args):
    
    return _pyaqcv.discrete_frechet_distance(*args)

def disjoint(*args):
    
    return _pyaqcv.disjoint(*args)

def distance(*args):
    
    return _pyaqcv.distance(*args)

def envelope(*args):
    
    return _pyaqcv.envelope(*args)

def return_envelope(*args):
    
    return _pyaqcv.return_envelope(*args)

def equals(*args):
    
    return _pyaqcv.equals(*args)

def segment_sampling(*args):
    
    return _pyaqcv.segment_sampling(*args)

def is_empty(*args):
    
    return _pyaqcv.is_empty(*args)

def is_rect(*args):
    
    return _pyaqcv.is_rect(*args)

def is_axial_rect(*args):
    
    return _pyaqcv.is_axial_rect(*args)

def is_rotate_rect(*args):
    
    return _pyaqcv.is_rotate_rect(*args)

def is_simple(*args):
    
    return _pyaqcv.is_simple(*args)
kNoFailure = _pyaqcv.kNoFailure
r"""The geometry is simple/valid."""
kEmpty = _pyaqcv.kEmpty
r"""The geometry is empty."""
kDuplicatePoints = _pyaqcv.kDuplicatePoints
r"""The geometry has (consecutive) duplicate points."""
kSpikes = _pyaqcv.kSpikes
r"""The geometry contains spikes."""
kSelfIntersections = _pyaqcv.kSelfIntersections
r"""The geometry has self-intersections."""
kPolygonOuterFailure = _pyaqcv.kPolygonOuterFailure
r"""The exterior ring of geometry is not simple/valid."""
kPolygonInnersFailure = _pyaqcv.kPolygonInnersFailure
r"""The interior rings of geometry is not simple/valid."""
kFewPoints = _pyaqcv.kFewPoints
r"""The geometry has a very small number of points."""
kWrongTopologicalDimension = _pyaqcv.kWrongTopologicalDimension
r"""
    The topological dimension of the geometry is smaller than its
     dimension.
    """
kInvalidCoordinate = _pyaqcv.kInvalidCoordinate
r"""The geometry has at least one point with an invalid coordinate."""
kWrongOrientation = _pyaqcv.kWrongOrientation
r"""
    The actual orientation of the geometry is different from the one
     defined.
    """
kInteriorRingsOutside = _pyaqcv.kInteriorRingsOutside
r"""
    The geometry contains interior rings that lie outside the exterior
     ring.
    """
kNestedInteriorRings = _pyaqcv.kNestedInteriorRings
r"""The geometry has nested interior rings."""

def return_is_simple(*args):
    return _pyaqcv.return_is_simple(*args)

def is_valid(*args):
    
    return _pyaqcv.is_valid(*args)

def return_is_valid(*args):
    
    return _pyaqcv.return_is_valid(*args)

def length(*args):
    
    return _pyaqcv.length(*args)

def line_interpolate(*args):
    
    return _pyaqcv.line_interpolate(*args)

def min_area_rect(*args):
    
    return _pyaqcv.min_area_rect(*args)

def return_min_area_rect(*args):
    
    return _pyaqcv.return_min_area_rect(*args)

def overlaps(*args):
    
    return _pyaqcv.overlaps(*args)

def perimeter(*args):
    r"""
    *Overload 1:*


    |

    *Overload 2:*
    """
    return _pyaqcv.perimeter(*args)

def vertical(*args):
    
    return _pyaqcv.vertical(*args)

def reverse(*args):
    
    return _pyaqcv.reverse(*args)

def return_reverse(*args):
    
    return _pyaqcv.return_reverse(*args)

def simplify(*args):
    
    return _pyaqcv.simplify(*args)

def return_simplify(*args):
    
    return _pyaqcv.return_simplify(*args)

def sym_difference(*args):
    
    return _pyaqcv.sym_difference(*args)

def return_sym_difference(*args):
    
    return _pyaqcv.return_sym_difference(*args)

def touches(*args):
    
    return _pyaqcv.touches(*args)

def union_areal(*args):
    
    return _pyaqcv.union_areal(*args)

def return_union_areal(*args):
    
    return _pyaqcv.return_union_areal(*args)

def unique(*args):
    
    return _pyaqcv.unique(*args)

def return_unique(*args):
    
    return _pyaqcv.return_unique(*args)

def within(*args):
    
    return _pyaqcv.within(*args)
class Matrix3f(object):
    r"""
    3x3 float matrix.

    Transformation matrix.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kSide = _pyaqcv.Matrix3f_kSide
    r"""The matrix row and col number."""

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct a 3*3 float matrix.

        The value of the principal diagonal is diag, the rest are 0.
        :type diag: float, optional
        :param diag: The principal diagonal value. If rhs is 1(As default), it will
            construct a identity matrix.

        |

        *Overload 2:*

        Construct a new Matrix3f object

        :type line1: std::array< float,3 >
        :param line1: The first row of matrix
        :type line2: std::array< float,3 >
        :param line2: The second row of matrix
        :type line3: std::array< float,3 >
        :param line3: The third row of matrix

        |

        *Overload 3:*

        Construct a 3*3 float matrix.

        Read parameters in first row the col order.

        |

        *Overload 4:*

        Deep copy constructor.

        It will not share the same references as the source object.
        :type rhs: :py:class:`Matrix3f`
        :param rhs: other Matrix3f.

        |

        *Overload 5:*

        Move constructor.

        :type rhs: :py:class:`Matrix3f`
        :param rhs: other rvalue Matrix3f.
        """
        _pyaqcv.Matrix3f_swiginit(self, _pyaqcv.new_Matrix3f(*args))
    __swig_destroy__ = _pyaqcv.delete_Matrix3f

    def __eq__(self, rhs):
        return _pyaqcv.Matrix3f___eq__(self, rhs)

    def __mul__(self, rhs):
        r"""
        Matrix multiplication.

        A * B = C.
        :type rhs: :py:class:`Matrix3f`
        :param rhs: B matrix.
        :rtype: :py:class:`Matrix3f`
        :return: Matrix3f C matrix.
        """
        return _pyaqcv.Matrix3f___mul__(self, rhs)

    def at(self, *args):
        r"""
        *Overload 1:*

        Return a reference to the specified array element.

        if row or col out of range, an see visionflow::excepts::InvalidArgument
        will be thrown.
        :type row: int
        :param row: Index along the dimension 1.
        :type col: int
        :param col: Index along the dimension 2.
        :rtype: float
        :return: NO_DISCARD float& array element.
        :raises: visionflow::excepts::InvalidArgument if row or col out of range.

        |

        *Overload 2:*

        Return the specified array element.

        if row or col out of range, an see visionflow::excepts::InvalidArgument
        will be thrown.
        :type row: int
        :param row: Index along the dimension 1.
        :type col: int
        :param col: Index along the dimension 2.
        :rtype: float
        :return: NO_DISCARD float array element.
        :raises: visionflow::excepts::InvalidArgument if row or col out of range.
        """
        return _pyaqcv.Matrix3f_at(self, *args)

# Register Matrix3f in _pyaqcv:
_pyaqcv.Matrix3f_swigregister(Matrix3f)

def sampling(*args):
    return _pyaqcv.sampling(*args)

def get_affine_transform(src, dst):
    r"""
    Calculate an affine transform from three pairs of the corresponding
    points.

    If the number of point pairs is less than 3, an see
    visionflow::excepts::InvalidArgument will be thrown.
    :type src: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param src: Coordinate of triangle vertices in the source image.
    :type dst: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param dst: Coordinate of the corresponding triangle vertices in the
        destination image.
    :rtype: :py:class:`Matrix3f`
    :return: transformation matrix.
    :raises: visionflow::excepts::InvalidArgument if the number of point pairs is
        less than requirement.
    """
    return _pyaqcv.get_affine_transform(src, dst)

def get_perspective_transform(src, dst):
    r"""
    Calculate a perspective transform from four pairs of the
    corresponding points.

    If the number of point pairs is less than 4, an see
    visionflow::excepts::InvalidArgument will be thrown.
    :type src: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param src: Coordinate of quadrangle vertices in the source image.
    :type dst: std::vector< visionflow::geometry::Point2f,std::allocator< visionflow::geometry::Point2f > >
    :param dst: Coordinate of the corresponding quadrangle vertices in the
        destination image.
    :rtype: :py:class:`Matrix3f`
    :return: transformation matrix.
    :raises: visionflow::excepts::InvalidArgument if the number of point pairs is
        less than requirement.
    """
    return _pyaqcv.get_perspective_transform(src, dst)

def get_inverse_transform(mat):
    r"""
    Get inverse transform matrix.

    :type mat: :py:class:`Matrix3f`
    :param mat: Source matrix.
    :rtype: :py:class:`Matrix3f`
    :return: inverse transform matrix.
    """
    return _pyaqcv.get_inverse_transform(mat)

def get_rotate_transform(*args):
    r"""
    *Overload 1:*

    Get rotate transform matrix.

    Follow see Radian definition direction, and the matrix is:

    .. math::

        \begin{bmatrix}
        cos\theta & -sin\theta & 0 \\
        sin\theta & cos\theta & 0 \\
        0 & 0 & 1
        \end{bmatrix}
    :type theta: :py:class:`Radian`
    :param theta: Rotation radian.
    :rtype: :py:class:`Matrix3f`
    :return: Matrix3f rotate transform matrix.

    |

    *Overload 2:*

    Get the transformation matrix rotated around a given center.

    Let the center pos be :math:`(x_c, y_c)`, then the transform matrix
    is:

    .. math::

        \begin{bmatrix}
        cos\theta & -sin\theta & (1 - cos\theta) x_c + sin\theta * y_c \\
        sin\theta & cos\theta & -sin\theta * x_c + (1 - cos\theta) y_c \\
        0 & 0 & 1
        \end{bmatrix}
    :type center: :py:class:`Point2f`
    :param center: The ratote center.
    :type theta: :py:class:`Radian`
    :param theta: Rotation radian.
    :rtype: :py:class:`Matrix3f`
    :return: Matrix3f the rotate transform matrix.
    """
    return _pyaqcv.get_rotate_transform(*args)

def get_scale_transform(*args):
    r"""
    *Overload 1:*

    Get scale transform matrix.

    The matrix is:

    .. math::

        \begin{bmatrix}
        s_x & 0 & 0 \\
        0 & s_y & 0 \\
        0 & 0 & 1
        \end{bmatrix}
    :type s_x: float
    :param s_x: Scaling ratio direction-x.
    :type s_y: float
    :param s_y: Scaling ratio direction-y.
    :rtype: :py:class:`Matrix3f`
    :return: scale transform matrix.

    |

    *Overload 2:*

    Get the transformation matrix scaled to the given point

    Let the center pos be :math:`(x_c, y_c)`, then the transform matrix
    is:

    .. math::

        \begin{bmatrix}
        s_x & 0 & (1 - s_x) x_c \\
        1 & s_y & (1 - s_y) y_c \\
        0 & 0 & 1
        \end{bmatrix}
    :type center: :py:class:`Point2f`
    :param center: The scale center.
    :type s_x: float
    :param s_x: Scaling ratio direction-x.
    :type s_y: float
    :param s_y: Scaling ratio direction-y.
    :rtype: :py:class:`Matrix3f`
    :return: Matrix3f scale transform matrix.
    """
    return _pyaqcv.get_scale_transform(*args)

def get_translate_transform(directx, directy):
    r"""
    Get translate transform matrix.

    :type directx: float
    :param directx: Translation transform direction-x.
    :type directy: float
    :param directy: Translation transform direction-y.
    :rtype: :py:class:`Matrix3f`
    :return: translate transform matrix
    """
    return _pyaqcv.get_translate_transform(directx, directy)

def get_flip_transform(flip_axis):
    r"""
    Get the mirror flip transform matrix.

    Let the symmetrical axis for mirror flip be :math:`ax + by + c = 0`, then the transform matrix is:

    .. math::

        \begin{bmatrix}
        (b^2 - a^2)/(a^2+b^2) & -2ab/(a^2+b^2) & -2ac/(a^2+b^2) \\
        -2ab/(a^2+b^2) & (a^2 - b^2)/(a^2+b^2) & -2bc/(a^2+b^2) \\
        0 & 0 & 1
        \end{bmatrix}
    :type flip_axis: :py:class:`Line2f`
    :param flip_axis: The symmetrical axis for mirror flip.
    :rtype: :py:class:`Matrix3f`
    :return: Matrix3f flip transform matrix
    """
    return _pyaqcv.get_flip_transform(flip_axis)

def transform_rotate(*args):
    r"""
    *Overload 1:*


    |

    *Overload 2:*


    |

    *Overload 3:*
    namespace geometry
    """
    return _pyaqcv.transform_rotate(*args)

def transform_scale(*args):
    r"""
    *Overload 1:*


    |

    *Overload 2:*
    """
    return _pyaqcv.transform_scale(*args)

def transform_translate(*args):
    
    return _pyaqcv.transform_translate(*args)

def intersects(*args):
    
    return _pyaqcv.intersects(*args)

def intersection(*args):
    
    return _pyaqcv.intersection(*args)

def wkt_geoemtry_type_name(wkt_str):
    r"""
    返回类型名称，名称为IGeometry::type_name返回结果名称
    Notes: 支持Point2i/Point2f/Polygon2i/Polygon2f/LineString2i/LineString2f，不支持的类型抛异常
    """
    return _pyaqcv.wkt_geoemtry_type_name(wkt_str)

def wkt_geometry_type(wkt_str):
    r"""
    返回类型名称，名称为IGeometry::type返回结果类型
    Notes: 支持Point2i/Point2f/Polygon2i/Polygon2f/LineString2i/LineString2f，不支持的类型抛异常
    """
    return _pyaqcv.wkt_geometry_type(wkt_str)

def geometry_to_wkt(*args):
    r"""geometry类型序列化成wkt"""
    return _pyaqcv.geometry_to_wkt(*args)

def geometry_read_wkt(*args):
    r"""wkt反序列化成geometry类型（失败抛异常）"""
    return _pyaqcv.geometry_read_wkt(*args)
class GeometryException(object):
    r"""base exception, all Exception should derived from this class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pyaqcv.GeometryException_swiginit(self, _pyaqcv.new_GeometryException(*args))
    __swig_destroy__ = _pyaqcv.delete_GeometryException

    def what(self):
        r"""
        get error message
        :rtype: string
        :return: error message.
        """
        return _pyaqcv.GeometryException_what(self)

    def name(self):
        r"""get current exception type name"""
        return _pyaqcv.GeometryException_name(self)

    def err_code(self):
        r"""get err_code, you can also determine the exception type by error code"""
        return _pyaqcv.GeometryException_err_code(self)

    def get_info(self):
        r"""get original exception info See also: ExceptionInfo"""
        return _pyaqcv.GeometryException_get_info(self)

# Register GeometryException in _pyaqcv:
_pyaqcv.GeometryException_swigregister(GeometryException)
class ExceptionInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    msg = property(_pyaqcv.ExceptionInfo_msg_get, _pyaqcv.ExceptionInfo_msg_set, doc=r"""error message""")
    func = property(_pyaqcv.ExceptionInfo_func_get, _pyaqcv.ExceptionInfo_func_set, doc=r"""exception was throw in which function""")
    file = property(_pyaqcv.ExceptionInfo_file_get, _pyaqcv.ExceptionInfo_file_set, doc=r"""file path that throw exception""")
    line = property(_pyaqcv.ExceptionInfo_line_get, _pyaqcv.ExceptionInfo_line_set, doc=r"""exception was throw in which line""")
    err_code = property(_pyaqcv.ExceptionInfo_err_code_get, _pyaqcv.ExceptionInfo_err_code_set, doc=r"""error code,every Exception has a specific error code""")

    def __init__(self):
        _pyaqcv.ExceptionInfo_swiginit(self, _pyaqcv.new_ExceptionInfo())
    __swig_destroy__ = _pyaqcv.delete_ExceptionInfo

# Register ExceptionInfo in _pyaqcv:
_pyaqcv.ExceptionInfo_swigregister(ExceptionInfo)

def geo_enable_exception():
    return _pyaqcv.geo_enable_exception()

def geo_handle_error(e):
    return _pyaqcv.geo_handle_error(e)
class WktReadError(GeometryException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.WktReadError_swiginit(self, _pyaqcv.new_WktReadError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_WktReadError

# Register WktReadError in _pyaqcv:
_pyaqcv.WktReadError_swigregister(WktReadError)
class HardwareError(GeometryException):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, msg, func, file, line):
        _pyaqcv.HardwareError_swiginit(self, _pyaqcv.new_HardwareError(msg, func, file, line))
    __swig_destroy__ = _pyaqcv.delete_HardwareError

# Register HardwareError in _pyaqcv:
_pyaqcv.HardwareError_swigregister(HardwareError)

def from_numpy(numpy_array, copy=True):
    return _pyaqcv.from_numpy(numpy_array, copy)

