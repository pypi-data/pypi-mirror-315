"""Autogenerated API schema"""
from argus_api import session


assess_event = {'tags': ['development'], 'summary': 'Assess event (DEV)', 'description': '', 'operationId': 'assessEvent', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Event ID', 'required': True, 'type': 'str'}, {'in': 'body', 'name': 'body', 'description': 'Event assessment request', 'required': False, 'schema': {'type': 'object', 'properties': {'enableFlag': {'type': 'list', 'position': 0, 'description': 'Which flags to enable. Overlap with disableFlag will be an invalid request.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['falsePositive', 'notAThreat', 'tuningCandidate', 'followup', 'identifiedThreat', 'acknowledged', 'partiallyAcknowledged']}}, 'disableFlag': {'type': 'list', 'position': 0, 'description': 'Which flags to disable. Overlap with enableFlag will be an invalid request.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['falsePositive', 'notAThreat', 'tuningCandidate', 'followup', 'identifiedThreat', 'acknowledged', 'partiallyAcknowledged']}}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'New severity of the event (if not set, keep current severity).', 'enum': ['low', 'medium', 'high', 'critical']}, 'comment': {'type': 'str', 'position': 0, 'description': 'Assessment comment to the event (not required).'}, 'handledByAnalyst': {'type': 'bool', 'position': 0, 'description': 'If true, then the event will be flagged as manually assessed by an analyst. (default false)', 'default': False}, 'associateCase': {'type': 'list', 'position': 0, 'description': 'Case IDs that are going to be associated with this event (not required).\nSpecified cases must be readable to the current user and they must belong to same customer as this event.\n', 'uniqueItems': True, 'items': {'type': 'int'}}, 'disassociateCase': {'type': 'list', 'position': 0, 'description': 'Case IDs that are going to be disassociated from this event\n(should not overlap with case IDs that are going to be associated with this event, not required).\n', 'uniqueItems': True, 'items': {'type': 'int'}}, 'trigger': {'type': 'list', 'position': 0, 'description': 'Set of checks which will be run after assessment (not required).', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['slaViolation', 'internalSlaViolation']}}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'Compatibility ID of the event (<type>/<timestamp>/<customerID>/<uuid>).'}, 'uuid': {'type': 'str', 'position': 0, 'description': 'UUID of the event.'}, 'type': 'str', 'source': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'destination': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the customer.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}}}, 'location': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the location.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the location.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}}}, 'signature': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'Name/ID of the signature.'}}}, 'alarm': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the alarm.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the alarm.'}, 'description': {'type': 'str', 'position': 0, 'description': 'Short description about the alarm.'}}}, 'attackCategory': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the attack category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the attack category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the attack category.'}}}, 'domain': {'type': 'str', 'position': 0, 'description': 'Fully qualified domain name associated with the event.'}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI associated with the event.'}, 'count': {'type': 'int', 'position': 0, 'description': 'Count of aggregate events, always 1 for raw events'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Enumerated severity of the event.', 'enum': ['low', 'medium', 'high', 'critical']}, 'timestamps': {'type': 'dict', 'properties': {'created': {'type': 'int', 'position': 0, 'description': 'Creation timestamp of the event.'}, 'lastUpdated': {'type': 'int', 'position': 0, 'description': 'Last update timestamp of the event (only for aggregated events).'}, 'firstEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the first observed event (only for aggregated events).'}, 'lastEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the last observed event (only for aggregated events).'}, 'enginePersisted': {'type': 'int', 'position': 0, 'description': 'Timestamp when the engine persisted the event.'}, 'firstAssessed': {'type': 'int', 'position': 0, 'description': 'Timestamp when the event was first assessed.'}, 'firstNotified': {'type': 'int', 'position': 0, 'description': 'Timestamp of the case association with the event.'}}}, 'sensor': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the device.'}, 'hostName': {'type': 'str', 'position': 0, 'description': 'Host name of the device.'}, 'ip': {'type': 'str', 'position': 0, 'description': 'IP address of the device.'}}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Enumerated Internet protocol of the event.', 'enum': ['tcp', 'udp', 'icmp', 'ip', 'esp', 'unknown']}, 'associatedCases': {'type': 'list', 'position': 0, 'description': 'Cases associated with the event (only available for aggregate events).', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the associated case.'}, 'subject': {'type': 'str', 'position': 0, 'description': 'Subject of the case.'}, 'categoryID': {'type': 'int', 'position': 0, 'description': 'Category ID of the case.'}, 'categoryName': {'type': 'str', 'position': 0, 'description': 'Category name of the case.'}, 'serviceID': {'type': 'int', 'position': 0, 'description': 'Service ID of the case.'}, 'serviceName': {'type': 'str', 'position': 0, 'description': 'Service name of the case.'}, 'status': {'type': 'str', 'position': 0, 'description': 'Status of the case.', 'enum': ['closed', 'pendingClose', 'pendingCustomer', 'pendingSoc', 'pendingVendor', 'workingCustomer', 'workingSoc']}, 'priority': {'type': 'str', 'position': 0, 'description': 'Priority of the case.', 'enum': ['low', 'medium', 'high', 'critical']}}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'If requested, contains the IDs of the events that the aggregated event consists of (null for raw events).', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'list', 'position': 0, 'description': 'If requested, contains a a filtered or full set of properties of the event.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'Key of the property.'}, 'type': 'str', 'values': {'type': 'list', 'position': 0, 'description': 'Value(s) of the property.', 'items': {'type': 'string'}}, 'options': ['boolean', 'long', 'string', 'double']}}}, 'comments': {'type': 'list', 'position': 0, 'description': 'If requested, contains the comments added to the event.', 'items': {'type': 'dict', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'Contents of the comment.'}, 'user': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the user.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the user.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the user.'}}}, 'timestamp': {'type': 'int', 'position': 0, 'description': 'Timestamp when the comment was created.'}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the event.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'options': ['aggregated', 'raw']}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Events not found'}, '412': {'description': 'Validation failed'}}}
assess_event_bulk = {'tags': ['development'], 'summary': 'Bulk assess events (DEV)', 'description': '', 'operationId': 'assessEventBulk', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Event bulk assessment request', 'required': False, 'schema': {'type': 'object', 'required': ['assessment', 'search'], 'properties': {'assessment': {'type': 'dict', 'properties': {'enableFlag': {'type': 'list', 'position': 0, 'description': 'Which flags to enable. Overlap with disableFlag will be an invalid request.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['falsePositive', 'notAThreat', 'tuningCandidate', 'followup', 'identifiedThreat', 'acknowledged', 'partiallyAcknowledged']}}, 'disableFlag': {'type': 'list', 'position': 0, 'description': 'Which flags to disable. Overlap with enableFlag will be an invalid request.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['falsePositive', 'notAThreat', 'tuningCandidate', 'followup', 'identifiedThreat', 'acknowledged', 'partiallyAcknowledged']}}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'New severity of the event (if not set, keep current severity).', 'enum': ['low', 'medium', 'high', 'critical']}, 'comment': {'type': 'str', 'position': 0, 'description': 'Assessment comment to the event (not required).'}, 'handledByAnalyst': {'type': 'bool', 'position': 0, 'description': 'If true, then the event will be flagged as manually assessed by an analyst. (default false)', 'default': False}, 'associateCase': {'type': 'list', 'position': 0, 'description': 'Case IDs that are going to be associated with this event (not required).\nSpecified cases must be readable to the current user and they must belong to same customer as this event.\n', 'uniqueItems': True, 'items': {'type': 'int'}}, 'disassociateCase': {'type': 'list', 'position': 0, 'description': 'Case IDs that are going to be disassociated from this event\n(should not overlap with case IDs that are going to be associated with this event, not required).\n', 'uniqueItems': True, 'items': {'type': 'int'}}, 'trigger': {'type': 'list', 'position': 0, 'description': 'Set of checks which will be run after assessment (not required).', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['slaViolation', 'internalSlaViolation']}}}}, 'search': {'type': 'dict', 'properties': {'type': 'list', 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'type': 'list', 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'type': 'list', 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': [], 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this sub criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this sub criterion.\nIf false the search only needs to match at least one sub criterion.\n (default false)', 'default': False}}, 'description': 'Sub-criteria allow constructing advanced queries with inclusions and exclusions'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this sub criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this sub criterion.\nIf false the search only needs to match at least one sub criterion.\n (default false)', 'default': False}}, 'description': 'Sub-criteria allow constructing advanced queries with inclusions and exclusions'}, 'maxItems': 10000, 'minItems': 0}, 'limit': {'type': 'int', 'position': 0, 'description': 'Limit the results to the specified amount. If set to 0 we will include all results matching the query (default 25)', 'minimum': 0, 'default': 25}, 'offset': {'type': 'int', 'position': 0, 'description': 'Skip specified amount of results (default 0)', 'minimum': 0, 'default': 0}, 'sortBy': {'type': 'list', 'position': 0, 'description': 'Which field(s) to sort the results by (default is ascending by createdTimestamp)', 'items': {'type': 'str', 'enum': ['customerID', 'eventID', 'createdTimestamp', 'lastUpdatedTimestamp', 'firstEventTimestamp', 'lastEventTimestamp', '-customerID', '-eventID', '-createdTimestamp', '-lastUpdatedTimestamp', '-firstEventTimestamp', '-lastEventTimestamp']}}, 'indexStartTimestamp': {'type': 'str', 'position': 0, 'description': 'Only search in indexes after or on this day. Defaults to current day.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. "\n+ "See the general integration guide for more details'}, 'indexEndTimestamp': {'type': 'str', 'position': 0, 'description': 'Only search in indexes before or on this day. Defaults to current day.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. "\n+ "See the general integration guide for more details'}}}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'successes': {'type': 'list', 'position': 0, 'description': 'IDs of the events that were successfully assessed.', 'uniqueItems': True, 'items': {'type': 'string'}}, 'failures': {'type': 'list', 'position': 0, 'description': 'Failure info of the events that failed assessment.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'eventID': {'type': 'str', 'position': 0, 'description': 'ID of the event that failed assessment.'}, 'reason': {'type': 'str', 'position': 0, 'description': 'The reason of assessment failure.'}}, 'description': 'Single event failure info.'}}}, 'description': 'A response that contains info about the bulk assessment of events.'}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
assess_event_by_compatibility_path = {'tags': ['development'], 'summary': 'Assess event (by compatibility path) (DEV)', 'description': '', 'operationId': 'assessEventCompatibility', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'type', 'in': 'path', 'description': 'Event type (ignored, provided for path compatibility)', 'required': True, 'type': 'str'}, {'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Event ID', 'required': True, 'type': 'str'}, {'in': 'body', 'name': 'body', 'description': 'Event assessment request', 'required': False, 'schema': {'type': 'object', 'properties': {'enableFlag': {'type': 'list', 'position': 0, 'description': 'Which flags to enable. Overlap with disableFlag will be an invalid request.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['falsePositive', 'notAThreat', 'tuningCandidate', 'followup', 'identifiedThreat', 'acknowledged', 'partiallyAcknowledged']}}, 'disableFlag': {'type': 'list', 'position': 0, 'description': 'Which flags to disable. Overlap with enableFlag will be an invalid request.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['falsePositive', 'notAThreat', 'tuningCandidate', 'followup', 'identifiedThreat', 'acknowledged', 'partiallyAcknowledged']}}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'New severity of the event (if not set, keep current severity).', 'enum': ['low', 'medium', 'high', 'critical']}, 'comment': {'type': 'str', 'position': 0, 'description': 'Assessment comment to the event (not required).'}, 'handledByAnalyst': {'type': 'bool', 'position': 0, 'description': 'If true, then the event will be flagged as manually assessed by an analyst. (default false)', 'default': False}, 'associateCase': {'type': 'list', 'position': 0, 'description': 'Case IDs that are going to be associated with this event (not required).\nSpecified cases must be readable to the current user and they must belong to same customer as this event.\n', 'uniqueItems': True, 'items': {'type': 'int'}}, 'disassociateCase': {'type': 'list', 'position': 0, 'description': 'Case IDs that are going to be disassociated from this event\n(should not overlap with case IDs that are going to be associated with this event, not required).\n', 'uniqueItems': True, 'items': {'type': 'int'}}, 'trigger': {'type': 'list', 'position': 0, 'description': 'Set of checks which will be run after assessment (not required).', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['slaViolation', 'internalSlaViolation']}}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'Compatibility ID of the event (<type>/<timestamp>/<customerID>/<uuid>).'}, 'uuid': {'type': 'str', 'position': 0, 'description': 'UUID of the event.'}, 'type': 'str', 'source': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'destination': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the customer.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}}}, 'location': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the location.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the location.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}}}, 'signature': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'Name/ID of the signature.'}}}, 'alarm': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the alarm.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the alarm.'}, 'description': {'type': 'str', 'position': 0, 'description': 'Short description about the alarm.'}}}, 'attackCategory': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the attack category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the attack category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the attack category.'}}}, 'domain': {'type': 'str', 'position': 0, 'description': 'Fully qualified domain name associated with the event.'}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI associated with the event.'}, 'count': {'type': 'int', 'position': 0, 'description': 'Count of aggregate events, always 1 for raw events'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Enumerated severity of the event.', 'enum': ['low', 'medium', 'high', 'critical']}, 'timestamps': {'type': 'dict', 'properties': {'created': {'type': 'int', 'position': 0, 'description': 'Creation timestamp of the event.'}, 'lastUpdated': {'type': 'int', 'position': 0, 'description': 'Last update timestamp of the event (only for aggregated events).'}, 'firstEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the first observed event (only for aggregated events).'}, 'lastEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the last observed event (only for aggregated events).'}, 'enginePersisted': {'type': 'int', 'position': 0, 'description': 'Timestamp when the engine persisted the event.'}, 'firstAssessed': {'type': 'int', 'position': 0, 'description': 'Timestamp when the event was first assessed.'}, 'firstNotified': {'type': 'int', 'position': 0, 'description': 'Timestamp of the case association with the event.'}}}, 'sensor': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the device.'}, 'hostName': {'type': 'str', 'position': 0, 'description': 'Host name of the device.'}, 'ip': {'type': 'str', 'position': 0, 'description': 'IP address of the device.'}}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Enumerated Internet protocol of the event.', 'enum': ['tcp', 'udp', 'icmp', 'ip', 'esp', 'unknown']}, 'associatedCases': {'type': 'list', 'position': 0, 'description': 'Cases associated with the event (only available for aggregate events).', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the associated case.'}, 'subject': {'type': 'str', 'position': 0, 'description': 'Subject of the case.'}, 'categoryID': {'type': 'int', 'position': 0, 'description': 'Category ID of the case.'}, 'categoryName': {'type': 'str', 'position': 0, 'description': 'Category name of the case.'}, 'serviceID': {'type': 'int', 'position': 0, 'description': 'Service ID of the case.'}, 'serviceName': {'type': 'str', 'position': 0, 'description': 'Service name of the case.'}, 'status': {'type': 'str', 'position': 0, 'description': 'Status of the case.', 'enum': ['closed', 'pendingClose', 'pendingCustomer', 'pendingSoc', 'pendingVendor', 'workingCustomer', 'workingSoc']}, 'priority': {'type': 'str', 'position': 0, 'description': 'Priority of the case.', 'enum': ['low', 'medium', 'high', 'critical']}}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'If requested, contains the IDs of the events that the aggregated event consists of (null for raw events).', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'list', 'position': 0, 'description': 'If requested, contains a a filtered or full set of properties of the event.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'Key of the property.'}, 'type': 'str', 'values': {'type': 'list', 'position': 0, 'description': 'Value(s) of the property.', 'items': {'type': 'string'}}, 'options': ['boolean', 'long', 'string', 'double']}}}, 'comments': {'type': 'list', 'position': 0, 'description': 'If requested, contains the comments added to the event.', 'items': {'type': 'dict', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'Contents of the comment.'}, 'user': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the user.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the user.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the user.'}}}, 'timestamp': {'type': 'int', 'position': 0, 'description': 'Timestamp when the comment was created.'}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the event.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'options': ['aggregated', 'raw']}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_event = {'tags': ['development'], 'summary': 'Fetches corresponding event (DEV)', 'description': '', 'operationId': 'getEventV2', 'produces': ['application/json'], 'parameters': [{'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Event ID', 'required': True, 'type': 'str'}, {'name': 'includeAllProperties', 'in': 'query', 'description': 'Whether to include all properties', 'required': False, 'type': 'bool', 'default': False}, {'name': 'includeComments', 'in': 'query', 'description': 'Whether to include comments', 'required': False, 'type': 'bool', 'default': False}, {'name': 'includeSubEvents', 'in': 'query', 'description': 'Whether to include sub-event IDs', 'required': False, 'type': 'bool', 'default': False}, {'name': 'includeProperties', 'in': 'query', 'description': 'Which properties to include in the response (if includeAllProperties=false)', 'required': False, 'type': 'list', 'items': {'type': 'string'}, 'collectionFormat': 'multi'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'Compatibility ID of the event (<type>/<timestamp>/<customerID>/<uuid>).'}, 'uuid': {'type': 'str', 'position': 0, 'description': 'UUID of the event.'}, 'type': 'str', 'source': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'destination': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the customer.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}}}, 'location': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the location.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the location.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}}}, 'signature': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'Name/ID of the signature.'}}}, 'alarm': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the alarm.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the alarm.'}, 'description': {'type': 'str', 'position': 0, 'description': 'Short description about the alarm.'}}}, 'attackCategory': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the attack category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the attack category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the attack category.'}}}, 'domain': {'type': 'str', 'position': 0, 'description': 'Fully qualified domain name associated with the event.'}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI associated with the event.'}, 'count': {'type': 'int', 'position': 0, 'description': 'Count of aggregate events, always 1 for raw events'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Enumerated severity of the event.', 'enum': ['low', 'medium', 'high', 'critical']}, 'timestamps': {'type': 'dict', 'properties': {'created': {'type': 'int', 'position': 0, 'description': 'Creation timestamp of the event.'}, 'lastUpdated': {'type': 'int', 'position': 0, 'description': 'Last update timestamp of the event (only for aggregated events).'}, 'firstEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the first observed event (only for aggregated events).'}, 'lastEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the last observed event (only for aggregated events).'}, 'enginePersisted': {'type': 'int', 'position': 0, 'description': 'Timestamp when the engine persisted the event.'}, 'firstAssessed': {'type': 'int', 'position': 0, 'description': 'Timestamp when the event was first assessed.'}, 'firstNotified': {'type': 'int', 'position': 0, 'description': 'Timestamp of the case association with the event.'}}}, 'sensor': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the device.'}, 'hostName': {'type': 'str', 'position': 0, 'description': 'Host name of the device.'}, 'ip': {'type': 'str', 'position': 0, 'description': 'IP address of the device.'}}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Enumerated Internet protocol of the event.', 'enum': ['tcp', 'udp', 'icmp', 'ip', 'esp', 'unknown']}, 'associatedCases': {'type': 'list', 'position': 0, 'description': 'Cases associated with the event (only available for aggregate events).', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the associated case.'}, 'subject': {'type': 'str', 'position': 0, 'description': 'Subject of the case.'}, 'categoryID': {'type': 'int', 'position': 0, 'description': 'Category ID of the case.'}, 'categoryName': {'type': 'str', 'position': 0, 'description': 'Category name of the case.'}, 'serviceID': {'type': 'int', 'position': 0, 'description': 'Service ID of the case.'}, 'serviceName': {'type': 'str', 'position': 0, 'description': 'Service name of the case.'}, 'status': {'type': 'str', 'position': 0, 'description': 'Status of the case.', 'enum': ['closed', 'pendingClose', 'pendingCustomer', 'pendingSoc', 'pendingVendor', 'workingCustomer', 'workingSoc']}, 'priority': {'type': 'str', 'position': 0, 'description': 'Priority of the case.', 'enum': ['low', 'medium', 'high', 'critical']}}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'If requested, contains the IDs of the events that the aggregated event consists of (null for raw events).', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'list', 'position': 0, 'description': 'If requested, contains a a filtered or full set of properties of the event.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'Key of the property.'}, 'type': 'str', 'values': {'type': 'list', 'position': 0, 'description': 'Value(s) of the property.', 'items': {'type': 'string'}}, 'options': ['boolean', 'long', 'string', 'double']}}}, 'comments': {'type': 'list', 'position': 0, 'description': 'If requested, contains the comments added to the event.', 'items': {'type': 'dict', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'Contents of the comment.'}, 'user': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the user.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the user.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the user.'}}}, 'timestamp': {'type': 'int', 'position': 0, 'description': 'Timestamp when the comment was created.'}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the event.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'options': ['aggregated', 'raw']}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_event_compatibility = {'tags': ['development'], 'summary': 'Fetches corresponding event (by compatibility path) (DEV)', 'description': '', 'operationId': 'getEventV2Compatibility', 'produces': ['application/json'], 'parameters': [{'name': 'type', 'in': 'path', 'description': 'Event type (ignored, provided for path compatibility)', 'required': True, 'type': 'str', 'pattern': '(AGGR|NIDS|RAW)'}, {'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Event ID', 'required': True, 'type': 'str'}, {'name': 'includeAllProperties', 'in': 'query', 'description': 'Whether to include all properties', 'required': False, 'type': 'bool', 'default': False}, {'name': 'includeComments', 'in': 'query', 'description': 'Whether to include comments', 'required': False, 'type': 'bool', 'default': False}, {'name': 'includeSubEvents', 'in': 'query', 'description': 'Whether to include sub-event IDs', 'required': False, 'type': 'bool', 'default': False}, {'name': 'includeProperties', 'in': 'query', 'description': 'Which properties to include in the response (if includeAllProperties=false)', 'required': False, 'type': 'list', 'items': {'type': 'string'}, 'collectionFormat': 'multi'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'Compatibility ID of the event (<type>/<timestamp>/<customerID>/<uuid>).'}, 'uuid': {'type': 'str', 'position': 0, 'description': 'UUID of the event.'}, 'type': 'str', 'source': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'destination': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the customer.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}}}, 'location': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the location.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the location.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}}}, 'signature': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'Name/ID of the signature.'}}}, 'alarm': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the alarm.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the alarm.'}, 'description': {'type': 'str', 'position': 0, 'description': 'Short description about the alarm.'}}}, 'attackCategory': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the attack category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the attack category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the attack category.'}}}, 'domain': {'type': 'str', 'position': 0, 'description': 'Fully qualified domain name associated with the event.'}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI associated with the event.'}, 'count': {'type': 'int', 'position': 0, 'description': 'Count of aggregate events, always 1 for raw events'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Enumerated severity of the event.', 'enum': ['low', 'medium', 'high', 'critical']}, 'timestamps': {'type': 'dict', 'properties': {'created': {'type': 'int', 'position': 0, 'description': 'Creation timestamp of the event.'}, 'lastUpdated': {'type': 'int', 'position': 0, 'description': 'Last update timestamp of the event (only for aggregated events).'}, 'firstEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the first observed event (only for aggregated events).'}, 'lastEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the last observed event (only for aggregated events).'}, 'enginePersisted': {'type': 'int', 'position': 0, 'description': 'Timestamp when the engine persisted the event.'}, 'firstAssessed': {'type': 'int', 'position': 0, 'description': 'Timestamp when the event was first assessed.'}, 'firstNotified': {'type': 'int', 'position': 0, 'description': 'Timestamp of the case association with the event.'}}}, 'sensor': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the device.'}, 'hostName': {'type': 'str', 'position': 0, 'description': 'Host name of the device.'}, 'ip': {'type': 'str', 'position': 0, 'description': 'IP address of the device.'}}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Enumerated Internet protocol of the event.', 'enum': ['tcp', 'udp', 'icmp', 'ip', 'esp', 'unknown']}, 'associatedCases': {'type': 'list', 'position': 0, 'description': 'Cases associated with the event (only available for aggregate events).', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the associated case.'}, 'subject': {'type': 'str', 'position': 0, 'description': 'Subject of the case.'}, 'categoryID': {'type': 'int', 'position': 0, 'description': 'Category ID of the case.'}, 'categoryName': {'type': 'str', 'position': 0, 'description': 'Category name of the case.'}, 'serviceID': {'type': 'int', 'position': 0, 'description': 'Service ID of the case.'}, 'serviceName': {'type': 'str', 'position': 0, 'description': 'Service name of the case.'}, 'status': {'type': 'str', 'position': 0, 'description': 'Status of the case.', 'enum': ['closed', 'pendingClose', 'pendingCustomer', 'pendingSoc', 'pendingVendor', 'workingCustomer', 'workingSoc']}, 'priority': {'type': 'str', 'position': 0, 'description': 'Priority of the case.', 'enum': ['low', 'medium', 'high', 'critical']}}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'If requested, contains the IDs of the events that the aggregated event consists of (null for raw events).', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'list', 'position': 0, 'description': 'If requested, contains a a filtered or full set of properties of the event.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'Key of the property.'}, 'type': 'str', 'values': {'type': 'list', 'position': 0, 'description': 'Value(s) of the property.', 'items': {'type': 'string'}}, 'options': ['boolean', 'long', 'string', 'double']}}}, 'comments': {'type': 'list', 'position': 0, 'description': 'If requested, contains the comments added to the event.', 'items': {'type': 'dict', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'Contents of the comment.'}, 'user': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the user.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the user.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the user.'}}}, 'timestamp': {'type': 'int', 'position': 0, 'description': 'Timestamp when the comment was created.'}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the event.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'options': ['aggregated', 'raw']}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_event_statistics = {'tags': ['development'], 'summary': 'Generate the requested statistics for events matching the provided search criteria. (DEV)', 'description': '', 'operationId': 'getEventStatistics', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Search criteria', 'required': False, 'schema': {'type': 'object', 'properties': {'type': {'type': 'list', 'position': 0, 'description': 'Restrict search to of events of this type. If nothing is specified we will return all types', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['aggregated', 'raw']}}, 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'type': 'list', 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'type': 'list', 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': [], 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this sub criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this sub criterion.\nIf false the search only needs to match at least one sub criterion.\n (default false)', 'default': False}}, 'description': 'Sub-criteria allow constructing advanced queries with inclusions and exclusions'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this sub criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this sub criterion.\nIf false the search only needs to match at least one sub criterion.\n (default false)', 'default': False}}, 'description': 'Sub-criteria allow constructing advanced queries with inclusions and exclusions'}, 'maxItems': 10000, 'minItems': 0}, 'groupBy': {'type': 'list', 'position': 0, 'description': 'The list of fields to group by\nThe order in the list will determine the hierarchy of the aggregations and their buckets.\n', 'items': {'type': 'dict', 'required': ['field'], 'properties': {'field': {'type': 'str', 'position': 0, 'description': 'The field to group by', 'enum': ['signature', 'attackCategory', 'alarm', 'location', 'severity', 'sourceIP', 'destinationIP', 'protocol', 'customer', 'sourceCountry', 'destinationCountry', 'associatedCase']}, 'limit': {'type': 'int', 'position': 0, 'description': 'The maximum number of groups to return'}, 'includeOthers': {'type': 'bool', 'position': 0, 'description': 'If true, one of the buckets will be the "other" bucket, which contains the count of the events not in the specified buckets\nThe other bucket will not have the rawEventCount field populated\n'}}, 'description': 'An GroupByCriteria represents which fields to aggregate statistics on'}}, 'timeline': {'type': 'list', 'position': 0, 'description': 'The set of time range metrics used to create histogram buckets\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['field', 'name', 'resolution'], 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'The name for this aggregation. Must be unique for the parent statistics request.\nThe name is used to identify the range aggregation in the result set.\n => [a-zA-Z0-9_:\\-\\.]*'}, 'field': {'type': 'str', 'position': 0, 'description': 'The field aggregated on to create the time range aggregation', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent']}, 'resolution': {'type': 'str', 'position': 0, 'description': 'The temporal resolution by which to sub-aggregate the range metric', 'enum': ['minutes', 'hours', 'days', 'weeks', 'months', 'years']}, 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Filter the by this min value. Defaults to 0 i.e. 1970-01-01. (default 0)'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Filter by this max value. Defaults to NOW'}, 'includeEmpty': {'type': 'bool', 'position': 0, 'description': 'Whether to return temporal buckets for the entire range regardless of whether they contain values (default true)', 'default': True}}, 'description': 'Request for statistics for events filtered by a time range'}}}, 'description': 'Request for creating aggregated statistics for an event'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'group': {'type': 'dict', 'properties': {'identifier': {'type': 'str', 'position': 0, 'description': "The aggregation container's identifier e.g. id or enum value"}, 'shortName': {'type': 'str', 'position': 0, 'description': "The aggregation container's shortName. Depending on the type of metadata can also be used to retrieve the full object."}, 'displayName': {'type': 'str', 'position': 0, 'description': "The aggregation container's display name."}, 'type': 'str', 'options': ['signature', 'attackCategory', 'alarm', 'location', 'severity', 'sourceIP', 'destinationIP', 'protocol', 'customer', 'sourceCountry', 'destinationCountry', 'associatedCase']}, 'description': 'A statistics field group'}, 'count': {'type': 'int', 'position': 0, 'description': 'The number of events contained within this record sharing the same metadata'}, 'rawEventCount': {'type': 'int', 'position': 0, 'description': 'The number of raw events found within this record sharing the same metadata'}, 'buckets': {'type': 'list', 'position': 0, 'description': 'Metric buckets below this level', 'items': {'type': 'dict', 'properties': {'group': {'type': 'dict', 'properties': {'identifier': {'type': 'str', 'position': 0, 'description': "The aggregation container's identifier e.g. id or enum value"}, 'shortName': {'type': 'str', 'position': 0, 'description': "The aggregation container's shortName. Depending on the type of metadata can also be used to retrieve the full object."}, 'displayName': {'type': 'str', 'position': 0, 'description': "The aggregation container's display name."}, 'type': 'str', 'options': ['signature', 'attackCategory', 'alarm', 'location', 'severity', 'sourceIP', 'destinationIP', 'protocol', 'customer', 'sourceCountry', 'destinationCountry', 'associatedCase']}, 'description': 'A statistics field group'}, 'count': {'type': 'int', 'position': 0, 'description': 'The number of events contained within this record sharing the same metadata'}, 'rawEventCount': {'type': 'int', 'position': 0, 'description': 'The number of raw events found within this record sharing the same metadata'}, 'buckets': {'type': 'list', 'position': 0, 'description': 'Metric buckets below this level', 'items': []}, 'timeline': {'type': 'list', 'position': 0, 'description': 'Time range metrics for the requested fields. Only ever found at the bottom of the bucket hierarchy.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'The name for this aggregation. It will match the one defined in the EventTimelineCriteria'}, 'count': {'type': 'int', 'position': 0, 'description': 'The number of events contained within this record sharing the same metadata'}, 'rawEventCount': {'type': 'int', 'position': 0, 'description': 'The number of raw events found within this record sharing the same metadata'}, 'buckets': {'type': 'list', 'position': 0, 'description': 'The histogram buckets', 'items': {'type': 'dict', 'properties': {'timestamp': {'type': 'int', 'position': 0, 'description': 'The start timestamp of the bucket'}, 'count': {'type': 'int', 'position': 0, 'description': 'The number of events in the bucket'}, 'rawEventCount': {'type': 'int', 'position': 0, 'description': 'The number of raw events in the bucket, i.e. the sum of the count of the events in the bucket'}}, 'description': 'A timeline histogram bucket'}}}, 'description': 'Metric representing the number of documents that matched the timestamp filter for a given time field\ne.g. events created within the last 2 weeks\n'}}}, 'description': 'Container for statistics about events'}}, 'timeline': {'type': 'list', 'position': 0, 'description': 'Time range metrics for the requested fields. Only ever found at the bottom of the bucket hierarchy.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'The name for this aggregation. It will match the one defined in the EventTimelineCriteria'}, 'count': {'type': 'int', 'position': 0, 'description': 'The number of events contained within this record sharing the same metadata'}, 'rawEventCount': {'type': 'int', 'position': 0, 'description': 'The number of raw events found within this record sharing the same metadata'}, 'buckets': {'type': 'list', 'position': 0, 'description': 'The histogram buckets', 'items': {'type': 'dict', 'properties': {'timestamp': {'type': 'int', 'position': 0, 'description': 'The start timestamp of the bucket'}, 'count': {'type': 'int', 'position': 0, 'description': 'The number of events in the bucket'}, 'rawEventCount': {'type': 'int', 'position': 0, 'description': 'The number of raw events in the bucket, i.e. the sum of the count of the events in the bucket'}}, 'description': 'A timeline histogram bucket'}}}, 'description': 'Metric representing the number of documents that matched the timestamp filter for a given time field\ne.g. events created within the last 2 weeks\n'}}}, 'description': 'Container for statistics about events'}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
get_payload = {'tags': ['development'], 'summary': 'Fetch specified event payload (DEV)', 'description': '', 'operationId': 'getPayloadV2', 'produces': ['application/json'], 'parameters': [{'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Unique UUID for the event', 'required': True, 'type': 'str'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'The ID of the event the payload was fetched for. The actual payload may belong to sub events'}, 'type': 'str', 'payload': {'type': 'str', 'position': 0, 'description': 'Payload string (may be base64-encoded binary, depending on type)'}, 'options': ['ethernet', 'binary', 'string', 'pcap']}, 'description': 'A payload response.\nThis response contains the event id used to fetch the payload, the payloads type, and the actual payload.\n'}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_payload_compatibility = {'tags': ['development'], 'summary': '  Fetch specified event payload. This variant accepts a type parameter which is not used\n  but should make it easier to paste in AGGR-ids from the v1 api.\n (DEV)', 'description': '', 'operationId': 'getPayloadV2Compatibility', 'produces': ['application/json'], 'parameters': [{'name': 'type', 'in': 'path', 'description': 'Event type (ignored, provided for path compatibility)', 'required': True, 'type': 'str', 'pattern': '(AGGR|NIDS|RAW)'}, {'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Unique UUID for the event', 'required': True, 'type': 'str'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'The ID of the event the payload was fetched for. The actual payload may belong to sub events'}, 'type': 'str', 'payload': {'type': 'str', 'position': 0, 'description': 'Payload string (may be base64-encoded binary, depending on type)'}, 'options': ['ethernet', 'binary', 'string', 'pcap']}, 'description': 'A payload response.\nThis response contains the event id used to fetch the payload, the payloads type, and the actual payload.\n'}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_pcap = {'tags': ['development'], 'summary': 'Fetch specified event payload as PCAP (DEV)', 'description': '', 'operationId': 'getPCAPV2', 'produces': ['application/x-pcap'], 'parameters': [{'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Unique UUID for the event', 'required': True, 'type': 'str'}], 'responses': {'401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_pcap_compatibility = {'tags': ['development'], 'summary': 'Fetch specified event payload as PCAP. This variant accepts a type parameter which is not used\nbut should make it easier to paste in AGGR-ids from the v1 api.\n (DEV)', 'description': '', 'operationId': 'getPCAPV2Compatibility', 'produces': ['application/x-pcap'], 'parameters': [{'name': 'type', 'in': 'path', 'description': 'Event type (ignored, provided for path compatibility)', 'required': True, 'type': 'str', 'pattern': '(AGGR|NIDS|RAW)'}, {'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Unique UUID for the event', 'required': True, 'type': 'str'}], 'responses': {'401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
list_event_v2_lineage = {'tags': ['development'], 'summary': 'Fetches the lineage of an event (DEV)', 'description': '', 'operationId': 'listEventV2Lineage', 'produces': ['application/json'], 'parameters': [{'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Event ID', 'required': True, 'type': 'str'}, {'name': 'sortBy', 'in': 'query', 'description': 'List of properties to sort by (prefix with "-" to sort descending)\nOnly accepts createdTimestamp and -createdTimestamp\nIf no value is given, it defaults to sorting by createdTimestamp descending\n', 'required': False, 'type': 'list', 'items': {'type': 'string'}, 'collectionFormat': 'multi'}, {'name': 'limit', 'in': 'query', 'description': 'The max number of events to return', 'required': False, 'type': 'int', 'default': 25, 'minimum': 0}, {'name': 'offset', 'in': 'query', 'description': 'The offset of the search', 'required': False, 'type': 'int', 'default': 0, 'minimum': 0}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'ID of the lineage event'}, 'type': 'str', 'description': {'type': 'str', 'position': 0, 'description': 'A description of the change event'}, 'dataCenter': {'type': 'str', 'position': 0, 'description': 'The data center the change event was performed in', 'enum': ['osl', 'svg']}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'The timestamp the change event was created'}, 'eventLastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'The lastUpdatedTimestamp of the event when the change was performed'}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'options': ['created', 'updated', 'assessed', 'indexedElasticSearch', 'indexedOpenSearch']}}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
list_event_v2_lineage_compatibility = {'tags': ['development'], 'summary': 'Fetches the lineage of an event (DEV)', 'description': '', 'operationId': 'listEventV2LineageCompatibility', 'produces': ['application/json'], 'parameters': [{'name': 'timestamp', 'in': 'path', 'description': 'Event timestamp', 'required': True, 'type': 'int', 'minimum': 0}, {'name': 'customerID', 'in': 'path', 'description': 'Customer ID', 'required': True, 'type': 'int', 'minimum': 1}, {'name': 'eventID', 'in': 'path', 'description': 'Event ID', 'required': True, 'type': 'str'}, {'name': 'sortBy', 'in': 'query', 'description': 'List of properties to sort by (prefix with "-" to sort descending)\nOnly accepts createdTimestamp and -createdTimestamp\nIf no value is given, it defaults to sorting by createdTimestamp descending\n', 'required': False, 'type': 'list', 'items': {'type': 'string'}, 'collectionFormat': 'multi'}, {'name': 'limit', 'in': 'query', 'description': 'The max number of events to return', 'required': False, 'type': 'int', 'default': 25, 'minimum': 0}, {'name': 'offset', 'in': 'query', 'description': 'The offset of the search', 'required': False, 'type': 'int', 'default': 0, 'minimum': 0}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'ID of the lineage event'}, 'type': 'str', 'description': {'type': 'str', 'position': 0, 'description': 'A description of the change event'}, 'dataCenter': {'type': 'str', 'position': 0, 'description': 'The data center the change event was performed in', 'enum': ['osl', 'svg']}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'The timestamp the change event was created'}, 'eventLastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'The lastUpdatedTimestamp of the event when the change was performed'}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'options': ['created', 'updated', 'assessed', 'indexedElasticSearch', 'indexedOpenSearch']}}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
list_events = {'tags': ['development'], 'summary': 'Simple search for events (DEV)', 'description': '', 'operationId': 'listEvents', 'produces': ['application/json', 'text/csv', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/jsonl'], 'parameters': [{'name': 'Accept', 'in': 'header', 'required': False, 'type': 'string'}, {'name': 'type', 'in': 'query', 'description': 'Limit to events of this type', 'required': False, 'type': 'list', 'items': {'type': 'str', 'enum': ['aggregated', 'raw']}, 'collectionFormat': 'multi'}, {'name': 'customer', 'in': 'query', 'description': 'Limit to customer', 'required': False, 'type': 'list', 'items': {'type': 'string'}, 'collectionFormat': 'multi'}, {'name': 'signature', 'in': 'query', 'description': 'Limit to signature', 'required': False, 'type': 'list', 'items': {'type': 'string'}, 'collectionFormat': 'multi'}, {'name': 'startTimestamp', 'in': 'query', 'description': 'Only look for events after this timestamp', 'required': False, 'type': 'int'}, {'name': 'endTimestamp', 'in': 'query', 'description': 'Only look for events before this timestamp', 'required': False, 'type': 'int'}, {'name': 'limit', 'in': 'query', 'description': 'The max number of events to return', 'required': False, 'type': 'int', 'default': 25, 'minimum': 0}, {'name': 'offset', 'in': 'query', 'description': 'The offset of the search', 'required': False, 'type': 'int', 'default': 0, 'minimum': 0}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'Compatibility ID of the event (<type>/<timestamp>/<customerID>/<uuid>).'}, 'uuid': {'type': 'str', 'position': 0, 'description': 'UUID of the event.'}, 'type': 'str', 'source': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'destination': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the customer.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}}}, 'location': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the location.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the location.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}}}, 'signature': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'Name/ID of the signature.'}}}, 'alarm': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the alarm.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the alarm.'}, 'description': {'type': 'str', 'position': 0, 'description': 'Short description about the alarm.'}}}, 'attackCategory': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the attack category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the attack category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the attack category.'}}}, 'domain': {'type': 'str', 'position': 0, 'description': 'Fully qualified domain name associated with the event.'}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI associated with the event.'}, 'count': {'type': 'int', 'position': 0, 'description': 'Count of aggregate events, always 1 for raw events'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Enumerated severity of the event.', 'enum': ['low', 'medium', 'high', 'critical']}, 'timestamps': {'type': 'dict', 'properties': {'created': {'type': 'int', 'position': 0, 'description': 'Creation timestamp of the event.'}, 'lastUpdated': {'type': 'int', 'position': 0, 'description': 'Last update timestamp of the event (only for aggregated events).'}, 'firstEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the first observed event (only for aggregated events).'}, 'lastEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the last observed event (only for aggregated events).'}, 'enginePersisted': {'type': 'int', 'position': 0, 'description': 'Timestamp when the engine persisted the event.'}, 'firstAssessed': {'type': 'int', 'position': 0, 'description': 'Timestamp when the event was first assessed.'}, 'firstNotified': {'type': 'int', 'position': 0, 'description': 'Timestamp of the case association with the event.'}}}, 'sensor': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the device.'}, 'hostName': {'type': 'str', 'position': 0, 'description': 'Host name of the device.'}, 'ip': {'type': 'str', 'position': 0, 'description': 'IP address of the device.'}}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Enumerated Internet protocol of the event.', 'enum': ['tcp', 'udp', 'icmp', 'ip', 'esp', 'unknown']}, 'associatedCases': {'type': 'list', 'position': 0, 'description': 'Cases associated with the event (only available for aggregate events).', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the associated case.'}, 'subject': {'type': 'str', 'position': 0, 'description': 'Subject of the case.'}, 'categoryID': {'type': 'int', 'position': 0, 'description': 'Category ID of the case.'}, 'categoryName': {'type': 'str', 'position': 0, 'description': 'Category name of the case.'}, 'serviceID': {'type': 'int', 'position': 0, 'description': 'Service ID of the case.'}, 'serviceName': {'type': 'str', 'position': 0, 'description': 'Service name of the case.'}, 'status': {'type': 'str', 'position': 0, 'description': 'Status of the case.', 'enum': ['closed', 'pendingClose', 'pendingCustomer', 'pendingSoc', 'pendingVendor', 'workingCustomer', 'workingSoc']}, 'priority': {'type': 'str', 'position': 0, 'description': 'Priority of the case.', 'enum': ['low', 'medium', 'high', 'critical']}}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'If requested, contains the IDs of the events that the aggregated event consists of (null for raw events).', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'list', 'position': 0, 'description': 'If requested, contains a a filtered or full set of properties of the event.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'Key of the property.'}, 'type': 'str', 'values': {'type': 'list', 'position': 0, 'description': 'Value(s) of the property.', 'items': {'type': 'string'}}, 'options': ['boolean', 'long', 'string', 'double']}}}, 'comments': {'type': 'list', 'position': 0, 'description': 'If requested, contains the comments added to the event.', 'items': {'type': 'dict', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'Contents of the comment.'}, 'user': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the user.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the user.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the user.'}}}, 'timestamp': {'type': 'int', 'position': 0, 'description': 'Timestamp when the comment was created.'}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the event.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'options': ['aggregated', 'raw']}}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
reindex_events = {'tags': ['events/v2'], 'summary': 'Reindexes a set of events into the search engine (INTERNAL)', 'description': '', 'operationId': 'reindexEvents', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'required': False, 'schema': {'type': 'object', 'properties': {'eventID': {'type': 'list', 'position': 0, 'description': 'The events that should be reindexed. The set should contain event IDs on the Argus EventID format, e.g. AGGR/10000/1/8bf1732c-f845-409a-8425-8fad3b5007ab.\nIf one of the IDs is malformed, or does not match an event you have access to the request will fail.\n', 'uniqueItems': True, 'items': {'type': 'string'}}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'count': {'type': 'int', 'position': 0, 'description': 'The number of reindex-ed events'}}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
search_events = {'tags': ['development'], 'summary': 'Searches for events (DEV)', 'description': '', 'operationId': 'searchEvents', 'consumes': ['application/json'], 'produces': ['application/json', 'text/csv', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/jsonl'], 'parameters': [{'name': 'Accept', 'in': 'header', 'required': False, 'type': 'string'}, {'in': 'body', 'name': 'body', 'description': 'Search criteria', 'required': False, 'schema': {'type': 'object', 'properties': {'type': {'type': 'list', 'position': 0, 'description': 'Restrict search to of events of this type. If nothing is specified we will return all types', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['aggregated', 'raw']}}, 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'type': 'list', 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'type': 'list', 'startTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data after this time.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'endTimestamp': {'type': 'str', 'position': 0, 'description': 'Restrict search to data before this time (epoch millis)\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Which time fields to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['created', 'lastUpdated', 'firstAssessment', 'enginePersisted', 'firstEvent', 'lastEvent', 'all']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Which time match strategy to use. Defaults to matching if any (default any)', 'enum': ['any', 'all']}, 'severity': {'type': 'list', 'position': 0, 'description': 'Which severities to search for', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['low', 'medium', 'high', 'critical']}}, 'eventIdentifier': {'type': 'list', 'position': 0, 'description': 'Which event identifiers to search for', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'customer': {'type': 'list', 'position': 0, 'description': 'Which customers to search for events for. Search by id or short name', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'productionCustomers': {'type': 'bool', 'position': 0, 'description': "Restricts the search to customers that either are, or are not in production.\nIf null we don't filter (default)\nIf true we only return production customers\nIf false, we exclude all production customers\n"}, 'endpoint': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with endpoints matching these criteria\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'ip': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints covered by one of these IPs\nYou can use CIDR notation to specify ip networks\n => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'endpointFieldStrategy': {'type': 'str', 'position': 0, 'description': 'Restrict the criterion to match with endpoints of this type (default all)', 'enum': ['source', 'destination', 'all']}, 'port': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with one of these ports', 'uniqueItems': True, 'items': {'type': 'int'}}, 'countryCode': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints located in one of these countries, specified by county code', 'uniqueItems': True, 'items': {'type': 'string'}}, 'minMaskBits': {'type': 'int', 'position': 0, 'description': 'Restrict the criterion to match with endpoints where the mask bits on the IP no wider than this'}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict the criterion to match with endpoints with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Endpoint criteria limit search depending on the endpoints of the event.\nThe fields in one EndpointCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'attack': {'type': 'list', 'position': 0, 'description': 'Restrict search to events matching these attack criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query\n', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'signature': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these signatures', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these alarms( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Restricts the search to events triggered by one of these attack categories( id or short name)', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Attack criteria limit search depending on the attack that triggered the event.\nThe fields in one AttackCriteria are AND-ed together\n'}, 'maxItems': 10000, 'minItems': 0}, 'domain': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with one of these domains set', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'includeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with ALL of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'excludeFlag': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with NONE of these flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'property': {'type': 'list', 'position': 0, 'description': 'Restrict search to events with properties matching these criteria.\nThese criteria follow sub request logic, which means that they are by default OR-ed together,\nbut will be AND-ed together if you set required=true.\nYou can also use exclude=true to match on the negation of the query.\n', 'uniqueItems': True, 'items': {'type': 'dict', 'required': ['valueMatchStrategy', 'valueSearchStrategy'], 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'The key of the property to search for. If the search will look for the value in any property'}, 'value': {'type': 'list', 'position': 0, 'description': 'The value of the property to search for. If not set, we will look for the presence of the key', 'uniqueItems': True, 'items': {'type': 'string'}, 'maxItems': 10000, 'minItems': 0}, 'valueMatchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the criteria matches the values (default any)', 'enum': ['any', 'all']}, 'valueSearchStrategy': {'type': 'str', 'position': 0, 'description': 'The strategy for deciding if the value matches the property (default exact)', 'enum': ['tokenized', 'exact']}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this criterion.\nIf false the search only needs to match at least one criterion.\n (default false)', 'default': False}}, 'description': 'Property criteria limit search depending on the properties that are set on the event.\n'}, 'maxItems': 10000, 'minItems': 0}, 'associatedCase': {'type': 'list', 'position': 0, 'description': 'Restrict search to events associated to cases with these IDs.\nNOTE: Searching for ID 0 will return events that are not associated to any cases.\n', 'uniqueItems': True, 'items': {'type': 'int'}, 'maxItems': 10000, 'minItems': 0}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'The set of sub criteria to add to the search', 'uniqueItems': True, 'items': [], 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this sub criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this sub criterion.\nIf false the search only needs to match at least one sub criterion.\n (default false)', 'default': False}}, 'description': 'Sub-criteria allow constructing advanced queries with inclusions and exclusions'}, 'maxItems': 10000, 'minItems': 0}, 'exclude': {'type': 'bool', 'position': 0, 'description': 'Exclude events that match this sub criterion (default false)', 'default': False}, 'required': {'type': 'bool', 'position': 0, 'description': 'Require that events match this sub criterion.\nIf false the search only needs to match at least one sub criterion.\n (default false)', 'default': False}}, 'description': 'Sub-criteria allow constructing advanced queries with inclusions and exclusions'}, 'maxItems': 10000, 'minItems': 0}, 'limit': {'type': 'int', 'position': 0, 'description': 'Limit the results to the specified amount. If set to 0 we will stream all results matching the query (default 25)', 'default': 25}, 'offset': {'type': 'int', 'position': 0, 'description': 'Skip specified amount of results (default 0)', 'default': 0}, 'indexStartTimestamp': {'type': 'str', 'position': 0, 'description': 'Only search in indexes after or on this day.\nDefaults to current day.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'indexEndTimestamp': {'type': 'str', 'position': 0, 'description': 'Only search in indexes before or on this day.\nDefaults to current day.\nTimestamps can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details\n'}, 'sortBy': {'type': 'list', 'position': 0, 'description': 'Which field(s) by which to sort the results', 'items': {'type': 'str', 'enum': ['customerID', 'eventID', 'createdTimestamp', 'lastUpdatedTimestamp', 'firstEventTimestamp', 'lastEventTimestamp', '-customerID', '-eventID', '-createdTimestamp', '-lastUpdatedTimestamp', '-firstEventTimestamp', '-lastEventTimestamp']}}, 'includeAllProperties': {'type': 'bool', 'position': 0, 'description': "Whether to include all properties (overrides the selection of 'includeProperties' if set to true). (default false)", 'default': False}, 'includeComments': {'type': 'bool', 'position': 0, 'description': 'Whether to include comments. (default false)', 'default': False}, 'includeSubEvents': {'type': 'bool', 'position': 0, 'description': "Whether to include sub-events' IDs (only for aggregated events). (default false)", 'default': False}, 'includeProperties': {'type': 'list', 'position': 0, 'description': 'Which properties to include (if includeAllProperties=false).', 'uniqueItems': True, 'items': {'type': 'string'}}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'Compatibility ID of the event (<type>/<timestamp>/<customerID>/<uuid>).'}, 'uuid': {'type': 'str', 'position': 0, 'description': 'UUID of the event.'}, 'type': 'str', 'source': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'destination': {'type': 'dict', 'properties': {'address': {'type': 'str', 'position': 0, 'description': 'IP address of the endpoint.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Host name of the endpoint.'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port of the endpoint (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'User associated with this endpoint.'}, 'geoInfo': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': 'Two-letter code of the country where this location is in.'}, 'countryName': {'type': 'str', 'position': 0, 'description': 'Name of the country where this location is in.'}, 'locationName': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Geographic latitude of the location.'}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Geographic longitude of the location.'}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the endpoint.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['isCustomerNet', 'isPartialCustomerNet', 'customAggregation', 'isManagedBySoc']}}}}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the customer.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}}}, 'location': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the location.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the location.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the location.'}}}, 'signature': {'type': 'dict', 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'Name/ID of the signature.'}}}, 'alarm': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the alarm.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the alarm.'}, 'description': {'type': 'str', 'position': 0, 'description': 'Short description about the alarm.'}}}, 'attackCategory': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the attack category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the attack category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the attack category.'}}}, 'domain': {'type': 'str', 'position': 0, 'description': 'Fully qualified domain name associated with the event.'}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI associated with the event.'}, 'count': {'type': 'int', 'position': 0, 'description': 'Count of aggregate events, always 1 for raw events'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Enumerated severity of the event.', 'enum': ['low', 'medium', 'high', 'critical']}, 'timestamps': {'type': 'dict', 'properties': {'created': {'type': 'int', 'position': 0, 'description': 'Creation timestamp of the event.'}, 'lastUpdated': {'type': 'int', 'position': 0, 'description': 'Last update timestamp of the event (only for aggregated events).'}, 'firstEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the first observed event (only for aggregated events).'}, 'lastEvent': {'type': 'int', 'position': 0, 'description': 'Timestamp of the last observed event (only for aggregated events).'}, 'enginePersisted': {'type': 'int', 'position': 0, 'description': 'Timestamp when the engine persisted the event.'}, 'firstAssessed': {'type': 'int', 'position': 0, 'description': 'Timestamp when the event was first assessed.'}, 'firstNotified': {'type': 'int', 'position': 0, 'description': 'Timestamp of the case association with the event.'}}}, 'sensor': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the device.'}, 'hostName': {'type': 'str', 'position': 0, 'description': 'Host name of the device.'}, 'ip': {'type': 'str', 'position': 0, 'description': 'IP address of the device.'}}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Enumerated Internet protocol of the event.', 'enum': ['tcp', 'udp', 'icmp', 'ip', 'esp', 'unknown']}, 'associatedCases': {'type': 'list', 'position': 0, 'description': 'Cases associated with the event (only available for aggregate events).', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the associated case.'}, 'subject': {'type': 'str', 'position': 0, 'description': 'Subject of the case.'}, 'categoryID': {'type': 'int', 'position': 0, 'description': 'Category ID of the case.'}, 'categoryName': {'type': 'str', 'position': 0, 'description': 'Category name of the case.'}, 'serviceID': {'type': 'int', 'position': 0, 'description': 'Service ID of the case.'}, 'serviceName': {'type': 'str', 'position': 0, 'description': 'Service name of the case.'}, 'status': {'type': 'str', 'position': 0, 'description': 'Status of the case.', 'enum': ['closed', 'pendingClose', 'pendingCustomer', 'pendingSoc', 'pendingVendor', 'workingCustomer', 'workingSoc']}, 'priority': {'type': 'str', 'position': 0, 'description': 'Priority of the case.', 'enum': ['low', 'medium', 'high', 'critical']}}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'If requested, contains the IDs of the events that the aggregated event consists of (null for raw events).', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'list', 'position': 0, 'description': 'If requested, contains a a filtered or full set of properties of the event.', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'key': {'type': 'str', 'position': 0, 'description': 'Key of the property.'}, 'type': 'str', 'values': {'type': 'list', 'position': 0, 'description': 'Value(s) of the property.', 'items': {'type': 'string'}}, 'options': ['boolean', 'long', 'string', 'double']}}}, 'comments': {'type': 'list', 'position': 0, 'description': 'If requested, contains the comments added to the event.', 'items': {'type': 'dict', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'Contents of the comment.'}, 'user': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the user.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the user.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the user.'}}}, 'timestamp': {'type': 'int', 'position': 0, 'description': 'Timestamp when the comment was created.'}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Enumerated flags describing the features of the event.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['established', 'blocked', 'partiallyBlocked', 'snapshot', 'finalized', 'falsePositive', 'notAThreat', 'tuningCandidate', 'notified', 'notifiedUnpublished', 'notifiedDeleted', 'followup', 'partiallyNotified', 'identifiedThreat', 'threatCandidate', 'acknowledged', 'partiallyAcknowledged', 'severityAdjusted', 'commented', 'filtered', 'checked', 'incompleteDetails', 'aggregatedBaseEvent', 'remoteStorage', 'hasDetails', 'hasPayload', 'hasPcap', 'associatedToCaseByFilter', 'severityIncreasedByFilter', 'severityReducedByFilter', 'createdByAnalysisFilter', 'extendEventTtl', 'initialTuning', 'postAnalysis', 'partialSslTerminated', 'sslTerminated', 'autoReport', 'missingTimestamp', 'clockOutOfSync', 'dropAnalysis', 'escalatedByReputation', 'hasSample', 'storeEvent', 'storeAggregated', 'handledByAnalyst', 'slaViolation', 'payloadTruncated', 'hasStringPayload', 'reassessed']}}, 'options': ['aggregated', 'raw']}}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
submit_events = {'tags': ['events/v2'], 'summary': 'Submit event to central storage. (INTERNAL)', 'description': 'This is a collector API, which will collect and enqueue the events for central storage.When this endpoint returns, the service guarantees that the events are validated and safely received for transport and storage. However, the services makes no guarantees for when the events will be searchable from the search endpoints.\n\nValidated events are enqueued for storage; the response will not indicate whether the event has been inserted or updated. Writing to an event ID (type/timestamp/customerID/UUID) of an existing event, will update/append the existing event with changed fields, and add flags/properties.\n\n If an event attempts to update an existing event which is marked as FINALIZED, the update will be ignored, even if this endpoint accepts the event.', 'operationId': 'submitEvents', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Event create request', 'required': False, 'schema': {'type': 'object', 'properties': {'startTimestamp': {'type': 'int'}, 'endTimestamp': {'type': 'int'}, 'id': {'type': 'dict', 'properties': {'uuid': {'type': 'str'}, 'customerDomain': {'type': 'string'}, 'customer': {'type': 'string'}, 'timestamp': {'type': 'int'}, 'type': 'str', 'options': ['raw', 'aggregated']}}, 'signature': {'type': 'str', 'position': 0, 'description': 'Event signature. If set, the system will automatically assign alarm and attack category based on this value.'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Event severity. When creating a new event, the default severity is low.', 'enum': ['low', 'medium', 'high', 'critical']}, 'count': {'type': 'int', 'position': 0, 'description': 'Number of occurrences this event represents. The value must be at least 1, which is the default.'}, 'location': {'type': 'str', 'position': 0, 'description': 'The sensor location (id or shortname) where this event was observed. If set, this location must be resolvable for the current user, and must either belong to the same customer as this event, or be a global location.'}, 'protocol': {'type': 'str', 'position': 0, 'description': 'The protocol id or well-known name. Numeric protocol ID must be between 0 and 255. Protocol name must be well known (icmp, tcp, udp, esp, ah)'}, 'source': {'type': 'dict', 'properties': {'ip': {'type': 'str', 'position': 0, 'description': 'IPv4 or IPv6 address (host or CIDR notation).'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'Username or identifier.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Hostname or identifier.'}, 'geoLocation': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': '2-letter country code.'}, 'geoLocationID': {'type': 'int', 'position': 0, 'description': 'MaxMind geolocation ID.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Latitude for location coordinates', 'minimum': -90, 'maximum': 90}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Longitude for location coordinates', 'minimum': -180, 'maximum': 180}}}}}, 'destination': {'type': 'dict', 'properties': {'ip': {'type': 'str', 'position': 0, 'description': 'IPv4 or IPv6 address (host or CIDR notation).'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'Username or identifier.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Hostname or identifier.'}, 'geoLocation': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': '2-letter country code.'}, 'geoLocationID': {'type': 'int', 'position': 0, 'description': 'MaxMind geolocation ID.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Latitude for location coordinates', 'minimum': -90, 'maximum': 90}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Longitude for location coordinates', 'minimum': -180, 'maximum': 180}}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Event flags requested by the client for this event. On updating an existing event, existing flags will be retained, and flags in the update will be added. Flags that have a PARTIAL flag have custom handling. If FINALIZED flag is set, additional updates to this event will be ignored.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'HAS_DETAILS', 'HAS_PAYLOAD', 'HAS_PCAP', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED', 'SOURCE_IS_MANAGED_BY_SOC', 'DESTINATION_IS_MANAGED_BY_SOC', 'SLA_VIOLATION', 'HANDLED_BY_ANALYST', 'PAYLOAD_TRUNCATED', 'HAS_STRING_PAYLOAD', 'REASSESSED']}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Custom properties for this event. Each property key may have multiple values.\nOn updating an existing event, setting an existing property will overwrite existing value.\n\nThe max length of property keys is 50 characters. Keys longer than that will be truncated to the first 50.\nIf there are duplicate keys, one will overwrite the other.\nThis will also happen if there are duplicates after truncation.\n\nThe max length of property values are 1024 characters for each value.\nAny value longer than this will be truncated to 1024 characters.\n', 'additionalProperties': {'type': 'list', 'uniqueItems': True, 'items': {'type': 'string'}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'IDs (on form TYPE/timestamp/customer/UUID) for subevents to this event. Subevents may not be stored yet. System will validate that all subevents have the same customer as this event.', 'uniqueItems': True, 'items': {'type': 'string'}}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI observed in this event.'}, 'fqdn': {'type': 'str', 'position': 0, 'description': 'FQDN (fqdn) observed in this event.'}, 'aggregationKey': {'type': 'str', 'position': 0, 'description': 'Client specified aggregation key for this event.'}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'Associated case ID. If set, the associated case must be readable for the current user, and must belong to the same customer as this event.'}, 'associatedCaseIDs': {'type': 'list', 'position': 0, 'description': 'Add one or more case associations to an event, not required. If set, the associated case must be readable for the current user, and must belong to the same customer as this event.', 'uniqueItems': True, 'items': {'type': 'int'}}, 'payload': {'type': 'dict', 'required': ['payload', 'payloadType'], 'properties': {'payload': {'type': 'str', 'position': 0, 'description': 'Payload associated to event', 'minLength': 0, 'maxLength': 1048576}, 'payloadType': {'type': 'str', 'position': 0, 'description': 'Type for payload associated to event', 'enum': ['ethernet', 'pcap', 'binary', 'string']}}}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'The ID of the submitted event. This will reflect the provided type, customerID, timestamp and UUID, or the generated values if these were not specified.'}, 'status': {'type': 'str', 'position': 0, 'description': "The submission status of this event. This will state 'rejected' if the event could not be validated, or 'accepted' if the event was accepted and has been enqueued for storage.", 'enum': ['accepted', 'rejected']}, 'message': {'type': 'str', 'position': 0, 'description': 'If the event was rejected with a validation error, this field will state the reason for the rejection.'}}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
submit_events_bulk = {'tags': ['events/v2'], 'summary': 'Submit a bulk of events to central storage. (INTERNAL)', 'description': 'This is a collector API, which will collect and enqueue the events for central storage.When this endpoint returns, the service guarantees that the events are validated and safely received for transport and storage. However, the services makes no guarantees for when the events will be searchable from the search endpoints.\n\nValidated events are enqueued for storage; the response will not indicate whether the event has been inserted or updated. Writing to an event ID (type/timestamp/customerID/UUID) of an existing event, will update/append the existing event with changed fields, and add flags/properties.\n\n If an event attempts to update an existing event which is marked as FINALIZED, the update will be ignored, even if this endpoint accepts the event.', 'operationId': 'submitEventsBulk', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Bulk request', 'required': False, 'schema': {'type': 'object', 'required': ['events'], 'properties': {'events': {'type': 'list', 'position': 0, 'description': 'Events to submit in this bulk.', 'items': {'type': 'dict', 'properties': {'startTimestamp': {'type': 'int'}, 'endTimestamp': {'type': 'int'}, 'id': {'type': 'dict', 'properties': {'uuid': {'type': 'str'}, 'customerDomain': {'type': 'string'}, 'customer': {'type': 'string'}, 'timestamp': {'type': 'int'}, 'type': 'str', 'options': ['raw', 'aggregated']}}, 'signature': {'type': 'str', 'position': 0, 'description': 'Event signature. If set, the system will automatically assign alarm and attack category based on this value.'}, 'severity': {'type': 'str', 'position': 0, 'description': 'Event severity. When creating a new event, the default severity is low.', 'enum': ['low', 'medium', 'high', 'critical']}, 'count': {'type': 'int', 'position': 0, 'description': 'Number of occurrences this event represents. The value must be at least 1, which is the default.'}, 'location': {'type': 'str', 'position': 0, 'description': 'The sensor location (id or shortname) where this event was observed. If set, this location must be resolvable for the current user, and must either belong to the same customer as this event, or be a global location.'}, 'protocol': {'type': 'str', 'position': 0, 'description': 'The protocol id or well-known name. Numeric protocol ID must be between 0 and 255. Protocol name must be well known (icmp, tcp, udp, esp, ah)'}, 'source': {'type': 'dict', 'properties': {'ip': {'type': 'str', 'position': 0, 'description': 'IPv4 or IPv6 address (host or CIDR notation).'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'Username or identifier.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Hostname or identifier.'}, 'geoLocation': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': '2-letter country code.'}, 'geoLocationID': {'type': 'int', 'position': 0, 'description': 'MaxMind geolocation ID.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Latitude for location coordinates', 'minimum': -90, 'maximum': 90}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Longitude for location coordinates', 'minimum': -180, 'maximum': 180}}}}}, 'destination': {'type': 'dict', 'properties': {'ip': {'type': 'str', 'position': 0, 'description': 'IPv4 or IPv6 address (host or CIDR notation).'}, 'port': {'type': 'int', 'position': 0, 'description': 'UDP or TCP port (0 - 65535).'}, 'user': {'type': 'str', 'position': 0, 'description': 'Username or identifier.'}, 'host': {'type': 'str', 'position': 0, 'description': 'Hostname or identifier.'}, 'geoLocation': {'type': 'dict', 'properties': {'countryCode': {'type': 'str', 'position': 0, 'description': '2-letter country code.'}, 'geoLocationID': {'type': 'int', 'position': 0, 'description': 'MaxMind geolocation ID.'}, 'latitude': {'type': 'float', 'position': 0, 'description': 'Latitude for location coordinates', 'minimum': -90, 'maximum': 90}, 'longitude': {'type': 'float', 'position': 0, 'description': 'Longitude for location coordinates', 'minimum': -180, 'maximum': 180}}}}}, 'flags': {'type': 'list', 'position': 0, 'description': 'Event flags requested by the client for this event. On updating an existing event, existing flags will be retained, and flags in the update will be added. Flags that have a PARTIAL flag have custom handling. If FINALIZED flag is set, additional updates to this event will be ignored.', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'HAS_DETAILS', 'HAS_PAYLOAD', 'HAS_PCAP', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED', 'SOURCE_IS_MANAGED_BY_SOC', 'DESTINATION_IS_MANAGED_BY_SOC', 'SLA_VIOLATION', 'HANDLED_BY_ANALYST', 'PAYLOAD_TRUNCATED', 'HAS_STRING_PAYLOAD', 'REASSESSED']}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Custom properties for this event. Each property key may have multiple values.\nOn updating an existing event, setting an existing property will overwrite existing value.\n\nThe max length of property keys is 50 characters. Keys longer than that will be truncated to the first 50.\nIf there are duplicate keys, one will overwrite the other.\nThis will also happen if there are duplicates after truncation.\n\nThe max length of property values are 1024 characters for each value.\nAny value longer than this will be truncated to 1024 characters.\n', 'additionalProperties': {'type': 'list', 'uniqueItems': True, 'items': {'type': 'string'}}}, 'subEvents': {'type': 'list', 'position': 0, 'description': 'IDs (on form TYPE/timestamp/customer/UUID) for subevents to this event. Subevents may not be stored yet. System will validate that all subevents have the same customer as this event.', 'uniqueItems': True, 'items': {'type': 'string'}}, 'uri': {'type': 'str', 'position': 0, 'description': 'URI observed in this event.'}, 'fqdn': {'type': 'str', 'position': 0, 'description': 'FQDN (fqdn) observed in this event.'}, 'aggregationKey': {'type': 'str', 'position': 0, 'description': 'Client specified aggregation key for this event.'}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'Associated case ID. If set, the associated case must be readable for the current user, and must belong to the same customer as this event.'}, 'associatedCaseIDs': {'type': 'list', 'position': 0, 'description': 'Add one or more case associations to an event, not required. If set, the associated case must be readable for the current user, and must belong to the same customer as this event.', 'uniqueItems': True, 'items': {'type': 'int'}}, 'payload': {'type': 'dict', 'required': ['payload', 'payloadType'], 'properties': {'payload': {'type': 'str', 'position': 0, 'description': 'Payload associated to event', 'minLength': 0, 'maxLength': 1048576}, 'payloadType': {'type': 'str', 'position': 0, 'description': 'Type for payload associated to event', 'enum': ['ethernet', 'pcap', 'binary', 'string']}}}}}, 'maxItems': 2147483647, 'minItems': 1}, 'onError': {'type': 'str', 'position': 0, 'description': 'Define how validation errors on single events should be handled. Using mode dropInvalid, invalid events will be ignored and reported in the response. The default mode is rejectAll, which will cause a 412 error on the entire request on a valiation failure for any event.', 'enum': ['rejectAll', 'dropInvalid']}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'accepted': {'type': 'int', 'position': 0, 'description': 'Number of accepted events'}, 'rejected': {'type': 'int', 'position': 0, 'description': 'Number of rejected events'}, 'events': {'type': 'list', 'position': 0, 'description': 'List of event submission results for each submitted event. This field will have the same number and order of events as the bulk submission request.', 'items': {'type': 'dict', 'properties': {'id': {'type': 'str', 'position': 0, 'description': 'The ID of the submitted event. This will reflect the provided type, customerID, timestamp and UUID, or the generated values if these were not specified.'}, 'status': {'type': 'str', 'position': 0, 'description': "The submission status of this event. This will state 'rejected' if the event could not be validated, or 'accepted' if the event was accepted and has been enqueued for storage.", 'enum': ['accepted', 'rejected']}, 'message': {'type': 'str', 'position': 0, 'description': 'If the event was rejected with a validation error, this field will state the reason for the rejection.'}}}}}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}