"""Autogenerated API schema"""
from argus_api import session


add_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Adds a match filter (INTERNAL)', 'description': '', 'operationId': 'addMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Add match filter request', 'required': False, 'schema': {'type': 'object', 'required': ['actions', 'customer', 'description', 'eventType', 'filters', 'name'], 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The index of the filter. Filters with lower index will be ran first. (default 5)', 'minimum': 0, 'maximum': 10, 'default': 5}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'str', 'position': 0, 'description': "The shortname or ID of the customer the filter belongs to. To create a global filter set the value to '0'"}, 'eventType': {'type': 'str', 'position': 0, 'description': "What type of event the filter should match against. Type raw will create a NIDSEventMatchFilter in v1, aggregated will create a AggregatedIPAttackEventMatchFilter, and all will create a IPAttackEventMatchFilter. Defaults to 'all'", 'enum': ['raw', 'aggregated', 'all']}, 'filters': {'type': 'dict', 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend'}, 'disableCompileStaticValidation': {'type': 'bool', 'position': 0, 'description': 'If true, we will skip static validation of the matchCode (default false)', 'default': False}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the source ip address is in this set. This corresponds to intruder in the old solution => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination ip address is in this set. This corresponds to victim in the old solution => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Only match events from the these locations, given by shortname or id', 'uniqueItems': True, 'items': {'type': 'string'}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Only match events with these signatures', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarmID': {'type': 'list', 'position': 0, 'description': 'Only match events connected to these alarms, given by id', 'uniqueItems': True, 'items': {'type': 'int'}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Only match events belonging to these attack categories, given by shortname or id', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'disableCompileStaticValidation': {'type': 'bool', 'position': 0, 'description': 'If true, we will skip static validation of the transformCode (default false)', 'default': False}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'Adds an associated case ID'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': 'If true, this event will be dropped (default false)', 'default': False}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed (default false)', 'default': False}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform (default false)', 'default': False}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching (default false)', 'default': False}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey (default false)', 'default': False}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event (default false)', 'default': False}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'A set of labels which can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'enabled': {'type': 'bool', 'position': 0, 'description': 'Whether or not the filter is enabled (default false)', 'default': False}, 'validFrom': {'type': 'str', 'position': 0, 'description': 'When the filter starts being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details (default 0)'}, 'validTo': {'type': 'str', 'position': 0, 'description': 'When the filter stops being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details (default 0)'}}, 'description': 'A request to add a match filter'}}], 'responses': {'201': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
debug_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Shows the result of running a match filter against a set of events (INTERNAL)', 'description': '', 'operationId': 'debugMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'in': 'body', 'name': 'body', 'description': 'Debug filter request', 'required': False, 'schema': {'type': 'object', 'required': ['eventIDs'], 'properties': {'eventIDs': {'type': 'list', 'position': 0, 'description': 'The list of event ids for the events to debug against. Can be given in the form of AGGR/1/123456789/{UUID} or simply UUID.', 'items': {'type': 'string'}, 'maxItems': 2147483647, 'minItems': 1}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset'}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend. Set to empty string to unset field'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': "Only match events with severity at least this value. Use 'unset' value to unset the field", 'enum': ['unset', 'lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': "Only match events with severity this value or lower. Use 'unset' value to unset the field. Use 'unset' value to unset the field", 'enum': ['unset', 'lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Only match events with the provided protocol. Set to empty string to unset field'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the domain matches this regex. Set to empty string to unset field'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the uri matches this regex. Set to empty string to unset field'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Only match events from the these locations, given by shortname or id', 'uniqueItems': True, 'items': {'type': 'string'}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Only match events with these signatures', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarmID': {'type': 'list', 'position': 0, 'description': 'Only match events connected to these alarms, given by id', 'uniqueItems': True, 'items': {'type': 'int'}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Only match events belonging to these attack categories, given by shortname or id', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend. Set to empty string to unset field'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true. Set to empty string to unset field'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': "The new severity of events that are matched by the filter. Use 'unset' value to unset the field", 'enum': ['unset', 'lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'Adds an associated case ID. Set to 0 to unset the value'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder. Set to 0 to unset the value'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim. Set to 0 to unset the value'}, 'drop': {'type': 'bool', 'position': 0, 'description': 'If true, this event will be dropped'}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}}, 'description': 'A request to debug a match filter against a set of events'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'match': {'type': 'dict', 'properties': {'matched': {'type': 'bool', 'position': 0, 'description': 'True if the filter matched the event'}, 'matchFailureReason': {'type': 'str', 'position': 0, 'description': "If the filter didn't match, this will describe the reason why"}}, 'description': 'This object hold whether a match filter matched an event, and if applicable which field failed to match'}, 'transformationErrors': {'type': 'list', 'position': 0, 'description': 'The errors that occurred while transforming the event', 'items': {'type': 'dict', 'properties': {'message': {'type': 'str', 'position': 0, 'description': 'The message explaining the filter failed to transform the event'}}, 'description': 'The explanation of why a match filter failed to transform a matched event'}}, 'event': {'type': 'dict', 'properties': {'eventID': {'type': 'str', 'position': 0, 'description': 'The ID of the event debugged against'}, 'properties': {'type': 'dict', 'position': 0, 'description': 'The properties of the event', 'additionalProperties': {'type': 'string'}}}, 'description': 'The properties of the event debugged against'}}, 'description': 'The result of debugging a match filter against a set of events'}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
debug_unsaved_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Shows the result of running a match filter against a set of events (INTERNAL)', 'description': '', 'operationId': 'debugUnsavedMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Debug filter request', 'required': False, 'schema': {'type': 'object', 'required': ['eventIDs', 'eventType'], 'properties': {'eventIDs': {'type': 'list', 'position': 0, 'description': 'The list of event ids for the events to debug against. Can be given in the form of AGGR/1/123456789/{UUID} or simply UUID.', 'items': {'type': 'string'}, 'maxItems': 2147483647, 'minItems': 1}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset'}, 'eventType': {'type': 'str', 'position': 0, 'description': "What type of event the filter should match against. Type raw will create a NIDSEventMatchFilter in v1, aggregated will create a AggregatedIPAttackEventMatchFilter, and all will create a IPAttackEventMatchFilter. Defaults to 'all'", 'enum': ['raw', 'aggregated', 'all']}, 'filters': {'type': 'dict', 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend'}, 'disableCompileStaticValidation': {'type': 'bool', 'position': 0, 'description': 'If true, we will skip static validation of the matchCode (default false)', 'default': False}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the source ip address is in this set. This corresponds to intruder in the old solution => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination ip address is in this set. This corresponds to victim in the old solution => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Only match events from the these locations, given by shortname or id', 'uniqueItems': True, 'items': {'type': 'string'}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Only match events with these signatures', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarmID': {'type': 'list', 'position': 0, 'description': 'Only match events connected to these alarms, given by id', 'uniqueItems': True, 'items': {'type': 'int'}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Only match events belonging to these attack categories, given by shortname or id', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'disableCompileStaticValidation': {'type': 'bool', 'position': 0, 'description': 'If true, we will skip static validation of the transformCode (default false)', 'default': False}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'Adds an associated case ID'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': 'If true, this event will be dropped (default false)', 'default': False}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed (default false)', 'default': False}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform (default false)', 'default': False}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching (default false)', 'default': False}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey (default false)', 'default': False}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event (default false)', 'default': False}}}}, 'description': 'A request to debug a match filter against a set of events'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'match': {'type': 'dict', 'properties': {'matched': {'type': 'bool', 'position': 0, 'description': 'True if the filter matched the event'}, 'matchFailureReason': {'type': 'str', 'position': 0, 'description': "If the filter didn't match, this will describe the reason why"}}, 'description': 'This object hold whether a match filter matched an event, and if applicable which field failed to match'}, 'transformationErrors': {'type': 'list', 'position': 0, 'description': 'The errors that occurred while transforming the event', 'items': {'type': 'dict', 'properties': {'message': {'type': 'str', 'position': 0, 'description': 'The message explaining the filter failed to transform the event'}}, 'description': 'The explanation of why a match filter failed to transform a matched event'}}, 'event': {'type': 'dict', 'properties': {'eventID': {'type': 'str', 'position': 0, 'description': 'The ID of the event debugged against'}, 'properties': {'type': 'dict', 'position': 0, 'description': 'The properties of the event', 'additionalProperties': {'type': 'string'}}}, 'description': 'The properties of the event debugged against'}}, 'description': 'The result of debugging a match filter against a set of events'}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
delete_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Deletes a match filter (INTERNAL)', 'description': '', 'operationId': 'deleteMatchFilter', 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter to delete', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}}}
disable_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Disables a match filter (INTERNAL)', 'description': '', 'operationId': 'disableMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'in': 'body', 'name': 'body', 'description': 'Disable match filter request', 'required': False, 'schema': {'type': 'object', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was enabled/disabled'}}, 'description': 'A request to enable a match filter'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
disable_match_filter_on_instance = {'tags': ['eventfilters/v2/match'], 'summary': 'Disables a match filter on instance (INTERNAL)', 'description': '', 'operationId': 'disableMatchFilterOnInstance', 'produces': ['application/json'], 'parameters': [{'name': 'filterID', 'in': 'path', 'description': 'ID of the filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'name': 'instanceID', 'in': 'path', 'description': 'ID of the instance', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'filterID': {'type': 'int', 'position': 0, 'description': 'The ID of the filter disabled on instance'}}, 'description': 'An object describing the filter disabled on instance'}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
duplicate_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Duplicates a match filter (INTERNAL)', 'description': '', 'operationId': 'duplicateMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'in': 'body', 'name': 'body', 'description': 'Match filter duplication request', 'required': False, 'schema': {'type': 'object', 'properties': {'customer': {'type': 'str', 'position': 0, 'description': "The customer the duplicate should belong to (id or shortname). Use '0' to create a global filter, If this field is not set the default is using the same customer as the original filter."}}, 'description': 'A request to duplicate a match filter'}}], 'responses': {'201': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}}}
enable_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Enables a match filter (INTERNAL)', 'description': '', 'operationId': 'enableMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'in': 'body', 'name': 'body', 'description': 'Enable match filter request', 'required': False, 'schema': {'type': 'object', 'properties': {'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was enabled/disabled'}}, 'description': 'A request to enable a match filter'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
enable_match_filter_on_instance = {'tags': ['eventfilters/v2/match'], 'summary': 'Enables a match filter on instance (INTERNAL)', 'description': '', 'operationId': 'enableMatchFilterOnInstance', 'produces': ['application/json'], 'parameters': [{'name': 'filterID', 'in': 'path', 'description': 'ID of the filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'name': 'instanceID', 'in': 'path', 'description': 'ID of the instance', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'filterID': {'type': 'int', 'position': 0, 'description': 'The ID of the filter enabled on instance'}}, 'description': 'An object describing the filter enabled on instance'}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Gets a match filter (INTERNAL)', 'description': '', 'operationId': 'getMatchFilter', 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'name': 'includeCode', 'in': 'query', 'description': 'Whether to include code in MatchFilter', 'required': False, 'type': 'bool', 'default': False}, {'name': 'revision', 'in': 'query', 'description': 'The expected revision of the filter', 'required': False, 'type': 'int'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
get_match_filter_status = {'tags': ['eventfilters/v2/match'], 'summary': 'Gets the statuses of a match filters instances (INTERNAL)', 'description': '', 'operationId': 'listMatchFilterStatus', 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'name': 'limit', 'in': 'query', 'description': 'Limit result', 'required': False, 'type': 'int', 'default': 25}, {'name': 'offset', 'in': 'query', 'description': 'Offset result', 'required': False, 'type': 'int', 'default': 0}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision of the filter that is running'}, 'filterStatus': {'type': 'str', 'position': 0, 'description': 'The current filter status of the filter', 'enum': ['ok', 'error', 'disabled', 'disabledByCircuitBreaker', 'disabledByError']}, 'errorMessage': {'type': 'str', 'position': 0, 'description': 'The current filter status of the filter'}, 'loggingStatus': {'type': 'str', 'position': 0, 'description': 'The current logging status of the filter', 'enum': ['debug', 'info']}, 'container': {'type': 'dict', 'properties': {'instanceID': {'type': 'int', 'position': 0, 'description': 'The id of the container the filter is running on'}, 'componentName': {'type': 'str', 'position': 0, 'description': 'The name of the component the filter is running on'}}, 'description': 'An object containing information about the container the filter instance is running on'}, 'host': {'type': 'dict', 'properties': {'hostName': {'type': 'str', 'position': 0, 'description': 'The name of the host the filter is running on'}, 'id': {'type': 'int', 'position': 0, 'description': 'The ID of the host'}}, 'description': 'An object containing information about the host the filter is running on'}}, 'description': 'An object describing the current status of a match filter instance on a host'}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}}}
list_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Simple search for match filters (INTERNAL)', 'description': '', 'operationId': 'listMatchFilter', 'produces': ['application/json'], 'parameters': [{'name': 'keywords', 'in': 'query', 'description': 'Search by keywords', 'required': False, 'type': 'list', 'items': {'type': 'string'}, 'collectionFormat': 'multi'}, {'name': 'keywordMatchStrategy', 'in': 'query', 'description': 'Set match strategy for keyword search', 'required': False, 'type': 'str', 'default': 'all', 'enum': ['any', 'all']}, {'name': 'keywordFieldStrategy', 'in': 'query', 'description': 'Set field strategy for keyword search', 'required': False, 'type': 'list', 'items': {'type': 'str', 'default': 'all', 'enum': ['id', 'description', 'name', 'matchCode', 'transformCode', 'protocol', 'domainPattern', 'uriPattern', 'newAggregationKey', 'label', 'attackIdentifier', 'signature', 'propertyKey', 'propertyValue', 'all']}, 'collectionFormat': 'multi'}, {'name': 'timestampMatchStrategy', 'in': 'query', 'description': 'Set match strategy for timestamp filtering', 'required': False, 'type': 'str', 'default': 'all', 'enum': ['any', 'all']}, {'name': 'timestampFieldStrategy', 'in': 'query', 'description': 'Set field strategy for timestamp filtering', 'required': False, 'type': 'list', 'items': {'type': 'str', 'default': 'lastUpdated', 'enum': ['validFrom', 'validTo', 'created', 'lastUpdated', 'deleted']}, 'collectionFormat': 'multi'}, {'name': 'startTimestamp', 'in': 'query', 'description': 'Lower bound timestamp filter value', 'required': False, 'type': 'int', 'default': 0, 'minimum': 0}, {'name': 'endTimestamp', 'in': 'query', 'description': 'Upper bound timestamp filter value', 'required': False, 'type': 'int', 'default': 0, 'minimum': 0}, {'name': 'includeCode', 'in': 'query', 'description': 'Whether to include code in results', 'required': False, 'type': 'bool', 'default': False}, {'name': 'sortBy', 'in': 'query', 'description': 'Field to sort by', 'required': False, 'type': 'list', 'items': {'type': 'str', 'enum': ['id', 'name', 'validFrom', 'validTo', 'created', 'lastUpdated', 'deleted', '-id', '-name', '-validFrom', '-validTo', '-created', '-lastUpdated', '-deleted']}, 'collectionFormat': 'multi'}, {'name': 'limit', 'in': 'query', 'description': 'Limit result', 'required': False, 'type': 'int', 'default': 25}, {'name': 'offset', 'in': 'query', 'description': 'Offset result', 'required': False, 'type': 'int', 'default': 0}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
list_match_filter_revisions = {'tags': ['eventfilters/v2/match'], 'summary': 'Gets a match filters earlier revisions (INTERNAL)', 'description': '', 'operationId': 'getMatchFilterRevisions', 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter to fetch revisions for', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'name': 'limit', 'in': 'query', 'description': 'The max amount of revisions to return', 'required': False, 'type': 'int', 'default': 25}, {'name': 'offset', 'in': 'query', 'description': 'The number of revisions to skip before returning', 'required': False, 'type': 'int', 'default': 0}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'The timestamp the filter was updated'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'comment': {'type': 'str', 'position': 0, 'description': 'An explanation of the change that was made'}}, 'description': 'A an earlier version of a filter. Should describe when and why a filter was changes, and who made the change'}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}}}
revert_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Reverts a match filter to a previous revision (INTERNAL)', 'description': '', 'operationId': 'revertMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'filterID', 'in': 'path', 'description': 'ID of the filter to revert( must be the current version of a filter)', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'in': 'body', 'name': 'body', 'description': 'Request specifying which revision to revert to', 'required': False, 'schema': {'type': 'object', 'required': ['comment'], 'properties': {'revisionID': {'type': 'int', 'position': 0, 'description': 'The ID of the filter to revert to. Must be a revision of the filter to revert'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was reverted'}}, 'description': 'A request to revert a match filter to an earlier version'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
revive_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Revives a deleted a Match filter (INTERNAL)', 'description': '', 'operationId': 'reviveMatchFilter', 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
search_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Searches for match filters (INTERNAL)', 'description': '', 'operationId': 'searchMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Search match filter request', 'required': False, 'schema': {'type': 'object', 'properties': {'sortBy': {'type': 'list', 'items': {'type': 'str', 'enum': ['id', 'name', 'validFrom', 'validTo', 'created', 'lastUpdated', 'deleted', '-id', '-name', '-validFrom', '-validTo', '-created', '-lastUpdated', '-deleted']}}, 'keywords': {'type': 'list', 'position': 0, 'description': 'Search for keywords against fields defined by keywordFieldStrategy', 'uniqueItems': True, 'items': {'type': 'string'}}, 'keywordFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which fields will be searched by keywords (default all supported fields) (default all)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['id', 'description', 'name', 'matchCode', 'transformCode', 'protocol', 'domainPattern', 'uriPattern', 'newAggregationKey', 'label', 'attackIdentifier', 'signature', 'propertyKey', 'propertyValue', 'all']}}, 'keywordMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict different keywords should be matched (default match all keywords) (default all)', 'enum': ['any', 'all']}, 'filterID': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given IDs', 'uniqueItems': True, 'items': {'type': 'int'}}, 'filterType': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given filter types', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'AttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter']}}, 'customer': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given customers, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'user': {'type': 'list', 'position': 0, 'description': 'Search using users identified by id or shortname. If given a group, we will resolve all members of the group recursively', 'uniqueItems': True, 'items': {'type': 'string'}}, 'userFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which fields will be searched by user (default all supported fields) (default all)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['createdBy', 'lastUpdatedBy', 'deletedBy', 'all']}}, 'userMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict different keywords should be matched (default match all keywords) (default all)', 'enum': ['any', 'all']}, 'startTimestamp': {'type': 'int', 'position': 0, 'description': 'Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)', 'minimum': 0, 'default': 0}, 'endTimestamp': {'type': 'int', 'position': 0, 'description': 'Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)', 'minimum': 0, 'default': 0}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which timestamps will be included in the search (default lastUpdated) (default lastUpdated)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['validFrom', 'validTo', 'created', 'lastUpdated', 'deleted']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)', 'enum': ['any', 'all']}, 'includeDeleted': {'type': 'bool', 'position': 0, 'description': 'Set to true to include deleted filters (excluded by default). (default false)', 'default': False}, 'includeFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which have the following flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled']}}, 'excludeFlags': {'type': 'list', 'position': 0, 'description': 'Exclude filters which have the following flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled']}}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which include the given event flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which exclude the given event flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'location': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following locations, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarmID': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following alarms', 'uniqueItems': True, 'items': {'type': 'int'}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following attack categories, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'associatedCaseID': {'type': 'list', 'position': 0, 'description': 'Limit to streaming filters for the following cases ', 'uniqueItems': True, 'items': {'type': 'int'}}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'Subcriteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'required': {'type': 'boolean'}, 'exclude': {'type': 'boolean'}, 'keywords': {'type': 'list', 'position': 0, 'description': 'Search for keywords against fields defined by keywordFieldStrategy', 'uniqueItems': True, 'items': {'type': 'string'}}, 'keywordFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which fields will be searched by keywords (default all supported fields) (default all)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['id', 'description', 'name', 'matchCode', 'transformCode', 'protocol', 'domainPattern', 'uriPattern', 'newAggregationKey', 'label', 'attackIdentifier', 'signature', 'propertyKey', 'propertyValue', 'all']}}, 'keywordMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict different keywords should be matched (default match all keywords) (default all)', 'enum': ['any', 'all']}, 'filterID': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given IDs', 'uniqueItems': True, 'items': {'type': 'int'}}, 'filterType': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given filter types', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'AttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter']}}, 'customer': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given customers, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'user': {'type': 'list', 'position': 0, 'description': 'Search using users identified by id or shortname. If given a group, we will resolve all members of the group recursively', 'uniqueItems': True, 'items': {'type': 'string'}}, 'userFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which fields will be searched by user (default all supported fields) (default all)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['createdBy', 'lastUpdatedBy', 'deletedBy', 'all']}}, 'userMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict different keywords should be matched (default match all keywords) (default all)', 'enum': ['any', 'all']}, 'startTimestamp': {'type': 'int', 'position': 0, 'description': 'Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)', 'minimum': 0, 'default': 0}, 'endTimestamp': {'type': 'int', 'position': 0, 'description': 'Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)', 'minimum': 0, 'default': 0}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which timestamps will be included in the search (default lastUpdated) (default lastUpdated)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['validFrom', 'validTo', 'created', 'lastUpdated', 'deleted']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)', 'enum': ['any', 'all']}, 'includeDeleted': {'type': 'bool', 'position': 0, 'description': 'Set to true to include deleted filters (excluded by default). (default false)', 'default': False}, 'includeFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which have the following flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled']}}, 'excludeFlags': {'type': 'list', 'position': 0, 'description': 'Exclude filters which have the following flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled']}}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which include the given event flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which exclude the given event flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'location': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following locations, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarmID': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following alarms', 'uniqueItems': True, 'items': {'type': 'int'}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following attack categories, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'associatedCaseID': {'type': 'list', 'position': 0, 'description': 'Limit to streaming filters for the following cases ', 'uniqueItems': True, 'items': {'type': 'int'}}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'Subcriteria to add to the search', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'required': {'type': 'boolean'}, 'exclude': {'type': 'boolean'}, 'keywords': {'type': 'list', 'position': 0, 'description': 'Search for keywords against fields defined by keywordFieldStrategy', 'uniqueItems': True, 'items': {'type': 'string'}}, 'keywordFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which fields will be searched by keywords (default all supported fields) (default all)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['id', 'description', 'name', 'matchCode', 'transformCode', 'protocol', 'domainPattern', 'uriPattern', 'newAggregationKey', 'label', 'attackIdentifier', 'signature', 'propertyKey', 'propertyValue', 'all']}}, 'keywordMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict different keywords should be matched (default match all keywords) (default all)', 'enum': ['any', 'all']}, 'filterID': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given IDs', 'uniqueItems': True, 'items': {'type': 'int'}}, 'filterType': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given filter types', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'AttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter']}}, 'customer': {'type': 'list', 'position': 0, 'description': 'Limit search to filters with the given customers, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'user': {'type': 'list', 'position': 0, 'description': 'Search using users identified by id or shortname. If given a group, we will resolve all members of the group recursively', 'uniqueItems': True, 'items': {'type': 'string'}}, 'userFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which fields will be searched by user (default all supported fields) (default all)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['createdBy', 'lastUpdatedBy', 'deletedBy', 'all']}}, 'userMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict different keywords should be matched (default match all keywords) (default all)', 'enum': ['any', 'all']}, 'startTimestamp': {'type': 'int', 'position': 0, 'description': 'Restrict to a time frame based on the set timeFieldStrategy (start timestamp) (default 0)', 'minimum': 0, 'default': 0}, 'endTimestamp': {'type': 'int', 'position': 0, 'description': 'Restrict to a time frame based on the set timeFieldStrategy (end timestamp) (default 0)', 'minimum': 0, 'default': 0}, 'timeFieldStrategy': {'type': 'list', 'position': 0, 'description': 'Defines which timestamps will be included in the search (default lastUpdated) (default lastUpdated)', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['validFrom', 'validTo', 'created', 'lastUpdated', 'deleted']}}, 'timeMatchStrategy': {'type': 'str', 'position': 0, 'description': 'Defines how strict to match against different timestamps (all/any) using start and end timestamp (default any) (default any)', 'enum': ['any', 'all']}, 'includeDeleted': {'type': 'bool', 'position': 0, 'description': 'Set to true to include deleted filters (excluded by default). (default false)', 'default': False}, 'includeFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which have the following flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled']}}, 'excludeFlags': {'type': 'list', 'position': 0, 'description': 'Exclude filters which have the following flags set', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled']}}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which include the given event flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Limit to filters which exclude the given event flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'location': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following locations, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarmID': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following alarms', 'uniqueItems': True, 'items': {'type': 'int'}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Limit to filters which target the following attack categories, identified by id or shortname', 'uniqueItems': True, 'items': {'type': 'string'}}, 'associatedCaseID': {'type': 'list', 'position': 0, 'description': 'Limit to streaming filters for the following cases ', 'uniqueItems': True, 'items': {'type': 'int'}}, 'subCriteria': {'type': 'list', 'position': 0, 'description': 'Subcriteria to add to the search', 'uniqueItems': True, 'items': []}}, 'description': 'The sub criteria for searching for match filters'}}}, 'description': 'The sub criteria for searching for match filters'}}, 'includeCode': {'type': 'bool', 'position': 0, 'description': 'Whether or not to include code in the result object. The code is only returned if set to true (default false)', 'default': False}, 'includeDescendingCustomers': {'type': 'bool', 'position': 0, 'description': 'When limiting filters by customer, include filters of descending customers (default is true) (default true)', 'default': True}, 'includeAscendingCustomers': {'type': 'bool', 'position': 0, 'description': 'When limiting filters by customer, include filters of ascending customers (default is false)'}, 'limit': {'type': 'int', 'position': 0, 'description': 'Limit maximum amount of results (default 25)', 'minimum': 0, 'default': 25}, 'offset': {'type': 'int', 'position': 0, 'description': 'Skip specified amount of results (default 0)', 'minimum': 0, 'default': 0}}, 'description': 'A request to search for match filters'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
search_match_filter_status = {'tags': ['eventfilters/v2/match'], 'summary': 'Search for match filters instance statuses for filters that match the criteria (INTERNAL)', 'description': '', 'operationId': 'searchMatchFilterStatus', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'in': 'body', 'name': 'body', 'description': 'Search match filter request', 'required': False, 'schema': {'type': 'object', 'properties': {'filterID': {'type': 'list', 'uniqueItems': True, 'items': {'type': 'int'}}, 'filterStatus': {'type': 'list', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ok', 'error', 'disabled', 'disabledByCircuitBreaker', 'disabledByError']}}, 'loggingStatus': {'type': 'list', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['debug', 'info']}}, 'customer': {'type': 'list', 'uniqueItems': True, 'items': {'type': 'string'}}, 'limit': {'type': 'int'}, 'offset': {'type': 'int'}}}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'list', 'description': 'Contains an array of results', 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision of the filter that is running'}, 'filterStatus': {'type': 'str', 'position': 0, 'description': 'The current filter status of the filter', 'enum': ['ok', 'error', 'disabled', 'disabledByCircuitBreaker', 'disabledByError']}, 'errorMessage': {'type': 'str', 'position': 0, 'description': 'The current filter status of the filter'}, 'loggingStatus': {'type': 'str', 'position': 0, 'description': 'The current logging status of the filter', 'enum': ['debug', 'info']}, 'container': {'type': 'dict', 'properties': {'instanceID': {'type': 'int', 'position': 0, 'description': 'The id of the container the filter is running on'}, 'componentName': {'type': 'str', 'position': 0, 'description': 'The name of the component the filter is running on'}}, 'description': 'An object containing information about the container the filter instance is running on'}, 'host': {'type': 'dict', 'properties': {'hostName': {'type': 'str', 'position': 0, 'description': 'The name of the host the filter is running on'}, 'id': {'type': 'int', 'position': 0, 'description': 'The ID of the host'}}, 'description': 'An object containing information about the host the filter is running on'}}, 'description': 'An object describing the current status of a match filter instance on a host'}}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '412': {'description': 'Validation failed'}}}
set_match_filter_log_level = {'tags': ['eventfilters/v2/match'], 'summary': 'Sets the log level of a Match filter (INTERNAL)', 'description': '', 'operationId': 'setMatchFilterLogLevel', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'in': 'body', 'name': 'body', 'description': 'Set Match filter log level request', 'required': False, 'schema': {'type': 'object', 'required': ['logLevel'], 'properties': {'logLevel': {'type': 'str', 'position': 0, 'description': 'The new log level of the filter', 'enum': ['debug', 'info']}}, 'description': 'A request to set the log level of the instances of a match filter'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'logLevel': {'type': 'str', 'position': 0, 'description': 'The new log level of the filter', 'enum': ['debug', 'info']}}, 'description': 'The log level filter instances of this filter should be set to'}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}
update_match_filter = {'tags': ['eventfilters/v2/match'], 'summary': 'Updates a match filter (INTERNAL)', 'description': '', 'operationId': 'updateMatchFilter', 'consumes': ['application/json'], 'produces': ['application/json'], 'parameters': [{'name': 'id', 'in': 'path', 'description': 'ID of filter', 'required': True, 'type': 'int', 'pattern': '[0-9]+'}, {'in': 'body', 'name': 'body', 'description': 'Update Match filter request', 'required': False, 'schema': {'type': 'object', 'required': ['comment'], 'properties': {'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The index of the filter. Filters with lower index will be ran first.', 'minimum': 0, 'maximum': 10}, 'validFrom': {'type': 'str', 'position': 0, 'description': 'When the filter starts being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset (default null)'}, 'validTo': {'type': 'str', 'position': 0, 'description': 'When the filter stops being applied. Timestamp can be milliseconds since epoch, ISO8601 timestamp, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset (default null)'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'filters': {'type': 'dict', 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend. Valid field for all filters'}, 'disableCompileStaticValidation': {'type': 'bool', 'position': 0, 'description': 'If true, we will skip static validation of the matchCode (default false)', 'default': False}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Only match events with severity at least this value. Valid field for all filters', 'enum': ['unset', 'lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Only match events with severity this value or lower. Valid field for all filters', 'enum': ['unset', 'lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that have these flags. Valid field for all filters', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Only match events that does not have any of these flags. Valid field for all filters', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Only match events with the provided protocol. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the domain matches this regex. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Only match events where the uri matches this regex. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the source ip address is in this set. This corresponds to intruder in the old solution. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the source port is in this set. This corresponds to intruder in the old solution. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination ip address is in this set. This corresponds to victim in the old solution. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where the destination port is in this set. This corresponds to victim in the old solution. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter => format:ip', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Only match events from the these locations, given by shortname or id. Valid field for all filters', 'uniqueItems': True, 'items': {'type': 'string'}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Only match events with these signatures. Valid field for all filters', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarmID': {'type': 'list', 'position': 0, 'description': 'Only match events connected to these alarms, given by id. Valid field for all filters', 'uniqueItems': True, 'items': {'type': 'int'}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Only match events belonging to these attack categories, given by shortname or id. Valid field for all filters', 'uniqueItems': True, 'items': {'type': 'string'}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Only match events which have these properties. Valid field for all filters', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend. Valid field for all filters'}, 'disableCompileStaticValidation': {'type': 'bool', 'position': 0, 'description': 'If true, we will skip static validation of the transformCode (default false)', 'default': False}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true. Valid field for all filters'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter. Valid field for all filters', 'enum': ['unset', 'lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'Adds an associated case ID. Valid field for AggregatedAttackEventMatchFilter and AggregatedIPAttackEventMatchFilter'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter'}, 'drop': {'type': 'bool', 'position': 0, 'description': 'If true, this event will be dropped. Valid field for all filters'}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter'}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed. Valid field for all filters'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform. Valid field for all filters'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching. Valid field for all filters'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey. Valid field for all filters'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event. Valid field for IPAttackEventMatchFilter, AggregatedIPAttackEventMatchFilter, and NIDSEventMatchFilter'}}}, 'removeLabels': {'type': 'list', 'position': 0, 'description': 'A set of labels to remove from the filter.  Will be applied before adding labels and ignore filters that are not present. Will throw an exception if used in conjunction with setLabels ', 'uniqueItems': True, 'items': {'type': 'string'}}, 'addLabels': {'type': 'list', 'position': 0, 'description': 'A set of labels to add to the filter.  Will be applied after removing labels. Will throw an exception if used in conjunction with setLabels ', 'uniqueItems': True, 'items': {'type': 'string'}}, 'setLabels': {'type': 'list', 'position': 0, 'description': 'Replace the current set of labels with these. Will throw an exception if used in conjunction with addLabels or removeLabels', 'uniqueItems': True, 'items': {'type': 'string'}}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was created'}}, 'description': 'A request to update a match filter'}}], 'responses': {'200': {'description': 'successful operation', 'schema': {'required': ['data'], 'properties': {'responseCode': {'type': 'int', 'description': 'Status code returned from API'}, 'limit': {'type': 'int', 'description': 'Maximum number of returned results'}, 'offset': {'type': 'int', 'description': 'Number of skipped results'}, 'count': {'type': 'int', 'description': 'Number of available results on server'}, 'size': {'type': 'int', 'description': 'Actual number of returned results'}, 'metaData': {'type': 'dict', 'description': 'Additional unstructured meta data associated with response'}, 'messages': {'type': 'list', 'description': 'Contains messages returned from the API, usually error messages', 'items': {'type': 'dict', 'properties': {'message': {'type': 'string'}, 'messageTemplate': {'type': 'string'}, 'type': 'str', 'field': {'type': 'string'}, 'parameter': {'type': 'object'}, 'timestamp': {'type': 'int'}, 'options': ['FIELD_ERROR', 'ACTION_ERROR', 'WARNING', 'NOTIFICATION', 'INFO']}}}, 'data': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The ID of the filter'}, 'index': {'type': 'int', 'position': 0, 'description': 'The execution index'}, 'revision': {'type': 'int', 'position': 0, 'description': 'The revision number of this filter instance'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the filter'}, 'validFrom': {'type': 'int', 'position': 0, 'description': 'When the filter starts being applied'}, 'validTo': {'type': 'int', 'position': 0, 'description': 'When the filter stops being applied'}, 'description': {'type': 'str', 'position': 0, 'description': 'A description of the filter'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'masterID': {'type': 'int', 'position': 0, 'description': "The ID of the master filter of this filter. Will be 'null' for the current filter"}, 'filterType': {'type': 'str', 'position': 0, 'description': 'The type of the match filter', 'enum': ['AggregatedAttackEventMatchFilter', 'AggregatedIPAttackEventMatchFilter', 'IPAttackEventMatchFilter', 'NIDSEventMatchFilter', 'AttackEventMatchFilter']}, 'filters': {'type': 'dict', 'required': ['destinationIPAddresses', 'sourceIPAddresses', 'sourceOrDestinationIPAddresses'], 'properties': {'matchCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for when the filter should match an event. Will be validated in the backend.'}, 'minSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity at least this value', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'maxSeverity': {'type': 'str', 'position': 0, 'description': 'Will only match events with severity this value or lower', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'includeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that have these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'excludeEventFlags': {'type': 'list', 'position': 0, 'description': 'Will only match events that does not have any of these flags', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['ESTABLISHED', 'BLOCKED', 'SNAPSHOT', 'FINALIZED', 'SOURCE_IS_CUSTOMERNET', 'DESTINATION_IS_CUSTOMERNET', 'SOURCE_IS_PARTIAL_CUSTOMERNET', 'DESTINATION_IS_PARTIAL_CUSTOMERNET', 'PARTIALLY_BLOCKED', 'FALSE_POSITIVE', 'NOT_A_THREAT', 'TUNING_CANDIDATE', 'NOTIFIED', 'PARTIALLY_NOTIFIED', 'FOLLOWUP', 'IDENTIFIED_THREAT', 'THREAT_CANDIDATE', 'ACKNOWLEDGED', 'PARTIALLY_ACKNOWLEDGED', 'SEVERITY_ADJUSTED', 'COMMENTED', 'FILTERED', 'CHECKED', 'INCOMPLETE_DETAILS', 'AGGREGATED_BASE_EVENT', 'REMOTE_STORAGE', 'CUSTOM_SOURCE_AGGREGATION', 'CUSTOM_DESTINATION_AGGREGATION', 'ASSOCIATED_TO_CASE_BY_FILTER', 'SEVERITY_INCREASED_BY_FILTER', 'SEVERITY_REDUCED_BY_FILTER', 'CREATED_BY_ANALYSIS_FILTER', 'IP_INVERTED_BY_FILTER', 'HAS_PAYLOAD', 'HAS_PCAP', 'EXTEND_EVENT_TTL', 'INITIAL_TUNING', 'PARTIAL_INITIAL_TUNING', 'POST_ANALYSIS', 'SSL_TERMINATED', 'PARTIAL_SSL_TERMINATED', 'AUTO_REPORT', 'MISSING_TIMESTAMP', 'CLOCK_OUT_OF_SYNC', 'DROP_ANALYSIS', 'ESCALATED_BY_REPUTATION', 'HAS_SAMPLE', 'STORE_EVENT', 'STORE_AGGREGATED']}}, 'protocol': {'type': 'str', 'position': 0, 'description': 'Will only match events with the provided protocol'}, 'domainPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the domain matches this regex'}, 'uriPattern': {'type': 'str', 'position': 0, 'description': 'Will only match events where the uri matches this regex'}, 'sourceIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source ip address is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourcePorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the source port is in this set. This corresponds to intruder in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'destinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination ip address is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'destinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where the destination port is in this set. This corresponds to victim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'sourceOrDestinationIPAddresses': {'type': 'list', 'position': 0, 'description': 'Will only match events where an ip address is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'string'}}, 'sourceOrDestinationPorts': {'type': 'list', 'position': 0, 'description': 'Will only match events where a port is in this set. This corresponds to intruderOrVictim in the old solution', 'uniqueItems': True, 'items': {'type': 'int'}}, 'location': {'type': 'list', 'position': 0, 'description': 'Will only match events from the these locations', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the Location'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the Location'}, 'name': {'type': 'str', 'position': 0, 'description': 'The name of the Location'}}}}, 'signature': {'type': 'list', 'position': 0, 'description': 'Will only match events with these attack identifiers', 'uniqueItems': True, 'items': {'type': 'string'}}, 'alarm': {'type': 'list', 'position': 0, 'description': 'Will only match events connected to these alarms', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'The id of the alarm'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'The unique shortname of the alarm'}, 'description': {'type': 'str', 'position': 0, 'description': 'The description of the alarm'}}}}, 'attackCategory': {'type': 'list', 'position': 0, 'description': 'Will only match events belonging to these attack categories', 'uniqueItems': True, 'items': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the category.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Short name of the category.'}, 'info': {'type': 'str', 'position': 0, 'description': 'Short information about the category.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the category.'}}}}, 'properties': {'type': 'dict', 'position': 0, 'description': 'Will only match events which have these properties', 'additionalProperties': {'type': 'string'}}}}, 'actions': {'type': 'dict', 'properties': {'transformCode': {'type': 'str', 'position': 0, 'description': 'Custom groovy code for how the event will be transformed. Will be validated in the backend'}, 'newAggregationKey': {'type': 'str', 'position': 0, 'description': 'If set this will set a new aggregation key on the event, given that changeAggregationKey is set to true'}, 'newSeverity': {'type': 'str', 'position': 0, 'description': 'The new severity of events that are matched by the filter', 'enum': ['lowStatistics', 'lowAggregated', 'low', 'medium', 'high', 'critical']}, 'associatedCaseID': {'type': 'int', 'position': 0, 'description': 'The case this filter is associated with'}, 'newSourceAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the source ip to this value. Source corresponds to what was earlier called intruder'}, 'newDestinationAggregationBits': {'type': 'int', 'position': 0, 'description': 'Changes the aggregation bits of the destination ip to this value. Destination corresponds to what was earlier called victim'}, 'drop': {'type': 'bool', 'position': 0, 'description': "If true, the event is dropped and won't be sent forward"}, 'dropRaw': {'type': 'bool', 'position': 0, 'description': 'If true, then RAW events will be dropped (default false)', 'default': False}, 'noTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this event will not be transformed'}, 'continueAfterTransform': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will continue to look for new events after transform'}, 'stopAfterNoMatch': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will stop looking for new matches after not matching'}, 'changeAggregationKey': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will change the aggregation key to the value of newAggregationKey'}, 'invertIp': {'type': 'bool', 'position': 0, 'description': 'If true, this filter will switch the source and destination ip in the event'}}}, 'labels': {'type': 'list', 'position': 0, 'description': 'The set of labels that can be used to categorize the filter', 'uniqueItems': True, 'items': {'type': 'string'}}, 'flags': {'type': 'list', 'position': 0, 'description': 'The flags that are set on the filter', 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted', 'enabled', 'controlled', 'hasMatchCode', 'hasTransformCode']}}, 'createdByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'createdTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was created'}, 'lastUpdatedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'lastUpdatedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was last updated'}, 'deletedByUser': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'shortName': {'type': 'str', 'position': 0, 'description': "The subject's short name"}, 'name': {'type': 'str', 'position': 0, 'description': "The subject's name"}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}, 'customer': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the customer.'}, 'shortName': {'type': 'str', 'position': 0, 'description': 'Shortname of the customer.'}, 'domain': {'type': 'dict', 'properties': {'id': {'type': 'int', 'position': 0, 'description': 'ID of the response object.'}, 'name': {'type': 'str', 'position': 0, 'description': 'Name of the domain.'}}, 'description': 'SPI DomainInfo'}}, 'description': 'SPI CustomerInfo'}, 'flags': {'type': 'list', 'position': 0, 'description': "The subject's flags", 'uniqueItems': True, 'items': {'type': 'str', 'enum': ['deleted']}}, 'type': 'str', 'options': ['user', 'group']}, 'description': 'SPI UserInfo'}, 'deletedTimestamp': {'type': 'int', 'position': 0, 'description': 'When the filter was deleted'}, 'comment': {'type': 'str', 'position': 0, 'description': 'A comment describing why the filter was modified'}}, 'description': "Match filters compare events against a set of criteria.\nIf the criteria match then one or more actions will be performed on the event.\nPossible actions are:\n  * drop - If the drop action is added, the event is dropped and won't be sent forward\n  * newSeverity - If newSeverity is set, the severity of the event is set to the new value\n  * newAggregationKey - If newAggregationKey is set, then the aggregation key is set to the new value\n  * newSourceAggregationBits - If newSourceAggregationBits is set, the aggregation bits for the source IP is\n    set to the selected value\n  * newDestinationAggregationBits - If newDestinationAggregationBits is set, the aggregation bits for the\n    destination IP is set to the selected value\n  * transformCode - If transformCode is set, the groovy code is run is run on the event. Should return the\n    transformed event\n  * continueAfterTransform - If continueAfterTransform is set, the filter matcher will continue looking for\n    matching filters\n\nBoth matchCode and transformCode implement methods with the following parameters\n  * event: The event to transform or check for match\n  * filter: The match filter itself\n"}}}}, '401': {'description': 'Authentication failed'}, '403': {'description': 'Access denied'}, '404': {'description': 'Object not found'}, '412': {'description': 'Validation failed'}}}