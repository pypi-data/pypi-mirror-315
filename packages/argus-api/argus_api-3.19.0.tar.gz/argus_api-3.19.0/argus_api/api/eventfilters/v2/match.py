"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
log = logging.getLogger(__name__)


@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def add_match_filter(
    name: str = None,
    description: str = None,
    customer: str = None,
    eventType: str = None,
    filters: dict = None,
    actions: dict = None,
    labels: str = None,
    validFrom: str = None,
    validTo: str = None,
    index: int = 5,
    enabled: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Adds a match filter (INTERNAL)
    
    :param str name: The name of the filter
    :param str description: A description of the filter
    :param str customer: The shortname or ID of the customer the filter belongs to. To create a global filter set the value to \'0\'
    :param str eventType: What type of event the filter should match against. Type raw will create a NIDSEventMatchFilter in v1\, aggregated will create a AggregatedIPAttackEventMatchFilter\, and all will create a IPAttackEventMatchFilter. Defaults to \'all\'
    :param dict filters: 
    :param dict actions: 
    :param list labels: A set of labels which can be used to categorize the filter
    :param str validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details \(default 0\)
    :param str validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details \(default 0\)
    :param int index: The index of the filter. Filters with lower index will be ran first. \(default 5\)
    :param bool enabled: Whether or not the filter is enabled \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match".format()
    headers = {}

    body = body or {}
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send index if the argument was provided, don't send null values
    if index is not None:
        body.update({"index": index})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send eventType if the argument was provided, don't send null values
    if eventType is not None:
        body.update({"eventType": eventType})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send labels if the argument was provided, don't send null values
    if labels is not None:
        body.update({"labels": labels})
    # Only send enabled if the argument was provided, don't send null values
    if enabled is not None:
        body.update({"enabled": enabled})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def debug_match_filter(
    id: int,
    eventIDs: str = None,
    validFrom: int = None,
    validTo: int = None,
    filters: dict = None,
    actions: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Shows the result of running a match filter against a set of events (INTERNAL)
    
    :param int id: ID of filter
    :param list eventIDs: The list of event ids for the events to debug against. Can be given in the form of AGGR\/1\/123456789\/\{UUID\} or simply UUID.
    :param int validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param int validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param dict filters: 
    :param dict actions: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/debug".format(id=id)
    headers = {}

    body = body or {}
    # Only send eventIDs if the argument was provided, don't send null values
    if eventIDs is not None:
        body.update({"eventIDs": eventIDs})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def debug_unsaved_match_filter(
    eventIDs: str = None,
    validFrom: int = None,
    validTo: int = None,
    eventType: str = None,
    filters: dict = None,
    actions: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Shows the result of running a match filter against a set of events (INTERNAL)
    
    :param list eventIDs: The list of event ids for the events to debug against. Can be given in the form of AGGR\/1\/123456789\/\{UUID\} or simply UUID.
    :param int validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param int validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param str eventType: What type of event the filter should match against. Type raw will create a NIDSEventMatchFilter in v1\, aggregated will create a AggregatedIPAttackEventMatchFilter\, and all will create a IPAttackEventMatchFilter. Defaults to \'all\'
    :param dict filters: 
    :param dict actions: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/debug".format()
    headers = {}

    body = body or {}
    # Only send eventIDs if the argument was provided, don't send null values
    if eventIDs is not None:
        body.update({"eventIDs": eventIDs})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})
    # Only send eventType if the argument was provided, don't send null values
    if eventType is not None:
        body.update({"eventType": eventType})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def delete_match_filter(
    id: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Deletes a match filter (INTERNAL)
    
    :param int id: ID of filter to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}".format(id=id)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def disable_match_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Disables a match filter (INTERNAL)
    
    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/disable".format(id=id)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def disable_match_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Disables a match filter on instance (INTERNAL)
    
    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{filterID}/{instanceID}/disable".format(filterID=filterID,
        instanceID=instanceID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def duplicate_match_filter(
    id: int,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Duplicates a match filter (INTERNAL)
    
    :param int id: ID of filter
    :param str customer: The customer the duplicate should belong to \(id or shortname\). Use \'0\' to create a global filter\, If this field is not set the default is using the same customer as the original filter.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/duplicate".format(id=id)
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def enable_match_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Enables a match filter (INTERNAL)
    
    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/enable".format(id=id)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def enable_match_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Enables a match filter on instance (INTERNAL)
    
    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{filterID}/{instanceID}/enable".format(filterID=filterID,
        instanceID=instanceID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def get_match_filter(
    id: int,
    revision: int = None,
    includeCode: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Gets a match filter (INTERNAL)
    
    :param int id: ID of filter
    :param int revision: The expected revision of the filter
    :param bool includeCode: Whether to include code in MatchFilter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}".format(id=id,
        includeCode=includeCode,
        revision=revision)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})
    
    # Only send revision if the argument was provided, don't send null values
    if revision is not None:
        query_parameters.update({"revision": revision})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def get_match_filter_status(
    id: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Gets the statuses of a match filters instances (INTERNAL)
    
    :param int id: ID of filter
    :param int limit: Limit result
    :param int offset: Offset result
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/status".format(limit=limit,
        id=id,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def list_match_filter(
    keywords: str = None,
    keywordFieldStrategy: str = None,
    timestampFieldStrategy: str = None,
    sortBy: str = None,
    keywordMatchStrategy: str = "all",
    timestampMatchStrategy: str = "all",
    limit: int = 25,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeCode: bool = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Simple search for match filters (INTERNAL)
    
    :param list keywords: Search by keywords
    :param list keywordFieldStrategy: Set field strategy for keyword search
    :param list timestampFieldStrategy: Set field strategy for timestamp filtering
    :param list sortBy: Field to sort by
    :param str keywordMatchStrategy: Set match strategy for keyword search
    :param str timestampMatchStrategy: Set match strategy for timestamp filtering
    :param int limit: Limit result
    :param int startTimestamp: Lower bound timestamp filter value
    :param int endTimestamp: Upper bound timestamp filter value
    :param bool includeCode: Whether to include code in results
    :param int offset: Offset result
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match".format(keywordMatchStrategy=keywordMatchStrategy,
        timestampMatchStrategy=timestampMatchStrategy,
        limit=limit,
        keywords=keywords,
        keywordFieldStrategy=keywordFieldStrategy,
        timestampFieldStrategy=timestampFieldStrategy,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        includeCode=includeCode,
        sortBy=sortBy,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        query_parameters.update({"keywordMatchStrategy": keywordMatchStrategy})
    
    # Only send timestampMatchStrategy if the argument was provided, don't send null values
    if timestampMatchStrategy is not None:
        query_parameters.update({"timestampMatchStrategy": timestampMatchStrategy})
    
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        query_parameters.update({"keywordFieldStrategy": keywordFieldStrategy})
    
    # Only send timestampFieldStrategy if the argument was provided, don't send null values
    if timestampFieldStrategy is not None:
        query_parameters.update({"timestampFieldStrategy": timestampFieldStrategy})
    
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def list_match_filter_revisions(
    id: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Gets a match filters earlier revisions (INTERNAL)
    
    :param int id: ID of filter to fetch revisions for
    :param int limit: The max amount of revisions to return
    :param int offset: The number of revisions to skip before returning
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/revisions".format(limit=limit,
        id=id,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def revert_match_filter(
    filterID: int,
    revisionID: int = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Reverts a match filter to a previous revision (INTERNAL)
    
    :param int filterID: ID of the filter to revert\( must be the current version of a filter\)
    :param int revisionID: The ID of the filter to revert to. Must be a revision of the filter to revert
    :param str comment: A comment describing why the filter was reverted
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{filterID}/revert".format(filterID=filterID)
    headers = {}

    body = body or {}
    # Only send revisionID if the argument was provided, don't send null values
    if revisionID is not None:
        body.update({"revisionID": revisionID})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def revive_match_filter(
    id: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Revives a deleted a Match filter (INTERNAL)
    
    :param int id: ID of filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/revive".format(id=id)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def search_match_filter(
    sortBy: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    filterID: int = None,
    filterType: str = None,
    customer: str = None,
    user: str = None,
    userFieldStrategy: str = None,
    userMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    includeEventFlags: str = None,
    excludeEventFlags: str = None,
    location: str = None,
    alarmID: int = None,
    attackCategory: str = None,
    associatedCaseID: int = None,
    subCriteria: dict = None,
    includeAscendingCustomers: bool = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeDeleted: bool = None,
    includeCode: bool = None,
    includeDescendingCustomers: bool = True,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Searches for match filters (INTERNAL)
    
    :param list sortBy: 
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\) \(default all\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default all\)
    :param list filterID: Limit search to filters with the given IDs
    :param list filterType: Limit search to filters with the given filter types
    :param list customer: Limit search to filters with the given customers\, identified by id or shortname
    :param list user: Search using users identified by id or shortname. If given a group\, we will resolve all members of the group recursively
    :param list userFieldStrategy: Defines which fields will be searched by user \(default all supported fields\) \(default all\)
    :param str userMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default all\)
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default lastUpdated\) \(default lastUpdated\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list includeFlags: Limit to filters which have the following flags set
    :param list excludeFlags: Exclude filters which have the following flags set
    :param list includeEventFlags: Limit to filters which include the given event flags
    :param list excludeEventFlags: Limit to filters which exclude the given event flags
    :param list location: Limit to filters which target the following locations\, identified by id or shortname
    :param list alarmID: Limit to filters which target the following alarms
    :param list attackCategory: Limit to filters which target the following attack categories\, identified by id or shortname
    :param list associatedCaseID: Limit to streaming filters for the following cases 
    :param list subCriteria: Subcriteria to add to the search
    :param bool includeAscendingCustomers: When limiting filters by customer\, include filters of ascending customers \(default is false\)
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param bool includeDeleted: Set to true to include deleted filters \(excluded by default\). \(default false\)
    :param bool includeCode: Whether or not to include code in the result object. The code is only returned if set to true \(default false\)
    :param bool includeDescendingCustomers: When limiting filters by customer\, include filters of descending customers \(default is true\) \(default true\)
    :param int limit: Limit maximum amount of results \(default 25\)
    :param int offset: Skip specified amount of results \(default 0\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/search".format()
    headers = {}

    body = body or {}
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send filterType if the argument was provided, don't send null values
    if filterType is not None:
        body.update({"filterType": filterType})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userMatchStrategy if the argument was provided, don't send null values
    if userMatchStrategy is not None:
        body.update({"userMatchStrategy": userMatchStrategy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeEventFlags if the argument was provided, don't send null values
    if includeEventFlags is not None:
        body.update({"includeEventFlags": includeEventFlags})
    # Only send excludeEventFlags if the argument was provided, don't send null values
    if excludeEventFlags is not None:
        body.update({"excludeEventFlags": excludeEventFlags})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send alarmID if the argument was provided, don't send null values
    if alarmID is not None:
        body.update({"alarmID": alarmID})
    # Only send attackCategory if the argument was provided, don't send null values
    if attackCategory is not None:
        body.update({"attackCategory": attackCategory})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        body.update({"includeCode": includeCode})
    # Only send includeDescendingCustomers if the argument was provided, don't send null values
    if includeDescendingCustomers is not None:
        body.update({"includeDescendingCustomers": includeDescendingCustomers})
    # Only send includeAscendingCustomers if the argument was provided, don't send null values
    if includeAscendingCustomers is not None:
        body.update({"includeAscendingCustomers": includeAscendingCustomers})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def search_match_filter_status(
    filterID: int = None,
    filterStatus: str = None,
    loggingStatus: str = None,
    customer: str = None,
    limit: int = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search for match filters instance statuses for filters that match the criteria (INTERNAL)
    
    :param list filterID: 
    :param list filterStatus: 
    :param list loggingStatus: 
    :param list customer: 
    :param int limit: 
    :param int offset: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/status/search".format()
    headers = {}

    body = body or {}
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send filterStatus if the argument was provided, don't send null values
    if filterStatus is not None:
        body.update({"filterStatus": filterStatus})
    # Only send loggingStatus if the argument was provided, don't send null values
    if loggingStatus is not None:
        body.update({"loggingStatus": loggingStatus})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def set_match_filter_log_level(
    id: int,
    logLevel: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Sets the log level of a Match filter (INTERNAL)
    
    :param int id: ID of filter
    :param str logLevel: The new log level of the filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/logging".format(id=id)
    headers = {}

    body = body or {}
    # Only send logLevel if the argument was provided, don't send null values
    if logLevel is not None:
        body.update({"logLevel": logLevel})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("eventfilters", "v2", "match"),
    module=argus_cli_module
)
def update_match_filter(
    id: int,
    name: str = None,
    index: int = None,
    validFrom: str = None,
    validTo: str = None,
    description: str = None,
    filters: dict = None,
    actions: dict = None,
    removeLabels: str = None,
    addLabels: str = None,
    setLabels: str = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Updates a match filter (INTERNAL)
    
    :param int id: ID of filter
    :param str name: The name of the filter
    :param int index: The index of the filter. Filters with lower index will be ran first.
    :param str validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset \(default null\)
    :param str validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset \(default null\)
    :param str description: A description of the filter
    :param dict filters: 
    :param dict actions: 
    :param list removeLabels: A set of labels to remove from the filter.  Will be applied before adding labels and ignore filters that are not present. Will throw an exception if used in conjunction with setLabels 
    :param list addLabels: A set of labels to add to the filter.  Will be applied after removing labels. Will throw an exception if used in conjunction with setLabels 
    :param list setLabels: Replace the current set of labels with these. Will throw an exception if used in conjunction with addLabels or removeLabels
    :param str comment: A comment describing why the filter was created
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}".format(id=id)
    headers = {}

    body = body or {}
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send index if the argument was provided, don't send null values
    if index is not None:
        body.update({"index": index})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send removeLabels if the argument was provided, don't send null values
    if removeLabels is not None:
        body.update({"removeLabels": removeLabels})
    # Only send addLabels if the argument was provided, don't send null values
    if addLabels is not None:
        body.update({"addLabels": addLabels})
    # Only send setLabels if the argument was provided, don't send null values
    if setLabels is not None:
        body.update({"setLabels": setLabels})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
