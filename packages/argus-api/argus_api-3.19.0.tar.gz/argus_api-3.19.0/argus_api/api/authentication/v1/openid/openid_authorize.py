"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from argus_api.utils import deprecated_alias
log = logging.getLogger(__name__)


@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def add_openid_group_mapping(
    idOrShortname: str,
    argusGroup: str = None,
    externalGroupName: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Add a group mapping to a OpenID provider (INTERNAL)
    
    :param str idOrShortname: ID or shortname of provider to update
    :param str argusGroup: The name or ID of the argus group to map to
    :param str externalGroupName: The name of the group to map from \(as it appears in the ID\-token group claim\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}/groupmappings".format(idOrShortname=idOrShortname)
    headers = {}

    body = body or {}
    # Only send argusGroup if the argument was provided, don't send null values
    if argusGroup is not None:
        body.update({"argusGroup": argusGroup})
    # Only send externalGroupName if the argument was provided, don't send null values
    if externalGroupName is not None:
        body.update({"externalGroupName": externalGroupName})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def add_openid_provider(
    shortName: str = None,
    name: str = None,
    clientID: str = None,
    customer: str = None,
    domain: str = None,
    jwks: str = None,
    jwksURI: str = None,
    configurationURI: str = None,
    issuer: str = None,
    certificate: str = None,
    providerURI: str = None,
    tokenURI: str = None,
    secret: str = None,
    claimsMapping: dict = None,
    responseType: str = None,
    responseMode: str = None,
    authorizationPrompt: str = None,
    scope: str = None,
    emailDomains: str = None,
    newUserMapping: bool = None,
    updateGroupMapping: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Define new OpenID provider (INTERNAL)
    
    :param str shortName: Set a shortname for this provider \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: The name of this provider \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str clientID: The OAuth ClientID of this provider
    :param str customer: The id or shortname of the customer this provider is bound to. If customer is a customer group\, subcustomer users are also eligible for this provider. If not set\, this provider will be domain global.
    :param str domain: The id or shortname of the domain this provider is bound to\, if this is a domain\-global provider. If not set\, customer must be set.
    :param str jwks: Base64\-encoding of a valid JWKS file which can be used to verify OpenID tokens. Exactly one of certificate\, jwks and jwksURI must be used.
    :param str jwksURI: The URI to the OpenID JWKS document. Exactly one of certificate\, jwks and jwksURI can be used. Setting jwksURI will enable automatic refresh of jwks. \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str configurationURI: The URI to the OpenID autodiscovery document \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str issuer: Define a specific issuer to require on id\-tokens. If not set\, the issuer is expected to be a prefix of the providerURI.
    :param str certificate: A valid X509 certificate which can be used to verify OpenID tokens. Exactly one of certificate\, jwks and jwksURI can be used.
    :param str providerURI: The URI to redirect to to initiate OpenID authentication flow \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str tokenURI: The URI for the token endpoint. Required for responseType\=code. \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str secret: Define secret to use for the token endpoint. Required for responseType\=code
    :param dict claimsMapping: 
    :param str responseType: Define response type to request from provider \(default idToken\)
    :param str responseMode: Define response mode to request from provider \(default none\)
    :param str authorizationPrompt: Define prompt type to request on authorization \(default login\)
    :param list scope: Define extra scopes to request \(in addition to openid\) \=\> Sanitize by regex \[\\x21\\x5D\-\\x7E\\x23\-\\x5B\]\+
    :param list emailDomains: Define email domains for automatic enrollment of users
    :param bool newUserMapping: Option to enable automatic mapping of new users. To map new users\, the claims mapping for name and email must be set.
    :param bool updateGroupMapping: Option to enable updates of automatic group mappings. This requires the claims mapping for groups to be set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises InvalidArgumentException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider".format()
    headers = {}

    body = body or {}
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send clientID if the argument was provided, don't send null values
    if clientID is not None:
        body.update({"clientID": clientID})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send jwks if the argument was provided, don't send null values
    if jwks is not None:
        body.update({"jwks": jwks})
    # Only send jwksURI if the argument was provided, don't send null values
    if jwksURI is not None:
        body.update({"jwksURI": jwksURI})
    # Only send configurationURI if the argument was provided, don't send null values
    if configurationURI is not None:
        body.update({"configurationURI": configurationURI})
    # Only send issuer if the argument was provided, don't send null values
    if issuer is not None:
        body.update({"issuer": issuer})
    # Only send certificate if the argument was provided, don't send null values
    if certificate is not None:
        body.update({"certificate": certificate})
    # Only send providerURI if the argument was provided, don't send null values
    if providerURI is not None:
        body.update({"providerURI": providerURI})
    # Only send tokenURI if the argument was provided, don't send null values
    if tokenURI is not None:
        body.update({"tokenURI": tokenURI})
    # Only send secret if the argument was provided, don't send null values
    if secret is not None:
        body.update({"secret": secret})
    # Only send claimsMapping if the argument was provided, don't send null values
    if claimsMapping is not None:
        body.update({"claimsMapping": claimsMapping})
    # Only send responseType if the argument was provided, don't send null values
    if responseType is not None:
        body.update({"responseType": responseType})
    # Only send responseMode if the argument was provided, don't send null values
    if responseMode is not None:
        body.update({"responseMode": responseMode})
    # Only send authorizationPrompt if the argument was provided, don't send null values
    if authorizationPrompt is not None:
        body.update({"authorizationPrompt": authorizationPrompt})
    # Only send scope if the argument was provided, don't send null values
    if scope is not None:
        body.update({"scope": scope})
    # Only send emailDomains if the argument was provided, don't send null values
    if emailDomains is not None:
        body.update({"emailDomains": emailDomains})
    # Only send newUserMapping if the argument was provided, don't send null values
    if newUserMapping is not None:
        body.update({"newUserMapping": newUserMapping})
    # Only send updateGroupMapping if the argument was provided, don't send null values
    if updateGroupMapping is not None:
        body.update({"updateGroupMapping": updateGroupMapping})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def delete_openid_group_mapping(
    idOrShortname: str,
    mappingID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete a group mapping from an OpenID provider (INTERNAL)
    
    :param str idOrShortname: ID or shortname of provider to update
    :param str mappingID: The ID of the mapping to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}/groupmappings/{mappingID}".format(idOrShortname=idOrShortname,
        mappingID=mappingID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def delete_openid_provider(
    idOrShortname: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete OpenID provider (INTERNAL)
    
    :param str idOrShortname: ID or shortname of provider to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}".format(idOrShortname=idOrShortname)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def get_openid_provider(
    idOrShortname: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Fetch OpenID provider (INTERNAL)
    
    :param str idOrShortname: ID or shortname of provider to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}".format(idOrShortname=idOrShortname)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def get_openid_user_link(
    email: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Fetch OpenID provider (INTERNAL)
    
    :param str email: Request a userlink sent to this email address
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises IfTheRequestIsInvalidException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/userlink".format(email=email)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send email if the argument was provided, don't send null values
    if email is not None:
        query_parameters.update({"email": email})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def list_openid_group_mappings(
    idOrShortname: str,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """List group mappings for a OpenID provider (INTERNAL)
    
    :param str idOrShortname: ID or shortname of provider to list mappings for
    :param int limit: Limit number of results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}/groupmappings".format(limit=limit,
        idOrShortname=idOrShortname,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def list_openid_providers(
    targetCustomer: str = None,
    customer: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """List OpenID providers (INTERNAL)
    
    :param str targetCustomer: Limit results to providers which apply to users bound to this customer
    :param list customer: Limit results to providers for this customer \(or subcustomers\)
    :param list keywords: Limit results to providers matching these keywords
    :param list sortBy: Specify sort order
    :param int limit: Limit number of results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider".format(limit=limit,
        targetCustomer=targetCustomer,
        customer=customer,
        keywords=keywords,
        sortBy=sortBy,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send targetCustomer if the argument was provided, don't send null values
    if targetCustomer is not None:
        query_parameters.update({"targetCustomer": targetCustomer})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def openid_authentication(
    provider: str,
    idToken: str = None,
    authorizationCode: str = None,
    flow: str = None,
    requestedAuthorizations: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Submit OpenID token for validation to create a new user session (PUBLIC)
    
    :param str provider: ID or shortname of OpenID provider
    :param str idToken: ID token from provider. Required for flow idToken.
    :param str authorizationCode: Authorization code provider. Required for flow authorizationCode.
    :param str flow: The flow to use. If set to authorizationCode\, follow the authorization code flow\, and the authorizationCode field must be set. If set to idToken\, follow the implicit flow\, and the idToken must be set \(default\). \(default idToken\)
    :param list requestedAuthorizations: Allow client to request authorizations as part of the authentication transaction. The client is not guaranteed to get the requested authorizations. The setPassword authorization is only returned if the current user has the FORCE\_PW\_CHANGE flag set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{provider}/authentication".format(provider=provider)
    headers = {}

    body = body or {}
    # Only send idToken if the argument was provided, don't send null values
    if idToken is not None:
        body.update({"idToken": idToken})
    # Only send authorizationCode if the argument was provided, don't send null values
    if authorizationCode is not None:
        body.update({"authorizationCode": authorizationCode})
    # Only send flow if the argument was provided, don't send null values
    if flow is not None:
        body.update({"flow": flow})
    # Only send requestedAuthorizations if the argument was provided, don't send null values
    if requestedAuthorizations is not None:
        body.update({"requestedAuthorizations": requestedAuthorizations})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def openid_pre_authentication(
    provider: str,
    state: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Request redirect URI to OpenID provider (PUBLIC)
    
    :param str provider: ID or shortname of OpenID provider
    :param str state: State to retain
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises InvalidArgumentException: on 412
    :raises TooManyPendingRequestsException: on 429
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{provider}/authentication".format(provider=provider,
        state=state)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send state if the argument was provided, don't send null values
    if state is not None:
        query_parameters.update({"state": state})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def request_openid_authorization_redirect(
    operation: str = None,
    context: dict = None,
    nextURI: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Register a user authorization request, and request a redirect to the OpenID Identity Provider to validate user presence. (INTERNAL)
    
    :param str operation: The name of the operation to authorize
    :param dict context: Context variables to scope this authorization. All context variables required by the executing service must be present and equal to those provided here.
    :param str nextURI: The URI to redirect\/route to after successful authorization. The URI will be validated according to policy. The authorization token returned from successful authorization should be appended as a query parameter to this URI.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/authorize/redirect".format()
    headers = {}

    body = body or {}
    # Only send operation if the argument was provided, don't send null values
    if operation is not None:
        body.update({"operation": operation})
    # Only send context if the argument was provided, don't send null values
    if context is not None:
        body.update({"context": context})
    # Only send nextURI if the argument was provided, don't send null values
    if nextURI is not None:
        body.update({"nextURI": nextURI})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def search_openid_providers(
    targetCustomer: str = None,
    customer: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search OpenID providers (INTERNAL)
    
    :param str targetCustomer: Limit result to providers which are usable for users bound to this customer \(by customer ID or shortname\)
    :param list customer: Limit result by customer ID or shortname
    :param list keywords: Match providers by keywords
    :param list sortBy: Specify sort order \(default shortName\)
    :param int limit: Limit the number of results \(default 25\)
    :param int offset: Skip the first results\, in sort order \(default 0\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/search".format()
    headers = {}

    body = body or {}
    # Only send targetCustomer if the argument was provided, don't send null values
    if targetCustomer is not None:
        body.update({"targetCustomer": targetCustomer})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def submit_openid_authorization(
    stateID: str = None,
    idToken: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Receive the ID token redirect response for a pending User Authorization (INTERNAL)
    
    :param str stateID: The OpenID state identifier
    :param str idToken: The ID token returned by the OpenID Provider
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/authorize".format()
    headers = {}

    body = body or {}
    # Only send stateID if the argument was provided, don't send null values
    if stateID is not None:
        body.update({"stateID": stateID})
    # Only send idToken if the argument was provided, don't send null values
    if idToken is not None:
        body.update({"idToken": idToken})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module
)
def update_openid_provider(
    idOrShortname: str,
    shortName: str = None,
    name: str = None,
    clientID: str = None,
    issuer: str = None,
    jwks: str = None,
    jwksURI: str = None,
    configurationURI: str = None,
    certificate: str = None,
    providerURI: str = None,
    tokenURI: str = None,
    secret: str = None,
    responseType: str = None,
    responseMode: str = None,
    authorizationPrompt: str = None,
    claimsMapping: dict = None,
    scope: str = None,
    emailDomains: str = None,
    newUserMapping: bool = None,
    updateGroupMapping: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Update OpenID provider (INTERNAL)
    
    :param str idOrShortname: ID or shortname of provider to update
    :param str shortName: If set\, update the shortname for this provider \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: If set\, update the name for this provider \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str clientID: If set\, update the OAuth ClientID for this provider
    :param str issuer: If set\, update the OpenID Issuer to require for this provider. Use blank string \"\" to reset to default.
    :param str jwks: If set\, update the JWKS for this provider. Must be Base64\-encoding of a valid JWKS file. Exactly one of certificate\, jwks and jwksURI can be used. Setting jwks will clear certificate and disable automatic refresh of jwks.
    :param str jwksURI: If set\, update the URI to the OpenID JWKS document. Exactly one of certificate\, jwks and jwksURI can be used. Setting jwksURI will clear certificate and enable automatic refresh of jwks. \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str configurationURI: If set\, update the URI to the OpenID autodiscovery document \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str certificate: If set\, update the X509 certificate for this provider. This will remove any stored jwks.
    :param str providerURI: If set\, update the authorization URI for this provider \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str tokenURI: If set\, update the token URI for this provider \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str secret: If set\, update the secret for use with the token URI for this provider
    :param str responseType: If set\, update the response type to request from provider
    :param str responseMode: If set\, update the response type to request from provider
    :param str authorizationPrompt: If set\, update the prompt to request from provider on authorization requests
    :param dict claimsMapping: 
    :param list scope: If set\, change the scopes to request from this provider \=\> Sanitize by regex \[\\x21\\x5D\-\\x7E\\x23\-\\x5B\]\+
    :param list emailDomains: If set\, change the email domains for automatic enrollment of users
    :param bool newUserMapping: If set\, enable\/disable option to enable automatic user mapping. To map new users\, the claims mapping for name and email must be set.
    :param bool updateGroupMapping: If set\, enable\/disable option to enable updates of automatic group mappings. This requires the claims mapping for groups to be set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}".format(idOrShortname=idOrShortname)
    headers = {}

    body = body or {}
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send clientID if the argument was provided, don't send null values
    if clientID is not None:
        body.update({"clientID": clientID})
    # Only send issuer if the argument was provided, don't send null values
    if issuer is not None:
        body.update({"issuer": issuer})
    # Only send jwks if the argument was provided, don't send null values
    if jwks is not None:
        body.update({"jwks": jwks})
    # Only send jwksURI if the argument was provided, don't send null values
    if jwksURI is not None:
        body.update({"jwksURI": jwksURI})
    # Only send configurationURI if the argument was provided, don't send null values
    if configurationURI is not None:
        body.update({"configurationURI": configurationURI})
    # Only send certificate if the argument was provided, don't send null values
    if certificate is not None:
        body.update({"certificate": certificate})
    # Only send providerURI if the argument was provided, don't send null values
    if providerURI is not None:
        body.update({"providerURI": providerURI})
    # Only send tokenURI if the argument was provided, don't send null values
    if tokenURI is not None:
        body.update({"tokenURI": tokenURI})
    # Only send secret if the argument was provided, don't send null values
    if secret is not None:
        body.update({"secret": secret})
    # Only send responseType if the argument was provided, don't send null values
    if responseType is not None:
        body.update({"responseType": responseType})
    # Only send responseMode if the argument was provided, don't send null values
    if responseMode is not None:
        body.update({"responseMode": responseMode})
    # Only send authorizationPrompt if the argument was provided, don't send null values
    if authorizationPrompt is not None:
        body.update({"authorizationPrompt": authorizationPrompt})
    # Only send claimsMapping if the argument was provided, don't send null values
    if claimsMapping is not None:
        body.update({"claimsMapping": claimsMapping})
    # Only send scope if the argument was provided, don't send null values
    if scope is not None:
        body.update({"scope": scope})
    # Only send emailDomains if the argument was provided, don't send null values
    if emailDomains is not None:
        body.update({"emailDomains": emailDomains})
    # Only send newUserMapping if the argument was provided, don't send null values
    if newUserMapping is not None:
        body.update({"newUserMapping": newUserMapping})
    # Only send updateGroupMapping if the argument was provided, don't send null values
    if updateGroupMapping is not None:
        body.update({"updateGroupMapping": updateGroupMapping})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

#: **DEPRECATED** : ``add_open_id_provider`` is an alias for ``add_openid_provider``. Exists
#: only for backward compatibility - **do not use** - use ``add_openid_provider`` instead.
add_open_id_provider = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="add_open_id_provider"
)(deprecated_alias("add_open_id_provider")(add_openid_provider))
#: **DEPRECATED** : ``delete_open_id_provider`` is an alias for ``delete_openid_provider``. Exists
#: only for backward compatibility - **do not use** - use ``delete_openid_provider`` instead.
delete_open_id_provider = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="delete_open_id_provider"
)(deprecated_alias("delete_open_id_provider")(delete_openid_provider))
#: **DEPRECATED** : ``get_open_id_provider`` is an alias for ``get_openid_provider``. Exists
#: only for backward compatibility - **do not use** - use ``get_openid_provider`` instead.
get_open_id_provider = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="get_open_id_provider"
)(deprecated_alias("get_open_id_provider")(get_openid_provider))
#: **DEPRECATED** : ``list_open_id_providers`` is an alias for ``list_openid_providers``. Exists
#: only for backward compatibility - **do not use** - use ``list_openid_providers`` instead.
list_open_id_providers = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="list_open_id_providers"
)(deprecated_alias("list_open_id_providers")(list_openid_providers))
#: **DEPRECATED** : ``open_id_authentication`` is an alias for ``openid_authentication``. Exists
#: only for backward compatibility - **do not use** - use ``openid_authentication`` instead.
open_id_authentication = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="open_id_authentication"
)(deprecated_alias("open_id_authentication")(openid_authentication))
#: **DEPRECATED** : ``open_id_pre_authentication`` is an alias for ``openid_pre_authentication``. Exists
#: only for backward compatibility - **do not use** - use ``openid_pre_authentication`` instead.
open_id_pre_authentication = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="open_id_pre_authentication"
)(deprecated_alias("open_id_pre_authentication")(openid_pre_authentication))
#: **DEPRECATED** : ``search_open_id_providers`` is an alias for ``search_openid_providers``. Exists
#: only for backward compatibility - **do not use** - use ``search_openid_providers`` instead.
search_open_id_providers = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="search_open_id_providers"
)(deprecated_alias("search_open_id_providers")(search_openid_providers))
#: **DEPRECATED** : ``update_open_id_provider`` is an alias for ``update_openid_provider``. Exists
#: only for backward compatibility - **do not use** - use ``update_openid_provider`` instead.
update_open_id_provider = register_command(
    extending=("authentication", "v1", "openid", "authorize"),
    module=argus_cli_module,
    alias="update_open_id_provider"
)(deprecated_alias("update_open_id_provider")(update_openid_provider))