"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from argus_api.utils import deprecated_alias
from requests import Response
log = logging.getLogger(__name__)


@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def acknowledge_sensor(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Acknowledge a sensor by its ID (INTERNAL)
    
    :param int sensorID: ID of sensor to acknowledge
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/acknowledge".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def acknowledge_sensors(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Acknowledge Sensors by their ID Any comment will be applied to ALL specified sensors. (INTERNAL)
    
    :param list sensorID: ID of sensors to acknowledge
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/acknowledge".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def add_comment(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Add comment to a sensor (INTERNAL)
    
    :param int sensorID: SensorID
    :param str comment: Any comments to append to the request
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def bulk_cancel_sensor_downtime(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Cancels downtime for supplied sensorIDs (INTERNAL)
    
    :param list sensorID: Cancel downtime for these Sensor IDs
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/downtime".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def bulk_schedule_sensor_downtime(
    fromTime: int = None,
    toTime: int = None,
    keepDowntimeOnUpdate: bool = None,
    comment: str = None,
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Schedules downtime for provided sensorIDs (INTERNAL)
    
    :param int fromTime: Timestamp in epoch ms from which the requested change takes effect. \(default now\)
    :param int toTime: Timestamp in epoch ms until which the requested change takes effect.
    :param bool keepDowntimeOnUpdate: Flag to maintain existing downtime configurations. 
If set\, downtime will not automatically end when the Sensor registers a new event.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param list sensorIDs: IDs of the Sensors for which we want to schedule downtime.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/downtime".format()
    headers = {}

    body = body or {}
    # Only send fromTime if the argument was provided, don't send null values
    if fromTime is not None:
        body.update({"fromTime": fromTime})
    # Only send toTime if the argument was provided, don't send null values
    if toTime is not None:
        body.update({"toTime": toTime})
    # Only send keepDowntimeOnUpdate if the argument was provided, don't send null values
    if keepDowntimeOnUpdate is not None:
        body.update({"keepDowntimeOnUpdate": keepDowntimeOnUpdate})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def bulk_update_contractual_status(
    sensorIDs: int = None,
    contractual: bool = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Update Sensors' contractual statusAny comment will be applied to ALL specified sensors.The operation will only return Sensors that were actually updated. (INTERNAL)
    
    :param list sensorIDs: IDs of Sensors to remove acknowledgement.
    :param bool contractual: Whether to set or unset the Sensors\' contractual status
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/contractual".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send contractual if the argument was provided, don't send null values
    if contractual is not None:
        body.update({"contractual": contractual})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def bulk_update_expected_update_interval(
    sensorIDs: int = None,
    expectedUpdateTimeIntervalMillis: int = None,
    overrideUpdateTimeFlag: bool = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Update Sensors' expected update time intervals
Any comment will be applied to ALL specified sensors.
 The operation will only return Sensors that were actually updated.
 (INTERNAL)
    
    :param list sensorIDs: IDs of Sensors whose expected update time interval we want to update.
    :param int expectedUpdateTimeIntervalMillis: The new expected update time interval in milliseconds
    :param bool overrideUpdateTimeFlag: Whether to set the override update time flag on sensors lacking it in the request
    :param str comment: Any comments to append to the request
NB\: Each Sensor specified in the request will receive the same comment.
If not specified the service will generate a generic one.
 \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/updateInterval".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send expectedUpdateTimeIntervalMillis if the argument was provided, don't send null values
    if expectedUpdateTimeIntervalMillis is not None:
        body.update({"expectedUpdateTimeIntervalMillis": expectedUpdateTimeIntervalMillis})
    # Only send overrideUpdateTimeFlag if the argument was provided, don't send null values
    if overrideUpdateTimeFlag is not None:
        body.update({"overrideUpdateTimeFlag": overrideUpdateTimeFlag})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def bulk_update_initial_tuning(
    sensorID: int,
    initialTuning: bool,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk updating initial tuning property for Sensors by their IDs. If provided any comment will be applied to ALL updated sensors. (INTERNAL)
    
    :param list sensorID: ID of sensors to remove acknowledgement
    :param bool initialTuning: Desired new Sensor initial tuning status
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/initialtuning".format(sensorID=sensorID,
        initialTuning=initialTuning)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})
    
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        query_parameters.update({"initialTuning": initialTuning})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def cancel_sensor_downtime(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Cancels downtime for supplied sensorID (INTERNAL)
    
    :param int sensorID: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/downtime".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def cluster_sensor(
    sensorID: int,
    clusterSensorID: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Cluster sensor (INTERNAL)
    
    :param int sensorID: ID of the sensor to cluster
    :param int clusterSensorID: Sensor with which we want to cluster
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/cluster".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send clusterSensorID if the argument was provided, don't send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def create_sensor(
    sslTerminating: bool = None,
    location: str = None,
    customer: str = None,
    application: str = None,
    information: str = None,
    hostname: str = None,
    ipAddress: str = None,
    additionalData: str = None,
    reportingSeverity: str = None,
    clusterSensorID: int = None,
    expectedUpdateTime: int = None,
    scheduledDowntimeFromTime: int = None,
    scheduledDowntimeUntilTime: int = None,
    active: bool = None,
    monitored: bool = None,
    monitoredOnlyDaytime: bool = None,
    initialTuning: bool = None,
    overrideDefaultUpdateTime: bool = None,
    sharedCustomerData: bool = None,
    contractual: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Creates a Sensor (INTERNAL)
    
    :param bool sslTerminating: 
    :param str location: Sensor Location ID or short name. The Location must be Global or belong to the same Customer as this Sensor.
    :param str customer: Sensor Customer ID or short name
    :param str application: Sensor type ID or short name
    :param str information: Sensor information
    :param str hostname: Sensor hostname. One of hostname or ipAddresss must be defined.
Attempts to create a Sensor with a duplicate hostname for the same customer will be rejected.
If you need to make a Sensor with a duplicate hostname ensure the additional data field\'s contents are unique.
 \=\> Sanitize by regex \(\[\\p\{Alnum\}\\.\_\-\]\+\)
    :param str ipAddress: Sensor\'s IP address\, one of hostname or ipAddress must be assigned
Attempts to create a Sensor with a duplicate IP address for the same customer will be rejected.
If you need to make a Sensor with a duplicate IP address ensure the additional data field\'s contents are unique.
 \=\> format\:ip
    :param str additionalData: Any additional data
    :param str reportingSeverity: If specified overwrite the ReportingSeverity level for this Sensor\'s Application
    :param int clusterSensorID: ID of the Sensor this new Sensor will be clustered with. 0 if unclustered. \(default 0\)
    :param int expectedUpdateTime: When the Sensor is expected to be updated\, 0 if not known\/never \(default 0\)
    :param int scheduledDowntimeFromTime: Time from which the Sensor will be offline\, 0 if not scheduled \(default 0\)
    :param int scheduledDowntimeUntilTime: Time until which the Sensor will be offline\, 0 if not scheduled \(default 0\)
    :param bool active: Sensor active flag \(default false\)
    :param bool monitored: Sensor monitored flag \(default false\)
    :param bool monitoredOnlyDaytime: Sensor is monitored only daytime flag \(default false\)
    :param bool initialTuning: Sensor\'s initial tuning status \(default false\)
    :param bool overrideDefaultUpdateTime: Override default update time \(default false\)
    :param bool sharedCustomerData: Sensor\'s shared customer data flag \(default false\)
    :param bool contractual: Whether the Sensor contributes to the customer\'s contractual Sensor limit \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor".format()
    headers = {}

    body = body or {}
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send application if the argument was provided, don't send null values
    if application is not None:
        body.update({"application": application})
    # Only send clusterSensorID if the argument was provided, don't send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})
    # Only send expectedUpdateTime if the argument was provided, don't send null values
    if expectedUpdateTime is not None:
        body.update({"expectedUpdateTime": expectedUpdateTime})
    # Only send scheduledDowntimeFromTime if the argument was provided, don't send null values
    if scheduledDowntimeFromTime is not None:
        body.update({"scheduledDowntimeFromTime": scheduledDowntimeFromTime})
    # Only send scheduledDowntimeUntilTime if the argument was provided, don't send null values
    if scheduledDowntimeUntilTime is not None:
        body.update({"scheduledDowntimeUntilTime": scheduledDowntimeUntilTime})
    # Only send information if the argument was provided, don't send null values
    if information is not None:
        body.update({"information": information})
    # Only send hostname if the argument was provided, don't send null values
    if hostname is not None:
        body.update({"hostname": hostname})
    # Only send ipAddress if the argument was provided, don't send null values
    if ipAddress is not None:
        body.update({"ipAddress": ipAddress})
    # Only send additionalData if the argument was provided, don't send null values
    if additionalData is not None:
        body.update({"additionalData": additionalData})
    # Only send active if the argument was provided, don't send null values
    if active is not None:
        body.update({"active": active})
    # Only send monitored if the argument was provided, don't send null values
    if monitored is not None:
        body.update({"monitored": monitored})
    # Only send monitoredOnlyDaytime if the argument was provided, don't send null values
    if monitoredOnlyDaytime is not None:
        body.update({"monitoredOnlyDaytime": monitoredOnlyDaytime})
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        body.update({"initialTuning": initialTuning})
    # Only send overrideDefaultUpdateTime if the argument was provided, don't send null values
    if overrideDefaultUpdateTime is not None:
        body.update({"overrideDefaultUpdateTime": overrideDefaultUpdateTime})
    # Only send sharedCustomerData if the argument was provided, don't send null values
    if sharedCustomerData is not None:
        body.update({"sharedCustomerData": sharedCustomerData})
    # Only send reportingSeverity if the argument was provided, don't send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})
    # Only send contractual if the argument was provided, don't send null values
    if contractual is not None:
        body.update({"contractual": contractual})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def create_sensor_interface(
    sensorID: int,
    interfaceName: str = None,
    location: str = None,
    customer: str = None,
    comment: str = None,
    active: bool = None,
    sslTerminating: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Adds an interface to a sensor (INTERNAL)
    
    :param int sensorID: ID of sensor to which we want to add the interface
    :param str interfaceName: Name of the Sensor Interface. Must be unique per Sensor. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str location: Location ID or short name of the Sensor\'s Interface.
    :param str customer: Customer id or shortname of the Interface.If neither the Interface nor Sensor\'s Location is Global\, the Interface and Sensor Customer must be the sameunless the shared data flag is set on the Sensor \(default null\)
    :param str comment: Comment describing why the Interface was added
    :param bool active: Status of the Sensor Interface \(default false\)
    :param bool sslTerminating: Interface\'s SSL terminating flag \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send interfaceName if the argument was provided, don't send null values
    if interfaceName is not None:
        body.update({"interfaceName": interfaceName})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send active if the argument was provided, don't send null values
    if active is not None:
        body.update({"active": active})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def decluster_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Decluster sensor (INTERNAL)
    
    :param int sensorID: ID of the sensor to decluster
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/cluster".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def delete_interface(
    sensorID: int,
    interface: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Deletes one of a Sensor's interfaces by its ID or name (INTERNAL)
    
    :param int sensorID: ID of the sensor to which the interface belongs
    :param str interface: ID of the interface
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises Sensor,Interface,OrLocationNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interface}".format(sensorID=sensorID,
        interface=interface)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def delete_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete sensor by ID (INTERNAL)
    
    :param int sensorID: ID of sensor to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def delete_sensor_comment(
    sensorID: int,
    timestamp: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Deletes a comment (INTERNAL)
    
    :param int sensorID: Delete comment from this sensor
    :param int timestamp: Delete comment made at this timestamp
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment/{timestamp}".format(sensorID=sensorID,
        timestamp=timestamp)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def delete_sensors(
    sensorIDs: int = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete sensors by ID (INTERNAL)
    
    :param list sensorIDs: IDs of Sensors we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/delete".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_monitoring(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Disable sensor monitoring (INTERNAL)
    
    :param int sensorID: ID for sensor to disable monitoring
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/monitoring/disable".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_monitoring_bulk(
    sensorIDs: int = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk disable sensor monitoring (INTERNAL)
    
    :param list sensorIDs: IDs of Sensors whose monitoring we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/monitoring/disable".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Deactivates a sensor (INTERNAL)
    
    :param int sensorID: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/disable".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def disable_sensors(
    comment: str = None,
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk deactivation of Sensors (INTERNAL)
    
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param list sensorIDs: IDs of Sensors to deactivate.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/disable".format()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_monitoring(
    sensorID: int,
    daytime: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Enable sensor monitoring. To set daytime only monitoring use the 'daytime' queryParm. (INTERNAL)
    
    :param int sensorID: ID for sensor to enable monitoring
    :param bool daytime: Daytime only monitoring flag
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/monitoring/enable".format(sensorID=sensorID,
        daytime=daytime)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send daytime if the argument was provided, don't send null values
    if daytime is not None:
        query_parameters.update({"daytime": daytime})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_monitoring_bulk(
    sensorIDs: int = None,
    comment: str = None,
    daytime: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk enable sensor monitoring. To set daytime only monitoring use the 'daytime' queryParm. (INTERNAL)
    
    :param list sensorIDs: IDs of Sensors whose monitoring we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param bool daytime: Daytime only monitoring flag
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/monitoring/enable".format(daytime=daytime)
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send daytime if the argument was provided, don't send null values
    if daytime is not None:
        query_parameters.update({"daytime": daytime})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Activates a sensor (INTERNAL)
    
    :param int sensorID: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/enable".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def enable_sensors(
    comment: str = None,
    sensorIDs: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk activation of sensors (INTERNAL)
    
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param list sensorIDs: IDs of Sensors to activate.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/enable".format()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_interface(
    sensorID: int,
    interfaceNameOrID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Gets one of a Sensor's interfaces (INTERNAL)
    
    :param int sensorID: ID of the sensor to which the interface belongs
    :param str interfaceNameOrID: ID or name of the Interface
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises SensorOrInterfaceNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interfaceNameOrID}".format(sensorID=sensorID,
        interfaceNameOrID=interfaceNameOrID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Fetch sensor by ID (INTERNAL)
    
    :param int sensorID: ID of sensor to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensor_comment(
    sensorID: int,
    timestamp: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Fetch comment by timestamp for sensor (INTERNAL)
    
    :param int sensorID: SensorID
    :param int timestamp: Timestamp
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment/{timestamp}".format(sensorID=sensorID,
        timestamp=timestamp)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensor_comments(
    sensorID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Fetch sensor comments by sensor ID (INTERNAL)
    
    :param int sensorID: ID of sensor to fetch comments for
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comments".format(limit=limit,
        sensorID=sensorID,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensor_status_by_sensor(
    sensorID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Gets status for a sensor (INTERNAL)
    
    :param int sensorID: ID of sensor whose status we want to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/status".format(sensorID=sensorID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def get_sensors(
    customerID: int = None,
    customer: str = None,
    applicationName: str = None,
    keywords: str = None,
    minExpectedUpdateTime: int = None,
    maxExpectedUpdateTime: int = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """List sensors (INTERNAL)
    
    :param list customerID: Limit search to these customer IDs
    :param list customer: Limit search to these customer ids or shortname
    :param list applicationName: Limit search to these applications by name
    :param list keywords: Limit search by sensor hostname or IP address
    :param int minExpectedUpdateTime: Filter by sensors with expectedUpdateTime at least this value in millis
    :param int maxExpectedUpdateTime: Filter by sensors with expectedUpdateTime at most this value in millis
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/sensors/v1/sensor".format(limit=limit,
        customerID=customerID,
        customer=customer,
        applicationName=applicationName,
        keywords=keywords,
        minExpectedUpdateTime=minExpectedUpdateTime,
        maxExpectedUpdateTime=maxExpectedUpdateTime,
        offset=offset)
    headers = {}
    headers['content'] = None
    if json:
        headers['content'] = 'application/json'

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send applicationName if the argument was provided, don't send null values
    if applicationName is not None:
        query_parameters.update({"applicationName": applicationName})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send minExpectedUpdateTime if the argument was provided, don't send null values
    if minExpectedUpdateTime is not None:
        query_parameters.update({"minExpectedUpdateTime": minExpectedUpdateTime})
    
    # Only send maxExpectedUpdateTime if the argument was provided, don't send null values
    if maxExpectedUpdateTime is not None:
        query_parameters.update({"maxExpectedUpdateTime": maxExpectedUpdateTime})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def list_sensor_comments(
    sensorID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Fetch comments for sensor (INTERNAL)
    
    :param int sensorID: SensorID
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/comment".format(limit=limit,
        sensorID=sensorID,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def list_sensor_interfaces(
    sensorID: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Gets a Sensor's interfaces (INTERNAL)
    
    :param int sensorID: ID of the sensor to which the interface belongs
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises SensorNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface".format(limit=limit,
        sensorID=sensorID,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def remove_acknowledgement_sensor(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Remove acknowledgement for a sensor by its ID.  (INTERNAL)
    
    :param int sensorID: ID of sensor to remove acknowledgment
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/removeacknowledgement".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def remove_acknowledgement_sensors(
    sensorID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk remove acknowledgement for Sensors by their IDs. Any comment will be applied to ALL specified sensors. (INTERNAL)
    
    :param list sensorID: ID of sensors to remove acknowledgement
    :param str comment: Any comments to append to the request. NB\: Each Sensor specified in the request will receive the same comment. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/removeacknowledgement".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        query_parameters.update({"sensorID": sensorID})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def restore_sensor(
    sensorID: int,
    enable: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Restore sensor by ID (INTERNAL)
    
    :param int sensorID: ID of sensor to restore
    :param bool enable: Whether to enable the Sensor at the same time as restoring it. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/restore".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send enable if the argument was provided, don't send null values
    if enable is not None:
        body.update({"enable": enable})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def restore_sensors(
    sensorIDs: int = None,
    comment: str = None,
    enable: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Restore sensors by ID (INTERNAL)
    
    :param list sensorIDs: IDs of Sensors we want to update.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param bool enable: Whether to enable the Sensors at the same time as restoring them. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/restore".format()
    headers = {}

    body = body or {}
    # Only send sensorIDs if the argument was provided, don't send null values
    if sensorIDs is not None:
        body.update({"sensorIDs": sensorIDs})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send enable if the argument was provided, don't send null values
    if enable is not None:
        body.update({"enable": enable})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def schedule_sensor_downtime(
    sensorID: int,
    fromTime: int = None,
    toTime: int = None,
    keepDowntimeOnUpdate: bool = None,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Schedules downtime for supplied sensorID (INTERNAL)
    
    :param int sensorID: 
    :param int fromTime: Timestamp in epoch ms from which the requested change takes effect. \(default now\)
    :param int toTime: Timestamp in epoch ms until which the requested change takes effect.
    :param bool keepDowntimeOnUpdate: Flag to maintain existing downtime configurations. 
If set\, downtime will not automatically end when the Sensor registers a new event.
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/downtime".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send fromTime if the argument was provided, don't send null values
    if fromTime is not None:
        body.update({"fromTime": fromTime})
    # Only send toTime if the argument was provided, don't send null values
    if toTime is not None:
        body.update({"toTime": toTime})
    # Only send keepDowntimeOnUpdate if the argument was provided, don't send null values
    if keepDowntimeOnUpdate is not None:
        body.update({"keepDowntimeOnUpdate": keepDowntimeOnUpdate})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def search_sensors(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    customerID: int = None,
    keywords: str = None,
    keywordMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    customer: str = None,
    timeMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    minExpectedUpdateTimeInterval: int = None,
    maxExpectedUpdateTimeInterval: int = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    sensorID: int = None,
    locationName: str = None,
    applicationName: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search sensors (INTERNAL)
    
    :param int limit: Limit results
    :param int offset: Offset results
    :param bool includeDeleted: Also include deleted objects \(where implemented\)
    :param list customerID: Limit result to objects belonging to these customers
    :param list keywords: Search for sensors matching these hostnames or IP\-addresses
    :param str keywordMatchStrategy: Defines how strictly different keywords should be matched \(default match any keywords\) \(default any\)
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(defaults to all supported fields\) \(default all\)
    :param list customer: Search for sensors belonging to customers identified by their ID or shortname
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp \(default lastUpdatedTimestamp\)
    :param int minExpectedUpdateTimeInterval: Filter sensors by min expected update time interval in millis
    :param int maxExpectedUpdateTimeInterval: Filter sensors by max expected update time interval in millis
    :param int startTimestamp: Search objects from this timestamp
    :param int endTimestamp: Search objects until this timestamp
    :param list sortBy: Order results by these properties \(prefix with \- to sort descending\)
    :param list includeFlags: Search objects with these flags set
    :param list excludeFlags: Exclude objects with these flags set
    :param list sensorID: Search for specific sensors by ID
    :param list locationName: DEPRECATED\: Use location instead.
    :param list applicationName: Search for sensors by application type
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/search".format()
    headers = {}
    headers['content'] = None
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send minExpectedUpdateTimeInterval if the argument was provided, don't send null values
    if minExpectedUpdateTimeInterval is not None:
        body.update({"minExpectedUpdateTimeInterval": minExpectedUpdateTimeInterval})
    # Only send maxExpectedUpdateTimeInterval if the argument was provided, don't send null values
    if maxExpectedUpdateTimeInterval is not None:
        body.update({"maxExpectedUpdateTimeInterval": maxExpectedUpdateTimeInterval})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        body.update({"sensorID": sensorID})
    # Only send locationName if the argument was provided, don't send null values
    if locationName is not None:
        body.update({"locationName": locationName})
    # Only send applicationName if the argument was provided, don't send null values
    if applicationName is not None:
        body.update({"applicationName": applicationName})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def submit_sensor_status_bulk(
    records: dict = None,
    ignoreOnFailed: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Submit sensor status records in a bulk operation (INTERNAL)
    
    :param list records: Sensor status records for submission
    :param bool ignoreOnFailed: If set to true submitted records with errors will be discarded and all remaining records will be processed. If set to false errors will fail the whole request. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/bulk/status".format()
    headers = {}

    body = body or {}
    # Only send records if the argument was provided, don't send null values
    if records is not None:
        body.update({"records": records})
    # Only send ignoreOnFailed if the argument was provided, don't send null values
    if ignoreOnFailed is not None:
        body.update({"ignoreOnFailed": ignoreOnFailed})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def update_initial_tuning(
    sensorID: int,
    initialTuning: bool,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Update initial tuning property for a Sensor. (INTERNAL)
    
    :param int sensorID: ID of sensor to change initial tuning status
    :param bool initialTuning: Desired new Sensor initial tuning status
    :param str comment: Any comment to append to the request. If not specified the service will generate a generic one. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/initialtuning".format(sensorID=sensorID,
        initialTuning=initialTuning)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        query_parameters.update({"initialTuning": initialTuning})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def update_interface(
    sensorID: int,
    interface: str,
    sslTerminating: bool = None,
    newInterfaceName: str = None,
    location: str = None,
    active: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Update Interface by ID (INTERNAL)
    
    :param int sensorID: ID of the Sensor to which the Interface belongs
    :param str interface: ID of the Interface we want to update
    :param bool sslTerminating: 
    :param str newInterfaceName: New name of the Sensor Interface. Must be unique per Sensor. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str location: New Location ID or short name of the Sensor Interface.
    :param bool active: New Status of the Sensor interface
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}/interface/{interface}".format(sensorID=sensorID,
        interface=interface)
    headers = {}

    body = body or {}
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send newInterfaceName if the argument was provided, don't send null values
    if newInterfaceName is not None:
        body.update({"newInterfaceName": newInterfaceName})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send active if the argument was provided, don't send null values
    if active is not None:
        body.update({"active": active})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module
)
def update_sensor(
    sensorID: int,
    location: str = None,
    clusterSensorID: int = None,
    information: str = None,
    hostname: str = None,
    ipAddress: str = None,
    additionalData: str = None,
    application: str = None,
    expectedUpdateTime: int = None,
    reportingSeverity: str = None,
    initialTuning: bool = None,
    overrideDefaultUpdateTime: bool = None,
    sharedCustomerData: bool = None,
    sslTerminating: bool = None,
    contractual: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Update sensor by ID (INTERNAL)
    
    :param int sensorID: ID of sensor to update
    :param str location: ID or shortname of the Sensor\'s location
    :param int clusterSensorID: DEPRECATED\: Deprecated. Please use the dedicated clustering endpoint\(s\) instead.
    :param str information: Sensor information
    :param str hostname: Sensor hostname.
Unless the Sensor\'s additional data is unique the hostname must also be unique for its owning customer.
If removing the hostname the Sensor must have a valid IP address.
 \=\> Sanitize by regex \(\[\\p\{Alnum\}\\.\_\-\]\+\)
    :param str ipAddress: Sensor\'s IP address.
Unless the Sensor\'s additional data is unique the IP address must also be unique for its owning customer.
If removing the IP address the Sensor must have a valid IP address.
 \=\> format\:ip
    :param str additionalData: Additional identifier
    :param str application: ID or shortname of Sensor type
    :param int expectedUpdateTime: Expected updated time\, only set if overrideDefaultUpdateTime is true
    :param str reportingSeverity: If specified overwrite the ReportingSeverity level for this Sensor\'s Application
    :param bool initialTuning: Sensor\'s initial tuning status \(default null\)
    :param bool overrideDefaultUpdateTime: Sensor\'s override default update time flag \(default null\)
    :param bool sharedCustomerData: Sensor\'s shared customer data flag \(default null\)
    :param bool sslTerminating: Sensor\'s SSL terminating flag \(default null\)
    :param bool contractual: Whether the Sensor contributes to the customer\'s contractual Sensor limit \(default null\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sensors/v1/sensor/{sensorID}".format(sensorID=sensorID)
    headers = {}

    body = body or {}
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send clusterSensorID if the argument was provided, don't send null values
    if clusterSensorID is not None:
        body.update({"clusterSensorID": clusterSensorID})
    # Only send information if the argument was provided, don't send null values
    if information is not None:
        body.update({"information": information})
    # Only send hostname if the argument was provided, don't send null values
    if hostname is not None:
        body.update({"hostname": hostname})
    # Only send ipAddress if the argument was provided, don't send null values
    if ipAddress is not None:
        body.update({"ipAddress": ipAddress})
    # Only send additionalData if the argument was provided, don't send null values
    if additionalData is not None:
        body.update({"additionalData": additionalData})
    # Only send application if the argument was provided, don't send null values
    if application is not None:
        body.update({"application": application})
    # Only send expectedUpdateTime if the argument was provided, don't send null values
    if expectedUpdateTime is not None:
        body.update({"expectedUpdateTime": expectedUpdateTime})
    # Only send initialTuning if the argument was provided, don't send null values
    if initialTuning is not None:
        body.update({"initialTuning": initialTuning})
    # Only send overrideDefaultUpdateTime if the argument was provided, don't send null values
    if overrideDefaultUpdateTime is not None:
        body.update({"overrideDefaultUpdateTime": overrideDefaultUpdateTime})
    # Only send sharedCustomerData if the argument was provided, don't send null values
    if sharedCustomerData is not None:
        body.update({"sharedCustomerData": sharedCustomerData})
    # Only send sslTerminating if the argument was provided, don't send null values
    if sslTerminating is not None:
        body.update({"sslTerminating": sslTerminating})
    # Only send reportingSeverity if the argument was provided, don't send null values
    if reportingSeverity is not None:
        body.update({"reportingSeverity": reportingSeverity})
    # Only send contractual if the argument was provided, don't send null values
    if contractual is not None:
        body.update({"contractual": contractual})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

#: **DEPRECATED** : ``list_sensors_1`` is an alias for ``get_sensors``. Exists
#: only for backward compatibility - **do not use** - use ``get_sensors`` instead.
list_sensors_1 = register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module,
    alias="list_sensors_1"
)(deprecated_alias("list_sensors_1")(get_sensors))
#: **DEPRECATED** : ``get_sensor_1`` is an alias for ``get_sensor``. Exists
#: only for backward compatibility - **do not use** - use ``get_sensor`` instead.
get_sensor_1 = register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module,
    alias="get_sensor_1"
)(deprecated_alias("get_sensor_1")(get_sensor))
#: **DEPRECATED** : ``get_comment`` is an alias for ``list_sensor_comments``. Exists
#: only for backward compatibility - **do not use** - use ``list_sensor_comments`` instead.
get_comment = register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module,
    alias="get_comment"
)(deprecated_alias("get_comment")(list_sensor_comments))
#: **DEPRECATED** : ``get_comment_1`` is an alias for ``get_sensor_comment``. Exists
#: only for backward compatibility - **do not use** - use ``get_sensor_comment`` instead.
get_comment_1 = register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module,
    alias="get_comment_1"
)(deprecated_alias("get_comment_1")(get_sensor_comment))
#: **DEPRECATED** : ``get_interface_1`` is an alias for ``get_interface``. Exists
#: only for backward compatibility - **do not use** - use ``get_interface`` instead.
get_interface_1 = register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module,
    alias="get_interface_1"
)(deprecated_alias("get_interface_1")(get_interface))
#: **DEPRECATED** : ``get_sensor_status`` is an alias for ``get_sensor_status_by_sensor``. Exists
#: only for backward compatibility - **do not use** - use ``get_sensor_status_by_sensor`` instead.
get_sensor_status = register_command(
    extending=("sensors", "v1", "sensor"),
    module=argus_cli_module,
    alias="get_sensor_status"
)(deprecated_alias("get_sensor_status")(get_sensor_status_by_sensor))