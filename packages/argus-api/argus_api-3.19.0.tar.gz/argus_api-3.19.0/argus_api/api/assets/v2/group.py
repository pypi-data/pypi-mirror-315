"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response
log = logging.getLogger(__name__)


@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def add_asset_group(
    customer: str = None,
    shortName: str = None,
    name: str = None,
    description: str = None,
    owner: str = None,
    criticality: dict = None,
    filter: str = None,
    forceIndex: bool = None,
    canContainAssets: bool = None,
    dynamic: bool = None,
    neverDynamic: bool = None,
    populateDynamicGroup: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Creates a new AssetGroup (PUBLIC)
    
    :param str customer: ID or short name of customer\, if not specified then current user\'s customer will be assigned
    :param str shortName: Customer unique short name of asset group. If not specified will be set to the new group\'s generated\/assigned UUID. \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: Name of asset group \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str description: Description of asset group. May use HTML\, which will be sanitized
    :param str owner: ID or username of user who owns the asset group. When username is specified\, it should exist within current user\'s domain \(default If not filled out\, it will default to the user who created the group.\)
    :param dict criticality: Request to set a Group or Asset\'s criticality triad
    :param str filter: Dynamic group filter ID or short name\, if the group is dynamic this value is Required.
    :param bool forceIndex: Whether to force an Elasticsearch index refresh making the new Asset group immediately searchable.
    :param bool canContainAssets: Restricts whether this group can contain only Assets or Groups \(default false\)
    :param bool dynamic: Describes if the group will be dynamically updated. If \'true\' the group must be a group of assets. \(default false\)
    :param bool neverDynamic: Describes if the group may be converted to a dynamic one. \(default false\)
    :param bool populateDynamicGroup: The group can be populated right away or it can wait for first refresh that is scheduled.
Note\: Populating dynamic groups is an async process\, so\, even with this option selected\, the group
may not be immediately available. Depending on the group size some wait time will be necessary. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group".format(forceIndex=forceIndex)
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send owner if the argument was provided, don't send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send criticality if the argument was provided, don't send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send canContainAssets if the argument was provided, don't send null values
    if canContainAssets is not None:
        body.update({"canContainAssets": canContainAssets})
    # Only send dynamic if the argument was provided, don't send null values
    if dynamic is not None:
        body.update({"dynamic": dynamic})
    # Only send neverDynamic if the argument was provided, don't send null values
    if neverDynamic is not None:
        body.update({"neverDynamic": neverDynamic})
    # Only send populateDynamicGroup if the argument was provided, don't send null values
    if populateDynamicGroup is not None:
        body.update({"populateDynamicGroup": populateDynamicGroup})
    # Only send filter if the argument was provided, don't send null values
    if filter is not None:
        body.update({"filter": filter})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def attach_assets(
    idOrShortName: str,
    customer: str = None,
    assets: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Attach asset to the asset group. Asset group will recalculate de-normalized fields and flags base on children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. (PUBLIC)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group\/asset short name was provided
    :param list assets: Specify set of assets to be attached to the asset group\, it accepts asset\'s ID or short name.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets".format(idOrShortName=idOrShortName,
        customer=customer)
    headers = {}

    body = body or {}
    # Only send assets if the argument was provided, don't send null values
    if assets is not None:
        body.update({"assets": assets})

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def attach_children_groups(
    idOrShortName: str,
    customer: str = None,
    childrenGroups: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Attach asset groups to parent asset group as children. Associating groups should not cause circular relationships. Parent group will recalculate de-normalized fields and flags base on children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. (PUBLIC)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param list childrenGroups: Specify set of asset groups to be attached as children groups\, it accepts asset group ID or short name. Child group should not cause circular relationship among asset groups.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups".format(idOrShortName=idOrShortName,
        customer=customer)
    headers = {}

    body = body or {}
    # Only send childrenGroups if the argument was provided, don't send null values
    if childrenGroups is not None:
        body.update({"childrenGroups": childrenGroups})

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def convert_group_to_dynamic(
    idOrShortName: str,
    customer: str = None,
    filter: str = None,
    populateDynamicGroup: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Converts an existing managed AssetGroup to dynamic (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param str filter: Dynamic group filter ID or short name.
    :param bool populateDynamicGroup: The group can be populated right away or it can wait for first refresh that is scheduled.
Note\: Populating dynamic groups is an async process\, so\, event with this option selected\, the group
may not be immediately available. Depending on the group size some wait time will be necessary. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/dynamic".format(idOrShortName=idOrShortName,
        customer=customer)
    headers = {}

    body = body or {}
    # Only send populateDynamicGroup if the argument was provided, don't send null values
    if populateDynamicGroup is not None:
        body.update({"populateDynamicGroup": populateDynamicGroup})
    # Only send filter if the argument was provided, don't send null values
    if filter is not None:
        body.update({"filter": filter})

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def convert_group_to_managed(
    idOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Converts an existing dynamic AssetGroup to managed (DEV)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/managed".format(idOrShortName=idOrShortName,
        customer=customer)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def delete_asset_group(
    idOrShortName: str,
    customer: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete asset group (PUBLIC)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that updates to the AssetGroup are immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def detach_assets(
    idOrShortName: str,
    asset: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Detach multiple assets from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (PUBLIC)
    
    :param str idOrShortName: Parent group\'s ID or short name
    :param list asset: Assets\' IDs or short names to be detached
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets".format(idOrShortName=idOrShortName,
        asset=asset,
        customer=customer)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        query_parameters.update({"asset": asset})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def detach_children_groups(
    idOrShortName: str,
    group: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Detach multiple asset groups from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (PUBLIC)
    
    :param str idOrShortName: Parent group\'s ID or short name
    :param list group: Children groups\' IDs or short names to be detached
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups".format(idOrShortName=idOrShortName,
        group=group,
        customer=customer)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send group if the argument was provided, don't send null values
    if group is not None:
        query_parameters.update({"group": group})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def detach_single_child_asset(
    idOrShortName: str,
    assetIDOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Detach single asset from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (PUBLIC)
    
    :param str idOrShortName: Parent group\'s ID or short name
    :param str assetIDOrShortName: Asset\'s ID or short name to be detached
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets/{assetIDOrShortName}".format(idOrShortName=idOrShortName,
        assetIDOrShortName=assetIDOrShortName,
        customer=customer)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def detach_single_child_group(
    idOrShortName: str,
    childGroupIDOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Detach single child asset group from parent asset group. Parent group will recalculate de-normalized fields and flags base on remaining children groups and assets, such as totalCVSS, vulnerabilitiesCount and flags to indicate whether there is high or critical severity vulnerability. Response with parent group after change. (PUBLIC)
    
    :param str idOrShortName: Parent group\'s ID or short name
    :param str childGroupIDOrShortName: Child group\'s ID or short name to be detached
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups/{childGroupIDOrShortName}".format(idOrShortName=idOrShortName,
        childGroupIDOrShortName=childGroupIDOrShortName,
        customer=customer)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def get_asset_group(
    idOrShortName: str,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Get Asset Group (PUBLIC)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def get_children_asset_groups(
    idOrShortName: str,
    customer: str = None,
    offset: int = None,
    limit: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Get non-deleted children asset groups associated with specified asset group you have permission to view (PUBLIC)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param int offset: How many Assets Groups to skip\, defaults to 0
    :param int limit: How many Assets Groups to return\, defaults to all
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/groups".format(idOrShortName=idOrShortName,
        customer=customer,
        offset=offset,
        limit=limit)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def get_children_assets(
    idOrShortName: str,
    customer: str = None,
    limit: int = 25,
    sortBy: str = "name",
    includeDeleted: bool = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Get assets that are immediate members of the specified asset group (PUBLIC)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param int limit: How many Assets to return
    :param str sortBy: Field to sort by
    :param bool includeDeleted: Whether to include deleted Assets in the response
    :param int offset: How many Assets to skip\, defaults to 0
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/assets".format(limit=limit,
        sortBy=sortBy,
        idOrShortName=idOrShortName,
        customer=customer,
        includeDeleted=includeDeleted,
        offset=offset)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def list_asset_groups(
    customer: str = None,
    group: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Basic Asset Group search.If keywords are present, they must all must be present in at least one of the keyword fields.Check the documentation for the KeywordFieldStrategy field for more details.If start/end timestamps are present, the range must be valid for at least one of the time stamp fields.Check the documentation for the TimestampFieldStrategy field for more details. (PUBLIC)
    
    :param list customer: Customer ids or short names
    :param list group: Asset group ids or short names
    :param list keywords: Limit search by asset group keywords
    :param list sortBy: Field\(s\) to sort by \- refer to the search POST endpoint to see which fields are permitted
    :param int limit: Limit results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param str startTimestamp: Lower bound timestamp filter value
    :param str endTimestamp: Upper bound timestamp filter value
    :param int offset: Offset results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param bool includeDeleted: Include deleted
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group".format(limit=limit,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        customer=customer,
        group=group,
        keywords=keywords,
        offset=offset,
        includeDeleted=includeDeleted,
        sortBy=sortBy)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send group if the argument was provided, don't send null values
    if group is not None:
        query_parameters.update({"group": group})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def recalculate_group(
    idOrShortName: str,
    customer: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Force a recalculation of an Asset Group's vulnerabilityCount, assetCount, memberCount, and totalCVSS fields.Generally this should not be necessary as these fields are automatically recalculated when necessary.NB: any changes are propagated up the Asset Group hierarchy if the Asset Group belongs to any other group(s). (INTERNAL)
    
    :param str idOrShortName: Asset Group ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when asset group short name was provided
    :param bool forceIndex: Whether to force an Elasticsearch index refresh making the recalculated asset group immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}/recalculate".format(idOrShortName=idOrShortName,
        customer=customer,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def reindex_asset_group(
    groupID: str = None,
    recursive: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Re-indexes specified Asset Groups (INTERNAL)
    
    :param list groupID: A set of asset group IDs to be re\-indexed
    :param str recursive: Enumerated type of chosen recursion strategy \(none \- reindex just asset groups\, asset \- reindex asset groups and associated assets\, all \- reindex asset groups\, associated assets and vulnerabilities\, asset groups also include their children groups\) \(default none\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/bulk/reindex".format()
    headers = {}

    body = body or {}
    # Only send groupID if the argument was provided, don't send null values
    if groupID is not None:
        body.update({"groupID": groupID})
    # Only send recursive if the argument was provided, don't send null values
    if recursive is not None:
        body.update({"recursive": recursive})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def search_asset_groups(
    exportFields: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    customer: str = None,
    group: str = None,
    asset: str = None,
    hasAsset: bool = None,
    parent: str = None,
    ancestor: str = None,
    child: str = None,
    hasChild: bool = None,
    minimumTotalCvss: float = None,
    maximumTotalCvss: float = None,
    criticality: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search Asset Groups (PUBLIC)
    
    :param list exportFields: Select order of and fields to export.
    :param list keywords: Search for keywords against fields defined by a KeywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\) \(default any\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default any\)
    :param str startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param str endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp \(default lastUpdatedTimestamp\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list userFieldStrategy: Defines which user fields to filter with the submitted user value\(s\) \(default all\)
    :param list user: Search for AssetGroups by associated user IDs or short names defined by the UserFieldStrategy
    :param list customer: Search for AssetGroups with these Customer IDs or short names
    :param list group: Search for AssetGroups with these IDs or short names
    :param list asset: Search for AssetGroups containing Assets with these IDs or short names
    :param bool hasAsset: Set to filter on\/out groups containing Assets
    :param list parent: Search for AssetGroups with these parent IDs or short names
    :param list ancestor: Search for AssetGroups in the hierarchy below these ancestor AssetGroups identified by their ID or short name.\<br \/\>This will resolve all descendant Asset Groups and expand the search to return AssetsGroups below these \'ancestor\' groups
    :param list child: Search for AssetGroups with these children IDs or short namesi.e. return the groups who contain at least one of these AssetGroups
    :param bool hasChild: Set to filter on\/out groups containing Asset Groups
    :param float minimumTotalCvss: Search for AssetGroups with at least this CVSS score
    :param float maximumTotalCvss: Search for AssetGroups with at most this CVSS score
    :param list criticality: Search for Asset Groups by Confidentiality\, Availability and Integrity.\<br \/\>All criteria values must match for an Asset Group to match. Use sub\-criteria for OR query behaviour.
    :param list includeFlags: Explicitly search for AssetGroups that contain these flags
    :param list excludeFlags: Explicitly filter out AssetGroups that contain these flags
    :param list subCriteria: Set additional criteria that are applied with logical OR by default
    :param list sortBy: Field\(s\) by which to sort the results
    :param int limit: Limit the results to the specified amount \(default 25\)
    :param int offset: Skip specified amount of results \(default 0\)
    :param bool includeDeleted: Whether to include deleted Asset groups \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/assets/v2/group/search".format(exportFields=exportFields)
    headers = {}
    headers['content'] = None
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send group if the argument was provided, don't send null values
    if group is not None:
        body.update({"group": group})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send hasAsset if the argument was provided, don't send null values
    if hasAsset is not None:
        body.update({"hasAsset": hasAsset})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send ancestor if the argument was provided, don't send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send child if the argument was provided, don't send null values
    if child is not None:
        body.update({"child": child})
    # Only send hasChild if the argument was provided, don't send null values
    if hasChild is not None:
        body.update({"hasChild": hasChild})
    # Only send minimumTotalCvss if the argument was provided, don't send null values
    if minimumTotalCvss is not None:
        body.update({"minimumTotalCvss": minimumTotalCvss})
    # Only send maximumTotalCvss if the argument was provided, don't send null values
    if maximumTotalCvss is not None:
        body.update({"maximumTotalCvss": maximumTotalCvss})
    # Only send criticality if the argument was provided, don't send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})

    query_parameters = {}
    # Only send exportFields if the argument was provided, don't send null values
    if exportFields is not None:
        query_parameters.update({"exportFields": exportFields})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "group"),
    module=argus_cli_module
)
def update_asset_group(
    idOrShortName: str,
    customer: str = None,
    shortName: str = None,
    name: str = None,
    description: str = None,
    owner: str = None,
    criticality: dict = None,
    neverDynamic: bool = None,
    filter: str = None,
    forceIndex: bool = None,
    populateDynamicGroup: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Updates an existing AssetGroup (PUBLIC)
    
    :param str idOrShortName: AssetGroup ID or short name
    :param str customer: Customer ID or short name \(default is user\'s customer\)\, only used when group short name was provided
    :param str shortName: Update short name of asset group \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: Update name of asset group \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str description: Update description of asset group. Support HTML\, which will be sanitized
    :param str owner: Update owner of asset group\, specified by user ID or username. When username is specified\, it should exist within current user\'s domain
    :param dict criticality: Request to update a Group or Asset\'s criticality triad
    :param bool neverDynamic: Describes if the group may be converted to a dynamic one. If the group is already dynamic\,
please convert it to managed using a dedicated endpoint\, before applying this flag\, otherwise
an error will be thrown.
    :param str filter: Dynamic group filter ID or short name.
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that changes to the AssetGroup are immediately searchable.
    :param bool populateDynamicGroup: The group can be populated right away or it can wait for first refresh that is scheduled.
Note\: Populating dynamic groups is an async process\, so\, even with this option selected\, the group
may not be immediately available. Depending on the group size some wait time will be necessary. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/group/{idOrShortName}".format(idOrShortName=idOrShortName,
        customer=customer,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send owner if the argument was provided, don't send null values
    if owner is not None:
        body.update({"owner": owner})
    # Only send criticality if the argument was provided, don't send null values
    if criticality is not None:
        body.update({"criticality": criticality})
    # Only send neverDynamic if the argument was provided, don't send null values
    if neverDynamic is not None:
        body.update({"neverDynamic": neverDynamic})
    # Only send populateDynamicGroup if the argument was provided, don't send null values
    if populateDynamicGroup is not None:
        body.update({"populateDynamicGroup": populateDynamicGroup})
    # Only send filter if the argument was provided, don't send null values
    if filter is not None:
        body.update({"filter": filter})

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
