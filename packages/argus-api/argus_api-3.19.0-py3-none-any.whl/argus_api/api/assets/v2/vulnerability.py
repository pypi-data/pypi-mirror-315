"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response
log = logging.getLogger(__name__)


@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def add_vulnerability(
    customer: str = None,
    dataSource: str = None,
    asset: str = None,
    vulnerability: str = None,
    components: dict = None,
    cvss: float = None,
    severity: str = None,
    rawOutput: str = None,
    ttl: int = None,
    observationDescription: str = None,
    observationReferences: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Creates a new vulnerability instance (PUBLIC)
    
    :param str customer: ID or short name of customer\, if not specified then current user\'s customer will be assigned.
    :param str dataSource: ID or short name of the Data Source
    :param str asset: ID or short name of asset. If short name is specified\, then the asset is looked up from the customer.
    :param str vulnerability: Either vulnerability definition ID \(UUID\) or vulnerability identifier \(e.g. CVE\-2015\-3429\). First the value will be used to lookup vulnerability definition \(UUID will only be supported for vulnerability definition lookup\). If vulnerability definition exists\, then associate this vulnerability instance to it\, and require read permission on vulnerability source of the definition. Otherwise create vulnerability instance with vulnerability identifier. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param list components: Specify components to be added with the vulnerability.
    :param float cvss: CVSS score of vulnerability \(range from 0 to 10\). Setting this field will overwrite
vulnerability definition settings and the value will not be updated when CVSS or Severity
in the definition changes.
    :param str severity: Severity level of vulnerability. If not provided\, then severity will be calculated based on CVSS value.
Setting this field will overwrite vulnerability definition settings and the value will not be updated
when CVSS or Severity in the definition changes.
    :param str rawOutput: Raw output from vulnerability scan. Will be sanitized as html.
    :param int ttl: Time to live duration of this vulnerability since last seen\, 0 means won\'t expire.
    :param str observationDescription: Description specific to this vulnerability. May contain customer specific data. Will be sanitized as HTML. 
    :param list observationReferences: References specific to this vulnerability e.g. internal URLs. May contain customer specific data.
    :param bool forceIndex: Whether to force an Elasticsearch index refresh making the new vulnerability immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability".format(forceIndex=forceIndex)
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        body.update({"dataSource": dataSource})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send vulnerability if the argument was provided, don't send null values
    if vulnerability is not None:
        body.update({"vulnerability": vulnerability})
    # Only send components if the argument was provided, don't send null values
    if components is not None:
        body.update({"components": components})
    # Only send cvss if the argument was provided, don't send null values
    if cvss is not None:
        body.update({"cvss": cvss})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send rawOutput if the argument was provided, don't send null values
    if rawOutput is not None:
        body.update({"rawOutput": rawOutput})
    # Only send ttl if the argument was provided, don't send null values
    if ttl is not None:
        body.update({"ttl": ttl})
    # Only send observationDescription if the argument was provided, don't send null values
    if observationDescription is not None:
        body.update({"observationDescription": observationDescription})
    # Only send observationReferences if the argument was provided, don't send null values
    if observationReferences is not None:
        body.update({"observationReferences": observationReferences})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def add_vulnerability_definition(
    vulnerabilitySource: str = None,
    vulnerabilityID: str = None,
    name: str = None,
    description: str = None,
    solution: str = None,
    conclusion: str = None,
    references: str = None,
    exploitAvailable: bool = None,
    severity: str = None,
    forceIndex: bool = None,
    exploitAvailableTimestamp: int = None,
    cvss: float = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Creates a new vulnerability definition also require to have read & write permission of vulnerability source that the definition is belonging to. (INTERNAL)
    
    :param str vulnerabilitySource: Define vulnerability source by source ID or short name.
    :param str vulnerabilityID: Identifier of vulnerability \(e.g. plug\-in ID from vulnerability scanner\). Needs to be unique. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str name: Name of vulnerability. Will be sanitized as text.
    :param str description: Description of vulnerability. Will be sanitized as html.
    :param str solution: How to fix vulnerability. Will be sanitized as html.
    :param str conclusion: Short summary of vulnerability. Will be sanitized as html.
    :param list references: References to vulnerability \(e.g. CVE number\). Will be sanitized as html.
    :param bool exploitAvailable: Set if an exploit is available for the vulnerability.
    :param str severity: Severity level of vulnerability definition. If not provided\, then severity will be calculated based on CVSS value.
    :param bool forceIndex: Whether to force an Elasticsearch index refresh making the new vulnerability definition immediately searchable.
    :param int exploitAvailableTimestamp: Set the timestamp when the exploit became available. Setting this value also expects setting exploitAvailable to \'true\' with this request. Setting\/leaving it to 0 will use current timestamp. \(default 0\)
    :param float cvss: CVSS score of vulnerability definition \(range from 0 to 10\). \(default 0.0\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition".format(forceIndex=forceIndex)
    headers = {}

    body = body or {}
    # Only send vulnerabilitySource if the argument was provided, don't send null values
    if vulnerabilitySource is not None:
        body.update({"vulnerabilitySource": vulnerabilitySource})
    # Only send vulnerabilityID if the argument was provided, don't send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send solution if the argument was provided, don't send null values
    if solution is not None:
        body.update({"solution": solution})
    # Only send conclusion if the argument was provided, don't send null values
    if conclusion is not None:
        body.update({"conclusion": conclusion})
    # Only send references if the argument was provided, don't send null values
    if references is not None:
        body.update({"references": references})
    # Only send exploitAvailable if the argument was provided, don't send null values
    if exploitAvailable is not None:
        body.update({"exploitAvailable": exploitAvailable})
    # Only send exploitAvailableTimestamp if the argument was provided, don't send null values
    if exploitAvailableTimestamp is not None:
        body.update({"exploitAvailableTimestamp": exploitAvailableTimestamp})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send cvss if the argument was provided, don't send null values
    if cvss is not None:
        body.update({"cvss": cvss})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def add_vulnerability_source(
    shortName: str = None,
    name: str = None,
    readPermission: str = None,
    writePermission: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Creates a new VulnerabilitySource (INTERNAL)
    
    :param str shortName: Vulnerability source short name\, required and unique \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: Name of source \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str readPermission: Permission required to allow read access of source \& vulnerability definition belong to this source \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str writePermission: Permission required to allow write access \(create\/update\/delete\) source \& of vulnerability definition belong to this source \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source".format()
    headers = {}

    body = body or {}
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send readPermission if the argument was provided, don't send null values
    if readPermission is not None:
        body.update({"readPermission": readPermission})
    # Only send writePermission if the argument was provided, don't send null values
    if writePermission is not None:
        body.update({"writePermission": writePermission})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def bulk_recast_observations(
    observations: str = None,
    severity: str = None,
    cvss: float = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk recasts a set of observations. (PUBLIC)
    
    :param list observations: The observations\' unique ids
    :param str severity: New Severity.
    :param float cvss: New CVSS score \(range from 0 to 10\).
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/bulk/recast".format()
    headers = {}

    body = body or {}
    # Only send observations if the argument was provided, don't send null values
    if observations is not None:
        body.update({"observations": observations})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send cvss if the argument was provided, don't send null values
    if cvss is not None:
        body.update({"cvss": cvss})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def bulk_resolve_vulnerabilities(
    observations: str = None,
    resolution: str = None,
    resolutionExpiryTimestamp: str = None,
    comment: str = None,
    ignoreResolved: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Bulk resolves a set of vulnerabilities. (PUBLIC)
    
    :param list observations: The observations\' unique ids
    :param str resolution: Specify resolution reason.
    :param str resolutionExpiryTimestamp: When will the current resolution expire \(0 means no expiry\). Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time values. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ \(default 0\)
    :param str comment: Comment on why the vulnerability is resolved. If present will apply to all vulnerabilities in the request. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param bool ignoreResolved: Whether to reject the entire request if any of the observations are already resolved. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/bulk/resolve".format()
    headers = {}

    body = body or {}
    # Only send observations if the argument was provided, don't send null values
    if observations is not None:
        body.update({"observations": observations})
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send resolutionExpiryTimestamp if the argument was provided, don't send null values
    if resolutionExpiryTimestamp is not None:
        body.update({"resolutionExpiryTimestamp": resolutionExpiryTimestamp})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send ignoreResolved if the argument was provided, don't send null values
    if ignoreResolved is not None:
        body.update({"ignoreResolved": ignoreResolved})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def delete_vulnerability(
    id: str,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete vulnerability (PUBLIC)
    
    :param str id: vulnerability ID
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that updates to the Vulnerability are immediately searchable
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}".format(id=id,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def delete_vulnerability_definition(
    idOrVulnerabilityID: str,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete Vulnerability definition, also require to have read & write permission of vulnerability source that the definition is belonging to. (INTERNAL)
    
    :param str idOrVulnerabilityID: Vulnerability definition ID or identifier of vulnerability
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that updates to the VulnerabilityDefinition are immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition/{idOrVulnerabilityID}".format(idOrVulnerabilityID=idOrVulnerabilityID,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def delete_vulnerability_source(
    source: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Marks a VulnerabilitySource as deleted (INTERNAL)
    
    :param str source: VulnerabilitySource ID or short name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/{source}".format(source=source)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_observations_by_vulnerability_compact_view(
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    references: str = None,
    observationReferences: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    asset: str = None,
    assetGroup: str = None,
    vulnerabilityID: str = None,
    vulnerabilityDefinition: str = None,
    customer: str = None,
    severity: str = None,
    resolution: str = None,
    dataSource: str = None,
    minimumCvss: float = None,
    maximumCvss: float = None,
    component: dict = None,
    assetComponent: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    sortBy: str = None,
    includeRawOutput: bool = None,
    limit: int = 25,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search for observations and group them by their vulnerability along with each vulnerability's observation count.
This differs from the stats endpoint in that it supports sorting and pagination of the resulting collapsed vulnerability results.
 (DEV)
    
    :param list keywords: Search for vulnerabilities by their definition keywords against definition text fields defined by a KeywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be queried for keywords \(defaults to all observation fields\) \(default all\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default any\)
    :param list references: Search for vulnerabilities by exact matches in their definition references
    :param list observationReferences: Search for vulnerabilities by exact matches in their references
    :param str startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param str endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp \(default lastSeenTimestamp\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list userFieldStrategy: Defines which user fields will be filtered with user ids or shortnames \(default all\)
    :param list user: Retrieve vulnerabilities by these users\, identified by their id or username
    :param list asset: Retrieve vulnerabilities detected on these assets by asset id or shortNames. As assets are customer specific we will resolve the assets for the customers provided in the criteria\, if any. If none are provided\, we attempt to use the customers the current user has access to.
    :param list assetGroup: Retrieve vulnerabilities detected on assets who are members or descendants of these groups identified by id or shortNames. As asset groups are customer specific we will resolve the groups for the customers provided in the criteria\, if any. If none are provided\, we attempt to use the customers the current user has access to.
    :param list vulnerabilityID: Retrieve vulnerabilities by their external ID e.g. CVE\-XXXX
    :param list vulnerabilityDefinition: Retrieve vulnerabilities by their vulnerability definition id or name
    :param list customer: Retrieve vulnerabilities by Customer id or name
    :param list severity: Retrieve vulnerabilities with these severities
    :param list resolution: Retrieve vulnerabilities with these resolutions
    :param list dataSource: Search for vulnerabilities detected and reported by these data sources\, identified by id or shortName
    :param float minimumCvss: Retrieve Vulnerabilities with at least this CVSS score
    :param float maximumCvss: Retrieve Vulnerabilities with at most this CVSS score
    :param list component: Search for Vulnerabilities with these components
    :param list assetComponent: Search for Vulnerabilities observed on Assets containing these components using AND search mode i.e. all criteria must match.\<br \/\>If you want different behaviour try using subcriteria
    :param list includeFlags: Explicitly retrieve Vulnerabilities that contain these flags
    :param list excludeFlags: Explicitly filter out Vulnerabilities that contain these flags
    :param list subCriteria: Set additional criteria that are applied with logical OR by default
    :param list sortBy: Field\(s\) by which to sort the results \(default \-count\)
    :param bool includeRawOutput: Whether to include raw output in the result objects \(default false\)
    :param int limit: Limit the results to the specified amount. \(default 25\)
    :param int offset: Skip specified amount of results. \(default 0\)
    :param bool includeDeleted: Whether to include deleted Vulnerabilities \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/compact/definition".format()
    headers = {}

    body = body or {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send references if the argument was provided, don't send null values
    if references is not None:
        body.update({"references": references})
    # Only send observationReferences if the argument was provided, don't send null values
    if observationReferences is not None:
        body.update({"observationReferences": observationReferences})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send assetGroup if the argument was provided, don't send null values
    if assetGroup is not None:
        body.update({"assetGroup": assetGroup})
    # Only send vulnerabilityID if the argument was provided, don't send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send vulnerabilityDefinition if the argument was provided, don't send null values
    if vulnerabilityDefinition is not None:
        body.update({"vulnerabilityDefinition": vulnerabilityDefinition})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        body.update({"dataSource": dataSource})
    # Only send minimumCvss if the argument was provided, don't send null values
    if minimumCvss is not None:
        body.update({"minimumCvss": minimumCvss})
    # Only send maximumCvss if the argument was provided, don't send null values
    if maximumCvss is not None:
        body.update({"maximumCvss": maximumCvss})
    # Only send component if the argument was provided, don't send null values
    if component is not None:
        body.update({"component": component})
    # Only send assetComponent if the argument was provided, don't send null values
    if assetComponent is not None:
        body.update({"assetComponent": assetComponent})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        body.update({"includeRawOutput": includeRawOutput})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_vulnerability_by_id(
    id: str,
    includeRawOutput: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Get Vulnerability by ID. (PUBLIC)
    
    :param str id: Vulnerability ID \(UUID\)
    :param bool includeRawOutput: Whether include raw output\, default not include
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}".format(id=id,
        includeRawOutput=includeRawOutput)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_vulnerability_definition(
    idOrVulnerabilityID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Get Vulnerability definition, also require to have read permission of vulnerability source that the definition is belonging to. (PUBLIC)
    
    :param str idOrVulnerabilityID: Vulnerability definition ID or identifier of vulnerability
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition/{idOrVulnerabilityID}".format(idOrVulnerabilityID=idOrVulnerabilityID)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_vulnerability_source(
    source: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Get VulnerabilitySource (INTERNAL)
    
    :param str source: VulnerabilitySource ID or short name
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/{source}".format(source=source)
    headers = {}

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def get_vulnerability_statistics(
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    references: str = None,
    observationReferences: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    asset: str = None,
    assetGroup: str = None,
    vulnerabilityID: str = None,
    vulnerabilityDefinition: str = None,
    customer: str = None,
    severity: str = None,
    resolution: str = None,
    dataSource: str = None,
    minimumCvss: float = None,
    maximumCvss: float = None,
    component: dict = None,
    assetComponent: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    fieldAggregation: dict = None,
    rangeMetric: dict = None,
    statisticsMetric: dict = None,
    includeRawOutput: bool = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Generate the requested statistics for Vulnerabilities matching the provided search criteria. (DEV)
    
    :param list keywords: Search for vulnerabilities by their definition keywords against definition text fields defined by a KeywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be queried for keywords \(defaults to all observation fields\) \(default all\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default any\)
    :param list references: Search for vulnerabilities by exact matches in their definition references
    :param list observationReferences: Search for vulnerabilities by exact matches in their references
    :param str startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param str endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp \(default lastSeenTimestamp\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list userFieldStrategy: Defines which user fields will be filtered with user ids or shortnames \(default all\)
    :param list user: Retrieve vulnerabilities by these users\, identified by their id or username
    :param list asset: Retrieve vulnerabilities detected on these assets by asset id or shortNames. As assets are customer specific we will resolve the assets for the customers provided in the criteria\, if any. If none are provided\, we attempt to use the customers the current user has access to.
    :param list assetGroup: Retrieve vulnerabilities detected on assets who are members or descendants of these groups identified by id or shortNames. As asset groups are customer specific we will resolve the groups for the customers provided in the criteria\, if any. If none are provided\, we attempt to use the customers the current user has access to.
    :param list vulnerabilityID: Retrieve vulnerabilities by their external ID e.g. CVE\-XXXX
    :param list vulnerabilityDefinition: Retrieve vulnerabilities by their vulnerability definition id or name
    :param list customer: Retrieve vulnerabilities by Customer id or name
    :param list severity: Retrieve vulnerabilities with these severities
    :param list resolution: Retrieve vulnerabilities with these resolutions
    :param list dataSource: Search for vulnerabilities detected and reported by these data sources\, identified by id or shortName
    :param float minimumCvss: Retrieve Vulnerabilities with at least this CVSS score
    :param float maximumCvss: Retrieve Vulnerabilities with at most this CVSS score
    :param list component: Search for Vulnerabilities with these components
    :param list assetComponent: Search for Vulnerabilities observed on Assets containing these components using AND search mode i.e. all criteria must match.\<br \/\>If you want different behaviour try using subcriteria
    :param list includeFlags: Explicitly retrieve Vulnerabilities that contain these flags
    :param list excludeFlags: Explicitly filter out Vulnerabilities that contain these flags
    :param list subCriteria: Set additional criteria that are applied with logical OR by default
    :param list fieldAggregation:   The fields by which to group statistics.
  The order of fieldAggregations in the request will determine the hierarchy of the aggregations and their buckets.

    :param list rangeMetric: The timestamp fields for which to generate statistics.
    :param list statisticsMetric: The numerical fields for which to generate metrics.
    :param bool includeRawOutput: Whether to include raw output in the result objects \(default false\)
    :param bool includeDeleted: Whether to include deleted Vulnerabilities \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/statistics".format()
    headers = {}

    body = body or {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send references if the argument was provided, don't send null values
    if references is not None:
        body.update({"references": references})
    # Only send observationReferences if the argument was provided, don't send null values
    if observationReferences is not None:
        body.update({"observationReferences": observationReferences})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send assetGroup if the argument was provided, don't send null values
    if assetGroup is not None:
        body.update({"assetGroup": assetGroup})
    # Only send vulnerabilityID if the argument was provided, don't send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send vulnerabilityDefinition if the argument was provided, don't send null values
    if vulnerabilityDefinition is not None:
        body.update({"vulnerabilityDefinition": vulnerabilityDefinition})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        body.update({"dataSource": dataSource})
    # Only send minimumCvss if the argument was provided, don't send null values
    if minimumCvss is not None:
        body.update({"minimumCvss": minimumCvss})
    # Only send maximumCvss if the argument was provided, don't send null values
    if maximumCvss is not None:
        body.update({"maximumCvss": maximumCvss})
    # Only send component if the argument was provided, don't send null values
    if component is not None:
        body.update({"component": component})
    # Only send assetComponent if the argument was provided, don't send null values
    if assetComponent is not None:
        body.update({"assetComponent": assetComponent})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        body.update({"includeRawOutput": includeRawOutput})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send fieldAggregation if the argument was provided, don't send null values
    if fieldAggregation is not None:
        body.update({"fieldAggregation": fieldAggregation})
    # Only send rangeMetric if the argument was provided, don't send null values
    if rangeMetric is not None:
        body.update({"rangeMetric": rangeMetric})
    # Only send statisticsMetric if the argument was provided, don't send null values
    if statisticsMetric is not None:
        body.update({"statisticsMetric": statisticsMetric})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def list_vulnerabilities(
    customer: str = None,
    asset: str = None,
    dataSource: str = None,
    vulnerabilityID: str = None,
    severity: str = None,
    resolution: str = None,
    timeFieldStrategy: str = None,
    sortBy: str = None,
    limit: int = 25,
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    offset: int = None,
    includeDeleted: bool = None,
    includeRawOutput: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Basic Vulnerability search. Will not return vulnerabilities seen more than 31 days ago.
Please use advanced search to return older vulnerabilities.
If start/end timestamps are present, the range must be valid
for at least one of the time stamp fields.
Check the documentation for the TimestampFieldStrategy field for more details. (PUBLIC)
    
    :param list customer: Customer ids or short names
    :param list asset: Asset ids or short names. Will resolve with the provided customers\, or those the current user has access to if none are provided
    :param list dataSource: Data source\, identified by id or shortname\, that detected the Vulnerability
    :param list vulnerabilityID: Vulnerability external ID
    :param list severity: Vulnerability Severity
    :param list resolution: Vulnerability Resolution
    :param list timeFieldStrategy: Which time field\(s\) to filter by timestamp start\/end
    :param list sortBy: Field\(s\) to sort by \- refer to the search POST endpoint to see which fields are permitted
    :param int limit: Limit results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param str startTimestamp: Lower bound timestamp filter value
    :param str endTimestamp: Upper bound timestamp filter value
    :param int offset: Offset results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param bool includeDeleted: Include deleted
    :param bool includeRawOutput: Include raw output from scanner
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability".format(limit=limit,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        customer=customer,
        asset=asset,
        dataSource=dataSource,
        vulnerabilityID=vulnerabilityID,
        severity=severity,
        resolution=resolution,
        offset=offset,
        includeDeleted=includeDeleted,
        includeRawOutput=includeRawOutput,
        timeFieldStrategy=timeFieldStrategy,
        sortBy=sortBy)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        query_parameters.update({"asset": asset})
    
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        query_parameters.update({"dataSource": dataSource})
    
    # Only send vulnerabilityID if the argument was provided, don't send null values
    if vulnerabilityID is not None:
        query_parameters.update({"vulnerabilityID": vulnerabilityID})
    
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        query_parameters.update({"severity": severity})
    
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        query_parameters.update({"resolution": resolution})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        query_parameters.update({"includeRawOutput": includeRawOutput})
    
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        query_parameters.update({"timeFieldStrategy": timeFieldStrategy})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def list_vulnerability_definitions(
    vulnerabilityID: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Basic Vulnerability Definition search. (PUBLIC)
    
    :param list vulnerabilityID: External Vulnerability ID
    :param list keywords: Keywords to search by. Will return matches in any field defined by the \'all\' KeywordFieldStrategy
    :param list sortBy: Field\(s\) to sort by \- refer to the search POST endpoint to see which fields are permitted
    :param int limit: Limit results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param str startTimestamp: Lower bound timestamp filter value
    :param str endTimestamp: Upper bound timestamp filter value
    :param int offset: Offset results. The sum of limit and offset must be \<\= 10\'000 when not streaming
    :param bool includeDeleted: Include deleted
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition".format(limit=limit,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        vulnerabilityID=vulnerabilityID,
        offset=offset,
        includeDeleted=includeDeleted,
        keywords=keywords,
        sortBy=sortBy)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    
    # Only send vulnerabilityID if the argument was provided, don't send null values
    if vulnerabilityID is not None:
        query_parameters.update({"vulnerabilityID": vulnerabilityID})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def reopen_vulnerability(
    id: str,
    comment: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Reopens a vulnerability, marking it as unresolved. (PUBLIC)
    
    :param str id: Vulnerability ID
    :param str comment: Comment describing why the vulnerability should be reopened
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that the reopened vulnerability is immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}/reopen".format(id=id,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def resolve_vulnerability(
    id: str,
    resolution: str = None,
    resolutionExpiryTimestamp: str = None,
    comment: str = None,
    forceIndex: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Resolves a vulnerability. (PUBLIC)
    
    :param str id: Vulnerability ID
    :param str resolution: Specify resolution reason.
    :param str resolutionExpiryTimestamp: When will the current resolution expire \(0 means no expiry\). Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time values. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ \(default 0\)
    :param str comment: Comment on why the vulnerability is resolved. \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that the resolved vulnerability is immediately searchable.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}/resolve".format(id=id,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send resolutionExpiryTimestamp if the argument was provided, don't send null values
    if resolutionExpiryTimestamp is not None:
        body.update({"resolutionExpiryTimestamp": resolutionExpiryTimestamp})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def search_vulnerabilities(
    exportFields: str = None,
    exportComponents: str = None,
    order: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    references: str = None,
    observationReferences: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    asset: str = None,
    assetGroup: str = None,
    vulnerabilityID: str = None,
    vulnerabilityDefinition: str = None,
    customer: str = None,
    severity: str = None,
    resolution: str = None,
    dataSource: str = None,
    minimumCvss: float = None,
    maximumCvss: float = None,
    component: dict = None,
    assetComponent: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    sortBy: str = None,
    indexStartTimestamp: str = None,
    indexEndTimestamp: str = None,
    includeRawOutput: bool = None,
    limit: int = 25,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search Vulnerabilities (PUBLIC)
    
    :param list exportFields: Select order of and fields to export.
    :param list exportComponents: Select which component values to include in the export.
    :param list order: 
    :param list keywords: Search for vulnerabilities by their definition keywords against definition text fields defined by a KeywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be queried for keywords \(defaults to all observation fields\) \(default all\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default any\)
    :param list references: Search for vulnerabilities by exact matches in their definition references
    :param list observationReferences: Search for vulnerabilities by exact matches in their references
    :param str startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param str endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp \(default lastSeenTimestamp\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list userFieldStrategy: Defines which user fields will be filtered with user ids or shortnames \(default all\)
    :param list user: Retrieve vulnerabilities by these users\, identified by their id or username
    :param list asset: Retrieve vulnerabilities detected on these assets by asset id or shortNames. As assets are customer specific we will resolve the assets for the customers provided in the criteria\, if any. If none are provided\, we attempt to use the customers the current user has access to.
    :param list assetGroup: Retrieve vulnerabilities detected on assets who are members or descendants of these groups identified by id or shortNames. As asset groups are customer specific we will resolve the groups for the customers provided in the criteria\, if any. If none are provided\, we attempt to use the customers the current user has access to.
    :param list vulnerabilityID: Retrieve vulnerabilities by their external ID e.g. CVE\-XXXX
    :param list vulnerabilityDefinition: Retrieve vulnerabilities by their vulnerability definition id or name
    :param list customer: Retrieve vulnerabilities by Customer id or name
    :param list severity: Retrieve vulnerabilities with these severities
    :param list resolution: Retrieve vulnerabilities with these resolutions
    :param list dataSource: Search for vulnerabilities detected and reported by these data sources\, identified by id or shortName
    :param float minimumCvss: Retrieve Vulnerabilities with at least this CVSS score
    :param float maximumCvss: Retrieve Vulnerabilities with at most this CVSS score
    :param list component: Search for Vulnerabilities with these components
    :param list assetComponent: Search for Vulnerabilities observed on Assets containing these components using AND search mode i.e. all criteria must match.\<br \/\>If you want different behaviour try using subcriteria
    :param list includeFlags: Explicitly retrieve Vulnerabilities that contain these flags
    :param list excludeFlags: Explicitly filter out Vulnerabilities that contain these flags
    :param list subCriteria: Set additional criteria that are applied with logical OR by default
    :param list sortBy: Field\(s\) by which to sort the results
    :param str indexStartTimestamp: Limit search to indices created on or after this timestamp. Must be in the range \[12 months ago \- today\].
    :param str indexEndTimestamp: Limit search to indices created on or before this timestamp. Must be in the range \[12 months ago \- today\].
    :param bool includeRawOutput: Whether to include raw output in the result objects \(default false\)
    :param int limit: Limit the results to the specified amount. If the sum of offset and limit is greater than 10\'000 the results will likely be incomplete as 10\'000 exceeds the search engine\'s maximum result window. \(default 25\)
    :param int offset: Skip specified amount of results. If the sum of offset and limit is greater than 10\'000 the results will likely be incomplete as 10\'000 exceeds the search engine\'s maximum result window. \(default 0\)
    :param bool includeDeleted: Whether to include deleted Vulnerabilities \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/search".format(exportFields=exportFields,
        exportComponents=exportComponents)
    headers = {}
    headers['content'] = None
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send order if the argument was provided, don't send null values
    if order is not None:
        body.update({"order": order})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send references if the argument was provided, don't send null values
    if references is not None:
        body.update({"references": references})
    # Only send observationReferences if the argument was provided, don't send null values
    if observationReferences is not None:
        body.update({"observationReferences": observationReferences})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send asset if the argument was provided, don't send null values
    if asset is not None:
        body.update({"asset": asset})
    # Only send assetGroup if the argument was provided, don't send null values
    if assetGroup is not None:
        body.update({"assetGroup": assetGroup})
    # Only send vulnerabilityID if the argument was provided, don't send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send vulnerabilityDefinition if the argument was provided, don't send null values
    if vulnerabilityDefinition is not None:
        body.update({"vulnerabilityDefinition": vulnerabilityDefinition})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send dataSource if the argument was provided, don't send null values
    if dataSource is not None:
        body.update({"dataSource": dataSource})
    # Only send minimumCvss if the argument was provided, don't send null values
    if minimumCvss is not None:
        body.update({"minimumCvss": minimumCvss})
    # Only send maximumCvss if the argument was provided, don't send null values
    if maximumCvss is not None:
        body.update({"maximumCvss": maximumCvss})
    # Only send component if the argument was provided, don't send null values
    if component is not None:
        body.update({"component": component})
    # Only send assetComponent if the argument was provided, don't send null values
    if assetComponent is not None:
        body.update({"assetComponent": assetComponent})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeRawOutput if the argument was provided, don't send null values
    if includeRawOutput is not None:
        body.update({"includeRawOutput": includeRawOutput})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})

    query_parameters = {}
    # Only send exportFields if the argument was provided, don't send null values
    if exportFields is not None:
        query_parameters.update({"exportFields": exportFields})
    
    # Only send exportComponents if the argument was provided, don't send null values
    if exportComponents is not None:
        query_parameters.update({"exportComponents": exportComponents})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def search_vulnerability_definitions(
    exportFields: str = None,
    order: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    vulnerabilitySource: str = None,
    vulnerabilityID: str = None,
    vulnerabilityDefinition: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    userFieldStrategy: str = None,
    user: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    severity: str = None,
    maximumCvss: float = None,
    minimumCvss: float = None,
    subCriteria: dict = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    includeDeleted: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search Vulnerability Definitions (PUBLIC)
    
    :param list exportFields: Select order of and fields to export.
    :param list order: 
    :param list keywords: Search for keywords against fields defined by a KeywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\) \(default all\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default any\)
    :param list vulnerabilitySource: Retrieve definitions by their source ID or shortname
    :param list vulnerabilityID: Retrieve definitions by their external ID e.g. CVE\-XXXX
    :param list vulnerabilityDefinition: Retrieve definitions by their internal db ID or vulnerabilityID
    :param str startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param str endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param list timeFieldStrategy: Defines which timestamps fields will be filtered with start\/endTimestamp \(default lastUpdatedTimestamp\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list userFieldStrategy: Defines which user fields to filter with the submitted user value\(s\) \(default all\)
    :param list user: Search for VulnerabilityDefinitions by associated user IDs or short names defined by the UserFieldStrategy
    :param list includeFlags: Explicitly search for VulnerabilityDefinitions that contain these flags
    :param list excludeFlags: Explicitly filter out VulnerabilityDefinitions that contain these flags
    :param list severity: Filter VulnerabilityDefinitions by Severity.
    :param float maximumCvss: Filter VulnerabilityDefinitions by CVSS lower or equal than.
    :param float minimumCvss: Filter VulnerabilityDefinitions by CVSS higher or equal than.
    :param list subCriteria: Set additional criteria that are applied with logical OR by default
    :param list sortBy: Field\(s\) by which to sort the results
    :param int limit: Limit the results to the specified amount \(default 25\)
    :param int offset: Skip specified amount of results \(default 0\)
    :param bool includeDeleted: Whether to include deleted Vulnerability Definitions \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition/search".format(exportFields=exportFields)
    headers = {}
    headers['content'] = None
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send order if the argument was provided, don't send null values
    if order is not None:
        body.update({"order": order})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send vulnerabilitySource if the argument was provided, don't send null values
    if vulnerabilitySource is not None:
        body.update({"vulnerabilitySource": vulnerabilitySource})
    # Only send vulnerabilityID if the argument was provided, don't send null values
    if vulnerabilityID is not None:
        body.update({"vulnerabilityID": vulnerabilityID})
    # Only send vulnerabilityDefinition if the argument was provided, don't send null values
    if vulnerabilityDefinition is not None:
        body.update({"vulnerabilityDefinition": vulnerabilityDefinition})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send maximumCvss if the argument was provided, don't send null values
    if maximumCvss is not None:
        body.update({"maximumCvss": maximumCvss})
    # Only send minimumCvss if the argument was provided, don't send null values
    if minimumCvss is not None:
        body.update({"minimumCvss": minimumCvss})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})

    query_parameters = {}
    # Only send exportFields if the argument was provided, don't send null values
    if exportFields is not None:
        query_parameters.update({"exportFields": exportFields})
    
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def search_vulnerability_sources(
    source: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    subCriteria: dict = None,
    sortBy: str = None,
    includeDeleted: bool = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search VulnerabilitySource with specified criteria (INTERNAL)
    
    :param list source: Restrict to specified Vulnerability source \(ID or short name\)
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\) \(default all\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default all\)
    :param str startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param str endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default lastUpdatedTimestamp\) \(default lastUpdatedTimestamp\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list subCriteria: Set additional criteria which are applied with logical OR by default
    :param list sortBy: Field\(s\) by which to sort the results
    :param bool includeDeleted: Whether include deleted results \(default false\)
    :param int limit: Limit maximum amount of results \(default 25\)
    :param int offset: Skip specified amount of results \(default 0\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/search".format()
    headers = {}

    body = body or {}
    # Only send source if the argument was provided, don't send null values
    if source is not None:
        body.update({"source": source})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def search_vulnerability_sources_simplified(
    keywords: str = None,
    keywordField: str = None,
    timeField: str = None,
    source: str = None,
    sortBy: str = None,
    limit: int = 25,
    keywordMatch: str = "all",
    startTimestamp: str = "0",
    endTimestamp: str = "0",
    timeMatch: str = "any",
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search VulnerabilitySources with specified query parameters (INTERNAL)
    
    :param list keywords: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list timeField: Set field strategy for time range search
    :param list source: Search by sources \(ID or short name\)
    :param list sortBy: Sort search result
    :param int limit: Maximum number of returned results
    :param str keywordMatch: Set match strategy for keyword search
    :param str startTimestamp: Start timestamp for time range search
    :param str endTimestamp: End timestamp for time range search
    :param str timeMatch: Set match strategy for time range search
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source".format(limit=limit,
        keywordMatch=keywordMatch,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        timeMatch=timeMatch,
        offset=offset,
        keywords=keywords,
        keywordField=keywordField,
        timeField=timeField,
        source=source,
        sortBy=sortBy)
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send keywordMatch if the argument was provided, don't send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    
    # Only send timeMatch if the argument was provided, don't send null values
    if timeMatch is not None:
        query_parameters.update({"timeMatch": timeMatch})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send keywordField if the argument was provided, don't send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    
    # Only send timeField if the argument was provided, don't send null values
    if timeField is not None:
        query_parameters.update({"timeField": timeField})
    
    # Only send source if the argument was provided, don't send null values
    if source is not None:
        query_parameters.update({"source": source})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def update_vulnerability(
    id: str,
    vulnerabilityDefinition: str = None,
    addComponents: dict = None,
    deleteComponents: str = None,
    cvss: float = None,
    severity: str = None,
    rawOutput: str = None,
    ttl: int = None,
    observationDescription: str = None,
    addObservationReferences: str = None,
    deleteObservationReferences: str = None,
    forceIndex: bool = None,
    updateLastSeen: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Updates an existing Vulnerability (PUBLIC)
    
    :param str id: vulnerability ID
    :param str vulnerabilityDefinition: Assign vulnerability definition. Only allowed when there was no vulnerability definition assigned.
    :param list addComponents: Specify components to be added with the vulnerability.
    :param list deleteComponents: Specify IDs of the components to be deleted from the vulnerability.
    :param float cvss: Update CVSS score of vulnerability \(range from 0 to 10\).
    :param str severity: Update severity level of vulnerability.
    :param str rawOutput: Update raw output from vulnerability scan. Will be sanitized as html.
    :param int ttl: Time to live duration of this vulnerability since last seen\, 0 means won\'t expire.
    :param str observationDescription: Description specific to this vulnerability. May contain customer specific data. Will be sanitized as HTML.
    :param list addObservationReferences: Add references specific to this vulnerability e.g. internal URLs. May contain customer specific data. Will be sanitized as HTML.
    :param list deleteObservationReferences: Delete references specific to this vulnerability. Will be sanitized as HTML first before checking against existing references.
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that changes to the vulnerability are immediately searchable.
    :param bool updateLastSeen: Temporary field added to make updating lastSeenTimestamp\/UserId easier. 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/{id}".format(id=id,
        forceIndex=forceIndex,
        updateLastSeen=updateLastSeen)
    headers = {}

    body = body or {}
    # Only send vulnerabilityDefinition if the argument was provided, don't send null values
    if vulnerabilityDefinition is not None:
        body.update({"vulnerabilityDefinition": vulnerabilityDefinition})
    # Only send addComponents if the argument was provided, don't send null values
    if addComponents is not None:
        body.update({"addComponents": addComponents})
    # Only send deleteComponents if the argument was provided, don't send null values
    if deleteComponents is not None:
        body.update({"deleteComponents": deleteComponents})
    # Only send cvss if the argument was provided, don't send null values
    if cvss is not None:
        body.update({"cvss": cvss})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send rawOutput if the argument was provided, don't send null values
    if rawOutput is not None:
        body.update({"rawOutput": rawOutput})
    # Only send ttl if the argument was provided, don't send null values
    if ttl is not None:
        body.update({"ttl": ttl})
    # Only send observationDescription if the argument was provided, don't send null values
    if observationDescription is not None:
        body.update({"observationDescription": observationDescription})
    # Only send addObservationReferences if the argument was provided, don't send null values
    if addObservationReferences is not None:
        body.update({"addObservationReferences": addObservationReferences})
    # Only send deleteObservationReferences if the argument was provided, don't send null values
    if deleteObservationReferences is not None:
        body.update({"deleteObservationReferences": deleteObservationReferences})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    # Only send updateLastSeen if the argument was provided, don't send null values
    if updateLastSeen is not None:
        query_parameters.update({"updateLastSeen": updateLastSeen})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def update_vulnerability_definition(
    idOrVulnerabilityID: str,
    name: str = None,
    description: str = None,
    solution: str = None,
    conclusion: str = None,
    addReferences: str = None,
    deleteReferences: str = None,
    exploitAvailable: bool = None,
    cvss: float = None,
    severity: str = None,
    forceIndex: bool = None,
    exploitAvailableTimestamp: int = None,
    updateObservations: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Updates an existing Vulnerability definition, also require to have read & write permission of vulnerability source that the definition is belonging to. (INTERNAL)
    
    :param str idOrVulnerabilityID: Vulnerability definition ID or identifier of vulnerability
    :param str name: Update name of the vulnerability definition. Will be sanitized as text.
    :param str description: Update description of the vulnerability definition. Will be sanitized as html.
    :param str solution: Update how to fix the vulnerability. Will be sanitized as html.
    :param str conclusion: Update short summary of the vulnerability. Will be sanitized as html.
    :param list addReferences: Add references to the vulnerability definition \(e.g. CVE number\). Will be sanitized as html.
    :param list deleteReferences: Delete references from the vulnerability definition. Will be sanitized as html first before check against existing references.
    :param bool exploitAvailable: Update whether an exploit is available for the vulnerability.
    :param float cvss: CVSS score of vulnerability \(range from 0 to 10\).
    :param str severity: Severity level of vulnerability. If not provided\, then severity will be calculated based on CVSS value.
    :param bool forceIndex: Whether to force an Elasticsearch index refresh such that changes to the VulnerabilityDefinition are immediately searchable.
    :param int exploitAvailableTimestamp: Set or update the timestamp when the exploit became available. Setting this value also expects having exploitAvailable as \'true\' or setting it with this request. If it hasn\'t been set before\, then setting\/leaving it to 0 will use current timestamp. \(default 0\)
    :param bool updateObservations: If true this will trigger updating all active \(non\-deleted with resolution status\: unresolved\,
accepted or temp\_accepted\) Observations thus overwriting their current Severity\/CVSS values. Unless
the values were previously overwritten manually. \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/definition/{idOrVulnerabilityID}".format(idOrVulnerabilityID=idOrVulnerabilityID,
        forceIndex=forceIndex)
    headers = {}

    body = body or {}
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send solution if the argument was provided, don't send null values
    if solution is not None:
        body.update({"solution": solution})
    # Only send conclusion if the argument was provided, don't send null values
    if conclusion is not None:
        body.update({"conclusion": conclusion})
    # Only send addReferences if the argument was provided, don't send null values
    if addReferences is not None:
        body.update({"addReferences": addReferences})
    # Only send deleteReferences if the argument was provided, don't send null values
    if deleteReferences is not None:
        body.update({"deleteReferences": deleteReferences})
    # Only send exploitAvailable if the argument was provided, don't send null values
    if exploitAvailable is not None:
        body.update({"exploitAvailable": exploitAvailable})
    # Only send exploitAvailableTimestamp if the argument was provided, don't send null values
    if exploitAvailableTimestamp is not None:
        body.update({"exploitAvailableTimestamp": exploitAvailableTimestamp})
    # Only send cvss if the argument was provided, don't send null values
    if cvss is not None:
        body.update({"cvss": cvss})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send updateObservations if the argument was provided, don't send null values
    if updateObservations is not None:
        body.update({"updateObservations": updateObservations})

    query_parameters = {}
    # Only send forceIndex if the argument was provided, don't send null values
    if forceIndex is not None:
        query_parameters.update({"forceIndex": forceIndex})
    
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("assets", "v2", "vulnerability"),
    module=argus_cli_module
)
def update_vulnerability_source(
    source: str,
    shortName: str = None,
    name: str = None,
    readPermission: str = None,
    writePermission: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Updates an existing VulnerabilitySource (INTERNAL)
    
    :param str source: VulnerabilitySource ID or short name
    :param str shortName: Update short name of vulnerability source \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: Update name of vulnerability source \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str readPermission: Update the permission required to allow read access of source \& vulnerability definition belong to the source \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str writePermission: Update the permission required to allow write access \(create\/update\/delete\) of source \& vulnerability definition belong to the source \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/assets/v2/vulnerability/source/{source}".format(source=source)
    headers = {}

    body = body or {}
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send readPermission if the argument was provided, don't send null values
    if readPermission is not None:
        body.update({"readPermission": readPermission})
    # Only send writePermission if the argument was provided, don't send null values
    if writePermission is not None:
        body.update({"writePermission": writePermission})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
