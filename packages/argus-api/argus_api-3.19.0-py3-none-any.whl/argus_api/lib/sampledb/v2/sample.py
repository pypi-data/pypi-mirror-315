"""Autogenerated API"""
from argus_api.session import get_session as _get_session
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession
from requests import Response


def add_analysis(
    sha256: str,
    analysisResult: dict = None,
    customer: str = None,
    userAgent: dict = None,
    tlp: str = None,
    acl: str = None,
    profile: str = None,
    triggeredDetections: dict = None,
    possibleDetections: int = None,
    verdictStatusOverride: str = None,
    tags: dict = None,
    executedWithInternetAccess: bool = None,
    analysisScore: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Adds an analysis to a sample (DEV)
    
    :param str sha256: Sha256 of sample to add analysis result to
    :param dict analysisResult: The result of the analysis as a JSON object
    :param str customer: The shortname or ID of customer the analysis belongs to
    :param dict userAgent: The user agent used in add requests
    :param str tlp: The TLP level of the analysis
    :param list acl: The shortname or IDs of users or groups that will be given explicit access
    :param str profile: The execution profile of the worker \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param list triggeredDetections: The triggered detections for this analysis
    :param int possibleDetections: The maximum number of possible detections
    :param str verdictStatusOverride: Can be set to signify that the worker posting the analysis result is 100\% certain that the sample is malicious or benign. The verdict engine will consider this field and use as an override for the verdict status. If there are contradicting overrides\, the verdict engine will set the verdict status to \'unknown\' instead
    :param list tags: The tags for the analysis
    :param bool executedWithInternetAccess: A boolean to indicate whether the analysis have been executed with internet access or not
    :param int analysisScore: The score for this analysis. The value is a score from \-1 to 100 and is an indication of how certain the analyzer is that the sample is malicious. A value of \-1 indicates no findings.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send analysisResult if the argument was provided, don't send null values
    if analysisResult is not None:
        body.update({"analysisResult": analysisResult})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send acl if the argument was provided, don't send null values
    if acl is not None:
        body.update({"acl": acl})
    # Only send profile if the argument was provided, don't send null values
    if profile is not None:
        body.update({"profile": profile})
    # Only send triggeredDetections if the argument was provided, don't send null values
    if triggeredDetections is not None:
        body.update({"triggeredDetections": triggeredDetections})
    # Only send possibleDetections if the argument was provided, don't send null values
    if possibleDetections is not None:
        body.update({"possibleDetections": possibleDetections})
    # Only send verdictStatusOverride if the argument was provided, don't send null values
    if verdictStatusOverride is not None:
        body.update({"verdictStatusOverride": verdictStatusOverride})
    # Only send tags if the argument was provided, don't send null values
    if tags is not None:
        body.update({"tags": tags})
    # Only send executedWithInternetAccess if the argument was provided, don't send null values
    if executedWithInternetAccess is not None:
        body.update({"executedWithInternetAccess": executedWithInternetAccess})
    # Only send analysisScore if the argument was provided, don't send null values
    if analysisScore is not None:
        body.update({"analysisScore": analysisScore})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_evidence(
    sha256: str,
    analysisID: str,
    evidence: str = None,
    mimeType: str = None,
    fileName: str = None,
    internal: bool = None,
    potentiallyMalicious: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Adds evidence to an analysis (DEV)
    
    :param str sha256: Sha256 of sample that holds the analysis
    :param str analysisID: UUID of analysis to add evidence to
    :param str evidence: Base64 encoded evidence
    :param str mimeType: The mimeType of the evidence
    :param str fileName: The file name given to the evidence
    :param bool internal: Whether the Evidence should be available to external users or not. By default this is false which means that external users have access. Set to true if only internal
    :param bool potentiallyMalicious: Whether the Evidence is malicious or not
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence".format(sha256=sha256,
        analysisID=analysisID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send evidence if the argument was provided, don't send null values
    if evidence is not None:
        body.update({"evidence": evidence})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send fileName if the argument was provided, don't send null values
    if fileName is not None:
        body.update({"fileName": fileName})
    # Only send internal if the argument was provided, don't send null values
    if internal is not None:
        body.update({"internal": internal})
    # Only send potentiallyMalicious if the argument was provided, don't send null values
    if potentiallyMalicious is not None:
        body.update({"potentiallyMalicious": potentiallyMalicious})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_link(
    sha256: str,
    customer: str = None,
    userAgent: dict = None,
    tlp: str = None,
    acl: str = None,
    type: str = None,
    reference: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Adds an link to a sample (DEV)
    
    :param str sha256: Sha256 of sample to add link to
    :param str customer: The shortname or ID of customer the link belongs to
    :param dict userAgent: The user agent used in add requests
    :param str tlp: The TLP level of the link
    :param list acl: The shortname or IDs of users or groups that will be given explicit access
    :param str type: The nature of the link between the two samples
    :param str reference: The ID of the sample the link references
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send acl if the argument was provided, don't send null values
    if acl is not None:
        body.update({"acl": acl})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send reference if the argument was provided, don't send null values
    if reference is not None:
        body.update({"reference": reference})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_sample(
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Upload a new sample file (INTERNAL)
    
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_static_fact(
    sha256: str,
    key: str = None,
    value: str = None,
    userAgent: dict = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Endpoint for registering a new static fact (DEV)
    
    :param str sha256: Sha256 of the sample to add the static fact to
    :param str key: The static fact key
    :param str value: The static fact value
    :param dict userAgent: The user agent used in add requests
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/fact".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        body.update({"key": key})
    # Only send value if the argument was provided, don't send null values
    if value is not None:
        body.update({"value": value})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_submission(
    sha256: str,
    fileName: str = None,
    customer: str = None,
    observedTimestamp: int = None,
    mimeType: str = None,
    metaData: dict = None,
    tlp: str = None,
    acl: str = None,
    userAgent: dict = None,
    challengeToken: dict = None,
    retention: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Add a new sample submission. Requires a challenge token. A challenge token is a solution to a challenge generated by the challenge endpoint (INTERNAL)
    
    :param str sha256: Sha256 of sample to add submission for
    :param str fileName: The filename of the sample
    :param str customer: The shortname or ID of customer the submission belongs to. Default value is the currernt user\'s customer
    :param int observedTimestamp: The timestamp of when the sample was observed. Defaults to the current time
    :param str mimeType: The sample mime type \(default application\/octet\-stream\)
    :param dict metaData: Meta data about the sample \(default \{\}\)
    :param str tlp: TLP color of the submission. Submissions with TLP Red will be rejected as Sample Service does not support submissions with TLP redDefaults to amber \(default amber\)
    :param list acl: List of user IDs or shortnames that are given explicit access to the submission
    :param dict userAgent: The user agent used in add requests
    :param dict challengeToken: Request containing the answer to a challenge
    :param str retention: Only retain the submission until the specified time. The submission will be deleted after this time\, unless the sample is malicious. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/submission".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send fileName if the argument was provided, don't send null values
    if fileName is not None:
        body.update({"fileName": fileName})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send observedTimestamp if the argument was provided, don't send null values
    if observedTimestamp is not None:
        body.update({"observedTimestamp": observedTimestamp})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send metaData if the argument was provided, don't send null values
    if metaData is not None:
        body.update({"metaData": metaData})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send acl if the argument was provided, don't send null values
    if acl is not None:
        body.update({"acl": acl})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})
    # Only send challengeToken if the argument was provided, don't send null values
    if challengeToken is not None:
        body.update({"challengeToken": challengeToken})
    # Only send retention if the argument was provided, don't send null values
    if retention is not None:
        body.update({"retention": retention})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def add_verdict(
    sha256: str,
    comment: str = None,
    statusOverride: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Manually add a verdict to a sample (DEV)
    
    :param str sha256: 
    :param str comment: A comment providing information or context to the verdict \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str statusOverride: Field for manually overriding the status of the sample. If this field is set\, this overrides the future event generations and verdicts for this sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/verdict".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send statusOverride if the argument was provided, don't send null values
    if statusOverride is not None:
        body.update({"statusOverride": statusOverride})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def advanced_search(
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    sha256: str = None,
    sha512: str = None,
    sha1: str = None,
    md5: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    classification: dict = None,
    submission: dict = None,
    user: str = None,
    userFieldStrategy: str = None,
    userMatchStrategy: str = None,
    customer: str = None,
    tlp: str = None,
    analysis: dict = None,
    link: dict = None,
    verdict: dict = None,
    subCriteria: dict = None,
    fact: dict = None,
    indexStartTimestamp: str = None,
    indexEndTimestamp: str = None,
    sortBy: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    offset: int = None,
    limit: int = 25,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Advanced search for samples (DEV)
    
    :param list keywords: A set of keywords to search for
    :param list keywordFieldStrategy: Restrict to search only in the selected keyword fields
    :param str keywordMatchStrategy: Whether all or any \(default\) of the fields must match one or more of the keywords
    :param list sha256: Restrict to search only in the selected sample sha256 IDs
    :param list sha512: Restrict to search only in samples with these sha512 hashes
    :param list sha1: Restrict to search only in samples with these sha1 hashes
    :param list md5: Restrict to search only in samples with these md5 hashes
    :param list timeFieldStrategy: Restrict the search by timestamp \(indicated by startTimestamp and endTimestamp\) to these fields. Default is \'all\'
    :param str timeMatchStrategy: Whether all or any \(default\) of the fields must match the time period \(indicated by startTimestamp and endTimestamp\)
    :param list classification: Search criteria for classifications
    :param list submission: Search criteria for submissions
    :param list user: Restrict the search to samples containing resources \(indicated by userFieldStrategy\) submitted by users
    :param list userFieldStrategy: Define what resources to apply the user criteria to. Defaults to \'all\'
    :param str userMatchStrategy:  Whether all or any \(default\) of the fields must match the user criteria
    :param list customer: Restrict the search to samples containing submissions owned by certain customers
    :param list tlp: Restrict the search to samples where the sample contains one or more submission\, analysis\, or link with any of the defined TLPs
    :param list analysis: Search criteria for analysis
    :param list link: Search criteria for links
    :param list verdict: Search criteria for verdicts
    :param list subCriteria: Search sub criteria
    :param list fact: Search criteria for static facts
    :param str indexStartTimestamp: Restrict search to data after this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details \(default now \- 1 month\)
    :param str indexEndTimestamp: Restrict search to data before this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details \(default now\)
    :param list sortBy: Specify sort ordering for returned samples \(default \-sampleCreatedTimestamp\)
    :param str startTimestamp: Restrict the search to resources \(indicated by timeFieldStrategy\) timestamped after this timestamp. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param str endTimestamp: Restrict the search to resources \(indicated by timeFieldStrategy\) timestamped before this timestamp.Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param int offset: Skip a number of search results \(default 0\)
    :param int limit: Limit the number of search results \(default 25\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/search".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send sha256 if the argument was provided, don't send null values
    if sha256 is not None:
        body.update({"sha256": sha256})
    # Only send sha512 if the argument was provided, don't send null values
    if sha512 is not None:
        body.update({"sha512": sha512})
    # Only send sha1 if the argument was provided, don't send null values
    if sha1 is not None:
        body.update({"sha1": sha1})
    # Only send md5 if the argument was provided, don't send null values
    if md5 is not None:
        body.update({"md5": md5})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send classification if the argument was provided, don't send null values
    if classification is not None:
        body.update({"classification": classification})
    # Only send submission if the argument was provided, don't send null values
    if submission is not None:
        body.update({"submission": submission})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userMatchStrategy if the argument was provided, don't send null values
    if userMatchStrategy is not None:
        body.update({"userMatchStrategy": userMatchStrategy})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send analysis if the argument was provided, don't send null values
    if analysis is not None:
        body.update({"analysis": analysis})
    # Only send link if the argument was provided, don't send null values
    if link is not None:
        body.update({"link": link})
    # Only send verdict if the argument was provided, don't send null values
    if verdict is not None:
        body.update({"verdict": verdict})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send fact if the argument was provided, don't send null values
    if fact is not None:
        body.update({"fact": fact})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def delete_sample(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Delete a sample and all of its resources including submissions, analyses, links, classifications, verdicts, and jobs async. A minimal metadata record will be left behind (DEV)
    
    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def download_raw_sample(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> Response:
    """Download a raw sample file. Warning: The file returned may be malicious. Take caution (INTERNAL)
    
    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object
    
    """

    route = "/sampledb/v2/sample/{sha256}/raw".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}
    headers['content'] = None

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response
    


def download_safe_sample(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> Response:
    """Download a zipped sample file, password protected with the password "infected". Warning: The zipped file may be malicious. Take caution (INTERNAL)
    
    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object
    
    """

    route = "/sampledb/v2/sample/{sha256}/safe".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}
    headers['content'] = None

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response
    


def get_analysis(
    sha256: str,
    analysisID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetches the analysis for the sample with the given ID (DEV)
    
    :param str sha256: Sha256 of sample to fetch the analysis from
    :param str analysisID: ID of the analysis to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}".format(sha256=sha256,
        analysisID=analysisID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_analysis_summary(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Get a summary of all analysis results for a given sample (DEV)
    
    :param str sha256: Sha256 of sample to fetch the analysis summary from
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/summary".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_evidence(
    sha256: str,
    analysisID: str,
    evidenceID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetches the evidence metadata for the analysis for the sample with the given ID (DEV)
    
    :param str sha256: Sha256 of sample to fetch the analysis from
    :param str analysisID: ID of the analysis the evidence is for
    :param str evidenceID: ID of the evidence to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence/{evidenceID}".format(sha256=sha256,
        analysisID=analysisID,
        evidenceID=evidenceID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_evidence_data(
    sha256: str,
    analysisID: str,
    evidenceID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> Response:
    """Returns the evidence file. (DEV)
    
    :param str sha256: Sha256 of sample the analysis is from
    :param str analysisID: The ID of the analysis you want to fetch evidence from
    :param str evidenceID: The ID of the evidence data you want to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object
    
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence/{evidenceID}/download".format(sha256=sha256,
        analysisID=analysisID,
        evidenceID=evidenceID)

    session = api_session or _get_session()
    headers = {}
    headers['content'] = None

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response
    


def get_link(
    sha256: str,
    linkID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetches the link for the sample with the given ID (DEV)
    
    :param str sha256: Sha256 of sample to fetch the link from
    :param str linkID: ID of the link to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link/{linkID}".format(sha256=sha256,
        linkID=linkID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_link_summary(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Get a summary of up to 1000 links for a given sample (DEV)
    
    :param str sha256: Sha256 of the sample to fetch the links summary from
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link/summary".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_sample_meta_data(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetch meta data about a sample file (INTERNAL)
    
    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_submission(
    sha256: str,
    submissionID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetch a submission for the sample with the given ID (INTERNAL)
    
    :param str sha256: Sha256 of the sample the submission belongs to
    :param str submissionID: The ID of the submission to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises TheSampleCouldNotBeFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/submission/{submissionID}".format(sha256=sha256,
        submissionID=submissionID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_upload_challenge(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Generate a new challenge for a sample. The solution of the challenge is SHA256(x) where x is 'length' bytes of data starting from 'offset' bytes into the sample file (INTERNAL)
    
    :param str sha256: Sha256 of sample to get submission challenge for
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises TheSampleCouldNotBeFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises TheSampleFileIsTooSmall.UploadTheFullSampleAndUseTheChallengeTokenReturnedInThatResponseAsProofException: on 422
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/challenge".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_analysis(
    sha256: str,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Lists the analysis for the sample (DEV)
    
    :param str sha256: Sha256 of sample to fetch the analysis from
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis".format(limit=limit,
        sha256=sha256,
        offset=offset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_classifications(
    sha256: str,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetch all classifications for a sample (DEV)
    
    :param str sha256: Sha256 of the sample
    :param list sortBy: The field on which to sort the classifications. Prefix with \'\-\' to sort descending
    :param int limit: The maximum number of classifications to return
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/classification".format(limit=limit,
        sha256=sha256,
        offset=offset,
        sortBy=sortBy)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_evidence(
    sha256: str,
    analysisID: str,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Lists the evidence metadata for the analysis (DEV)
    
    :param str sha256: Sha256 of sample the analysis is from
    :param str analysisID: The ID of the analysis you want to list evidence from
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence".format(limit=limit,
        sha256=sha256,
        analysisID=analysisID,
        offset=offset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_links(
    sha256: str,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Lists the links for the sample (DEV)
    
    :param str sha256: Sha256 of sample to fetch the link from
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link".format(limit=limit,
        sha256=sha256,
        offset=offset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_static_fact(
    sha256: str,
    sortBy: str = None,
    key: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Endpoint for listing the static facts for a sample (DEV)
    
    :param str sha256: Sha256 of the sample the static facts are for
    :param list sortBy: Sort order of returned results. Prefix with \'\-\' to sort descending
    :param list key: A set of keys to search for
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/fact".format(limit=limit,
        sha256=sha256,
        offset=offset,
        sortBy=sortBy,
        key=key)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        query_parameters.update({"key": key})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_submissions(
    sha256: str,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """List all the submissions for a sample (INTERNAL)
    
    :param str sha256: Sha256 of the sample to fetch submissions for
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises TheSampleCouldNotBeFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/submission".format(limit=limit,
        sha256=sha256,
        offset=offset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_verdicts(
    sha256: str,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """List all verdicts for a sample (DEV)
    
    :param str sha256: Sha256 of the sample to fetch verdicts for
    :param list sortBy: The field on which to sort the verdicts. Prefix any of the allowed values with \'\-\' to sort descending
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/verdict".format(limit=limit,
        sha256=sha256,
        offset=offset,
        sortBy=sortBy)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def reanalyse_sample(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Triggering reanalysis of a Sample without having to upload a new submission. (DEV)
    
    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/reanalyse".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def reclassify_sample(
    sha256: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Manually reclassify an existing sample (DEV)
    
    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/reclassify".format(sha256=sha256)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def simple_search(
    sortBy: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    limit: int = 25,
    indexStartTimestamp: str = "now - 1 month",
    indexEndTimestamp: str = "now",
    keywordMatchStrategy: str = "any",
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Simple search for samples (DEV)
    
    :param list sortBy: The fields to sort the results by. Prefix with \'\-\' to sort descending
    :param list keywords: A set of keywords to search for
    :param list keywordFieldStrategy: Which fields to search on
    :param int limit: Maximum number of returned results
    :param str indexStartTimestamp: Restrict search to data after this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param str indexEndTimestamp: Restrict search to data before this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param str keywordMatchStrategy: Whether the keywords must match all or any of the keyword fields
    :param int offset: Number of results to skip
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample".format(limit=limit,
        indexStartTimestamp=indexStartTimestamp,
        indexEndTimestamp=indexEndTimestamp,
        keywordMatchStrategy=keywordMatchStrategy,
        offset=offset,
        sortBy=sortBy,
        keywords=keywords,
        keywordFieldStrategy=keywordFieldStrategy)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        query_parameters.update({"indexStartTimestamp": indexStartTimestamp})
    
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        query_parameters.update({"indexEndTimestamp": indexEndTimestamp})
    
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        query_parameters.update({"keywordMatchStrategy": keywordMatchStrategy})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        query_parameters.update({"keywordFieldStrategy": keywordFieldStrategy})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def upload_evidence(
    sha256: str,
    analysisID: str,
    fileName: str,
    internal: bool = None,
    potentiallyMalicious: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Uploads an evidence file (DEV)
    
    :param str sha256: Sha256 of sample that holds the analysis
    :param str analysisID: UUID of analysis to add evidence to
    :param str fileName: The name of the evidence file to upload
    :param bool internal: If the evidence is internal
    :param bool potentiallyMalicious: If the evidence is potentially malicious
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence/{fileName}".format(sha256=sha256,
        analysisID=analysisID,
        fileName=fileName,
        internal=internal,
        potentiallyMalicious=potentiallyMalicious)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send internal if the argument was provided, don't send null values
    if internal is not None:
        query_parameters.update({"internal": internal})
    
    # Only send potentiallyMalicious if the argument was provided, don't send null values
    if potentiallyMalicious is not None:
        query_parameters.update({"potentiallyMalicious": potentiallyMalicious})
    

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
