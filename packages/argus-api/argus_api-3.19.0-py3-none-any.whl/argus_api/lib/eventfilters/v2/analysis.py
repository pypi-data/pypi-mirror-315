"""Autogenerated API"""
from argus_api.session import get_session as _get_session
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession


def add_analysis_filter(
    shortName: str = None,
    name: str = None,
    description: str = None,
    customer: str = None,
    filters: dict = None,
    actions: dict = None,
    labels: str = None,
    authoredByUser: str = None,
    commitID: str = None,
    enabled: bool = None,
    externallyManaged: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Adds an analysis filter (INTERNAL)
    
    :param str shortName: Optional short name of the filter. \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: The name of the filter
    :param str description: A description of the filter
    :param str customer: The shortname or ID of the customer the filter belongs to. To create a global filter set the value to \'0\'
    :param dict filters: 
    :param dict actions: 
    :param list labels: A set of labels which can be used to categorize the filter
    :param str authoredByUser: The user that submitted the Filter\-as\-Code change. Should be used with externallyManaged\=true.
    :param str commitID: The commit ID of the Filter\-as\-Code change. Should be used with externallyManaged\=true.
    :param bool enabled: Whether or not the filter is enabled \(default false\)
    :param bool externallyManaged: Whether or not the filter code is externally managed \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send labels if the argument was provided, don't send null values
    if labels is not None:
        body.update({"labels": labels})
    # Only send enabled if the argument was provided, don't send null values
    if enabled is not None:
        body.update({"enabled": enabled})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})
    # Only send authoredByUser if the argument was provided, don't send null values
    if authoredByUser is not None:
        body.update({"authoredByUser": authoredByUser})
    # Only send commitID if the argument was provided, don't send null values
    if commitID is not None:
        body.update({"commitID": commitID})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def delete_analysis_filter(
    idOrShortName: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Deletes an analysis filter (INTERNAL)
    
    :param str idOrShortName: ID or short name of filter to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{idOrShortName}".format(idOrShortName=idOrShortName)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def disable_analysis_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Disables an analysis filter (INTERNAL)
    
    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{id}/disable".format(id=id)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def disable_analysis_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Disables an analysis filter on instance (INTERNAL)
    
    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{filterID}/{instanceID}/disable".format(filterID=filterID,
        instanceID=instanceID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def duplicate_analysis_filter(
    id: int,
    customer: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Duplicates an analysis filter (INTERNAL)
    
    :param int id: ID of filter
    :param str customer: The customer the duplicate should belong to \(id or shortname\). Use \'0\' to create a global filter\, If this field is not set the default is using the same customer as the original filter.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{id}/duplicate".format(id=id)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def enable_analysis_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Enables an analysis filter (INTERNAL)
    
    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{id}/enable".format(id=id)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def enable_analysis_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Enables an analysis filter on instance (INTERNAL)
    
    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{filterID}/{instanceID}/enable".format(filterID=filterID,
        instanceID=instanceID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_analysis_filter(
    idOrShortName: str,
    revision: int = None,
    includeCode: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Gets an analysis filter (INTERNAL)
    
    :param str idOrShortName: ID or short name of filter
    :param int revision: The expected revision of the filter
    :param bool includeCode: Whether to include code in AnnotationFilter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{idOrShortName}".format(idOrShortName=idOrShortName,
        includeCode=includeCode,
        revision=revision)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})
    
    # Only send revision if the argument was provided, don't send null values
    if revision is not None:
        query_parameters.update({"revision": revision})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_analysis_filter_revisions(
    id: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Gets a analysis filters earlier revisions (INTERNAL)
    
    :param int id: ID of filter to fetch revisions for
    :param int limit: The max amount of revisions to return
    :param int offset: The number of revisions to skip before returning
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{id}/revisions".format(limit=limit,
        id=id,
        offset=offset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_analysis_filter_status(
    id: int,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Gets the status of a analysis filters instance statuses (INTERNAL)
    
    :param int id: ID of filter
    :param int limit: Limit result
    :param int offset: Offset result
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{id}/status".format(limit=limit,
        id=id,
        offset=offset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_analysis_filter(
    keywords: str = None,
    keywordFieldStrategy: str = None,
    timestampFieldStrategy: str = None,
    sortBy: str = None,
    keywordMatchStrategy: str = "all",
    timestampMatchStrategy: str = "all",
    limit: int = 25,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeCode: bool = None,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Simple search for analysis filters (INTERNAL)
    
    :param list keywords: Search by keywords
    :param list keywordFieldStrategy: Set field strategy for keyword search
    :param list timestampFieldStrategy: Set field strategy for timestamp filtering
    :param list sortBy: Field to sort by
    :param str keywordMatchStrategy: Set match strategy for keyword search
    :param str timestampMatchStrategy: Set match strategy for timestamp filtering
    :param int limit: Limit result
    :param int startTimestamp: Lower bound timestamp filter value
    :param int endTimestamp: Upper bound timestamp filter value
    :param bool includeCode: Whether to include code in results
    :param int offset: Offset result
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis".format(keywordMatchStrategy=keywordMatchStrategy,
        timestampMatchStrategy=timestampMatchStrategy,
        limit=limit,
        keywords=keywords,
        keywordFieldStrategy=keywordFieldStrategy,
        timestampFieldStrategy=timestampFieldStrategy,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        includeCode=includeCode,
        sortBy=sortBy,
        offset=offset)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        query_parameters.update({"keywordMatchStrategy": keywordMatchStrategy})
    
    # Only send timestampMatchStrategy if the argument was provided, don't send null values
    if timestampMatchStrategy is not None:
        query_parameters.update({"timestampMatchStrategy": timestampMatchStrategy})
    
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        query_parameters.update({"keywordFieldStrategy": keywordFieldStrategy})
    
    # Only send timestampFieldStrategy if the argument was provided, don't send null values
    if timestampFieldStrategy is not None:
        query_parameters.update({"timestampFieldStrategy": timestampFieldStrategy})
    
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})
    
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def revert_analysis_filter(
    filterID: int,
    revisionID: int = None,
    comment: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Reverts an analysis filter to a previous revision (INTERNAL)
    
    :param int filterID: ID of the filter to revert\( must be the current version of a filter\)
    :param int revisionID: The ID of the filter to revert to. Must be a revision of the filter to revert
    :param str comment: A comment describing why the filter was reverted
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{filterID}/revert".format(filterID=filterID)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send revisionID if the argument was provided, don't send null values
    if revisionID is not None:
        body.update({"revisionID": revisionID})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def revive_analysis_filter(
    id: int,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Revives a deleted a analysis filter (INTERNAL)
    
    :param int id: ID of filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{id}/revive".format(id=id)

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_analysis_filter(
    sortBy: str = None,
    keywords: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    filterID: int = None,
    customer: str = None,
    user: str = None,
    userFieldStrategy: str = None,
    userMatchStrategy: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    subCriteria: dict = None,
    includeAscendingCustomers: bool = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    includeDeleted: bool = None,
    includeCode: bool = None,
    includeDescendingCustomers: bool = True,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Searches for analysis filters (INTERNAL)
    
    :param list sortBy: 
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\) \(default all\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default all\)
    :param list filterID: Limit search to filters with the given IDs
    :param list customer: Limit search to filters with the given customers\, identified by id or shortname
    :param list user: Search using users identified by id or shortname. If given a group\, we will resolve all members of the group recursively
    :param list userFieldStrategy: Defines which fields will be searched by user \(default all supported fields\) \(default all\)
    :param str userMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\) \(default all\)
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default lastUpdated\) \(default lastUpdated\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\) \(default any\)
    :param list includeFlags: Flags to include
    :param list excludeFlags: Flags to exclude
    :param list subCriteria: The set of sub criteria to add to the search
    :param bool includeAscendingCustomers: When limiting filters by customer\, include filters of ascending customers \(default is false\)
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\) \(default 0\)
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\) \(default 0\)
    :param bool includeDeleted: Set to true to include deleted filters \(excluded by default\). \(default false\)
    :param bool includeCode: Whether or not to include code in the result object. The code is only returned if set to true \(default false\)
    :param bool includeDescendingCustomers: When limiting filters by customer\, include filters of descending customers \(default is true\) \(default true\)
    :param int limit: Limit maximum amount of results \(default 25\)
    :param int offset: Skip specified amount of results \(default 0\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/search".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userMatchStrategy if the argument was provided, don't send null values
    if userMatchStrategy is not None:
        body.update({"userMatchStrategy": userMatchStrategy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        body.update({"includeCode": includeCode})
    # Only send includeDescendingCustomers if the argument was provided, don't send null values
    if includeDescendingCustomers is not None:
        body.update({"includeDescendingCustomers": includeDescendingCustomers})
    # Only send includeAscendingCustomers if the argument was provided, don't send null values
    if includeAscendingCustomers is not None:
        body.update({"includeAscendingCustomers": includeAscendingCustomers})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_analysis_filter_status(
    filterID: int = None,
    filterStatus: str = None,
    loggingStatus: str = None,
    customer: str = None,
    limit: int = None,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Search for analysis filters instance statuses for filters that match the criteria (INTERNAL)
    
    :param list filterID: 
    :param list filterStatus: 
    :param list loggingStatus: 
    :param list customer: 
    :param int limit: 
    :param int offset: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/status/search".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send filterStatus if the argument was provided, don't send null values
    if filterStatus is not None:
        body.update({"filterStatus": filterStatus})
    # Only send loggingStatus if the argument was provided, don't send null values
    if loggingStatus is not None:
        body.update({"loggingStatus": loggingStatus})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def set_analysis_filter_log_level(
    id: int,
    logLevel: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Sets the log level of a analysis filter (INTERNAL)
    
    :param int id: ID of filter
    :param str logLevel: The new log level of the filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{id}/logging".format(id=id)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send logLevel if the argument was provided, don't send null values
    if logLevel is not None:
        body.update({"logLevel": logLevel})

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_analysis_filter(
    idOrShortName: str,
    shortName: str = None,
    name: str = None,
    description: str = None,
    filters: dict = None,
    actions: dict = None,
    removeLabels: str = None,
    addLabels: str = None,
    setLabels: str = None,
    comment: str = None,
    externallyManaged: bool = None,
    authoredByUser: str = None,
    commitID: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Updates an analysis filter (INTERNAL)
    
    :param str idOrShortName: ID or short name of filter
    :param str shortName: Optional short name of the filter \(no change if left blank\) \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param str name: The name of the filter
    :param str description: A description of the filter
    :param dict filters: 
    :param dict actions: 
    :param list removeLabels: A set of labels to remove from the filter.  Will be applied before adding labels and ignore filters that are not present. Will throw an exception if used in conjunction with setLabels 
    :param list addLabels: A set of labels to add to the filter.  Will be applied after removing labels. Will throw an exception if used in conjunction with setLabels 
    :param list setLabels: Replace the current set of labels with these. Will throw an exception if used in conjunction with addLabels or removeLabels
    :param str comment: A comment describing why the filter was updated
    :param bool externallyManaged: Whether or not the filter code is externally managed
    :param str authoredByUser: The user that submitted the Filter\-as\-Code change. Should be used with externallyManaged\=true or existing filter should have that flag set.
    :param str commitID: The commit ID of the Filter\-as\-Code change. Should be used with externallyManaged\=true or existing filter should have that flag set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/analysis/{idOrShortName}".format(idOrShortName=idOrShortName)

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send removeLabels if the argument was provided, don't send null values
    if removeLabels is not None:
        body.update({"removeLabels": removeLabels})
    # Only send addLabels if the argument was provided, don't send null values
    if addLabels is not None:
        body.update({"addLabels": addLabels})
    # Only send setLabels if the argument was provided, don't send null values
    if setLabels is not None:
        body.update({"setLabels": setLabels})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})
    # Only send authoredByUser if the argument was provided, don't send null values
    if authoredByUser is not None:
        body.update({"authoredByUser": authoredByUser})
    # Only send commitID if the argument was provided, don't send null values
    if commitID is not None:
        body.update({"commitID": commitID})

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
