# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.request_timeout_error import RequestTimeoutError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.all_domain_links import AllDomainLinks
from ...types.all_links import AllLinks
from ...types.author_name import AuthorName
from ...types.by_parse_date import ByParseDate
from ...types.content_sentiment_max import ContentSentimentMax
from ...types.content_sentiment_min import ContentSentimentMin
from ...types.countries import Countries
from ...types.custom_tags import CustomTags
from ...types.error import Error
from ...types.from import From
from ...types.from_rank import FromRank
from ...types.has_nlp import HasNlp
from ...types.iab_tags import IabTags
from ...types.include_nlp_data import IncludeNlpData
from ...types.iptc_tags import IptcTags
from ...types.is_headline import IsHeadline
from ...types.is_opinion import IsOpinion
from ...types.is_paid_content import IsPaidContent
from ...types.lang import Lang
from ...types.ner_name import NerName
from ...types.not_author_name import NotAuthorName
from ...types.not_countries import NotCountries
from ...types.not_iab_tags import NotIabTags
from ...types.not_iptc_tags import NotIptcTags
from ...types.not_lang import NotLang
from ...types.not_sources import NotSources
from ...types.not_theme import NotTheme
from ...types.page import Page
from ...types.page_size import PageSize
from ...types.parent_url import ParentUrl
from ...types.predefined_sources import PredefinedSources
from ...types.published_date_precision import PublishedDatePrecision
from ...types.ranked_only import RankedOnly
from ...types.sort_by import SortBy
from ...types.sources import Sources
from ...types.theme import Theme
from ...types.title_sentiment_max import TitleSentimentMax
from ...types.title_sentiment_min import TitleSentimentMin
from ...types.to import To
from ...types.to_rank import ToRank
from ...types.word_count_max import WordCountMax
from ...types.word_count_min import WordCountMin
from .types.authors_get_request_published_date_precision import \
    AuthorsGetRequestPublishedDatePrecision
from .types.authors_get_request_sort_by import AuthorsGetRequestSortBy
from .types.authors_get_response import AuthorsGetResponse
from .types.authors_post_response import AuthorsPostResponse

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore
            
# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)
class AuthorsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper
    def get(self, *, author_name: str, not_author_name: typing.Optional[str] = None, predefined_sources: typing.Optional[str] = None, sources: typing.Optional[str] = None, not_sources: typing.Optional[str] = None, lang: typing.Optional[str] = None, not_lang: typing.Optional[str] = None, countries: typing.Optional[str] = None, not_countries: typing.Optional[str] = None, from_: typing.Optional[str] = None, to: typing.Optional[str] = None, published_date_precision: typing.Optional[AuthorsGetRequestPublishedDatePrecision] = None, by_parse_date: typing.Optional[bool] = None, sort_by: typing.Optional[AuthorsGetRequestSortBy] = None, ranked_only: typing.Optional[bool] = None, from_rank: typing.Optional[int] = None, to_rank: typing.Optional[int] = None, is_headline: typing.Optional[bool] = None, is_opinion: typing.Optional[bool] = None, is_paid_content: typing.Optional[bool] = None, parent_url: typing.Optional[str] = None, all_links: typing.Optional[str] = None, all_domain_links: typing.Optional[str] = None, word_count_min: typing.Optional[int] = None, word_count_max: typing.Optional[int] = None, page: typing.Optional[int] = None, page_size: typing.Optional[int] = None, include_nlp_data: typing.Optional[bool] = None, has_nlp: typing.Optional[bool] = None, theme: typing.Optional[str] = None, not_theme: typing.Optional[str] = None, ner_name: typing.Optional[str] = None, title_sentiment_min: typing.Optional[float] = None, title_sentiment_max: typing.Optional[float] = None, content_sentiment_min: typing.Optional[float] = None, content_sentiment_max: typing.Optional[float] = None, iptc_tags: typing.Optional[str] = None, not_iptc_tags: typing.Optional[str] = None, iab_tags: typing.Optional[str] = None, not_iab_tags: typing.Optional[str] = None, custom_tags: typing.Optional[str] = None) -> AuthorsGetResponse:
        """
        Searches for articles written by a specified author. You can filter results by language, country, source, and more.
        
        Parameters:
            - author_name: str. The name of the author to search for. This parameter returns exact matches only.
            
            - not_author_name: typing.Optional[str]. The list of author names to exclude from your search.
                                                     To exclude articles by specific authors, use a comma-separated string.
                                                     
                                                     Example: `"John Doe, Jane Doe"`
            - predefined_sources: typing.Optional[str]. Predefined top sources per country. 
                                                        
                                                        Format: start with the word `top`, followed by the number of desired sources, 
                                                        and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
                                                        
                                                        Examples: 
                                                        - `"top 100 US"`
                                                        - `"top 33 AT"`
                                                        - `"top 5 GB"`       
                                                        
                                                        Multiple countries can be specified with custom numbers as a comma-separated string. 
                                                        
                                                        Examples: 
                                                        - `"top 50 US, top 20 GB"`
                                                        - `"top 33 AT, top 50 IT"`
            - sources: typing.Optional[str]. One or more news sources to narrow down the search. The format must be a domain URL. 
                                             Subdomains, such as `finance.yahoo.com`, are also acceptable.
                                             To specify multiple sources, use a comma-separated string.
                                             
                                             Examples:
                                             - `"nytimes.com"`
                                             - `"theguardian.com, finance.yahoo.com"`
            - not_sources: typing.Optional[str]. The news sources to exclude from the search.
                                                 To exclude multiple sources, use a comma-separated string. 
                                                 
                                                 Example: `"cnn.com, wsj.com"`
            - lang: typing.Optional[str]. The language(s) of the search. 
                                          The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code.
                                          To select multiple languages, use a comma-separated string. 
                                          
                                          Example: `"en, es"`
                                          
                                          To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
            - not_lang: typing.Optional[str]. The language(s) to exclude from the search. 
                                              The accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code.
                                              To exclude multiple languages, use a comma-separated string. 
                                              
                                              Example: `"fr, de"`
                                              
                                              To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
            - countries: typing.Optional[str]. The countries where the news publisher is located. 
                                               The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
                                               To select multiple countries, use a comma-separated string.
                                               
                                               Example: `"US, CA"`
                                               
                                               To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
            - not_countries: typing.Optional[str]. The publisher location countries to exclude from the search. 
                                                   The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
                                                   To exclude multiple countries, use a comma-separated string. 
                                                   
                                                   Example:`"US, CA"`
                                                   
                                                   To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
            - from_: typing.Optional[str].
            
            - to: typing.Optional[str].
            
            - published_date_precision: typing.Optional[AuthorsGetRequestPublishedDatePrecision]. The precision of the published date. There are three types:
                                                                                                  - `full`: The day and time of an article is correctly identified with the appropriate timezone.
                                                                                                  - `timezone unknown`: The day and time of an article is correctly identified without timezone.
                                                                                                  - `date`: Only the day is identified without an exact time.
            - by_parse_date: typing.Optional[bool]. If true, the `from_` and `to_` parameters use article parse dates instead of published dates. 
                                                    Additionally, the `parse_date` variable is added to the output list for each article.
            - sort_by: typing.Optional[AuthorsGetRequestSortBy]. The sorting order of the results. Possible values are:
                                                                 - `relevancy`: The most relevant results first.
                                                                 - `date`: The most recently published results first.
                                                                 - `rank`: The results from the highest-ranked sources first.
            - ranked_only: typing.Optional[bool]. If true, limits the search to sources ranked in the top 1 million online websites. 
                                                  If false, includes unranked sources which are assigned a rank of 999999.
            - from_rank: typing.Optional[int]. The lowest boundary of the rank of a news website to filter by. 
                                               Range: `1` to `999999`, where a lower rank indicates a more popular source. 
                                               If you set this to `100`, the API includes sources ranked 100 or higher.
            - to_rank: typing.Optional[int]. The highest boundary of the rank of a news website to filter by. 
                                             Range: `1` to `999999`, where a lower rank indicates a more popular source. 
                                             If you set this to `100`, the API includes sources ranked 100 or lower.
            - is_headline: typing.Optional[bool]. If true, only returns articles that were posted on the home page of a given news domain.
            
            - is_opinion: typing.Optional[bool]. If true, returns only opinion pieces. 
                                                 If false, excludes opinion-based articles and returns news only.
            - is_paid_content: typing.Optional[bool]. If false, returns only articles that have publicly available complete content. 
                                                      Some publishers partially block content, so this setting ensures that only full articles are retrieved.
            - parent_url: typing.Optional[str]. The categorical URL(s) to filter your search.
                                                To filter your search by multiple categorical URLs, use a comma-separated string.
                                                
                                                Example: `"wsj.com/politics, wsj.com/tech"`
            - all_links: typing.Optional[str]. The complete URL(s) mentioned in the article.
                                               For multiple URLs, use a comma-separated string.
                                               
                                               Example: `"https://aiindex.stanford.edu/report, https://www.stateof.ai"`
                                               
                                               For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
            - all_domain_links: typing.Optional[str]. The domain(s) mentioned in the article.
                                                      For multiple domains, use a comma-separated string.
                                                      
                                                      Example: `"who.int, nih.gov"`
                                                      
                                                      For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
            - word_count_min: typing.Optional[int]. The minimum number of words an article must contain. 
                                                    To be used for avoiding articles with small content.
            - word_count_max: typing.Optional[int]. The maximum number of words an article can contain. 
                                                    To be used for avoiding articles with large content.
            - page: typing.Optional[int]. The page number to scroll through the results. 
                                          This parameter is used to paginate: scroll through results because one API response cannot return more than 1000 articles.
            - page_size: typing.Optional[int]. The number of articles to return per page. 
                                               Range: `1` to `1000`.
            - include_nlp_data: typing.Optional[bool]. If true, includes an NLP layer with each article in the response. 
                                                       This layer provides enhanced information such as theme classification, 
                                                       article summary, sentiment analysis, tags, and named entity recognition.
                                                       
                                                       The NLP layer includes:
                                                       - Theme: General topic of the article.
                                                       - Summary: A concise overview of the article content.
                                                       - Sentiment: Separate scores for title and content (range: -1 to 1).
                                                       - Named entities: Identified persons (PER), organizations (ORG), locations (LOC), and miscellaneous entities (MISC).
                                                       - IPTC tags: Standardized news category tags.
                                                       - IAB tags: Content categories for digital advertising.
                                                       
                                                       **Note**: The `include_nlp_data` parameter is only available if NLP is included in your subscription plan.
                                                       
                                                       To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - has_nlp: typing.Optional[bool]. If true, filters the results to include only articles with an NLP layer. 
                                              This allows you to focus on articles that have been processed with advanced NLP techniques.
                                              
                                              **Note**: The `has_nlp` parameter is only available if NLP is included in your subscription plan.
                                              
                                              To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - theme: typing.Optional[str]. Filters articles based on their general topic, as determined by NLP analysis.
                                           To select multiple themes, use a comma-separated string.
                                           
                                           Example: `"Finance, Tech"`
                                           
                                           **Note**: The `theme` parameter is only available if NLP is included in your subscription plan.
                                           
                                           To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
                                           
                                           Available options: `Business`, `Economics`, `Entertainment`, `Finance`, `Health`, `Politics`, `Science`, `Sports`, `Tech`, `Crime`, `Financial Crime`, `Lifestyle`, `Automotive`, `Travel`, `Weather`, `General`.
            - not_theme: typing.Optional[str]. Inverse of the `theme` parameter. Excludes articles based on their general topic, as determined by NLP analysis. 
                                               To exclude multiple themes, use a comma-separated string. 
                                               
                                               Example: `"Crime, Tech"`
                                               
                                               **Note**: The `not_theme` parameter is only available if NLP is included in your subscription plan.
                                               
                                               To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - ner_name: typing.Optional[str]. The name of person, organization, location, product or other named entity to search for.
                                              To specify multiple names use a comma-separated string. 
                                              
                                              Example: `"Tesla, Amazon"`
            - title_sentiment_min: typing.Optional[float]. Filters articles based on the minimum sentiment score of their titles.
                                                           
                                                           Range is `-1.0` to `1.0`, where:
                                                           - Negative values indicate negative sentiment.
                                                           - Positive values indicate positive sentiment.
                                                           - Values close to 0 indicate neutral sentiment.
                                                           
                                                           **Note**: The `title_sentiment_min` parameter is only available if NLP is included in your subscription plan.
                                                           
                                                           To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - title_sentiment_max: typing.Optional[float]. Filters articles based on the maximum sentiment score of their titles.
                                                           
                                                           Range is `-1.0` to `1.0`, where:
                                                           - Negative values indicate negative sentiment.
                                                           - Positive values indicate positive sentiment.
                                                           - Values close to 0 indicate neutral sentiment.
                                                           
                                                           **Note**: The `title_sentiment_max` parameter is only available if NLP is included in your subscription plan.
                                                           
                                                           To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - content_sentiment_min: typing.Optional[float]. Filters articles based on the minimum sentiment score of their content.
                                                             
                                                             Range is `-1.0` to `1.0`, where:
                                                             - Negative values indicate negative sentiment.
                                                             - Positive values indicate positive sentiment.
                                                             - Values close to 0 indicate neutral sentiment.
                                                             
                                                             **Note**: The `content_sentiment_min` parameter is only available if NLP is included in your subscription plan.
                                                             
                                                             To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - content_sentiment_max: typing.Optional[float]. Filters articles based on the maximum sentiment score of their content.
                                                             
                                                             Range is `-1.0` to `1.0`, where:
                                                             - Negative values indicate negative sentiment.
                                                             - Positive values indicate positive sentiment.
                                                             - Values close to 0 indicate neutral sentiment.
                                                             
                                                             **Note**: The `content_sentiment_max` parameter is only available if NLP is included in your subscription plan.
                                                             
                                                             To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - iptc_tags: typing.Optional[str]. Filters articles based on IPTC (International Press Telecommunications Council) media topic tags.
                                               To specify multiple IPTC tags, use a comma-separated string of tag IDs. 
                                               
                                               Example: `"20000199, 20000209"`
                                               
                                               **Note**: The `iptc_tags` parameter is only available if tags are included in your subscription plan.
                                               
                                               To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
            - not_iptc_tags: typing.Optional[str]. Inverse of the `iptc_tags` parameter. Excludes articles based on IPTC (International Press Telecommunications Council) media topic tags.
                                                   To specify multiple IPTC tags to exclude, use a comma-separated string of tag IDs. 
                                                   
                                                   Example: `"20000205, 20000209"`
                                                   
                                                   **Note**: The `not_iptc_tags` parameter is only available if tags are included in your subscription plan.
                                                   
                                                   To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
            - iab_tags: typing.Optional[str]. Filters articles based on IAB (Interactive Advertising Bureau) content categories.
                                              These tags provide a standardized taxonomy for digital advertising content categorization.
                                              To specify multiple IAB categories, use a comma-separated string. 
                                              
                                              Example: `"Business, Events"`
                                              
                                              **Note**: The `iab_tags` parameter is only available if tags are included in your subscription plan.
                                              
                                              To learn more, see the [IAB Content taxonomy](https://iabtechlab.com/standards/content-taxonomy/).
            - not_iab_tags: typing.Optional[str]. Inverse of the `iab_tags` parameter. Excludes articles based on IAB (Interactive Advertising Bureau) content categories.
                                                  These tags provide a standardized taxonomy for digital advertising content categorization.
                                                  To specify multiple IAB categories to exclude, use a comma-separated string. 
                                                  
                                                  Example: `"Agriculture, Metals"`
                                                  
                                                  **Note**: The `not_iab_tags` parameter is only available if tags are included in your subscription plan.
                                                  
                                                  To learn more, see the [IAB Content taxonomy](https://iabtechlab.com/standards/content-taxonomy/).
            - custom_tags: typing.Optional[str]. Filters articles based on custom taxonomy tags specific to your organization.
                                                 Each taxonomy is a custom-built classification system tailored to your specific needs
                                                 and is accessible only with your API key.
                                                 
                                                 To specify the taxonomy and its tags, use the following pattern: 
                                                 
                                                 - `custom_tags.taxonomy=Tag1,Tag2,Tag3`, 
                                                 
                                                 where `taxonomy` is your taxonomy name and `Tag1,Tag2,Tag3` are specific tag names.
                                                 
                                                 Example: `custom_tags.my_taxonomy=Tag1,Tag2,Tag3`
                                                 
                                                 To learn more, see the [Custom tags](/docs/v3/documentation/guides-and-concepts/custom-tags).
        """
        _response = self._client_wrapper.httpx_client.request("GET", urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/authors"), 
            params=remove_none_from_dict({"author_name": author_name, "not_author_name": not_author_name, "predefined_sources": predefined_sources, "sources": sources, "not_sources": not_sources, "lang": lang, "not_lang": not_lang, "countries": countries, "not_countries": not_countries, "from_": from_, "to_": to, "published_date_precision": published_date_precision, "by_parse_date": by_parse_date, "sort_by": sort_by, "ranked_only": ranked_only, "from_rank": from_rank, "to_rank": to_rank, "is_headline": is_headline, "is_opinion": is_opinion, "is_paid_content": is_paid_content, "parent_url": parent_url, "all_links": all_links, "all_domain_links": all_domain_links, "word_count_min": word_count_min, "word_count_max": word_count_max, "page": page, "page_size": page_size, "include_nlp_data": include_nlp_data, "has_nlp": has_nlp, "theme": theme, "not_theme": not_theme, "ner_name": ner_name, "title_sentiment_min": title_sentiment_min, "title_sentiment_max": title_sentiment_max, "content_sentiment_min": content_sentiment_min, "content_sentiment_max": content_sentiment_max, "iptc_tags": iptc_tags, "not_iptc_tags": not_iptc_tags, "iab_tags": iab_tags, "not_iab_tags": not_iab_tags, "custom_tags": custom_tags, },
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AuthorsGetResponse, _response.json())# type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json())# type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
    def post(self, *, author_name: AuthorName, not_author_name: typing.Optional[NotAuthorName] = OMIT, predefined_sources: typing.Optional[PredefinedSources] = OMIT, sources: typing.Optional[Sources] = OMIT, not_sources: typing.Optional[NotSources] = OMIT, lang: typing.Optional[Lang] = OMIT, not_lang: typing.Optional[NotLang] = OMIT, countries: typing.Optional[Countries] = OMIT, not_countries: typing.Optional[NotCountries] = OMIT, from: typing.Optional[From] = OMIT, to: typing.Optional[To] = OMIT, published_date_precision: typing.Optional[PublishedDatePrecision] = OMIT, by_parse_date: typing.Optional[ByParseDate] = OMIT, sort_by: typing.Optional[SortBy] = OMIT, ranked_only: typing.Optional[RankedOnly] = OMIT, from_rank: typing.Optional[FromRank] = OMIT, to_rank: typing.Optional[ToRank] = OMIT, is_headline: typing.Optional[IsHeadline] = OMIT, is_opinion: typing.Optional[IsOpinion] = OMIT, is_paid_content: typing.Optional[IsPaidContent] = OMIT, parent_url: typing.Optional[ParentUrl] = OMIT, all_links: typing.Optional[AllLinks] = OMIT, all_domain_links: typing.Optional[AllDomainLinks] = OMIT, word_count_min: typing.Optional[WordCountMin] = OMIT, word_count_max: typing.Optional[WordCountMax] = OMIT, page: typing.Optional[Page] = OMIT, page_size: typing.Optional[PageSize] = OMIT, include_nlp_data: typing.Optional[IncludeNlpData] = OMIT, has_nlp: typing.Optional[HasNlp] = OMIT, theme: typing.Optional[Theme] = OMIT, not_theme: typing.Optional[NotTheme] = OMIT, ner_name: typing.Optional[NerName] = OMIT, title_sentiment_min: typing.Optional[TitleSentimentMin] = OMIT, title_sentiment_max: typing.Optional[TitleSentimentMax] = OMIT, content_sentiment_min: typing.Optional[ContentSentimentMin] = OMIT, content_sentiment_max: typing.Optional[ContentSentimentMax] = OMIT, iptc_tags: typing.Optional[IptcTags] = OMIT, not_iptc_tags: typing.Optional[NotIptcTags] = OMIT, iab_tags: typing.Optional[IabTags] = OMIT, not_iab_tags: typing.Optional[NotIabTags] = OMIT, custom_tags: typing.Optional[CustomTags] = OMIT) -> AuthorsPostResponse:
        """
        Searches for articles by author. You can filter results by language, country, source, and more.
        
        Parameters:
            - author_name: AuthorName.
            
            - not_author_name: typing.Optional[NotAuthorName].
            
            - predefined_sources: typing.Optional[PredefinedSources].
            
            - sources: typing.Optional[Sources].
            
            - not_sources: typing.Optional[NotSources].
            
            - lang: typing.Optional[Lang].
            
            - not_lang: typing.Optional[NotLang].
            
            - countries: typing.Optional[Countries].
            
            - not_countries: typing.Optional[NotCountries].
            
            - from: typing.Optional[From].
            
            - to: typing.Optional[To].
            
            - published_date_precision: typing.Optional[PublishedDatePrecision].
            
            - by_parse_date: typing.Optional[ByParseDate].
            
            - sort_by: typing.Optional[SortBy].
            
            - ranked_only: typing.Optional[RankedOnly].
            
            - from_rank: typing.Optional[FromRank].
            
            - to_rank: typing.Optional[ToRank].
            
            - is_headline: typing.Optional[IsHeadline].
            
            - is_opinion: typing.Optional[IsOpinion].
            
            - is_paid_content: typing.Optional[IsPaidContent].
            
            - parent_url: typing.Optional[ParentUrl].
            
            - all_links: typing.Optional[AllLinks].
            
            - all_domain_links: typing.Optional[AllDomainLinks].
            
            - word_count_min: typing.Optional[WordCountMin].
            
            - word_count_max: typing.Optional[WordCountMax].
            
            - page: typing.Optional[Page].
            
            - page_size: typing.Optional[PageSize].
            
            - include_nlp_data: typing.Optional[IncludeNlpData].
            
            - has_nlp: typing.Optional[HasNlp].
            
            - theme: typing.Optional[Theme].
            
            - not_theme: typing.Optional[NotTheme].
            
            - ner_name: typing.Optional[NerName].
            
            - title_sentiment_min: typing.Optional[TitleSentimentMin].
            
            - title_sentiment_max: typing.Optional[TitleSentimentMax].
            
            - content_sentiment_min: typing.Optional[ContentSentimentMin].
            
            - content_sentiment_max: typing.Optional[ContentSentimentMax].
            
            - iptc_tags: typing.Optional[IptcTags].
            
            - not_iptc_tags: typing.Optional[NotIptcTags].
            
            - iab_tags: typing.Optional[IabTags].
            
            - not_iab_tags: typing.Optional[NotIabTags].
            
            - custom_tags: typing.Optional[CustomTags].
        """
        _request: typing.Dict[str, typing.Any] = {
            "author_name": author_name,
        }
        if not_author_name is not OMIT:
            _request["not_author_name"] = not_author_name
        if predefined_sources is not OMIT:
            _request["predefined_sources"] = predefined_sources
        if sources is not OMIT:
            _request["sources"] = sources
        if not_sources is not OMIT:
            _request["not_sources"] = not_sources
        if lang is not OMIT:
            _request["lang"] = lang
        if not_lang is not OMIT:
            _request["not_lang"] = not_lang
        if countries is not OMIT:
            _request["countries"] = countries
        if not_countries is not OMIT:
            _request["not_countries"] = not_countries
        if from is not OMIT:
            _request["from_"] = from
        if to is not OMIT:
            _request["to_"] = to
        if published_date_precision is not OMIT:
            _request["published_date_precision"] = published_date_precision.value
        if by_parse_date is not OMIT:
            _request["by_parse_date"] = by_parse_date
        if sort_by is not OMIT:
            _request["sort_by"] = sort_by.value
        if ranked_only is not OMIT:
            _request["ranked_only"] = ranked_only
        if from_rank is not OMIT:
            _request["from_rank"] = from_rank
        if to_rank is not OMIT:
            _request["to_rank"] = to_rank
        if is_headline is not OMIT:
            _request["is_headline"] = is_headline
        if is_opinion is not OMIT:
            _request["is_opinion"] = is_opinion
        if is_paid_content is not OMIT:
            _request["is_paid_content"] = is_paid_content
        if parent_url is not OMIT:
            _request["parent_url"] = parent_url
        if all_links is not OMIT:
            _request["all_links"] = all_links
        if all_domain_links is not OMIT:
            _request["all_domain_links"] = all_domain_links
        if word_count_min is not OMIT:
            _request["word_count_min"] = word_count_min
        if word_count_max is not OMIT:
            _request["word_count_max"] = word_count_max
        if page is not OMIT:
            _request["page"] = page
        if page_size is not OMIT:
            _request["page_size"] = page_size
        if include_nlp_data is not OMIT:
            _request["include_nlp_data"] = include_nlp_data
        if has_nlp is not OMIT:
            _request["has_nlp"] = has_nlp
        if theme is not OMIT:
            _request["theme"] = theme
        if not_theme is not OMIT:
            _request["not_theme"] = not_theme
        if ner_name is not OMIT:
            _request["ner_name"] = ner_name
        if title_sentiment_min is not OMIT:
            _request["title_sentiment_min"] = title_sentiment_min
        if title_sentiment_max is not OMIT:
            _request["title_sentiment_max"] = title_sentiment_max
        if content_sentiment_min is not OMIT:
            _request["content_sentiment_min"] = content_sentiment_min
        if content_sentiment_max is not OMIT:
            _request["content_sentiment_max"] = content_sentiment_max
        if iptc_tags is not OMIT:
            _request["iptc_tags"] = iptc_tags
        if not_iptc_tags is not OMIT:
            _request["not_iptc_tags"] = not_iptc_tags
        if iab_tags is not OMIT:
            _request["iab_tags"] = iab_tags
        if not_iab_tags is not OMIT:
            _request["not_iab_tags"] = not_iab_tags
        if custom_tags is not OMIT:
            _request["custom_tags"] = custom_tags
        _response = self._client_wrapper.httpx_client.request("POST", urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/authors"), 
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AuthorsPostResponse, _response.json())# type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json())# type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
class AsyncAuthorsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper
    async def get(self, *, author_name: str, not_author_name: typing.Optional[str] = None, predefined_sources: typing.Optional[str] = None, sources: typing.Optional[str] = None, not_sources: typing.Optional[str] = None, lang: typing.Optional[str] = None, not_lang: typing.Optional[str] = None, countries: typing.Optional[str] = None, not_countries: typing.Optional[str] = None, from_: typing.Optional[str] = None, to: typing.Optional[str] = None, published_date_precision: typing.Optional[AuthorsGetRequestPublishedDatePrecision] = None, by_parse_date: typing.Optional[bool] = None, sort_by: typing.Optional[AuthorsGetRequestSortBy] = None, ranked_only: typing.Optional[bool] = None, from_rank: typing.Optional[int] = None, to_rank: typing.Optional[int] = None, is_headline: typing.Optional[bool] = None, is_opinion: typing.Optional[bool] = None, is_paid_content: typing.Optional[bool] = None, parent_url: typing.Optional[str] = None, all_links: typing.Optional[str] = None, all_domain_links: typing.Optional[str] = None, word_count_min: typing.Optional[int] = None, word_count_max: typing.Optional[int] = None, page: typing.Optional[int] = None, page_size: typing.Optional[int] = None, include_nlp_data: typing.Optional[bool] = None, has_nlp: typing.Optional[bool] = None, theme: typing.Optional[str] = None, not_theme: typing.Optional[str] = None, ner_name: typing.Optional[str] = None, title_sentiment_min: typing.Optional[float] = None, title_sentiment_max: typing.Optional[float] = None, content_sentiment_min: typing.Optional[float] = None, content_sentiment_max: typing.Optional[float] = None, iptc_tags: typing.Optional[str] = None, not_iptc_tags: typing.Optional[str] = None, iab_tags: typing.Optional[str] = None, not_iab_tags: typing.Optional[str] = None, custom_tags: typing.Optional[str] = None) -> AuthorsGetResponse:
        """
        Searches for articles written by a specified author. You can filter results by language, country, source, and more.
        
        Parameters:
            - author_name: str. The name of the author to search for. This parameter returns exact matches only.
            
            - not_author_name: typing.Optional[str]. The list of author names to exclude from your search.
                                                     To exclude articles by specific authors, use a comma-separated string.
                                                     
                                                     Example: `"John Doe, Jane Doe"`
            - predefined_sources: typing.Optional[str]. Predefined top sources per country. 
                                                        
                                                        Format: start with the word `top`, followed by the number of desired sources, 
                                                        and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).
                                                        
                                                        Examples: 
                                                        - `"top 100 US"`
                                                        - `"top 33 AT"`
                                                        - `"top 5 GB"`       
                                                        
                                                        Multiple countries can be specified with custom numbers as a comma-separated string. 
                                                        
                                                        Examples: 
                                                        - `"top 50 US, top 20 GB"`
                                                        - `"top 33 AT, top 50 IT"`
            - sources: typing.Optional[str]. One or more news sources to narrow down the search. The format must be a domain URL. 
                                             Subdomains, such as `finance.yahoo.com`, are also acceptable.
                                             To specify multiple sources, use a comma-separated string.
                                             
                                             Examples:
                                             - `"nytimes.com"`
                                             - `"theguardian.com, finance.yahoo.com"`
            - not_sources: typing.Optional[str]. The news sources to exclude from the search.
                                                 To exclude multiple sources, use a comma-separated string. 
                                                 
                                                 Example: `"cnn.com, wsj.com"`
            - lang: typing.Optional[str]. The language(s) of the search. 
                                          The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code.
                                          To select multiple languages, use a comma-separated string. 
                                          
                                          Example: `"en, es"`
                                          
                                          To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
            - not_lang: typing.Optional[str]. The language(s) to exclude from the search. 
                                              The accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code.
                                              To exclude multiple languages, use a comma-separated string. 
                                              
                                              Example: `"fr, de"`
                                              
                                              To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
            - countries: typing.Optional[str]. The countries where the news publisher is located. 
                                               The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
                                               To select multiple countries, use a comma-separated string.
                                               
                                               Example: `"US, CA"`
                                               
                                               To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
            - not_countries: typing.Optional[str]. The publisher location countries to exclude from the search. 
                                                   The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
                                                   To exclude multiple countries, use a comma-separated string. 
                                                   
                                                   Example:`"US, CA"`
                                                   
                                                   To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
            - from_: typing.Optional[str].
            
            - to: typing.Optional[str].
            
            - published_date_precision: typing.Optional[AuthorsGetRequestPublishedDatePrecision]. The precision of the published date. There are three types:
                                                                                                  - `full`: The day and time of an article is correctly identified with the appropriate timezone.
                                                                                                  - `timezone unknown`: The day and time of an article is correctly identified without timezone.
                                                                                                  - `date`: Only the day is identified without an exact time.
            - by_parse_date: typing.Optional[bool]. If true, the `from_` and `to_` parameters use article parse dates instead of published dates. 
                                                    Additionally, the `parse_date` variable is added to the output list for each article.
            - sort_by: typing.Optional[AuthorsGetRequestSortBy]. The sorting order of the results. Possible values are:
                                                                 - `relevancy`: The most relevant results first.
                                                                 - `date`: The most recently published results first.
                                                                 - `rank`: The results from the highest-ranked sources first.
            - ranked_only: typing.Optional[bool]. If true, limits the search to sources ranked in the top 1 million online websites. 
                                                  If false, includes unranked sources which are assigned a rank of 999999.
            - from_rank: typing.Optional[int]. The lowest boundary of the rank of a news website to filter by. 
                                               Range: `1` to `999999`, where a lower rank indicates a more popular source. 
                                               If you set this to `100`, the API includes sources ranked 100 or higher.
            - to_rank: typing.Optional[int]. The highest boundary of the rank of a news website to filter by. 
                                             Range: `1` to `999999`, where a lower rank indicates a more popular source. 
                                             If you set this to `100`, the API includes sources ranked 100 or lower.
            - is_headline: typing.Optional[bool]. If true, only returns articles that were posted on the home page of a given news domain.
            
            - is_opinion: typing.Optional[bool]. If true, returns only opinion pieces. 
                                                 If false, excludes opinion-based articles and returns news only.
            - is_paid_content: typing.Optional[bool]. If false, returns only articles that have publicly available complete content. 
                                                      Some publishers partially block content, so this setting ensures that only full articles are retrieved.
            - parent_url: typing.Optional[str]. The categorical URL(s) to filter your search.
                                                To filter your search by multiple categorical URLs, use a comma-separated string.
                                                
                                                Example: `"wsj.com/politics, wsj.com/tech"`
            - all_links: typing.Optional[str]. The complete URL(s) mentioned in the article.
                                               For multiple URLs, use a comma-separated string.
                                               
                                               Example: `"https://aiindex.stanford.edu/report, https://www.stateof.ai"`
                                               
                                               For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
            - all_domain_links: typing.Optional[str]. The domain(s) mentioned in the article.
                                                      For multiple domains, use a comma-separated string.
                                                      
                                                      Example: `"who.int, nih.gov"`
                                                      
                                                      For more details, see [Search by URL](/docs/v3/documentation/how-to/search-by-url).
            - word_count_min: typing.Optional[int]. The minimum number of words an article must contain. 
                                                    To be used for avoiding articles with small content.
            - word_count_max: typing.Optional[int]. The maximum number of words an article can contain. 
                                                    To be used for avoiding articles with large content.
            - page: typing.Optional[int]. The page number to scroll through the results. 
                                          This parameter is used to paginate: scroll through results because one API response cannot return more than 1000 articles.
            - page_size: typing.Optional[int]. The number of articles to return per page. 
                                               Range: `1` to `1000`.
            - include_nlp_data: typing.Optional[bool]. If true, includes an NLP layer with each article in the response. 
                                                       This layer provides enhanced information such as theme classification, 
                                                       article summary, sentiment analysis, tags, and named entity recognition.
                                                       
                                                       The NLP layer includes:
                                                       - Theme: General topic of the article.
                                                       - Summary: A concise overview of the article content.
                                                       - Sentiment: Separate scores for title and content (range: -1 to 1).
                                                       - Named entities: Identified persons (PER), organizations (ORG), locations (LOC), and miscellaneous entities (MISC).
                                                       - IPTC tags: Standardized news category tags.
                                                       - IAB tags: Content categories for digital advertising.
                                                       
                                                       **Note**: The `include_nlp_data` parameter is only available if NLP is included in your subscription plan.
                                                       
                                                       To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - has_nlp: typing.Optional[bool]. If true, filters the results to include only articles with an NLP layer. 
                                              This allows you to focus on articles that have been processed with advanced NLP techniques.
                                              
                                              **Note**: The `has_nlp` parameter is only available if NLP is included in your subscription plan.
                                              
                                              To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - theme: typing.Optional[str]. Filters articles based on their general topic, as determined by NLP analysis.
                                           To select multiple themes, use a comma-separated string.
                                           
                                           Example: `"Finance, Tech"`
                                           
                                           **Note**: The `theme` parameter is only available if NLP is included in your subscription plan.
                                           
                                           To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
                                           
                                           Available options: `Business`, `Economics`, `Entertainment`, `Finance`, `Health`, `Politics`, `Science`, `Sports`, `Tech`, `Crime`, `Financial Crime`, `Lifestyle`, `Automotive`, `Travel`, `Weather`, `General`.
            - not_theme: typing.Optional[str]. Inverse of the `theme` parameter. Excludes articles based on their general topic, as determined by NLP analysis. 
                                               To exclude multiple themes, use a comma-separated string. 
                                               
                                               Example: `"Crime, Tech"`
                                               
                                               **Note**: The `not_theme` parameter is only available if NLP is included in your subscription plan.
                                               
                                               To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - ner_name: typing.Optional[str]. The name of person, organization, location, product or other named entity to search for.
                                              To specify multiple names use a comma-separated string. 
                                              
                                              Example: `"Tesla, Amazon"`
            - title_sentiment_min: typing.Optional[float]. Filters articles based on the minimum sentiment score of their titles.
                                                           
                                                           Range is `-1.0` to `1.0`, where:
                                                           - Negative values indicate negative sentiment.
                                                           - Positive values indicate positive sentiment.
                                                           - Values close to 0 indicate neutral sentiment.
                                                           
                                                           **Note**: The `title_sentiment_min` parameter is only available if NLP is included in your subscription plan.
                                                           
                                                           To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - title_sentiment_max: typing.Optional[float]. Filters articles based on the maximum sentiment score of their titles.
                                                           
                                                           Range is `-1.0` to `1.0`, where:
                                                           - Negative values indicate negative sentiment.
                                                           - Positive values indicate positive sentiment.
                                                           - Values close to 0 indicate neutral sentiment.
                                                           
                                                           **Note**: The `title_sentiment_max` parameter is only available if NLP is included in your subscription plan.
                                                           
                                                           To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - content_sentiment_min: typing.Optional[float]. Filters articles based on the minimum sentiment score of their content.
                                                             
                                                             Range is `-1.0` to `1.0`, where:
                                                             - Negative values indicate negative sentiment.
                                                             - Positive values indicate positive sentiment.
                                                             - Values close to 0 indicate neutral sentiment.
                                                             
                                                             **Note**: The `content_sentiment_min` parameter is only available if NLP is included in your subscription plan.
                                                             
                                                             To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - content_sentiment_max: typing.Optional[float]. Filters articles based on the maximum sentiment score of their content.
                                                             
                                                             Range is `-1.0` to `1.0`, where:
                                                             - Negative values indicate negative sentiment.
                                                             - Positive values indicate positive sentiment.
                                                             - Values close to 0 indicate neutral sentiment.
                                                             
                                                             **Note**: The `content_sentiment_max` parameter is only available if NLP is included in your subscription plan.
                                                             
                                                             To learn more, see [NLP features](/docs/v3/documentation/guides-and-concepts/nlp-features).
            - iptc_tags: typing.Optional[str]. Filters articles based on IPTC (International Press Telecommunications Council) media topic tags.
                                               To specify multiple IPTC tags, use a comma-separated string of tag IDs. 
                                               
                                               Example: `"20000199, 20000209"`
                                               
                                               **Note**: The `iptc_tags` parameter is only available if tags are included in your subscription plan.
                                               
                                               To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
            - not_iptc_tags: typing.Optional[str]. Inverse of the `iptc_tags` parameter. Excludes articles based on IPTC (International Press Telecommunications Council) media topic tags.
                                                   To specify multiple IPTC tags to exclude, use a comma-separated string of tag IDs. 
                                                   
                                                   Example: `"20000205, 20000209"`
                                                   
                                                   **Note**: The `not_iptc_tags` parameter is only available if tags are included in your subscription plan.
                                                   
                                                   To learn more, see [IPTC Media Topic NewsCodes](https://www.iptc.org/std/NewsCodes/treeview/mediatopic/mediatopic-en-GB.html).
            - iab_tags: typing.Optional[str]. Filters articles based on IAB (Interactive Advertising Bureau) content categories.
                                              These tags provide a standardized taxonomy for digital advertising content categorization.
                                              To specify multiple IAB categories, use a comma-separated string. 
                                              
                                              Example: `"Business, Events"`
                                              
                                              **Note**: The `iab_tags` parameter is only available if tags are included in your subscription plan.
                                              
                                              To learn more, see the [IAB Content taxonomy](https://iabtechlab.com/standards/content-taxonomy/).
            - not_iab_tags: typing.Optional[str]. Inverse of the `iab_tags` parameter. Excludes articles based on IAB (Interactive Advertising Bureau) content categories.
                                                  These tags provide a standardized taxonomy for digital advertising content categorization.
                                                  To specify multiple IAB categories to exclude, use a comma-separated string. 
                                                  
                                                  Example: `"Agriculture, Metals"`
                                                  
                                                  **Note**: The `not_iab_tags` parameter is only available if tags are included in your subscription plan.
                                                  
                                                  To learn more, see the [IAB Content taxonomy](https://iabtechlab.com/standards/content-taxonomy/).
            - custom_tags: typing.Optional[str]. Filters articles based on custom taxonomy tags specific to your organization.
                                                 Each taxonomy is a custom-built classification system tailored to your specific needs
                                                 and is accessible only with your API key.
                                                 
                                                 To specify the taxonomy and its tags, use the following pattern: 
                                                 
                                                 - `custom_tags.taxonomy=Tag1,Tag2,Tag3`, 
                                                 
                                                 where `taxonomy` is your taxonomy name and `Tag1,Tag2,Tag3` are specific tag names.
                                                 
                                                 Example: `custom_tags.my_taxonomy=Tag1,Tag2,Tag3`
                                                 
                                                 To learn more, see the [Custom tags](/docs/v3/documentation/guides-and-concepts/custom-tags).
        """
        _response = await self._client_wrapper.httpx_client.request("GET", urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/authors"), 
            params=remove_none_from_dict({"author_name": author_name, "not_author_name": not_author_name, "predefined_sources": predefined_sources, "sources": sources, "not_sources": not_sources, "lang": lang, "not_lang": not_lang, "countries": countries, "not_countries": not_countries, "from_": from_, "to_": to, "published_date_precision": published_date_precision, "by_parse_date": by_parse_date, "sort_by": sort_by, "ranked_only": ranked_only, "from_rank": from_rank, "to_rank": to_rank, "is_headline": is_headline, "is_opinion": is_opinion, "is_paid_content": is_paid_content, "parent_url": parent_url, "all_links": all_links, "all_domain_links": all_domain_links, "word_count_min": word_count_min, "word_count_max": word_count_max, "page": page, "page_size": page_size, "include_nlp_data": include_nlp_data, "has_nlp": has_nlp, "theme": theme, "not_theme": not_theme, "ner_name": ner_name, "title_sentiment_min": title_sentiment_min, "title_sentiment_max": title_sentiment_max, "content_sentiment_min": content_sentiment_min, "content_sentiment_max": content_sentiment_max, "iptc_tags": iptc_tags, "not_iptc_tags": not_iptc_tags, "iab_tags": iab_tags, "not_iab_tags": not_iab_tags, "custom_tags": custom_tags, },
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AuthorsGetResponse, _response.json())# type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json())# type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
    async def post(self, *, author_name: AuthorName, not_author_name: typing.Optional[NotAuthorName] = OMIT, predefined_sources: typing.Optional[PredefinedSources] = OMIT, sources: typing.Optional[Sources] = OMIT, not_sources: typing.Optional[NotSources] = OMIT, lang: typing.Optional[Lang] = OMIT, not_lang: typing.Optional[NotLang] = OMIT, countries: typing.Optional[Countries] = OMIT, not_countries: typing.Optional[NotCountries] = OMIT, from: typing.Optional[From] = OMIT, to: typing.Optional[To] = OMIT, published_date_precision: typing.Optional[PublishedDatePrecision] = OMIT, by_parse_date: typing.Optional[ByParseDate] = OMIT, sort_by: typing.Optional[SortBy] = OMIT, ranked_only: typing.Optional[RankedOnly] = OMIT, from_rank: typing.Optional[FromRank] = OMIT, to_rank: typing.Optional[ToRank] = OMIT, is_headline: typing.Optional[IsHeadline] = OMIT, is_opinion: typing.Optional[IsOpinion] = OMIT, is_paid_content: typing.Optional[IsPaidContent] = OMIT, parent_url: typing.Optional[ParentUrl] = OMIT, all_links: typing.Optional[AllLinks] = OMIT, all_domain_links: typing.Optional[AllDomainLinks] = OMIT, word_count_min: typing.Optional[WordCountMin] = OMIT, word_count_max: typing.Optional[WordCountMax] = OMIT, page: typing.Optional[Page] = OMIT, page_size: typing.Optional[PageSize] = OMIT, include_nlp_data: typing.Optional[IncludeNlpData] = OMIT, has_nlp: typing.Optional[HasNlp] = OMIT, theme: typing.Optional[Theme] = OMIT, not_theme: typing.Optional[NotTheme] = OMIT, ner_name: typing.Optional[NerName] = OMIT, title_sentiment_min: typing.Optional[TitleSentimentMin] = OMIT, title_sentiment_max: typing.Optional[TitleSentimentMax] = OMIT, content_sentiment_min: typing.Optional[ContentSentimentMin] = OMIT, content_sentiment_max: typing.Optional[ContentSentimentMax] = OMIT, iptc_tags: typing.Optional[IptcTags] = OMIT, not_iptc_tags: typing.Optional[NotIptcTags] = OMIT, iab_tags: typing.Optional[IabTags] = OMIT, not_iab_tags: typing.Optional[NotIabTags] = OMIT, custom_tags: typing.Optional[CustomTags] = OMIT) -> AuthorsPostResponse:
        """
        Searches for articles by author. You can filter results by language, country, source, and more.
        
        Parameters:
            - author_name: AuthorName.
            
            - not_author_name: typing.Optional[NotAuthorName].
            
            - predefined_sources: typing.Optional[PredefinedSources].
            
            - sources: typing.Optional[Sources].
            
            - not_sources: typing.Optional[NotSources].
            
            - lang: typing.Optional[Lang].
            
            - not_lang: typing.Optional[NotLang].
            
            - countries: typing.Optional[Countries].
            
            - not_countries: typing.Optional[NotCountries].
            
            - from: typing.Optional[From].
            
            - to: typing.Optional[To].
            
            - published_date_precision: typing.Optional[PublishedDatePrecision].
            
            - by_parse_date: typing.Optional[ByParseDate].
            
            - sort_by: typing.Optional[SortBy].
            
            - ranked_only: typing.Optional[RankedOnly].
            
            - from_rank: typing.Optional[FromRank].
            
            - to_rank: typing.Optional[ToRank].
            
            - is_headline: typing.Optional[IsHeadline].
            
            - is_opinion: typing.Optional[IsOpinion].
            
            - is_paid_content: typing.Optional[IsPaidContent].
            
            - parent_url: typing.Optional[ParentUrl].
            
            - all_links: typing.Optional[AllLinks].
            
            - all_domain_links: typing.Optional[AllDomainLinks].
            
            - word_count_min: typing.Optional[WordCountMin].
            
            - word_count_max: typing.Optional[WordCountMax].
            
            - page: typing.Optional[Page].
            
            - page_size: typing.Optional[PageSize].
            
            - include_nlp_data: typing.Optional[IncludeNlpData].
            
            - has_nlp: typing.Optional[HasNlp].
            
            - theme: typing.Optional[Theme].
            
            - not_theme: typing.Optional[NotTheme].
            
            - ner_name: typing.Optional[NerName].
            
            - title_sentiment_min: typing.Optional[TitleSentimentMin].
            
            - title_sentiment_max: typing.Optional[TitleSentimentMax].
            
            - content_sentiment_min: typing.Optional[ContentSentimentMin].
            
            - content_sentiment_max: typing.Optional[ContentSentimentMax].
            
            - iptc_tags: typing.Optional[IptcTags].
            
            - not_iptc_tags: typing.Optional[NotIptcTags].
            
            - iab_tags: typing.Optional[IabTags].
            
            - not_iab_tags: typing.Optional[NotIabTags].
            
            - custom_tags: typing.Optional[CustomTags].
        """
        _request: typing.Dict[str, typing.Any] = {
            "author_name": author_name,
        }
        if not_author_name is not OMIT:
            _request["not_author_name"] = not_author_name
        if predefined_sources is not OMIT:
            _request["predefined_sources"] = predefined_sources
        if sources is not OMIT:
            _request["sources"] = sources
        if not_sources is not OMIT:
            _request["not_sources"] = not_sources
        if lang is not OMIT:
            _request["lang"] = lang
        if not_lang is not OMIT:
            _request["not_lang"] = not_lang
        if countries is not OMIT:
            _request["countries"] = countries
        if not_countries is not OMIT:
            _request["not_countries"] = not_countries
        if from is not OMIT:
            _request["from_"] = from
        if to is not OMIT:
            _request["to_"] = to
        if published_date_precision is not OMIT:
            _request["published_date_precision"] = published_date_precision.value
        if by_parse_date is not OMIT:
            _request["by_parse_date"] = by_parse_date
        if sort_by is not OMIT:
            _request["sort_by"] = sort_by.value
        if ranked_only is not OMIT:
            _request["ranked_only"] = ranked_only
        if from_rank is not OMIT:
            _request["from_rank"] = from_rank
        if to_rank is not OMIT:
            _request["to_rank"] = to_rank
        if is_headline is not OMIT:
            _request["is_headline"] = is_headline
        if is_opinion is not OMIT:
            _request["is_opinion"] = is_opinion
        if is_paid_content is not OMIT:
            _request["is_paid_content"] = is_paid_content
        if parent_url is not OMIT:
            _request["parent_url"] = parent_url
        if all_links is not OMIT:
            _request["all_links"] = all_links
        if all_domain_links is not OMIT:
            _request["all_domain_links"] = all_domain_links
        if word_count_min is not OMIT:
            _request["word_count_min"] = word_count_min
        if word_count_max is not OMIT:
            _request["word_count_max"] = word_count_max
        if page is not OMIT:
            _request["page"] = page
        if page_size is not OMIT:
            _request["page_size"] = page_size
        if include_nlp_data is not OMIT:
            _request["include_nlp_data"] = include_nlp_data
        if has_nlp is not OMIT:
            _request["has_nlp"] = has_nlp
        if theme is not OMIT:
            _request["theme"] = theme
        if not_theme is not OMIT:
            _request["not_theme"] = not_theme
        if ner_name is not OMIT:
            _request["ner_name"] = ner_name
        if title_sentiment_min is not OMIT:
            _request["title_sentiment_min"] = title_sentiment_min
        if title_sentiment_max is not OMIT:
            _request["title_sentiment_max"] = title_sentiment_max
        if content_sentiment_min is not OMIT:
            _request["content_sentiment_min"] = content_sentiment_min
        if content_sentiment_max is not OMIT:
            _request["content_sentiment_max"] = content_sentiment_max
        if iptc_tags is not OMIT:
            _request["iptc_tags"] = iptc_tags
        if not_iptc_tags is not OMIT:
            _request["not_iptc_tags"] = not_iptc_tags
        if iab_tags is not OMIT:
            _request["iab_tags"] = iab_tags
        if not_iab_tags is not OMIT:
            _request["not_iab_tags"] = not_iab_tags
        if custom_tags is not OMIT:
            _request["custom_tags"] = custom_tags
        _response = await self._client_wrapper.httpx_client.request("POST", urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/authors"), 
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60)
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AuthorsPostResponse, _response.json())# type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json())# type: ignore
            )
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json())# type: ignore
            )
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
