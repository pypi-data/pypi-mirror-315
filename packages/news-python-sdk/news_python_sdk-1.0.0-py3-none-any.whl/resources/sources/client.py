# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.request_timeout_error import RequestTimeoutError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.countries import Countries
from ...types.error import Error
from ...types.from_rank import FromRank
from ...types.include_additional_info import IncludeAdditionalInfo
from ...types.is_news_domain import IsNewsDomain
from ...types.lang import Lang
from ...types.news_domain_type import NewsDomainType
from ...types.news_type import NewsType
from ...types.predefined_sources import PredefinedSources
from ...types.source_name import SourceName
from ...types.source_response import SourceResponse
from ...types.source_url import SourceUrl
from ...types.to_rank import ToRank
from .types.sources_get_request_news_domain_type import SourcesGetRequestNewsDomainType

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SourcesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        *,
        lang: typing.Optional[str] = None,
        countries: typing.Optional[str] = None,
        predefined_sources: typing.Optional[str] = None,
        source_name: typing.Optional[str] = None,
        source_url: typing.Optional[str] = None,
        include_additional_info: typing.Optional[bool] = None,
        is_news_domain: typing.Optional[bool] = None,
        news_domain_type: typing.Optional[SourcesGetRequestNewsDomainType] = None,
        news_type: typing.Optional[str] = None,
        from_rank: typing.Optional[int] = None,
        to_rank: typing.Optional[int] = None,
    ) -> SourceResponse:
        """
        Retrieves a list of sources based on specified criteria such as language, country, rank, and more.

        Parameters:
            - lang: typing.Optional[str]. The language(s) of the search.
                                          The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code.
                                          To select multiple languages, use a comma-separated string.

                                          Example: `"en, es"`

                                          To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
            - countries: typing.Optional[str]. The countries where the news publisher is located.
                                               The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
                                               To select multiple countries, use a comma-separated string.

                                               Example: `"US, CA"`

                                               To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
            - predefined_sources: typing.Optional[str]. Predefined top sources per country.

                                                        Format: start with the word `top`, followed by the number of desired sources,
                                                        and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).

                                                        Examples:
                                                        - `"top 100 US"`
                                                        - `"top 33 AT"`
                                                        - `"top 5 GB"`

                                                        Multiple countries can be specified with custom numbers as a comma-separated string.

                                                        Examples:
                                                        - `"top 50 US, top 20 GB"`
                                                        - `"top 33 AT, top 50 IT"`
            - source_name: typing.Optional[str]. Specifies terms to search within the source names.
                                                 To specify multiple terms, use a comma-separated string.

                                                 Example: `"sport, tech"`

                                                 **Note**: The search does not require an exact match and returns all sources that include
                                                 the specified terms anywhere in their names. You can use any word, phrase, or outlet name,
                                                 such as `"sport"`, or `"new york times"`. For example, using `"sport"` as a term returns
                                                 sources like `"Motorsport"`, `"Dot Esport"`, and `"Tuttosport"`.
            - source_url: typing.Optional[str]. The domain(s) of the news publication to search for.

                                                **Caution**:  When specifying the `source_url` parameter,
                                                you can only use `include_additional_info` as an extra parameter.
            - include_additional_info: typing.Optional[bool]. If true, returns the following additional datapoints about each news source:
                                                              - `nb_articles_for_7d`: The number of articles published by the source in the last week.
                                                              - `country`: Source country of origin.
                                                              - `rank`: SEO rank.
                                                              - `is_news_domain`: Boolean indicating if the source is a news domain.
                                                              - `news_domain_type`: Type of news domain (e.g., "Original Content").
                                                              - `news_type`: Category of news (e.g., "General News Outlets").
            - is_news_domain: typing.Optional[bool]. If true, filters results to include only news domains.

            - news_domain_type: typing.Optional[SourcesGetRequestNewsDomainType]. Filters results based on the news domain type.
                                                                                  Possible values are:
                                                                                  - `Original Content`: Sources that produce their own content.
                                                                                  - `Aggregator`: Sources that collect content from various other sources.
                                                                                  - `Press Releases`: Sources primarily publishing press releases.
                                                                                  - `Republisher`: Sources that republish content from other sources.
                                                                                  - `Other`: Sources that don't fit into main categories.
            - news_type: typing.Optional[str]. Filters results based on the news type.
                                               Multiple types can be specified using a comma-separated string.

                                               Example: `"General News Outlets,Tech News and Updates"`

                                               For a complete list of available news types, see [Enumerated parameters > News type](/docs/v3/api-reference/overview/enumerated-parameters#news-type-news-type).
            - from_rank: typing.Optional[int]. The lowest boundary of the rank of a news website to filter by.
                                               Range: `1` to `999999`, where a lower rank indicates a more popular source.
                                               If you set this to `100`, the API includes sources ranked 100 or higher.
            - to_rank: typing.Optional[int]. The highest boundary of the rank of a news website to filter by.
                                             Range: `1` to `999999`, where a lower rank indicates a more popular source.
                                             If you set this to `100`, the API includes sources ranked 100 or lower.---
        from newscatcher.client import NewscatcherApi

        client = NewscatcherApi(
            api_key="YOUR_API_KEY",
        )
        client.sources.get(
            predefined_sources="top 100 US, top 5 GB",
            source_url="bbc.com",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/sources"),
            params=remove_none_from_dict(
                {
                    "lang": lang,
                    "countries": countries,
                    "predefined_sources": predefined_sources,
                    "source_name": source_name,
                    "source_url": source_url,
                    "include_additional_info": include_additional_info,
                    "is_news_domain": is_news_domain,
                    "news_domain_type": news_domain_type,
                    "news_type": news_type,
                    "from_rank": from_rank,
                    "to_rank": to_rank,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SourceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def post(
        self,
        *,
        lang: typing.Optional[Lang] = OMIT,
        countries: typing.Optional[Countries] = OMIT,
        predefined_sources: typing.Optional[PredefinedSources] = OMIT,
        source_name: typing.Optional[SourceName] = OMIT,
        source_url: typing.Optional[SourceUrl] = OMIT,
        include_additional_info: typing.Optional[IncludeAdditionalInfo] = OMIT,
        is_news_domain: typing.Optional[IsNewsDomain] = OMIT,
        news_domain_type: typing.Optional[NewsDomainType] = OMIT,
        news_type: typing.Optional[NewsType] = OMIT,
        from_rank: typing.Optional[FromRank] = OMIT,
        to_rank: typing.Optional[ToRank] = OMIT,
    ) -> SourceResponse:
        """
        Retrieves the list of sources available in the database. You can filter the sources by language, country, and more.

        Parameters:
            - lang: typing.Optional[Lang].

            - countries: typing.Optional[Countries].

            - predefined_sources: typing.Optional[PredefinedSources].

            - source_name: typing.Optional[SourceName].

            - source_url: typing.Optional[SourceUrl].

            - include_additional_info: typing.Optional[IncludeAdditionalInfo].

            - is_news_domain: typing.Optional[IsNewsDomain].

            - news_domain_type: typing.Optional[NewsDomainType].

            - news_type: typing.Optional[NewsType].

            - from_rank: typing.Optional[FromRank].

            - to_rank: typing.Optional[ToRank].
        ---
        from newscatcher import NewsDomainType
        from newscatcher.client import NewscatcherApi

        client = NewscatcherApi(
            api_key="YOUR_API_KEY",
        )
        client.sources.post(
            include_additional_info=True,
            is_news_domain=True,
            news_domain_type=NewsDomainType.ORIGINAL_CONTENT,
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if lang is not OMIT:
            _request["lang"] = lang
        if countries is not OMIT:
            _request["countries"] = countries
        if predefined_sources is not OMIT:
            _request["predefined_sources"] = predefined_sources
        if source_name is not OMIT:
            _request["source_name"] = source_name
        if source_url is not OMIT:
            _request["source_url"] = source_url
        if include_additional_info is not OMIT:
            _request["include_additional_info"] = include_additional_info
        if is_news_domain is not OMIT:
            _request["is_news_domain"] = is_news_domain
        if news_domain_type is not OMIT:
            _request["news_domain_type"] = news_domain_type.value
        if news_type is not OMIT:
            _request["news_type"] = news_type
        if from_rank is not OMIT:
            _request["from_rank"] = from_rank
        if to_rank is not OMIT:
            _request["to_rank"] = to_rank
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/sources"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SourceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncSourcesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        *,
        lang: typing.Optional[str] = None,
        countries: typing.Optional[str] = None,
        predefined_sources: typing.Optional[str] = None,
        source_name: typing.Optional[str] = None,
        source_url: typing.Optional[str] = None,
        include_additional_info: typing.Optional[bool] = None,
        is_news_domain: typing.Optional[bool] = None,
        news_domain_type: typing.Optional[SourcesGetRequestNewsDomainType] = None,
        news_type: typing.Optional[str] = None,
        from_rank: typing.Optional[int] = None,
        to_rank: typing.Optional[int] = None,
    ) -> SourceResponse:
        """
        Retrieves a list of sources based on specified criteria such as language, country, rank, and more.

        Parameters:
            - lang: typing.Optional[str]. The language(s) of the search.
                                          The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code.
                                          To select multiple languages, use a comma-separated string.

                                          Example: `"en, es"`

                                          To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).
            - countries: typing.Optional[str]. The countries where the news publisher is located.
                                               The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code.
                                               To select multiple countries, use a comma-separated string.

                                               Example: `"US, CA"`

                                               To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).
            - predefined_sources: typing.Optional[str]. Predefined top sources per country.

                                                        Format: start with the word `top`, followed by the number of desired sources,
                                                        and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).

                                                        Examples:
                                                        - `"top 100 US"`
                                                        - `"top 33 AT"`
                                                        - `"top 5 GB"`

                                                        Multiple countries can be specified with custom numbers as a comma-separated string.

                                                        Examples:
                                                        - `"top 50 US, top 20 GB"`
                                                        - `"top 33 AT, top 50 IT"`
            - source_name: typing.Optional[str]. Specifies terms to search within the source names.
                                                 To specify multiple terms, use a comma-separated string.

                                                 Example: `"sport, tech"`

                                                 **Note**: The search does not require an exact match and returns all sources that include
                                                 the specified terms anywhere in their names. You can use any word, phrase, or outlet name,
                                                 such as `"sport"`, or `"new york times"`. For example, using `"sport"` as a term returns
                                                 sources like `"Motorsport"`, `"Dot Esport"`, and `"Tuttosport"`.
            - source_url: typing.Optional[str]. The domain(s) of the news publication to search for.

                                                **Caution**:  When specifying the `source_url` parameter,
                                                you can only use `include_additional_info` as an extra parameter.
            - include_additional_info: typing.Optional[bool]. If true, returns the following additional datapoints about each news source:
                                                              - `nb_articles_for_7d`: The number of articles published by the source in the last week.
                                                              - `country`: Source country of origin.
                                                              - `rank`: SEO rank.
                                                              - `is_news_domain`: Boolean indicating if the source is a news domain.
                                                              - `news_domain_type`: Type of news domain (e.g., "Original Content").
                                                              - `news_type`: Category of news (e.g., "General News Outlets").
            - is_news_domain: typing.Optional[bool]. If true, filters results to include only news domains.

            - news_domain_type: typing.Optional[SourcesGetRequestNewsDomainType]. Filters results based on the news domain type.
                                                                                  Possible values are:
                                                                                  - `Original Content`: Sources that produce their own content.
                                                                                  - `Aggregator`: Sources that collect content from various other sources.
                                                                                  - `Press Releases`: Sources primarily publishing press releases.
                                                                                  - `Republisher`: Sources that republish content from other sources.
                                                                                  - `Other`: Sources that don't fit into main categories.
            - news_type: typing.Optional[str]. Filters results based on the news type.
                                               Multiple types can be specified using a comma-separated string.

                                               Example: `"General News Outlets,Tech News and Updates"`

                                               For a complete list of available news types, see [Enumerated parameters > News type](/docs/v3/api-reference/overview/enumerated-parameters#news-type-news-type).
            - from_rank: typing.Optional[int]. The lowest boundary of the rank of a news website to filter by.
                                               Range: `1` to `999999`, where a lower rank indicates a more popular source.
                                               If you set this to `100`, the API includes sources ranked 100 or higher.
            - to_rank: typing.Optional[int]. The highest boundary of the rank of a news website to filter by.
                                             Range: `1` to `999999`, where a lower rank indicates a more popular source.
                                             If you set this to `100`, the API includes sources ranked 100 or lower.---
        from newscatcher.client import AsyncNewscatcherApi

        client = AsyncNewscatcherApi(
            api_key="YOUR_API_KEY",
        )
        await client.sources.get(
            predefined_sources="top 100 US, top 5 GB",
            source_url="bbc.com",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/sources"),
            params=remove_none_from_dict(
                {
                    "lang": lang,
                    "countries": countries,
                    "predefined_sources": predefined_sources,
                    "source_name": source_name,
                    "source_url": source_url,
                    "include_additional_info": include_additional_info,
                    "is_news_domain": is_news_domain,
                    "news_domain_type": news_domain_type,
                    "news_type": news_type,
                    "from_rank": from_rank,
                    "to_rank": to_rank,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SourceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def post(
        self,
        *,
        lang: typing.Optional[Lang] = OMIT,
        countries: typing.Optional[Countries] = OMIT,
        predefined_sources: typing.Optional[PredefinedSources] = OMIT,
        source_name: typing.Optional[SourceName] = OMIT,
        source_url: typing.Optional[SourceUrl] = OMIT,
        include_additional_info: typing.Optional[IncludeAdditionalInfo] = OMIT,
        is_news_domain: typing.Optional[IsNewsDomain] = OMIT,
        news_domain_type: typing.Optional[NewsDomainType] = OMIT,
        news_type: typing.Optional[NewsType] = OMIT,
        from_rank: typing.Optional[FromRank] = OMIT,
        to_rank: typing.Optional[ToRank] = OMIT,
    ) -> SourceResponse:
        """
        Retrieves the list of sources available in the database. You can filter the sources by language, country, and more.

        Parameters:
            - lang: typing.Optional[Lang].

            - countries: typing.Optional[Countries].

            - predefined_sources: typing.Optional[PredefinedSources].

            - source_name: typing.Optional[SourceName].

            - source_url: typing.Optional[SourceUrl].

            - include_additional_info: typing.Optional[IncludeAdditionalInfo].

            - is_news_domain: typing.Optional[IsNewsDomain].

            - news_domain_type: typing.Optional[NewsDomainType].

            - news_type: typing.Optional[NewsType].

            - from_rank: typing.Optional[FromRank].

            - to_rank: typing.Optional[ToRank].
        ---
        from newscatcher import NewsDomainType
        from newscatcher.client import AsyncNewscatcherApi

        client = AsyncNewscatcherApi(
            api_key="YOUR_API_KEY",
        )
        await client.sources.post(
            include_additional_info=True,
            is_news_domain=True,
            news_domain_type=NewsDomainType.ORIGINAL_CONTENT,
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if lang is not OMIT:
            _request["lang"] = lang
        if countries is not OMIT:
            _request["countries"] = countries
        if predefined_sources is not OMIT:
            _request["predefined_sources"] = predefined_sources
        if source_name is not OMIT:
            _request["source_name"] = source_name
        if source_url is not OMIT:
            _request["source_url"] = source_url
        if include_additional_info is not OMIT:
            _request["include_additional_info"] = include_additional_info
        if is_news_domain is not OMIT:
            _request["is_news_domain"] = is_news_domain
        if news_domain_type is not OMIT:
            _request["news_domain_type"] = news_domain_type.value
        if news_type is not OMIT:
            _request["news_type"] = news_type
        if from_rank is not OMIT:
            _request["from_rank"] = from_rank
        if to_rank is not OMIT:
            _request["to_rank"] = to_rank
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/sources"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SourceResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 408:
            raise RequestTimeoutError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
