# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.datetime_utils import serialize_datetime
from .authors import Authors
from .dto_additional_domain_info import DtoAdditionalDomainInfo
from .dto_responses_author_search_response_article_result_all_domain_links import (
    DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks,
)
from .dto_responses_author_search_response_article_result_all_links import (
    DtoResponsesAuthorSearchResponseArticleResultAllLinks,
)
from .journalists import Journalists
from .nlp_data_entity import NlpDataEntity

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class DtoResponsesAuthorSearchResponseArticleResult(pydantic.BaseModel):
    """
    The data model representing a single article in the search results.
    """

    title: str = pydantic.Field(description="The title of the article.")
    author: typing.Optional[str] = pydantic.Field(description="The primary author of the article.")
    authors: typing.Optional[Authors] = pydantic.Field(description="A list of authors of the article.")
    journalists: typing.Optional[Journalists] = pydantic.Field(
        description="A list of journalists associated with the article."
    )
    published_date: typing.Optional[str] = pydantic.Field(description="The date the article was published.")
    published_date_precision: typing.Optional[str] = pydantic.Field(description="The precision of the published date.")
    updated_date: typing.Optional[str] = pydantic.Field(description="The date the article was last updated.")
    updated_date_precision: typing.Optional[str] = pydantic.Field(description="The precision of the updated date.")
    parse_date: typing.Optional[str] = pydantic.Field(description="The date the article was parsed.")
    link: str = pydantic.Field(description="The URL link to the article.")
    domain_url: str = pydantic.Field(description="The domain URL of the article.")
    full_domain_url: str = pydantic.Field(description="The full domain URL of the article.")
    name_source: typing.Optional[str] = pydantic.Field(
        description="The name of the source where the article was published."
    )
    is_headline: typing.Optional[bool] = pydantic.Field(description="Indicates if the article is a headline.")
    paid_content: typing.Optional[bool] = pydantic.Field(description="Indicates if the article is paid content.")
    extraction_data: typing.Optional[str] = pydantic.Field(description="The data extracted from the article.")
    country: typing.Optional[str] = pydantic.Field(description="The country where the article was published.")
    rights: typing.Optional[str] = pydantic.Field(description="The rights information for the article.")
    rank: int = pydantic.Field(description="The rank of the article's source.")
    media: typing.Optional[str] = pydantic.Field(description="The media associated with the article.")
    language: typing.Optional[str] = pydantic.Field(description="The language in which the article is written.")
    description: typing.Optional[str] = pydantic.Field(description="A brief description of the article.")
    content: str = pydantic.Field(description="The content of the article.")
    word_count: typing.Optional[int] = pydantic.Field(description="The word count of the article.")
    is_opinion: typing.Optional[bool] = pydantic.Field(description="Indicates if the article is an opinion piece.")
    twitter_account: typing.Optional[str] = pydantic.Field(
        description="The Twitter account associated with the article."
    )
    all_links: typing.Optional[DtoResponsesAuthorSearchResponseArticleResultAllLinks] = pydantic.Field(
        description="A list of all URLs mentioned in the article."
    )
    all_domain_links: typing.Optional[DtoResponsesAuthorSearchResponseArticleResultAllDomainLinks] = pydantic.Field(
        description="A list of all domain URLs mentioned in the article."
    )
    nlp: typing.Optional[NlpDataEntity]
    id: str = pydantic.Field(description="The unique identifier for the article.")
    score: float = pydantic.Field(description="The relevance score of the article.")
    custom_tags: typing.Optional[typing.Dict[str, typing.List[str]]] = pydantic.Field(
        description="An object that contains custom tags associated with an article, where each key is a taxonomy name, and the value is an array of tags."
    )
    additional_domain_info: typing.Optional[DtoAdditionalDomainInfo]

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
