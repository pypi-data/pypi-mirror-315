void random_edge(int n, int& i, int& j, bool allow_loops = false) {
  do {
    long long k = random_value(0ll, (long long)n*n-1);
    i = k / n; j = k % n;
  } while (!allow_loops && i == j);
}

// generate a random directed tree with n nodes
// node degrees can be limited
vector<pair<int, int>> random_tree(int n, int maxDeg = -1) {
  assert(maxDeg == -1 || (1 <= maxDeg && maxDeg < n));
  // no limit for node degrees
  if (maxDeg == -1)
    maxDeg = n;
  // degree of every node -- number of its children
  vector<int> degree(n, 0);
  vector<pair<int, int>> edges;
  // add n-1 edges
  for (int i = 1; i <= n-1; i++) {
    while (true) {
      // assign a random parent to each new node
      int parent = random_value(0, i-1);
      if (degree[parent] == maxDeg)
        continue;
      edges.emplace_back(parent, i);
      degree[parent]++;
      break;
    }
  }
  return edges;
}

// a given tree is oriented (orientation is determined by specifying the root)  
vector<pair<int, int>> rooted_tree(const vector<pair<int, int>>& tree, int root) {
  // number of edges and nodes
  int m = tree.size();
  int n = m + 1;
  vector<pair<int, int>> edges;
  edges.reserve(n);
  // represent unoriented tree by neigbours lists
  vector<vector<int>> nbr(n);
  for (const auto& p : tree) {
    nbr[p.first].push_back(p.second);
    nbr[p.second].push_back(p.first);
  }
  // perform a DFS traversal starting from the root
  vector<bool> visited(n);
  stack<int> st;
  st.push(root);
  visited[root] = true;
  while (!st.empty()) {
    int c = st.top(); st.pop();
    for (int s : nbr[c])
      if (!visited[s]) {
        st.push(s);
        visited[s] = true;
        edges.emplace_back(c, s);
      }
  }
  return edges;
}

// generate a random undirected graph with n nodes and m edges
// self-loops can be disallowed
vector<pair<int, int>> random_undirected_graph(int n, int m, bool allow_loops = false) {
  long long maxEdges = (long long)n*(n+1)/2 - (allow_loops ? 0 : n);
  assert(0 <= m && m <= maxEdges);
  if (m < maxEdges / 2) {
    // sparse graphs are generated by including random edges
    set<pair<int, int>> include_edges;
    while (include_edges.size() < m) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      if (i > j) swap(i, j);
      include_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges(begin(include_edges), end(include_edges));
    return edges;
  } else {
    // dense graphs are generated by excluding random edges (from a full graph)
    set<pair<int, int>> exclude_edges;
    while (exclude_edges.size() + m < maxEdges) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      if (i > j) swap(i, j);
      exclude_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges;
    for (int j = 0; j < n; j++)
      for (int i = 0; i <= j; i++) {
        if (!allow_loops && i == j)
          continue;
        if (exclude_edges.find(make_pair(i, j)) == exclude_edges.end())
          edges.emplace_back(i, j);
      }
    return edges;
  }
}

// generate a random directed graph with n nodes and m edges
// self-loops can be disallowed
vector<pair<int, int>> random_directed_graph(int n, int m, bool allow_loops = false) {
  // number of edges must be within its theoretical limits

  int maxEdges = (long long)n*n-(allow_loops ? 0 : n);
  assert(0 <= m && m <= maxEdges);

  if (m < maxEdges / 2) {
    // sparse graphs are generated by including random edges
    set<pair<int, int>> include_edges;
    while (include_edges.size() < m) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      include_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges(begin(include_edges), end(include_edges));
    return edges;
  } else {
    // dense graphs are generated by excluding random edges (from a full graph)
    set<pair<int, int>> exclude_edges;
    while (exclude_edges.size() + m < maxEdges) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      exclude_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges;
    for (int j = 0; j < n; j++)
      for (int i = 0; i < n; i++) {
        if (!allow_loops && i == j)
          continue;
        if (exclude_edges.find(make_pair(i, j)) == exclude_edges.end())
          edges.emplace_back(i, j);
      }
    return edges;
  }
}


// generate a random connected undirected graph with n nodes and m edges
// self-loops can be disallowed
vector<pair<int, int>> random_connected_undirected_graph(int n, int m, bool allow_loops = false) {
  // each connected graph must have between n-1 and n*(n-1)/2 edges
  long long maxEdges = (long long)n*(n+1)/2 - (allow_loops ? 0 : n);
  assert(n-1 <= m && m <= maxEdges);
  
  // connectivity is ensured by including nodes of a randomly generated tree 
  vector<pair<int, int>> tree = random_tree(n);

  if (m < maxEdges / 2) {
    // sparse graphs are generated by including random edges
    set<pair<int, int>> include_edges(begin(tree), end(tree));
    while (include_edges.size() < m) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      if (i > j)
        swap(i, j);
      include_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges(begin(include_edges), end(include_edges));
    return edges;
  } else {
    // dense graphs are generated by excluding random edges (from a full graph)
    set<pair<int, int>> tree_edges(begin(tree), end(tree));
    set<pair<int, int>> exclude_edges;
    while (exclude_edges.size() + m < maxEdges) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      if (i > j)
        swap(i, j);
      if (tree_edges.find(make_pair(i, j)) == tree_edges.end())
        exclude_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges;
    for (int j = 0; j < n; j++)
      for (int i = 0; i <= j; i++) {
        if (!allow_loops && i == j)
          continue;
        if (exclude_edges.find(make_pair(i, j)) == exclude_edges.end())
          edges.emplace_back(i, j);
      }
    return edges;
  }
}

// generate a random connected directed graph with n nodes and m edges,
// ensuring that all vertices are reachable from a given root
vector<pair<int, int>> random_connected_directed_graph(int n, int m, int root, bool allow_loops = false) {
  // each connected graph must have between n-1 and n*(n-1)/2 edges
  long long maxEdges = (long long)n*n - (allow_loops ? 0 : n);
  assert(n-1 <= m && m <= maxEdges);
  
  // connectivity is ensured by including nodes of a randomly generated rootet tree
  vector<pair<int, int>> tree = rooted_tree(random_tree(n), root);

  if (m < maxEdges / 2) {
    // sparse graphs are generated by including random edges
    set<pair<int, int>> include_edges(begin(tree), end(tree));
    while (include_edges.size() < m) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      include_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges(begin(include_edges), end(include_edges));
    return edges;
  } else {
    // dense graphs are generated by excluding random edges (from a full graph)
    set<pair<int, int>> tree_edges(begin(tree), end(tree));
    set<pair<int, int>> exclude_edges;
    while (exclude_edges.size() + m < maxEdges) {
      int i, j;
      random_edge(n, i, j, allow_loops);
      if (tree_edges.find(make_pair(i, j)) == tree_edges.end())
        exclude_edges.emplace(i, j);
    }
    vector<pair<int, int>> edges;
    for (int j = 0; j < n; j++)
      for (int i = 0; i < n; i++) {
        if (!allow_loops && i == j)
          continue;
        if (exclude_edges.find(make_pair(i, j)) == exclude_edges.end())
          edges.emplace_back(i, j);
      }
    return edges;
  }
}

vector<pair<int, int>> relabelNodes(int n, const vector<pair<int, int>>& edges) {
  // a random permutation of [0, n) used to relabel the nodes
  vector<int> perm(n);
  iota(begin(perm), end(perm), 0);
  random_shuffle(begin(perm), end(perm));
  
  // generate and return the relabeled edges
  vector<pair<int, int>> relabeledEdges;
  for (const auto& p : edges)
    relabeledEdges.emplace_back(perm[p.first], perm[p.second]);
  
  return relabeledEdges;
}

// generate a random directed acyclic graph with n nodes and m vertices
vector<pair<int, int>> random_directed_acyclic_graph(int n, int m) {
  vector<pair<int, int>> edges = random_undirected_graph(n, m);
  // ensure that all edges are oriented to go from a lower to a higher number
  // giving acyclicity of the directed graph
  for (auto& p : edges)
    if (p.first > p.second)
      swap(p.first, p.second);
  return relabelNodes(n, edges);
}

// adds random weights to all graph edges
template<class T>
vector<tuple<int, int, T>> add_random_weights(const vector<pair<int, int>>& edges,
                                              T min, T max) {
  vector<tuple<int, int, T>> result;
  result.reserve(edges.size());
  for (const auto& p : edges)
    result.emplace_back(p.first, p.second, random_value(min, max));
  return result;
}

// prints graph with n nodes and give edges to the output stream ostr
// index of the first node can be specified (it is usually either 0 or 1)
// if one_line_header is true, number of nodes and edges are printed in a single line
void print_graph(int n, const vector<pair<int, int>>& edges, ostream& ostr,
                 int node_index = 0, bool one_line_header = false) {
  ostr << n;
  if (one_line_header) ostr << " ";
  else ostr << endl;
  ostr << edges.size() << endl;
  for (const auto& p : edges)
    ostr << p.first + node_index << " " << p.second + node_index << endl;
}

// prints weighted graph with n nodes and give edges to the output stream ostr
// index of the first node can be specified (it is usually either 0 or 1)
// if one_line_header is true, number of nodes and edges are printed in a single line
template<class T>                                                
void print_weighted_graph(int n, const vector<tuple<int, int, T>>& edges, ostream& ostr,
                          int node_index = 0, bool one_line_header = false) {
  ostr << n;
  if (one_line_header) ostr << " ";
  else ostr << endl;
  ostr << edges.size() << endl;
  for (const auto& t : edges)
    ostr << get<0>(t) + node_index << " " << get<1>(t) + node_index << " " << get<2>(t) << endl;
}
