from typing import TypeAlias, overload

import numpy as np
import optype.numpy as onp

_Inexact0D: TypeAlias = np.float64 | np.complex128
_InexactND: TypeAlias = onp.ArrayND[np.float64 | np.complex128]

@overload
def spherical_jn(n: onp.ToInt, z: onp.ToFloat, derivative: bool = False) -> np.float64: ...
@overload
def spherical_jn(n: onp.ToInt, z: onp.ToComplex, derivative: bool = False) -> _Inexact0D: ...
@overload
def spherical_jn(n: onp.ToInt, z: onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_jn(n: onp.ToIntND, z: onp.ToFloat | onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_jn(n: onp.ToInt, z: onp.ToComplexND, derivative: bool = False) -> _InexactND: ...
@overload
def spherical_jn(n: onp.ToIntND, z: onp.ToComplex | onp.ToComplexND, derivative: bool = False) -> _InexactND: ...

#
@overload
def spherical_yn(n: onp.ToInt, z: onp.ToFloat, derivative: bool = False) -> np.float64: ...
@overload
def spherical_yn(n: onp.ToInt, z: onp.ToComplex, derivative: bool = False) -> _Inexact0D: ...
@overload
def spherical_yn(n: onp.ToInt, z: onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_yn(n: onp.ToIntND, z: onp.ToFloat | onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_yn(n: onp.ToInt, z: onp.ToComplexND, derivative: bool = False) -> _InexactND: ...
@overload
def spherical_yn(n: onp.ToIntND, z: onp.ToComplex | onp.ToComplexND, derivative: bool = False) -> _InexactND: ...

#
@overload
def spherical_in(n: onp.ToInt, z: onp.ToFloat, derivative: bool = False) -> np.float64: ...
@overload
def spherical_in(n: onp.ToInt, z: onp.ToComplex, derivative: bool = False) -> _Inexact0D: ...
@overload
def spherical_in(n: onp.ToInt, z: onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_in(n: onp.ToIntND, z: onp.ToFloat | onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_in(n: onp.ToInt, z: onp.ToComplexND, derivative: bool = False) -> _InexactND: ...
@overload
def spherical_in(n: onp.ToIntND, z: onp.ToComplex | onp.ToComplexND, derivative: bool = False) -> _InexactND: ...

#
@overload
def spherical_kn(n: onp.ToInt, z: onp.ToFloat, derivative: bool = False) -> np.float64: ...
@overload
def spherical_kn(n: onp.ToInt, z: onp.ToComplex, derivative: bool = False) -> _Inexact0D: ...
@overload
def spherical_kn(n: onp.ToInt, z: onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_kn(n: onp.ToIntND, z: onp.ToFloat | onp.ToFloatND, derivative: bool = False) -> onp.ArrayND[np.float64]: ...
@overload
def spherical_kn(n: onp.ToInt, z: onp.ToComplexND, derivative: bool = False) -> _InexactND: ...
@overload
def spherical_kn(n: onp.ToIntND, z: onp.ToComplex | onp.ToComplexND, derivative: bool = False) -> _InexactND: ...
