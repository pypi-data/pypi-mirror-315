from abc import ABC, abstractmethod
from datetime import datetime
from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, ConfigDict

from liminal.enums import BenchlingReportLevel

if TYPE_CHECKING:
    from liminal.orm.base_model import BaseModel as BaseModelBenchling


class BenchlingValidatorReport(BaseModel):
    """
    Represents a report generated by a Benchling validator.

    Attributes
    ----------
    valid : bool
        Indicates whether the validation passed or failed.
    model : str
        The name of the model being validated. (eg: NGSSample)
    level : BenchlingReportLevel
        The severity level of the validation report.
    validator_name : str | None
        The name of the validator that generated this report. (eg: BioContextValidator)
    entity_id : str | None
        The ID of the entity being validated.
    registry_id : str | None
        The ID of the registry associated with the entity.
    entity_name : str | None
        The name of the entity being validated.
    message : str | None
        A message describing the result of the validation.
    creator_name : str | None
        The name of the creator of the entity being validated.
    creator_email : str | None
        The email of the creator of the entity being validated.
    updated_date : datetime | None
        The date the entity was last updated.
    **kwargs: Any
        Additional metadata to include in the report.
    """

    valid: bool
    model: str
    level: BenchlingReportLevel
    validator_name: str | None = None
    entity_id: str | None = None
    registry_id: str | None = None
    entity_name: str | None = None
    web_url: str | None = None
    message: str | None = None
    creator_name: str | None = None
    creator_email: str | None = None
    updated_date: datetime | None = None

    model_config = ConfigDict(extra="allow")


class BenchlingValidator(ABC):
    """Base class for benchling validators."""

    def __str__(self) -> str:
        return self.__class__.__name__ + "()"

    def _prefix(self) -> str:
        """Creates a prefix for the formatted error message which includes the class name and any instance variables.
        Ex: "BenchlingValidator(field_name=sample_code, field_value=123):"
        """
        prefix = f"{self.__class__.__name__}"
        if vars(self):
            prefix += "("
            for key, val in vars(self).items():
                prefix += f"{key}={self.truncate_msg(val, max_len=50)}, "
            prefix = prefix[:-2] + "):"
        else:
            prefix += ":"
        return prefix

    @abstractmethod
    def validate(self, entity: type["BaseModelBenchling"]) -> BenchlingValidatorReport:
        """Abstract method that all validator subclass must implement. Each subclass will have a differently defined validation
        function that runs on the given benchling entity.

        Parameters
        ----------
        entity : type["BaseModelBenchling"]
            The Benchling entity to validate.

        Returns
        -------
        BenchlingValidatorReport
            A report indicating whether the validation passed or failed, and any additional metadata.
        """
        raise NotImplementedError

    def __getattribute__(self, name: str) -> Any:
        attr = super().__getattribute__(name)
        if name == "validate":
            # Wrap the validate method in a try-except block to catch any unexpected errors that occur during validation.
            # If an unexpected error occurs, return a BenchlingValidatorReport with the unexpected error message.
            def try_except_wrapped_func(
                *args: Any, **kwargs: dict
            ) -> BenchlingValidatorReport:
                try:
                    return attr(*args, **kwargs)
                except Exception as e:
                    entity: type[BaseModelBenchling] = args[0]
                    return BenchlingValidatorReport(
                        valid=False,
                        model=entity.__class__.__name__,
                        validator_name=self.__class__.__name__,
                        level=BenchlingReportLevel.UNEXPECTED,
                        entity_id=entity.id,
                        registry_id=entity.file_registry_id,
                        entity_name=entity.name,
                        web_url=entity.url if entity.url else None,
                        creator_name=entity.creator.name if entity.creator else None,
                        creator_email=entity.creator.email if entity.creator else None,
                        updated_date=entity.modified_at,
                        message=f"Unexpected exception: {e}",
                    )

            return try_except_wrapped_func
        return attr

    @classmethod
    def create_report(
        cls,
        valid: bool,
        level: BenchlingReportLevel,
        entity: type["BaseModelBenchling"],
        message: str | None = None,
        **kwargs: Any,
    ) -> BenchlingValidatorReport:
        """Creates a BenchlingValidatorReport with the given parameters."""
        return BenchlingValidatorReport(
            valid=valid,
            level=level,
            model=entity.__class__.__name__,
            validator_name=cls.__name__,
            entity_id=entity.id,
            registry_id=entity.file_registry_id,
            entity_name=entity.name,
            web_url=entity.url,
            creator_name=entity.creator.name if entity.creator else None,
            creator_email=entity.creator.email if entity.creator else None,
            updated_date=entity.modified_at,
            message=message,
            **kwargs,
        )

    def format_err(self, *msgs: str | None) -> str:
        """Creates a formatted error message from the given messages. The first message is prefixed with the class name and any instance variables.
        Ex: "BenchlingValidator(field_name=sample_code, field_value=123): The field value is invalid | The field value is too long"
        """
        ret_val = ""
        for ind, msg in enumerate(msgs):
            if ind == 0:
                if (msg is None) or (msg == ""):
                    continue
                elif not msg.startswith(self._prefix()):
                    ret_val += f"{self._prefix()} {msg}"
                else:
                    ret_val += f"{msg}"
            elif ((msgs[0] is None) or (msgs[0] == "")) and (ind == 1):
                ret_val += f"{self._prefix()} {msg}"
            else:
                ret_val += f" | {msg}"
        return ret_val

    def truncate_msg(self, msg: Any, max_len: int = 150) -> str:
        """Shortens the given message to the given max length. If the message is longer than the max length, it is truncated and an ellipsis is added to the end."""
        msg = str(msg)
        if len(msg) > max_len:
            return f"{msg[:max_len]}..."
        return msg
