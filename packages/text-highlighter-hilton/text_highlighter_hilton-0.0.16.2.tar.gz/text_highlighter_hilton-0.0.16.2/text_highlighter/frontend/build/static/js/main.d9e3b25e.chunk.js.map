{"version":3,"sources":["TextHighlighter.tsx","index.tsx"],"names":["MyComponent","state","tag","isFocused","render","annotations","props","args","colors","labels","text","selected_label","show_label_selector","text_height","strip_whitespace","theme","style","borderStyling","primaryColor","border","outline","initial","value","setState","className","map","label","index","key","backgroundColor","onClick","paddingBottom","lineHeight","height","overflowY","content","onChange","updateState","getSpan","span","color","indexOf","mergeAnnotations","filter","annotation","isNaN","start","end","annotation1","isOverlapping","otherAnnotation","annotation2","newAnnotations","annotation3","push","callback","trimmedValue","mergedValue","Streamlit","setComponentValue","_onFocus","_onBlur","StreamlitComponentBase","withStreamlitConnection","ReactDOM","TextHighlighter","document","getElementById"],"mappings":"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","file":"static/js/main.d9e3b25e.chunk.js","sourcesContent":["import {\n  Streamlit,\n  StreamlitComponentBase,\n  withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\nimport { TextAnnotator } from 'react-text-annotate'\nimport { State } from 'react-powerplug'\nimport \"./style.css\"\n\ninterface BaseState {\n  isFocused: boolean,\n  tag: string,\n}\n\n/**\n * This is a React-based component template. The `render()` function is called\n * automatically when your component should be re-rendered.\n */\nclass MyComponent extends StreamlitComponentBase<BaseState> {\n  public state = { tag: '', isFocused: false }\n\n  public render = (): ReactNode => {\n    // Arguments that are passed to the plugin in Python are accessible\n    // via `this.props.args`. Here, we access the \"name\" arg.\n    const annotations = this.props.args[\"annotations\"]\n    const colors = this.props.args[\"colors\"]\n    const labels = this.props.args[\"labels\"]\n    const text = this.props.args[\"text\"]\n    const selected_label = this.props.args[\"selected_label\"]\n    const show_label_selector = this.props.args[\"show_label_selector\"]\n    const text_height = this.props.args[\"text_height\"]\n    const strip_whitespace = this.props.args[\"strip_whitespace\"]\n\n    // Streamlit sends us a theme object via props that we can use to ensure\n    // that our component has visuals that match the active theme in a\n    // streamlit app.\n    const { theme } = this.props\n    const style: React.CSSProperties = {}\n\n    // Maintain compatibility with older versions of Streamlit that don't send\n    // a theme object.\n    if (theme) {\n      // Use the theme object to style our button border. Alternatively, the\n      // theme style is defined in CSS vars.\n      const borderStyling = `1px solid ${this.state.isFocused ? theme.primaryColor : \"gray\"\n        }`\n      style.border = borderStyling\n      style.outline = borderStyling\n    }\n\n    // Show a button and some text.\n    // When the button is clicked, we'll increment our \"numClicks\" state\n    // variable, and send its new value back to Streamlit, where it'll\n    // be available to the Python program.\n    // initial={{ value: [{ start: 18, end: 28, tag: 'PERSON' }], tag: 'PERSON' }}\n    return (\n      <State initial={{ value: annotations, tag: selected_label }}>\n        {({ state, setState }) => (\n          <span>\n            {show_label_selector && <span className=\"label-selector\">{\n              labels.map((label: any, index: number) => (\n                  <span\n                      key={label}\n                      className={`label-pill ${state.tag === label ? 'selected' : 'deselected'}`}\n                      style={{backgroundColor: colors[index]}}\n                      onClick={() => setState({tag: label})}\n                  >\n                {label}\n                </span>\n              ))\n            }</span>}\n\n            <TextAnnotator\n              style={{\n                paddingBottom: '8px',\n                lineHeight: 1.5,\n                height: text_height + 'px',\n                overflowY: 'scroll'\n              }}\n              content={text}\n              value={state.value}\n              onChange={(value: any) => this.updateState(value, setState, strip_whitespace)}\n              getSpan={span => ({\n                ...span,\n                tag: state.tag,\n                color: colors[labels.indexOf(state.tag)],\n              })}\n            />\n          </span>\n        )}\n      </State>\n\n    )\n  }\n\n  private mergeAnnotations = (annotations: any[]) => {\n    // Remove all annotations which are a subannotation of another annotation;\n    // which means that annotation2.start >= annotation1.start and annotation2.end <= annotation1.end\n    // Remove any annotations with start NaN or end NaN\n    annotations = annotations.filter((annotation: any) => !isNaN(annotation.start) && !isNaN(annotation.end));\n    for (const annotation1 of annotations) {\n      var isOverlapping = false;\n      let otherAnnotation = null;\n      for (const annotation2 of annotations) {\n        if (annotation1.start === annotation2.start && annotation1.end === annotation2.end) continue;\n        if ((annotation2.start <= annotation1.start && annotation2.end >= annotation1.start) || (annotation2.start <= annotation1.end && annotation2.end >= annotation1.end)) {\n          isOverlapping = true;\n          otherAnnotation = annotation2;\n          break;\n        }\n      }\n      if (isOverlapping) {\n        const newAnnotations = [];\n        for (const annotation3 of annotations) {\n          if (annotation3.start !== annotation1.start && annotation3.end !== annotation1.end && annotation3.start !== otherAnnotation?.start && annotation3.end !== otherAnnotation?.end) {\n            newAnnotations.push(annotation3);\n          }\n        }\n        // Deselect both annotation1 and otherannotation\n        return newAnnotations;\n      }\n    }\n    return annotations;\n  }\n\n  private updateState = (value: any, callback: any, strip_whitespace: boolean): void => {\n    const text = this.props.args[\"text\"];\n    let trimmedValue = value;\n\n    // Trim leading/trailing spaces by adjusting start/end indices\n    if (strip_whitespace) {\n        trimmedValue = value.map((annotation: any) => {\n        let {start, end} = annotation;\n\n        // Trim leading spaces\n        while (start < end && text[start] === ' ') {\n          start += 1;\n        }\n\n        // Trim trailing spaces\n        while (end > start && text[end - 1] === ' ') {\n          end -= 1;\n        }\n\n        return {...annotation, start, end};\n      });\n    }\n\n    const mergedValue = this.mergeAnnotations(trimmedValue);\n    callback({ value: mergedValue });\n    Streamlit.setComponentValue(mergedValue);\n  }\n\n  /** Focus handler for our \"Click Me!\" button. */\n  private _onFocus = (): void => {\n    this.setState({ isFocused: true })\n  }\n\n  /** Blur handler for our \"Click Me!\" button. */\n  private _onBlur = (): void => {\n    this.setState({ isFocused: false })\n  }\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(MyComponent)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport TextHighlighter from \"./TextHighlighter\"\n\nReactDOM.render(\n  <TextHighlighter />,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}