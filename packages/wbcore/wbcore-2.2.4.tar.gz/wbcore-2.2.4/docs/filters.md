Filters are based on Django-Filters and can mostly be autogenerated from a simple dictionary when using a `wbcore.viewsets.ModelViewSet`. All customized parameters are taken from the attached model and are applied to the filter. When the completely autogenerated filter is not sufficient, a custom `wbcore.filters.FilterSet` can be provided to overwrite filters or set custom filters.

### Setup

Below are two examples on how to set up a rudimentary filter, where both examples yield exactly the same result: Two filters for the field `first_field`, one which filters for exact values, and one which filters for similar values (`SQL: LIKE`).

```python
from wbcore.filters import DjangoFilterBackend
from wbcore.viewsets import ModelViewSet

class XYZModelViewSet(ModelViewSet):
    filter_backends = [DjangoFilterBackend]
    filterset_fields = {
        "first_field": ["exact", "icontains"]
    }
```

```python
from wbcore.filters import DjangoFilterBackend, FilterSet
from wbcore.viewsets import ModelViewSet

class XYZFilterSet(FilterSet):
    class Meta:
        model = XYZ
        fields = {
            "first_field": ["exact", "icontains"]
        }

class XYZModelViewSet(ModelViewSet):
    filter_backends = [DjangoFilterBackend]
    filter_class = XYZFilterSet
```

### Lookup Expressions

!!! warning
    Not all field lookups from [Django](https://docs.djangoproject.com/en/3.0/ref/models/querysets/#field-lookups) are supported yet.

The different lookup expressions that are currently available are:

* `exact`: An exact match against the filtered value (for Text, Number, Dropdown). In SQL `=`
* `icontains`: A loose match against the filtered value (for Text, Number). In SQL `LIKE`
* `gt`: Greater than a value (for Number). In SQL `>`
* `gte`: Greater than or equal to a value (for Number). In SQL `>=`
* `lt`: Less than a value (for Number). In SQL `<`
* `lte`: Less than or equal to a value (for Number). In SQL `<=`

### Custom Filter

As mentioned previously, custom filters are specified in a `wbcore.filters.FilterSet`. There are two different reasons for custom filters:

1. Overwrite the filter method behind a filter
2. Specify filters that are not part of a field of the model

When implementing a custom filter, it is really important that this filter is specified the same as the other filters, as a dictionairy.

``` python
from wbcore.filters import FilterSet, BooleanFilter

class XYZFilterSet(FilterSet):
    non_field_filter = BooleanFilter(label="Non Field", method="get_non_field_filter")

    def get_non_field_filter(self, queryset, name, value):
        if value:
            return qs.filter(some_field=True)
        return qs

    class Meta:
        model = XYZ
        fields = {
            "non_field_filter": ["exact"]
        }

```

Any dedicated model filter fields can take an extra `filter_params` argument (either as a dictionary or a callable) which returns the
dictionary to url encode. Let's recall that the resulting endpoint (and its potential query parameters) are returned to the frontend
and will be used by it to fetch the filter field representation.

Example:

```python
def get_filter_params(request, view):
    return {}

class XXXFilter(wb_filters.FilterSet):
    dedicated_filter = wb_filters.ModelChoiceFilter(
        label="A filter",
        queryset=Model.objects.all(),
        endpoint=Model.get_representation_endpoint(),
        value_key=Model.get_representation_value_key(),
        label_key=Model.get_representation_label_key(),
        filter_params=get_filter_params # or {'key': value},
    )
```
### Remote Filters

In case a viewset needs to define extra filters proposed by another module (dependency), remote filters can be defined using a received to `add_filters`

Example: We have a module XXX and another YYY. YYY introduces a new field (e.g ForeignKey) on XXX and as such, we would like to define
a new filter on XXX viewset (from within YYY module) to avoid circular module dependency from XXX and YYY.

Do not forget to register/import the file where the signals receiver are defined
```python
# YYY.filters.signals
from wbcore.signals.filters import (
    add_filters
)
from wbcore import filters as wb_filters
from django.dispatch import receiver
from xxx.filters import XXXFilter

@receiver(add_filters, sender=CompanyFilter)
def add_xxx_filter(sender, *args, **kwargs):
    def method_x(queryset, name, value):
        if value:
            # do something with the field introduced by the module YYY on XXX
            return queryset # Do something
        return queryset
    return {
        'xxx_filter': wb_filters.BooleanFilter(
            field_name="fitler_name", # important!
            label="XXX filter",
            method=method_x
        )
    }
```
