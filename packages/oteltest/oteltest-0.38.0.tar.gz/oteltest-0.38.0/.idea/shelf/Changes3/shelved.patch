Index: src/oteltest/sink/__init__.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import abc\nimport threading\nfrom concurrent import futures\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\n\nimport grpc  # type: ignore\nfrom opentelemetry.proto.collector.logs.v1 import (  # type: ignore\n    logs_service_pb2_grpc,\n)\nfrom opentelemetry.proto.collector.logs.v1.logs_service_pb2 import (\n    ExportLogsServiceRequest,  # type: ignore\n)\nfrom opentelemetry.proto.collector.metrics.v1 import (  # type: ignore\n    metrics_service_pb2_grpc,\n)\nfrom opentelemetry.proto.collector.metrics.v1.metrics_service_pb2 import (\n    ExportMetricsServiceRequest,  # type: ignore\n)\nfrom opentelemetry.proto.collector.trace.v1 import (  # type: ignore\n    trace_service_pb2_grpc,\n)\nfrom opentelemetry.proto.collector.trace.v1.trace_service_pb2 import (\n    ExportTraceServiceRequest,  # type: ignore\n)\n\nfrom oteltest.sink.private import (\n    _LogsServiceServicer,\n    _MetricsServiceServicer,\n    _TraceServiceServicer,\n)\n\n\nclass RequestHandler(abc.ABC):\n    \"\"\"\n    The RequestHandler interface is meant to be implemented by users of the otelsink API. If you use the API,\n    you'll want to create a RequestHandler implementation, instantiate it, and pass the instance to the GrpcSink\n    constructor. As messages arrive, the callbacks defined by this interface will be invoked.\n\n    grpc_sink = GrpcSink(MyRequestHandler())\n    \"\"\"\n\n    @abc.abstractmethod\n    def handle_logs(self, request: ExportLogsServiceRequest, headers):\n        pass\n\n    @abc.abstractmethod\n    def handle_metrics(self, request: ExportMetricsServiceRequest, headers):\n        pass\n\n    @abc.abstractmethod\n    def handle_trace(self, request: ExportTraceServiceRequest, headers):\n        pass\n\n\nclass GrpcSink:\n    \"\"\"\n    This is an OTel GRPC server to which you can send metrics, traces, and\n    logs. It requires a RequestHandler implementation passed in.\n    \"\"\"\n\n    def __init__(\n        self,\n        request_handler: RequestHandler,\n        max_workers: int = 10,\n        address: str = \"0.0.0.0:4317\",\n    ):\n        self.svr = grpc.server(futures.ThreadPoolExecutor(max_workers=max_workers))\n        trace_service_pb2_grpc.add_TraceServiceServicer_to_server(\n            _TraceServiceServicer(request_handler.handle_trace), self.svr\n        )\n        metrics_service_pb2_grpc.add_MetricsServiceServicer_to_server(\n            _MetricsServiceServicer(request_handler.handle_metrics), self.svr\n        )\n        logs_service_pb2_grpc.add_LogsServiceServicer_to_server(\n            _LogsServiceServicer(request_handler.handle_logs), self.svr\n        )\n        self.svr.add_insecure_port(address)\n        print(f\"- Set up grpc sink at address {address}\")\n\n    def start(self):\n        \"\"\"Starts the server. Does not block.\"\"\"\n        self.svr.start()\n\n    def wait_for_termination(self):\n        \"\"\"Blocks until the server stops.\"\"\"\n        try:\n            self.svr.wait_for_termination()\n        except BaseException:\n            print(\"terminated\")\n\n    def stop(self):\n        \"\"\"Stops the server immediately.\"\"\"\n        self.svr.stop(grace=None)\n\n\nclass HttpSink:\n\n    def __init__(self, listener, port=4318, daemon=True):\n        self.listener = listener\n        self.port = port\n        self.handlers = {\n            \"/v1/traces\": self.handle_trace,\n            \"/v1/metrics\": self.handle_metrics,\n            \"/v1/logs\": self.handle_logs,\n        }\n        self.svr_thread = threading.Thread(target=self.run_server)\n        self.svr_thread.daemon = daemon\n        print(f\"- Set up http sink on port {port}\")\n\n    def start(self):\n        self.svr_thread.start()\n\n    def run_server(self):\n        class Handler(BaseHTTPRequestHandler):\n\n            # noinspection PyPep8Naming\n            def do_POST(this):\n                # /v1/traces\n                content_length = int(this.headers[\"Content-Length\"])\n                post_data = this.rfile.read(content_length)\n\n                otlp_handler_func = self.handlers.get(this.path)\n                if otlp_handler_func:\n                    # noinspection PyArgumentList\n                    otlp_handler_func(\n                        post_data, {k: v for k, v in this.headers.items()}\n                    )\n\n                this.send_response(200)\n                this.send_header(\"Content-type\", \"text/html\")\n                this.end_headers()\n\n                this.wfile.write(\"OK\".encode(\"utf-8\"))\n\n        # noinspection PyTypeChecker\n        httpd = HTTPServer((\"\", self.port), Handler)\n        httpd.serve_forever()\n\n    def handle_trace(self, post_data, headers):\n        req = ExportTraceServiceRequest()\n        req.ParseFromString(post_data)\n        self.listener.handle_trace(req, headers)\n\n    def handle_metrics(self, post_data, headers):\n        req = ExportMetricsServiceRequest()\n        req.ParseFromString(post_data)\n        self.listener.handle_metrics(req, headers)\n\n    def handle_logs(self, post_data, headers):\n        req = ExportLogsServiceRequest()\n        req.ParseFromString(post_data)\n        self.listener.handle_logs(req, headers)\n\n    def stop(self):\n        self.svr_thread.join()\n\n\nclass PrintHandler(RequestHandler):\n    \"\"\"\n    A RequestHandler implementation that prints the received messages.\n    \"\"\"\n\n    def handle_logs(self, request, headers):  # noqa: ARG002\n        print(f\"log request: {request}\", flush=True)  # noqa: T201\n\n    def handle_metrics(self, request, context):  # noqa: ARG002\n        print(f\"metrics request: {request}\", flush=True)  # noqa: T201\n\n    def handle_trace(self, request, context):  # noqa: ARG002\n        print(f\"trace request: {request}\", flush=True)  # noqa: T201\n\n\ndef run_grpc():\n    sink = GrpcSink(PrintHandler())\n    sink.start()\n    sink.wait_for_termination()\n\n\ndef run_http():\n    sink = HttpSink(PrintHandler(), daemon=False)\n    sink.start()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/oteltest/sink/__init__.py b/src/oteltest/sink/__init__.py
--- a/src/oteltest/sink/__init__.py	(revision 5df84b37fed3d72762605d805fb2fc558b02c6b8)
+++ b/src/oteltest/sink/__init__.py	(date 1723661335347)
@@ -63,6 +63,8 @@
         request_handler: RequestHandler,
         max_workers: int = 10,
         address: str = "0.0.0.0:4317",
+        key_file: str = None,
+        cert_file: str = None,
     ):
         self.svr = grpc.server(futures.ThreadPoolExecutor(max_workers=max_workers))
         trace_service_pb2_grpc.add_TraceServiceServicer_to_server(
@@ -74,8 +76,15 @@
         logs_service_pb2_grpc.add_LogsServiceServicer_to_server(
             _LogsServiceServicer(request_handler.handle_logs), self.svr
         )
-        self.svr.add_insecure_port(address)
-        print(f"- Set up grpc sink at address {address}")
+        if key_file and cert_file:
+            server_credentials = grpc.ssl_server_credentials(
+                [(open(key_file, "rb").read(), open(cert_file, "rb").read())]
+            )
+            self.svr.add_secure_port(address, server_credentials)
+            print(f"- Set up secure grpc sink at {address}")
+        else:
+            self.svr.add_insecure_port(address)
+            print(f"- Set up insecure grpc sink at {address}")
 
     def start(self):
         """Starts the server. Does not block."""
