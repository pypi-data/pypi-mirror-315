"""
Quantum Attack Simulator - Receiver Module
------------------------------------------
This module is part of the Quantum Attack Simulator project, licensed under the Apache 2.0 License.
It implements the receiver's actions in the BB84 quantum key distribution protocol, including:

- Measuring incoming qubits.
- Performing key reconciliation with the sender.
- Detecting potential interception or errors during quantum communication.

Original Repository: https://github.com/koraydns/quantum-attack-simulator
License: Apache 2.0 (See LICENSE file for details)

Note:
This module is designed for educational and research purposes. If you modify this file, 
please indicate that changes have been made and retain this notice.

For more details, visit the GitHub repository:
https://github.com/koraydns/quantum-attack-simulator
"""

from qiskit import Aer, execute
import random

def select_random_bases(num_bases):
    """
    Randomly select bases ('Z' or 'X') for quantum state preparation or measurement.

    Parameters:
        num_bases (int): Number of bases to generate.

    Returns:
        str: A string of randomly chosen bases ('Z' or 'X').
    """
    bases_string = ""
    for i in range(num_bases):
        rand_basis = random.randint(0, 1)
        bases_string += "Z" if rand_basis == 0 else "X"
    return bases_string


def measure_quantum_states(qubits, bases):
    """
    Retrieve classical information by analyzing quantum states using specific bases.

    This function performs measurements on quantum states, transforming them into classical bits.
    The choice of measurement basis ('Z' or 'X') determines the process:
    - 'Z' basis extracts information directly in the computational basis.
    - 'X' basis applies a transformation (Hadamard gate) before extracting information.

    Parameters:
        qubits (list): A collection of QuantumCircuit objects representing the quantum states.
        bases (str): A string specifying the bases ('Z' or 'X') for measurements.

    Returns:
        str: A binary string containing the results of the measurements.
    """
    bits = "" 

    for qubit, basis in zip(qubits, bases):

        if basis == "Z":
            qubit.measure(0, 0)
        elif basis == "X":
            qubit.h(0)
            qubit.measure(0, 0)

        # Execute on Simulator
        simulator = Aer.get_backend('qasm_simulator')
        result = execute(qubit, backend=simulator, shots=1).result()
        counts = result.get_counts()
        measured_bit = max(counts, key=counts.get)

        bits += measured_bit

    return bits


def analyze_depolarization_impact(alice_key_bits, bob_key_bits, noise_probability=0.1):
    """
    Determine if differences in keys are caused by depolarization noise or other attacks.

    Parameters:
        alice_key_bits (list): Key bits generated by Alice.
        bob_key_bits (list): Key bits measured by Bob.
        noise_probability (float): Probability of depolarization noise.

    Returns:
        bool: True if mismatches are within acceptable depolarization noise levels, False otherwise.
    """
    mismatches_due_to_noise = sum(
        1 for alice_bit, bob_bit in zip(alice_key_bits, bob_key_bits) if alice_bit != bob_bit
    )
    total_bits = len(alice_key_bits)
    observed_error_rate = mismatches_due_to_noise / total_bits

    print(f"Observed error rate: {observed_error_rate:.2%} (expected <= {noise_probability:.2%})")

    # If observed error rate is below or equal to noise probability, assume it's noise
    if observed_error_rate <= noise_probability:
        print("Differences are likely caused by depolarization noise.")
        return True
    else:
        print("Differences exceed depolarization noise levels and may indicate an attack.")
        return False


def detect_interception(sender_bits, receiver_bits):
    """
    Detect if interception occurred by comparing Sender's and Receiver's bits.

    Parameters:
        sender_bits (str): Bits generated by Sender.
        receiver_bits (str): Bits measured by Receiver.

    Returns:
        bool: True if interception is detected, False otherwise.
    """
    mismatches = sum(1 for a, b in zip(sender_bits, receiver_bits) if a != b)
    if mismatches > 0:
        print(f"An interception detected. Mismatched bits: {mismatches}")
        return True
    else:
        print("Seems no interception. The tested bits of Sender and Receiver are the same.")
        return False
    

def calculate_error_rates(sender_initial_intensities, receiver_intensities):
    """
    Calculate error rates for each intensity level by comparing Sender's and Receiver's intensities.

    Parameters:
        sender_initial_intensities (list): Intensities assigned by Sender.
        receiver_intensities (list): Intensities observed by Receiver.

    Returns:
        dict: Error rates for each intensity level.
    """
    error_counts = {'low': 0, 'medium': 0, 'high': 0, 'lower': 0}
    total_counts = {'low': 0, 'medium': 0, 'high': 0, 'lower': 0}

    for initial, current in zip(sender_initial_intensities, receiver_intensities):
        if initial == "none":  # Skip signal qubits
            continue
        if initial != current:
            error_counts[initial] += 1
        total_counts[initial] += 1

    error_rates = {intensity: error_counts[intensity] / total_counts[intensity]
                   for intensity in total_counts if total_counts[intensity] > 0}
    return error_rates


def check_error_rates(error_rates, threshold=0.1):
    """
    Check if error rates exceed the threshold to detect a PNS attack.

    Parameters:
        error_rates (dict): Error rates for each intensity level.
        threshold (float): Threshold for detecting a PNS attack.

    Returns:
        tuple: True if PNS attack is detected, along with the highest error rate.
    """
    for intensity, rate in error_rates.items():
        if rate > threshold:
            return True, rate  # PNS attack detected
    return False, None  # No PNS attack detected


def generate_key(sender_bits):
    """
    Generate the final key from Sender's bits.

    Parameters:
        sender_bits (list): Bits shared between Sender and Receiver.

    Returns:
        str: Final key generated.
    """
    key = "".join(sender_bits)
    print("\nKey: " + key)
    print("The key is " + str(len(key)) + " bits long.")
    return key
    


