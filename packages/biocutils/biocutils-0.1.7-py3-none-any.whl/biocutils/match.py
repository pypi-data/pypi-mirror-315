from typing import Sequence, Union, Optional
import numpy

from .map_to_index import DUPLICATE_METHOD, map_to_index


def match(
    x: Sequence,
    targets: Union[dict, Sequence],
    duplicate_method: DUPLICATE_METHOD = "first",
    dtype: Optional[numpy.ndarray] = None,
) -> numpy.ndarray:
    """Find a matching value of each element of ``x`` in ``target``.

    Args:
        x: Squence of values to match.

        targets:
            Sequence of targets to be matched against. Alternatively, a
            dictionary generated by passing a sequence of targets to
            :py:meth:`~biocutils.map_to_index.map_to_index`.

        duplicate_method:
            How to handle duplicate entries in ``targets``. Matches can
            be reported to the first or last occurrence of duplicates.

        dtype:
            NumPy type of the output array. This should be an integer type; if
            missing values are expected, the type should be a signed integer.
            If None, a suitable type is automatically determined.

    Returns:
        Array of length equal to ``x``, containing the integer position of each
        entry of ``x`` inside ``target``; or -1, if the entry of ``x`` is
        None or cannot be found in ``target``.
    """
    if not isinstance(targets, dict):
        targets = map_to_index(targets, duplicate_method=duplicate_method)

    if dtype is None:
        dtype = numpy.min_scalar_type(-len(targets)) # get a signed type
    indices = numpy.zeros(len(x), dtype=dtype)

    for i, y in enumerate(x):
        if y not in targets:
            indices[i] = -1
        else:
            indices[i] = targets[y]

    return indices
