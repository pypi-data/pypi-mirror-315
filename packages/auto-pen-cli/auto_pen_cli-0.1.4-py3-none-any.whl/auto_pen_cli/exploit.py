import typer
import requests
from rich import print
from rich.prompt import Prompt
from rich.table import Table
import os
from dotenv import load_dotenv

app = typer.Typer()

load_dotenv(dotenv_path="./typercli/.env")
BASE_URL_SQLMAP = os.getenv("BASE_URL_SQLMAP", "http://127.0.0.1:8000/sqlmap")
BASE_URL_METASPLOIT = os.getenv("BASE_URL_METASPLOIT", "http://127.0.0.1:8000/metasploit")
BASE_URL_XSSTRIKE = os.getenv("BASE_URL_XSSTRIKE", "http://127.0.0.1:8000/xsstrike")


@app.command("sqlmap")
def sqlmap_scan(targets: str):
    """
    Perform SQLMap scan on multiple URLs with optional cookies in the format:
    "http://example.com, <cookie if applicable> | http://test.com, <cookie if applicable>"
    """
    # Split the input into targets using '|'
    target_entries = [entry.strip() for entry in targets.split("|")]

    payload = {"urls": []}
    for entry in target_entries:
        # split each entry into URL and cookie
        parts = entry.split(",", 1)
        url = parts[0].strip()
        cookies = parts[1].strip() if len(parts) > 1 else None
        payload["urls"].append({"url": url, "cookies": cookies})

    endpoint_url = f"{BASE_URL_SQLMAP}/scan/multipleUrls"

    try:
        response = requests.post(endpoint_url, json=payload)
        if response.status_code == 200:
            results = response.json()
            display_sqlmap_results(results)
        else:
            print(f"[red]Failed to call SQLMap API: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")

@app.command("missing-exploit-options")
def missing_exploit_options(exploit_name: str):
    """
    Fetch missing required options for a specified exploit. Required input format:
    "exploit module"
    """
    endpoint_url = f"{BASE_URL_METASPLOIT}/missing_exploit_options?exploit_name={exploit_name}"

    try:
        response = requests.get(endpoint_url)
        if response.status_code == 200:
            options = response.json()
            display_missing_results("Missing Exploit Options", options)
        else:
            print(f"[red]Failed to fetch missing exploit options: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")


@app.command("available-exploit-options")
def available_exploit_options(exploit_name: str):
    """
    Fetch available options for a specified exploit. Required input format:
    "exploit module"
    """
    endpoint_url = f"{BASE_URL_METASPLOIT}/available_exploit_options?exploit_name={exploit_name}"

    try:
        response = requests.get(endpoint_url)
        if response.status_code == 200:
            options = response.json()
            display_available_results("Available Exploit Options", options)
        else:
            print(f"[red]Failed to fetch available exploit options: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")


@app.command("missing-auxiliary-options")
def missing_auxiliary_options(auxiliary_name: str):
    """
    Fetch missing required options for a specified auxiliary. Required input format:
    "auxiliary module"
    """
    endpoint_url = f"{BASE_URL_METASPLOIT}/missing_auxiliary_options?auxiliary_name={auxiliary_name}"

    try:
        response = requests.get(endpoint_url)
        if response.status_code == 200:
            options = response.json()
            display_missing_results("Missing Auxiliary Options", options)
        else:
            print(f"[red]Failed to fetch missing auxiliary options: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")


@app.command("available-auxiliary-options")
def available_auxiliary_options(auxiliary_name: str):
    """
    Fetch available options for a specified auxiliary. Required input format:
    "auxiliary module"
    """
    endpoint_url = f"{BASE_URL_METASPLOIT}/available_auxiliary_options?auxiliary_name={auxiliary_name}"

    try:
        response = requests.get(endpoint_url)
        if response.status_code == 200:
            options = response.json()
            display_available_results("Available Auxiliary Options", options)
        else:
            print(f"[red]Failed to fetch available auxiliary options: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")


@app.command("missing-payload-options")
def missing_payload_options(payload_name: str):
    """
    Fetch missing required options for a specified payload. Required input format:
    "payload"
    """
    endpoint_url = f"{BASE_URL_METASPLOIT}/missing_payload_options?payload_name={payload_name}"

    try:
        response = requests.get(endpoint_url)
        if response.status_code == 200:
            options = response.json()
            display_missing_results("Missing Payload Options", options)
        else:
            print(f"[red]Failed to fetch missing payload options: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")


@app.command("available-payload-options")
def available_payload_options(payload_name: str):
    """
    Fetch available options for a specified payload. Required input format:
    "payload"
    """
    endpoint_url = f"{BASE_URL_METASPLOIT}/available_payload_options?payload_name={payload_name}"

    try:
        response = requests.get(endpoint_url)
        if response.status_code == 200:
            options = response.json()
            display_available_results("Available Payload Options", options)
        else:
            print(f"[red]Failed to fetch available payload options: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")

@app.command("search-modules")
def search_modules(keyword: str):
    """
    Search for Metasploit modules by keyword. Required input format:
    "Keyword"
    """
    endpoint_url = f"{BASE_URL_METASPLOIT}/search-module?any={keyword}"

    try:
        response = requests.get(endpoint_url)
        if response.status_code == 200:
            modules = response.json()
            display_search_results(modules)
        else:
            print(f"[red]Failed to search modules: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An error occurred: {str(e)}[/red]")

@app.command("run-auxiliary")
def execute_auxiliary():
    """
    Execute an auxiliary module.
    """
    auxiliary_url = f"{BASE_URL_METASPLOIT}/execute-auxiliary"

    # Ask the user for auxiliary module details
    auxiliary_name = Prompt.ask("Enter the auxiliary module name (e.g., scanner/ssh/ssh_version)").strip()
    if auxiliary_name.lower() == "exit":
        print("\n[bold red]Exiting the session.[/bold red]")
        return

    # Get auxiliary options
    try:
        auxiliary_options = Prompt.ask("Enter auxiliary options as a JSON string (e.g., {\"RHOSTS\": \"192.168.1.1\"})")
        if auxiliary_options.lower() == "exit":
            print("\n[bold red]Exiting the session.[/bold red]")
            return
        else:
            auxiliary_options = eval(auxiliary_options)  # Convert string to dict
    except Exception as e:
        print(f"\n[bold red]Invalid format for auxiliary options: {str(e)}[/bold red]")
        return

    # Prepare the auxiliary payload 
    auxiliary_payload = {
        "auxiliary_name": auxiliary_name,
        "auxiliary_options": auxiliary_options,
    }

    try:
        print("\n[bold green]Executing the auxiliary module with the provided options...[/bold green]")
        auxiliary_response = requests.post(auxiliary_url, json=auxiliary_payload)

        if auxiliary_response.status_code == 200:
            result = auxiliary_response.json()

            if "error" in result:
                print(f"\n[bold red]Error: {result['error']}[/bold red]")
            else:
                print(f"\n[bold green]Auxiliary module '{auxiliary_name}' executed successfully![/bold green]")
                print(f"\n[bold blue]Scan Results:[/bold blue]\n{result.get('scan_results', 'No results available')}")
        else:
            print(f"\n[bold red]Failed to execute auxiliary module: {auxiliary_response.status_code} - {auxiliary_response.text}[/bold red]")
    except Exception as e:
        print(f"\n[bold red]An unexpected error occurred: {str(e)}[/bold red]")

@app.command("run")
def execute_exploit():
    """
    Execute an exploit and run commands in the session.
    """
    exploit_url = f"{BASE_URL_METASPLOIT}/execute-exploit"

    # Ask user for exploit and payload details
    exploit_name = Prompt.ask("Enter the exploit name (e.g., multi/http/php_cgi_arg_injection)").strip()
    if exploit_name.lower() == "exit":
            print("\n[bold red]Exiting the session.[/bold red]")
            return
    payload_name = Prompt.ask("Enter the payload name (e.g., php/meterpreter/reverse_tcp)").strip()
    if payload_name.lower() == "exit":
            print("\n[bold red]Exiting the session.[/bold red]")
            return
    else:

        # Get exploit options
        try:
            exploit_options = Prompt.ask("Enter exploit options as a JSON string (e.g., {\"RHOSTS\": \"192.168.1.1\"})")
            if exploit_options.lower() == "exit":
                print("\n[bold red]Exiting the session.[/bold red]")
                return
            else:
                exploit_options = eval(exploit_options) 
        except Exception as e:
            print(f"\n[bold red]Invalid format for exploit options: {str(e)}[/bold red]")
            return

        # Get payload options
        try:
            payload_options = Prompt.ask("\nEnter payload options as a JSON string (e.g., {\"LHOST\": \"192.168.1.100\"})")
            if payload_options.lower() == "exit":
                print("\n[bold red]Exiting the session.[/bold red]")
                return
            else:
                payload_options = eval(payload_options) 
        except Exception as e:
            print(f"\n[bold red]Invalid format for payload options: {str(e)}[/bold red]")
            return

        # prepare the exploit
        exploit_payload = {
            "exploit_name": exploit_name,
            "payload_name": payload_name,
            "exploit_options": exploit_options,
            "payload_options": payload_options,
        }

        try:
            print("\n[bold green]Executing the exploit with the provided payload...[/bold green]")
            exploit_response = requests.post(exploit_url, json=exploit_payload)

            if exploit_response.status_code == 200:
                result = exploit_response.json()
                if "error" in result:
                    print(f"\n[bold red]Error: {result['error']}[/bold red]")

                job_id = result.get("job_id")

                # Check if it is valid
                if not job_id:
                    print("\n[bold red]Failed to execute exploit. No job ID returned.[/bold red]")
                    return
                else:
                    print(f"\n[bold green]Exploit executed successfully. Job ID: {job_id}[/bold green]")

                interact_with_session(job_id, exploit_payload)
            else:
                print(f"\n[bold red]Failed to execute exploit: {exploit_response.status_code} - {exploit_response.text}[/bold red]")
                return
            
        except KeyboardInterrupt:
            print("\n[bold red]Exiting the session...[/bold red]")
            raise typer.Exit()
        except Exception as e:
            print(f"\n[bold red]An unexpected error occurred: {str(e)}[/bold red]")

@app.command("run-xsstrike")
def execute_xsstrike():
    """
    Perform an XSStrike scan on a target URL.
    """
    # Prompt for user inputs
    target = Prompt.ask("Enter the target URL (e.g., http://example.com)").strip()
    if not target:
        print("[red]Target URL cannot be empty.[/red]")
        return

    param_data_input = Prompt.ask(
        "Enter parameter data as JSON string (e.g., {\"name\": \"value\"}) or leave empty for GET requests",
        default="{}"
    )
    headers_input = Prompt.ask(
        "Enter headers as JSON string (e.g., {\"Cookie\": \"value\"}) or leave empty",
        default="{}"
    )
    delay = typer.prompt("Enter delay between requests in seconds (default: 0)", default=0)
    timeout = typer.prompt("Enter request timeout in seconds (default: 10)", default=10)
    skip_dom = typer.confirm("Skip DOM vulnerabilities scan?", default=False)
    max_payloads = typer.prompt("Enter the maximum number of payloads to generate (default: 10)", default=10)

    # Parse JSON inputs
    try:
        param_data = eval(param_data_input) if param_data_input.strip() else {}
        headers = json_to_header_string(headers_input)
        print(headers)

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]Invalid JSON format: {e}[/red]")
        return

    # Prepare payload for the API
    xsstrike_payload = {
        "target": target,
        "param_data": param_data,
        "headers": headers,
        "delay": delay,
        "timeout": timeout,
        "skip_dom": skip_dom,
        "max_payloads": max_payloads,
    }

    # API endpoint for XSStrike scan
    endpoint_url = f"{BASE_URL_XSSTRIKE}/scan"

    try:
        print("\n[green]Starting XSStrike scan...[/green]")
        response = requests.post(endpoint_url, json=xsstrike_payload)

        if response.status_code == 200:
            result = response.json()
            if "error" in result:
                print(f"\n[bold red]Error: {result['error']}[/bold red]")
            else:
                display_xsstrike_results(result)
        else:
            print(f"[red]Failed to execute XSStrike scan: {response.status_code} - {response.text}[/red]")

    except KeyboardInterrupt:
        print("\n[bold red]Exiting the session...[/bold red]")
        raise typer.Exit()
    except Exception as e:
        print(f"[red]An unexpected error occurred: {str(e)}[/red]")


def json_to_header_string(headers_input):
        """
        Converts a JSON dictionary of headers into a single string with '\n' .

        Like this: from {"Accept-Language": "en-US", "Cookie": "value"} to "Accept-Language: en-US\nCookie: value"
        """
        json_headers=eval(headers_input) if headers_input.strip() else {}
        return "\n".join(f"{key}: {value}" for key, value in json_headers.items())

def display_xsstrike_results(results: dict):
    """
    Display results from the XSStrike scan in a structured format.
    """
    print("\n[bold blue]--- XSStrike Scan Results ---[/bold blue]")

    # Display general information
    print(f"[bold green]Target:[/bold green] {results['target']}")
    print(f"[bold green]WAF Status:[/bold green] {results.get('waf', 'Unknown')}")
    print(f"[bold green]Total Payloads Generated:[/bold green] {results.get('total_num_payloads', 0)}")

    # Display DOM issues
    print("\n[bold green]DOM Issues:[/bold green]")
    if results["dom_issues"]:
        for issue in results["dom_issues"]:
            print(f"- [yellow]{issue}[/yellow]")
    else:
        print("[red]No DOM issues found.[/red]")

    # Display reflections
    print("\n[bold green]Reflections:[/bold green]")
    if results["reflections"]:
        for reflection in results["reflections"]:
            print(f"- Parameter: {reflection['parameter']}")
            for occ in reflection["occurrences"].values():
                print(f"  - [cyan]Position:[/cyan] {occ['position']}")
                print(f"    [cyan]Context:[/cyan] {occ['context']}")
    else:
        print("[red]No reflections found.[/red]")

    # Display payloads
    print("\n[bold green]Payloads:[/bold green]")
    if results["payloads"]:
        table = Table( show_lines=True)
        table.add_column("Payload", style="cyan")
        table.add_column("Efficiency", style="green")
        table.add_column("Confidence", style="magenta")
        table.add_column("Progress", style="white")

        for payload in results["payloads"]:
            table.add_row(
                payload["payload"],
                str(payload["efficiency"]),
                str(payload["confidence"]),
                payload["progress"]
            )
        print(table)
    else:
        print("[red]No payloads generated.[/red]")


def kill_session(job_id: str):
    """
    Call the kill session API 
    """
    kill_session_url = f"{BASE_URL_METASPLOIT}/kill-session"

    try:
        kill_session_response = requests.delete(kill_session_url, params={"job_id": job_id})
        if kill_session_response.status_code == 200:
            kill_result = kill_session_response.json()
            if "error" in kill_result:
                 print(f"\n[red]{kill_result['error']}[/red]")
            else:
                print(f"\n[green]{kill_result['message']}[/green]")
        else:
            print(f"\n[red]Failed to kill session {job_id}: {kill_session_response.status_code} - {kill_session_response.text}[/red]")
    except Exception as e:
        print(f"\n[red]An unexpected error occurred: {str(e)}[/red]")
        return
    
def interact_with_session(job_id: str, exploit_payload: dict):
    """
    Interact with the session and execute commands.
    """
    session_url = f"{BASE_URL_METASPLOIT}/get_session_and_execute_commands"

    while True:
        # Ask the user for a command or exit
        command = Prompt.ask("Enter a command to execute in the session (or type 'exit' to quit)").strip()
        if command.lower() == "exit":
            print("\n[bold red]Exiting the session.[/bold red]")
            kill_session(job_id)
            break

        # Prepare the session payload
        session_payload = {"job_id": job_id, "command": command}

        try:
            session_response = requests.post(session_url, json=session_payload)
            if session_response.status_code == 200:
                session_result = session_response.json()

                if "error" in session_result and "Session ID" in session_result["error"]:
                    print(f"\n[bold red]Error: {session_result['error']}[/bold red]")
                    rerun = Prompt.ask("\nSession does not exist. Would you like to rerun the exploit? (y/n)").strip().lower()
                    if rerun == "y":
                        print("\n[bold green]Rerunning the exploit...[/bold green]")
                        job_id = rerun_exploit(exploit_payload)  # Rerun the exploit with the same payload
                        if not job_id:
                            print("\n[bold red]Failed to rerun exploit. Exiting interactive session.[/bold red]")
                            kill_session(job_id)
                            break
                    else:
                        kill_session(job_id)
                        break

                # Display results
                elif "command_output" in session_result:
                    print(f"\n[bold green]Command Output:[/bold green]\n\n{session_result['command_output']}\n")
                else:
                    print("\n[bold red]Unexpected response format.[/bold red]")
            else:
                print(f"\n[bold red]Failed to execute session command: {session_response.status_code} - {session_response.text}[/bold red]")
   
        except Exception as e:
            print(f"\n[bold red]An unexpected error occurred: {str(e)}[/bold red]")
            return

    

def rerun_exploit(exploit_payload: dict) -> str:
    """
    Rerun the same exploit
    """
    exploit_url = f"{BASE_URL_METASPLOIT}/execute-exploit"

    try:
        print("\n[bold green]Rerunning the exploit with the provided payload...[/bold green]")
        exploit_response = requests.post(exploit_url, json=exploit_payload)

        if exploit_response.status_code == 200:
            result = exploit_response.json()
            job_id = result.get("job_id")

            if not job_id:
                print("\n[bold red]Failed to rerun exploit. No job ID returned.[/bold red]")
                return
            else:
                print(f"\n[bold green]Exploit rerun successfully. New Job ID: {job_id}[/bold green]")
            return job_id
        else:
            print(f"\n[bold red]Failed to rerun exploit: {exploit_response.status_code} - {exploit_response.text}[/bold red]")
    except Exception as e:
        print(f"\n[bold red]An unexpected error occurred while rerunning the exploit: {str(e)}[/bold red]")
        return
        
def display_sqlmap_results(results):
    """
    Display results from SQLMap scans.
    """
    for url, scan_data in results.items():
        if isinstance(scan_data, str):
            print(f"[bold red]An error occurred: {scan_data}[/bold red]")
        else:

            if not scan_data.get("success"):
                print(f"[red]SQLMap scan failed or returned no data for {url}.[/red]")
            elif not scan_data.get("data"):
                print(f"[bold red]No results found for {url}.[/bold red]")
            else:

                data = scan_data.get("data", [])
                print(f"\n[bold green]SQLMap Scan Results for {url}:[/bold green]")

                for entry in data:

                    entry_type = entry.get("type")
                    value = entry.get("value")

                    # display URL details if entry_type is 0 (general info)
                    if entry_type == 0 and isinstance(value, dict):
                        url = value.get("url", "N/A")
                        query = value.get("query", "N/A")
                        print(f"\n[bold white]URL:[/bold white] [italic]{url}[/italic]")
                        print(f"[bold white]Query:[/bold white] [italic]{query}[/italic]")

                    # display vulnerability details if entry_type is 1 (vulnerabilities)
                    elif entry_type == 1 and isinstance(value, list):
                        for injection in value:
                            print("\n[bold green]Detected Vulnerability:[/bold green]")
                            print(f"[bold white]Injection Point:[/bold white] [italic]{injection.get('place', 'N/A')}[/italic]")
                            print(f"[bold white]Parameter:[/bold white] [italic]{injection.get('parameter', 'N/A')}[/italic]")
                            print(f"[bold white]DBMS:[/bold white] [italic]{injection.get('dbms', 'N/A')}[/italic]")
                            print(f"[bold white]DBMS Version:[/bold white] [italic]{', '.join(injection.get('dbms_version', []))}[/italic]")
                            print(f"[bold white]Operating System:[/bold white] [italic]{injection.get('os', 'N/A')}[/italic]")

                            for key, details in injection.get("data", {}).items():
                                print(f"\n[bold white]Title:[/bold white] [italic]{details.get('title', 'N/A')}[/italic]")
                                print(f"[bold white]Payload:[/bold white] [italic]{details.get('payload', 'N/A')}[/italic]")
                                print(f"[bold white]True Code:[/bold white] [italic]{details.get('trueCode', 'N/A')}[/italic]")
                                print(f"[bold white]False Code:[/bold white] [italic]{details.get('falseCode', 'N/A')}[/italic]")

                                vector = details.get("vector", [])
                                if isinstance(vector, list):
                                    print(f"[bold white]Vector:[/bold white]")
                                    for v in vector:
                                        print(f"  [italic]{v}[/italic]")
                                elif isinstance(vector, str):
                                    print(f"[bold white]Vector:[/bold white] [italic]{vector}[/italic]")

                                comment = details.get("comment")
                                if comment:
                                    print(f"[bold white]Comment:[/bold white] [italic]{comment}[/italic]")

                                print(" ")
                                print("-" * 40)

def display_missing_results(title: str, data: dict):
    """
    Display results for various Metasploit API outputs in a user-friendly format.
    """
    print(f"\n[bold green]{title}:[/bold green]")

    # Check if the response contains an error
    if "error" in data:
        print(f"[bold red]Error: {data['error']}[/bold red]")
    elif "missing_required_exploit_options" in data:
        missing_options = data["missing_required_exploit_options"]
        if missing_options:
            for option in missing_options:
                print(f"  [cyan]- {option}[/cyan]")
        else:
            print("[red]No missing required exploit options.[/red]")
    elif "missing_required_auxiliary_options" in data:
        missing_options = data["missing_required_auxiliary_options"]
        if missing_options:
            for option in missing_options:
                print(f"  [cyan]- {option}[/cyan]")
        else:
            print("[red]No missing required auxiliary options.[/red]")
    else:
        missing_options = data["missing_required_payload_options"]
        if missing_options:
            for option in missing_options:
                print(f"  [cyan]- {option}[/cyan]")
        else:
            print("[red]No missing required payload options.[/red]")

def display_available_results(title: str, data: dict):
    """
    Display available options for exploits or payloads in a table
    """
    print(f"\n[bold green]{title}:[/bold green]")

    if "error" in data:
        print(f"[bold red]Error: {data['error']}[/bold red]")
    elif "avaiable_exploit_options" in data:
        options = data["avaiable_exploit_options"]
        if options:
            # Create a table
            table = Table(show_header=True, header_style="bold magenta")
            table.add_column("Option", style="cyan", no_wrap=True)
            table.add_column("Value", style="white")

            for option, value in options.items():
                table.add_row(str(option), str(value))
            
            print(table)
        else:
            print("[red]No available exploit options found.[/red]")
    elif "avaiable_auxiliary_options" in data:
        options = data["avaiable_auxiliary_options"]
        if options:
            # Create a table
            table = Table(show_header=True, header_style="bold magenta")
            table.add_column("Option", style="cyan", no_wrap=True)
            table.add_column("Value", style="white")

            for option, value in options.items():
                table.add_row(str(option), str(value))
            
            print(table)
        else:
            print("[red]No available auxiliary options found.[/red]")
    else:
        options = data["avaiable_payload_options"]
        if options:
            # Create a table
            table = Table(show_header=True, header_style="bold magenta")
            table.add_column("Option", style="cyan", no_wrap=True)
            table.add_column("Value", style="white")

            for option, value in options.items():
                table.add_row(str(option), str(value))

            print(table)
        else:
            print("[red]No available exploit options found.[/red]")

def display_search_results(modules: dict):
    """
    Display Metasploit module search results
    """
    if "error" in modules:
        print(f"[bold red]Error: {modules['error']}[/bold red]")

    elif "modules" not in modules or not modules["modules"]:
        print("[yellow]No modules found matching the search criteria[/yellow]")
    
    else:
        print("\n[bold green]Metasploit Module Search Results:[/bold green]\n")

        # go through modules and display them
        for index, module in enumerate(modules["modules"], start=1):
            print(f"[bold white]{index}. Name:[/bold white] {module.get('name', 'N/A')}")
            print(f"   [cyan]Rank:[/cyan] {module.get('rank', 'N/A')}")
            print(f"   [cyan]Type:[/cyan] {module.get('type', 'N/A')}")
            print(f"   [cyan]Full Name:[/cyan] {module.get('fullname', 'N/A')}")
            disclosure_date = module.get("disclosure_date", "N/A")
            if disclosure_date:
                print(f"   [cyan]Disclosure Date:[/cyan] {disclosure_date}")
            print("-" * 40)
            print("")