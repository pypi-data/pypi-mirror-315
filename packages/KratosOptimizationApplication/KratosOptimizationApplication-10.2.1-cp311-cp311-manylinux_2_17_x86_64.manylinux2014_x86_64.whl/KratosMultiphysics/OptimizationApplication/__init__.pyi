import Kratos
import Kratos.Expression
import numpy
from . import CollectiveExpressionIO as CollectiveExpressionIO, ControlUtils as ControlUtils, ExpressionUtils as ExpressionUtils, ImplicitFilterUtils as ImplicitFilterUtils, OptAppModelPartUtils as OptAppModelPartUtils, OptimizationUtils as OptimizationUtils, PropertiesVariableExpressionIO as PropertiesVariableExpressionIO, ResponseUtils as ResponseUtils
from typing import overload

class CollectiveExpression:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list[Kratos.Expression.NodalExpression | Kratos.Expression.ConditionExpression | Kratos.Expression.ElementExpression]) -> None: ...
    @overload
    def Add(self, arg0: Kratos.Expression.NodalExpression | Kratos.Expression.ConditionExpression | Kratos.Expression.ElementExpression) -> None: ...
    @overload
    def Add(self, arg0: CollectiveExpression) -> None: ...
    def Clear(self) -> None: ...
    def Clone(self) -> CollectiveExpression: ...
    def Evaluate(self) -> numpy.ndarray[numpy.float64]: ...
    def GetCollectiveFlattenedDataSize(self) -> int: ...
    def GetContainerExpressions(self) -> list[Kratos.Expression.NodalExpression | Kratos.Expression.ConditionExpression | Kratos.Expression.ElementExpression]: ...
    def IsCompatibleWith(self, arg0: CollectiveExpression) -> bool: ...
    @overload
    def __add__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __add__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __iadd__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __iadd__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __imul__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __imul__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __ipow__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __ipow__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __isub__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __isub__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __itruediv__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __itruediv__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __mul__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __mul__(self, arg0: float) -> CollectiveExpression: ...
    def __neg__(self) -> CollectiveExpression: ...
    @overload
    def __pow__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __pow__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __sub__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __sub__(self, arg0: float) -> CollectiveExpression: ...
    @overload
    def __truediv__(self, arg0: CollectiveExpression) -> CollectiveExpression: ...
    @overload
    def __truediv__(self, arg0: float) -> CollectiveExpression: ...

class ConditionExplicitDamping:
    def __init__(self, *args, **kwargs) -> None: ...
    def CalculateMatrix(self, output_matrix: Kratos.Matrix, component_index: int) -> None: ...
    def GetDampedModelParts(self) -> list[list[Kratos.ModelPart]]: ...
    def GetRadius(self) -> Kratos.Expression.ConditionExpression: ...
    def GetStride(self) -> int: ...
    def SetRadius(self, radius_expression: Kratos.Expression.ConditionExpression) -> None: ...
    def Update(self) -> None: ...

class ConditionExplicitFilterUtils:
    def __init__(self, model_part: Kratos.ModelPart, kernel_function_type: str, max_number_of_neighbours: int, echo_level: int) -> None: ...
    def BackwardFilterField(self, physical_space_mesh_independent_gradient: Kratos.Expression.ConditionExpression) -> Kratos.Expression.ConditionExpression: ...
    def BackwardFilterIntegratedField(self, physical_space_mesh_dependent_gradient: Kratos.Expression.ConditionExpression) -> Kratos.Expression.ConditionExpression: ...
    def CalculateMatrix(self, output_filtering_matrix: Kratos.Matrix) -> None: ...
    def ForwardFilterField(self, mesh_independent_control_space_field: Kratos.Expression.ConditionExpression) -> Kratos.Expression.ConditionExpression: ...
    def GetIntegrationWeights(self, integration_weight_field: Kratos.Expression.ConditionExpression) -> None: ...
    def GetRadius(self) -> Kratos.Expression.ConditionExpression: ...
    def SetDamping(self, damping: ConditionExplicitDamping) -> None: ...
    def SetRadius(self, filter_radius: Kratos.Expression.ConditionExpression) -> None: ...
    def Update(self) -> None: ...

class ElementExplicitDamping:
    def __init__(self, *args, **kwargs) -> None: ...
    def CalculateMatrix(self, output_matrix: Kratos.Matrix, component_index: int) -> None: ...
    def GetDampedModelParts(self) -> list[list[Kratos.ModelPart]]: ...
    def GetRadius(self) -> Kratos.Expression.ElementExpression: ...
    def GetStride(self) -> int: ...
    def SetRadius(self, radius_expression: Kratos.Expression.ElementExpression) -> None: ...
    def Update(self) -> None: ...

class ElementExplicitFilterUtils:
    def __init__(self, model_part: Kratos.ModelPart, kernel_function_type: str, max_number_of_neighbours: int, echo_level: int) -> None: ...
    def BackwardFilterField(self, physical_space_mesh_independent_gradient: Kratos.Expression.ElementExpression) -> Kratos.Expression.ElementExpression: ...
    def BackwardFilterIntegratedField(self, physical_space_mesh_dependent_gradient: Kratos.Expression.ElementExpression) -> Kratos.Expression.ElementExpression: ...
    def CalculateMatrix(self, output_filtering_matrix: Kratos.Matrix) -> None: ...
    def ForwardFilterField(self, mesh_independent_control_space_field: Kratos.Expression.ElementExpression) -> Kratos.Expression.ElementExpression: ...
    def GetIntegrationWeights(self, integration_weight_field: Kratos.Expression.ElementExpression) -> None: ...
    def GetRadius(self) -> Kratos.Expression.ElementExpression: ...
    def SetDamping(self, damping: ElementExplicitDamping) -> None: ...
    def SetRadius(self, filter_radius: Kratos.Expression.ElementExpression) -> None: ...
    def Update(self) -> None: ...

class HelmholtzJacobianStiffened3DLaw(Kratos.ConstitutiveLaw):
    def __init__(self) -> None: ...

class IntegratedNearestConditionExplicitDamping(ConditionExplicitDamping):
    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, stride: int) -> None: ...

class IntegratedNearestElementExplicitDamping(ElementExplicitDamping):
    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, stride: int) -> None: ...

class IntegratedNearestNodeExplicitDamping(NodeExplicitDamping):
    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, stride: int) -> None: ...

class InterfaceOptResponse:
    def __init__(self, arg0: str, arg1: Kratos.Model, arg2: Kratos.Parameters) -> None: ...
    def CalculateGradient(self) -> None: ...
    def CalculateValue(self) -> float: ...
    def Initialize(self) -> None: ...

class KratosOptimizationApplication(Kratos.KratosApplication):
    def __init__(self) -> None: ...

class LinearStrainEnergyOptResponse:
    def __init__(self, arg0: str, arg1: Kratos.Model, arg2: Kratos.Parameters) -> None: ...
    def CalculateGradient(self) -> None: ...
    def CalculateValue(self) -> float: ...
    def Initialize(self) -> None: ...

class MassOptResponse:
    def __init__(self, arg0: str, arg1: Kratos.Model, arg2: Kratos.Parameters) -> None: ...
    def CalculateGradient(self) -> None: ...
    def CalculateValue(self) -> float: ...
    def Initialize(self) -> None: ...

class NearestConditionExplicitDamping(ConditionExplicitDamping):
    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, stride: int) -> None: ...

class NearestElementExplicitDamping(ElementExplicitDamping):
    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, stride: int) -> None: ...

class NearestNodeExplicitDamping(NodeExplicitDamping):
    def __init__(self, model: Kratos.Model, parameters: Kratos.Parameters, stride: int) -> None: ...

class NodeExplicitDamping:
    def __init__(self, *args, **kwargs) -> None: ...
    def CalculateMatrix(self, output_matrix: Kratos.Matrix, component_index: int) -> None: ...
    def GetDampedModelParts(self) -> list[list[Kratos.ModelPart]]: ...
    def GetRadius(self) -> Kratos.Expression.NodalExpression: ...
    def GetStride(self) -> int: ...
    def SetRadius(self, radius_expression: Kratos.Expression.NodalExpression) -> None: ...
    def Update(self) -> None: ...

class NodeExplicitFilterUtils:
    def __init__(self, model_part: Kratos.ModelPart, kernel_function_type: str, max_number_of_neighbours: int, echo_level: int) -> None: ...
    def BackwardFilterField(self, physical_space_mesh_independent_gradient: Kratos.Expression.NodalExpression) -> Kratos.Expression.NodalExpression: ...
    def BackwardFilterIntegratedField(self, physical_space_mesh_dependent_gradient: Kratos.Expression.NodalExpression) -> Kratos.Expression.NodalExpression: ...
    def CalculateMatrix(self, output_filtering_matrix: Kratos.Matrix) -> None: ...
    def ForwardFilterField(self, mesh_independent_control_space_field: Kratos.Expression.NodalExpression) -> Kratos.Expression.NodalExpression: ...
    def GetIntegrationWeights(self, integration_weight_field: Kratos.Expression.NodalExpression) -> None: ...
    def GetRadius(self) -> Kratos.Expression.NodalExpression: ...
    def SetDamping(self, damping: NodeExplicitDamping) -> None: ...
    def SetRadius(self, filter_radius: Kratos.Expression.NodalExpression) -> None: ...
    def Update(self) -> None: ...

class PartitionInterfaceStressOptResponse:
    def __init__(self, arg0: str, arg1: Kratos.Model, arg2: Kratos.Parameters) -> None: ...
    def CalculateGradient(self) -> None: ...
    def CalculateValue(self) -> float: ...
    def Initialize(self) -> None: ...

class PartitionMassOptResponse:
    def __init__(self, arg0: str, arg1: Kratos.Model, arg2: Kratos.Parameters) -> None: ...
    def CalculateGradient(self) -> None: ...
    def CalculateValue(self) -> float: ...
    def Initialize(self) -> None: ...

class StressOptResponse:
    def __init__(self, arg0: str, arg1: Kratos.Model, arg2: Kratos.Parameters, arg3: list[Kratos.LinearSolver]) -> None: ...
    def CalculateGradient(self) -> None: ...
    def CalculateValue(self) -> float: ...
    def Initialize(self) -> None: ...

class SymmetryUtility:
    def __init__(self, arg0: str, arg1: Kratos.ModelPart, arg2: Kratos.Parameters) -> None: ...
    def ApplyOnScalarField(self, arg0: Kratos.DoubleVariable) -> None: ...
    def ApplyOnVectorField(self, arg0: Kratos.Array1DVariable3) -> None: ...
    def Initialize(self) -> None: ...
    def Update(self) -> None: ...
