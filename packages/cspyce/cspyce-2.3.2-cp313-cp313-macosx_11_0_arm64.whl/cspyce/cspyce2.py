################################################################################
# cspyce/cspyce2.py
#
# This module re-declares every cspyce1 function explicitly, with its list of
# argument names as used by CSPICE. The practical effect is that functions in
# cspyce2 module can be called in a fully Python-like way, the rightmost inputs
# in any order and identified by their names.
#
# Used internally by cspyce; not intended for direct import.
#
# This file is automatically generated by the program make_cspyce2.py. 
# Do not modify. 
################################################################################

import cspyce.cspyce1 as cs1

def __copy_attributes_from(function, old_function):
    for key, value in vars(old_function).items():
        if callable(value):
            value = globals()[value.__name__]
        setattr(function, key, value)

#########################
# axisar
#########################

def axisar(axis, angle):
    """
    Construct a rotation matrix that rotates vectors by a specified angle
    about a specified axis.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/axisar_c.html
    
    Inputs:
      float[3]   axis   = Rotation axis.
      float      angle  = Rotation angle, in radians.
    
    Returns:
      float[3,3] rotmat = Rotation matrix corresponding to axis and angle.
    """
    return cs1.axisar(axis, angle)

def axisar_vector(axis, angle):
    """
    Construct a rotation matrix that rotates vectors by a specified angle
    about a specified axis.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/axisar_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]   axis   = Rotation axis.
      float[_]     angle  = Rotation angle, in radians.
    
    Returns:
      float[_,3,3] rotmat = Rotation matrix corresponding to axis and angle.
    """
    return cs1.axisar_vector(axis, angle)

__copy_attributes_from(axisar, cs1.axisar)
__copy_attributes_from(axisar_vector, cs1.axisar_vector)

#########################
# azlcpo
#########################

def azlcpo(method, target, et, abcorr, azccw, elplsz, obspos, obsctr, obsref):
    """
    Return the azimuth/elevation coordinates of a specified target relative
    to an "observer," where the observer has constant position in a
    specified reference frame. The observer's position is provided by the
    calling program rather than by loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/azlcpo_c.html
    
    Inputs:
      string   method = Method to obtain the surface normal vector;
                        "ELLIPSOID" is the one and only option.
      string   target = Name of target ephemeris object.
      float    et     = Observation epoch.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      bool     azccw  = Flag indicating how azimuth is measured, True for
                        counterclockwise, False for clockwise.
      bool     elplsz = Flag indicating how elevation is measured, True for
                        increasing toward +Z, False for -Z.
      float[3] obspos = Observer position relative to center of motion.
      string   obsctr = Center of motion of observer.
      string   obsref = Body-fixed, body-centered frame of observer's
                        center.
    
    Returns:
      float[6] azlsta = State of target with respect to observer, in
                        azimuth/elevation coordinates.
      float    lt     = One way light time between target and observer.
    """
    return cs1.azlcpo(method, target, et, abcorr, azccw, elplsz, obspos, obsctr, obsref)

def azlcpo_vector(method, target, et, abcorr, azccw, elplsz, obspos, obsctr, obsref):
    """
    Return the azimuth/elevation coordinates of a specified target relative
    to an "observer," where the observer has constant position in a
    specified reference frame. The observer's position is provided by the
    calling program rather than by loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/azlcpo_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Method to obtain the surface normal vector;
                          "ELLIPSOID" is the one and only option.
      string     target = Name of target ephemeris object.
      float[_]   et     = Observation epoch.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      bool       azccw  = Flag indicating how azimuth is measured, True for
                          counterclockwise, False for clockwise.
      bool       elplsz = Flag indicating how elevation is measured, True
                          for increasing toward +Z, False for -Z.
      float[_,3] obspos = Observer position relative to center of motion.
      string     obsctr = Center of motion of observer.
      string     obsref = Body-fixed, body-centered frame of observer's
                          center.
    
    Returns:
      float[_,6] azlsta = State of target with respect to observer, in
                          azimuth/elevation coordinates.
      float[_]   lt     = One way light time between target and observer.
    """
    return cs1.azlcpo_vector(method, target, et, abcorr, azccw, elplsz, obspos, obsctr, obsref)

__copy_attributes_from(azlcpo, cs1.azlcpo)
__copy_attributes_from(azlcpo_vector, cs1.azlcpo_vector)

#########################
# azlrec
#########################

def azlrec(range, az, el, azccw, elplsz):
    """
    Convert from range, azimuth and elevation of a point to rectangular
    coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/azlrec_c.html
    
    Inputs:
      float    range  = Distance of the point from the origin.
      float    az     = Azimuth in radians.
      float    el     = Elevation in radians.
      bool     azccw  = Flag indicating how azimuth is measured, True for
                        counterclockwise, False for clockwise.
      bool     elplsz = Flag indicating how elevation is measured, True for
                        increasing toward +Z, False for -Z.
    
    Returns:
      float[3] rectan = Rectangular coordinates of a point.
    """
    return cs1.azlrec(range, az, el, azccw, elplsz)

def azlrec_vector(range, az, el, azccw, elplsz):
    """
    Convert from range, azimuth and elevation of a point to rectangular
    coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/azlrec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   range  = Distance of the point from the origin.
      float[_]   az     = Azimuth in radians.
      float[_]   el     = Elevation in radians.
      bool       azccw  = Flag indicating how azimuth is measured, True for
                          counterclockwise, False for clockwise.
      bool       elplsz = Flag indicating how elevation is measured, True
                          for increasing toward +Z, False for -Z.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of a point.
    """
    return cs1.azlrec_vector(range, az, el, azccw, elplsz)

__copy_attributes_from(azlrec, cs1.azlrec)
__copy_attributes_from(azlrec_vector, cs1.azlrec_vector)

#########################
# b1900
#########################

def b1900():
    """
    Return the Julian Date corresponding to Besselian Date 1900.0.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/b1900_c.html
    
    Inputs: none
    
    Returns:
      float jd = JD of Besselian Date 1900.0
    """
    return cs1.b1900()

__copy_attributes_from(b1900, cs1.b1900)

#########################
# b1950
#########################

def b1950():
    """
    Return the Julian Date corresponding to Besselian Date 1950.0.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/b1950_c.html
    
    Inputs: none
    
    Returns:
      float jd = JD of Besselian Date 1950.0.
    """
    return cs1.b1950()

__copy_attributes_from(b1950, cs1.b1950)

#########################
# badkpv
#########################

def badkpv(caller, name, comp, size, divby, type):
    """
    Determine if a kernel pool variable is present and if so that it has the
    correct size and type.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/badkpv_c.html
    
    Inputs:
      string caller = Name of the routine calling this routine.
      string name   = Name of a kernel pool variable.
      string comp   = Comparison operator, one of "=", "<", ">", "=>", "<=".
      int    size   = Expected size of the kernel pool variable.
      int    divby  = A divisor of the size of the kernel pool variable.
      string type   = Expected type of the kernel pool variable, "C" for
                      string, "N" for numeric.
    
    Returns: none
    """
    return cs1.badkpv(caller, name, comp, size, divby, type)

__copy_attributes_from(badkpv, cs1.badkpv)

#########################
# bltfrm
#########################

def bltfrm(frmcls, ids = 1000):
    """
    Return an array containing the frame IDs of all built-in frames of a
    specified class.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bltfrm_c.html
    
    Inputs:
      int frmcls = Frame class (-1 = all; 1 = built-in inertial; 2 = PCK-
                   based; 3 = CK-based; 4 = fixed rotational; 5 = dynamic).
      int ids    = Array of ID codes of frames of the specified class.
    
    Returns:
      int ids    = Array of ID codes of frames of the specified class.
    """
    return cs1.bltfrm(frmcls, ids)

__copy_attributes_from(bltfrm, cs1.bltfrm)

#########################
# bodc2n
#########################

def bodc2n(code):
    """
    Translate the SPICE integer code of a body into a common name for that
    body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodc2n_c.html
    
    Inputs:
      int    code  = Integer ID code to be translated into a name.
    
    Returns:
      string name  = A common name for the body identified by code.
      bool   found = True if translated, otherwise False.
    """
    return cs1.bodc2n(code)

def bodc2n_error(code):
    """
    Translate the SPICE integer code of a body into a common name for that
    body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodc2n_c.html
    
    Inputs:
      int    code = Integer ID code to be translated into a name.
    
    Returns:
      string name = A common name for the body identified by code.
    
    Note: Raise KeyError(BODYIDNOTFOUND) if name could not be translated.
    """
    return cs1.bodc2n_error(code)

__copy_attributes_from(bodc2n, cs1.bodc2n)
__copy_attributes_from(bodc2n_error, cs1.bodc2n_error)

#########################
# bodc2s
#########################

def bodc2s(code):
    """
    Translate a body ID code to either the corresponding name or if no name
    to ID code mapping exists, the string representation of the body ID
    value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodc2s_c.html
    
    Inputs:
      int    code = Integer ID code to translate to a string.
    
    Returns:
      string name = String corresponding to 'code'.
    """
    return cs1.bodc2s(code)

__copy_attributes_from(bodc2s, cs1.bodc2s)

#########################
# boddef
#########################

def boddef(name, code):
    """
    Define a body name/ID code pair for later translation via bodn2c or
    bodc2n.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/boddef_c.html
    
    Inputs:
      string name = Common name of some body.
      int    code = Integer code for that body.
    
    Returns: none
    """
    return cs1.boddef(name, code)

__copy_attributes_from(boddef, cs1.boddef)

#########################
# bodfnd
#########################

def bodfnd(body, item):
    """
    Determine whether values exist for some item for any body in the kernel
    pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodfnd_c.html
    
    Inputs:
      int    body  = ID code of body.
      string item  = Item to find ("RADII", "NUT_AMP_RA", etc.).
    
    Returns:
      bool   found = True if the item is in the kernel pool; False if it is
                     not.
    """
    return cs1.bodfnd(body, item)

__copy_attributes_from(bodfnd, cs1.bodfnd)

#########################
# bodn2c
#########################

def bodn2c(name):
    """
    Translate the name of a body or object to the corresponding SPICE
    integer ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodn2c_c.html
    
    Inputs:
      string name  = Body name to be translated into a SPICE ID code.
    
    Returns:
      int    code  = SPICE integer ID code for the named body.
      bool   found = True if translated, otherwise False.
    """
    return cs1.bodn2c(name)

def bodn2c_error(name):
    """
    Translate the name of a body or object to the corresponding SPICE
    integer ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodn2c_c.html
    
    Inputs:
      string name = Body name to be translated into a SPICE ID code.
    
    Returns:
      int    code = SPICE integer ID code for the named body.
    
    Note: Raise KeyError(BODYNAMENOTFOUND) if name could not be
    translated.
    """
    return cs1.bodn2c_error(name)

__copy_attributes_from(bodn2c, cs1.bodn2c)
__copy_attributes_from(bodn2c_error, cs1.bodn2c_error)

#########################
# bods2c
#########################

def bods2c(name):
    """
    Translate a string containing a body name or ID code to an integer code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bods2c_c.html
    
    Inputs:
      string name  = String to be translated to an ID code.
    
    Returns:
      int    code  = Integer ID code corresponding to `name'.
      bool   found = Flag indicating whether translation succeeded.
    """
    return cs1.bods2c(name)

def bods2c_error(name):
    """
    Translate a string containing a body name or ID code to an integer code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bods2c_c.html
    
    Inputs:
      string name = String to be translated to an ID code.
    
    Returns:
      int    code = Integer ID code corresponding to `name'.
    
    Note: Raise KeyError(BODYNAMENOTFOUND) if name could not be
    translated.
    """
    return cs1.bods2c_error(name)

__copy_attributes_from(bods2c, cs1.bods2c)
__copy_attributes_from(bods2c_error, cs1.bods2c_error)

#########################
# bodvar
#########################

def bodvar(body, item):
    """
    Deprecated: This routine has been superseded by bodvcd and bodvrd. This
    routine is supported for purposes of backward compatibility only.
    
    Return the values of some item for any body in the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodvar_c.html
    
    Inputs:
      int      body   = ID code of body.
      string   item   = Item for which values are desired. ("RADII",
                        "NUT_PREC_ANGLES", etc.).
    
    Returns:
      float[*] values = Array of values.
    """
    return cs1.bodvar(body, item)

__copy_attributes_from(bodvar, cs1.bodvar)

#########################
# bodvcd
#########################

def bodvcd(bodyid, item):
    """
    Fetch from the kernel pool the floating-point values of an item
    associated with a body, where the body is specified by an integer ID
    code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodvcd_c.html
    
    Inputs:
      int      bodyid = Body ID code.
      string   item   = Item for which values are desired. ("RADII",
                        "NUT_PREC_ANGLES", etc.).
    
    Returns:
      float[*] values = Array of values.
    """
    return cs1.bodvcd(bodyid, item)

__copy_attributes_from(bodvcd, cs1.bodvcd)

#########################
# bodvrd
#########################

def bodvrd(bodynm, item):
    """
    Fetch from the kernel pool the floating-point values of an item
    associated with a body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bodvrd_c.html
    
    Inputs:
      string   bodynm = Body name.
      string   item   = Item for which values are desired. ("RADII",
                        "NUT_PREC_ANGLES", etc.).
    
    Returns:
      float[*] values = Array of values.
    """
    return cs1.bodvrd(bodynm, item)

__copy_attributes_from(bodvrd, cs1.bodvrd)

#########################
# brcktd
#########################

def brcktd(number, end1, end2):
    """
    Bracket a floating-point number. That is, given a number and an
    acceptable interval, make sure that the number is contained in the
    interval. (If the number is already in the interval, leave it alone. If
    not, set it to the nearest endpoint of the interval.)
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/brcktd_c.html
    
    Inputs:
      float number = Number to be bracketed.
      float end1   = One of the bracketing endpoints for `number'.
      float end2   = The other bracketing endpoint for `number'.
    
    Returns: none
    """
    return cs1.brcktd(number, end1, end2)

def brcktd_vector(number, end1, end2):
    """
    Bracket a floating-point number. That is, given a number and an
    acceptable interval, make sure that the number is contained in the
    interval. (If the number is already in the interval, leave it alone. If
    not, set it to the nearest endpoint of the interval.)
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/brcktd_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] number = Number to be bracketed.
      float[_] end1   = One of the bracketing endpoints for `number'.
      float[_] end2   = The other bracketing endpoint for `number'.
    
    Returns: none
    """
    return cs1.brcktd_vector(number, end1, end2)

__copy_attributes_from(brcktd, cs1.brcktd)
__copy_attributes_from(brcktd_vector, cs1.brcktd_vector)

#########################
# brckti
#########################

def brckti(number, end1, end2):
    """
    Bracket an integer number. That is, given a number and an acceptable
    interval, make sure that the number is contained in the interval. (If
    the number is already in the interval, leave it alone. If not, set it to
    the nearest endpoint of the interval.)
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/brckti_c.html
    
    Inputs:
      int number = Number to be bracketed.
      int end1   = One of the bracketing endpoints for `number'.
      int end2   = The other bracketing endpoint for `number'.
    
    Returns:
      int result = Bracketed value.
    """
    return cs1.brckti(number, end1, end2)

__copy_attributes_from(brckti, cs1.brckti)

#########################
# bschoc
#########################

def bschoc(value, array, order):
    """
    Do a binary search for a given value within an array of character
    strings, accompanied by an order vector. Return the index of the
    matching array entry, or -1 if the key value is not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bschoc_c.html
    
    Inputs:
      string    value = Key value to be found in `array'.
      string[*] array = Character string array to search.
      int[*]    order = Order vector.
    
    Returns:
      int       index = Index of value in array.
    """
    return cs1.bschoc(value, array, order)

__copy_attributes_from(bschoc, cs1.bschoc)

#########################
# bschoi
#########################

def bschoi(value, array, order):
    """
    Do a binary search for a given value within an integer array,
    accompanied by an order vector. Return the index of the matching array
    entry, or -1 if the key value is not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bschoi_c.html
    
    Inputs:
      int    value = Value to find in `array'.
      int[*] array = Array to be searched.
      int[*] order = Order vector.
    
    Returns:
      int    index = Index of value in array.
    """
    return cs1.bschoi(value, array, order)

__copy_attributes_from(bschoi, cs1.bschoi)

#########################
# bsrchc
#########################

def bsrchc(value, array):
    """
    Do a binary search for a given value within a character string array,
    assumed to be in nondecreasing order. Return the index of the matching
    array entry, or -1 if the key value is not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bsrchc_c.html
    
    Inputs:
      string    value = Key value to be found in `array'.
      string[*] array = Character string array to search.
    
    Returns:
      int       index = Index of value in array.
    """
    return cs1.bsrchc(value, array)

__copy_attributes_from(bsrchc, cs1.bsrchc)

#########################
# bsrchd
#########################

def bsrchd(value, array):
    """
    Do a binary search for a given value within a floating-point array,
    assumed to be in nondecreasing order. Return the index of the matching
    array entry, or -1 if the key value is not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bsrchd_c.html
    
    Inputs:
      float    value = Value to find in `array'.
      float[*] array = Array to be searched.
    
    Returns:
      int      index = Index of value in array.
    """
    return cs1.bsrchd(value, array)

def bsrchd_vector(value, array):
    """
    Do a binary search for a given value within a floating-point array,
    assumed to be in nondecreasing order. Return the index of the matching
    array entry, or -1 if the key value is not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bsrchd_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   value = Value to find in `array'.
      float[_,*] array = Array to be searched.
    
    Returns:
      int        index = Index of value in array.
    """
    return cs1.bsrchd_vector(value, array)

__copy_attributes_from(bsrchd, cs1.bsrchd)
__copy_attributes_from(bsrchd_vector, cs1.bsrchd_vector)

#########################
# bsrchi
#########################

def bsrchi(value, array):
    """
    Do a binary search for a given value within an integer array, assumed to
    be in nondecreasing order. Return the index of the matching array entry,
    or -1 if the key value is not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/bsrchi_c.html
    
    Inputs:
      int    value = Value to find in `array'.
      int[*] array = Array to be searched.
    
    Returns:
      int    index = Index of value in array.
    """
    return cs1.bsrchi(value, array)

__copy_attributes_from(bsrchi, cs1.bsrchi)

#########################
# ccifrm
#########################

def ccifrm(frclss, clssid):
    """
    Return the frame name, frame ID, and center associated with a given
    frame class and class ID.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ccifrm_c.html
    
    Inputs:
      int    frclss = Class of frame.
      int    clssid = Class ID of frame.
    
    Returns:
      int    frcode = ID code of the frame.
      string frname = Name of the frame.
      int    center = ID code of the center of the frame.
      bool   found  = True if the requested information is available.
    """
    return cs1.ccifrm(frclss, clssid)

def ccifrm_error(frclss, clssid):
    """
    Return the frame name, frame ID, and center associated with a given
    frame class and class ID.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ccifrm_c.html
    
    Inputs:
      int    frclss = Class of frame.
      int    clssid = Class ID of frame.
    
    Returns:
      int    frcode = ID code of the frame.
      string frname = Name of the frame.
      int    center = ID code of the center of the frame.
    
    Note: Raise ValueError(INVALIDFRAMEDEF) if frame is not found.
    """
    return cs1.ccifrm_error(frclss, clssid)

__copy_attributes_from(ccifrm, cs1.ccifrm)
__copy_attributes_from(ccifrm_error, cs1.ccifrm_error)

#########################
# cgv2el
#########################

def cgv2el(center, vec1, vec2):
    """
    Form a CSPICE ellipse from a center vector and two generating vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cgv2el_c.html
    
    Inputs:
      float[3]     center  = Center of an ellipse.
      float[3]     vec1    = First of two generating vectors for an ellipse.
      float[3]     vec2    = Second of two generating vectors for an
                             ellipse.
    
    Returns:
      SpiceEllipse ellipse = The CSPICE ellipse defined by the input
                             vectors.
    """
    return cs1.cgv2el(center, vec1, vec2)

def cgv2el_vector(center, vec1, vec2):
    """
    Form a CSPICE ellipse from a center vector and two generating vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cgv2el_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]   center  = Center of an ellipse.
      float[_,3]   vec1    = First of two generating vectors for an ellipse.
      float[_,3]   vec2    = Second of two generating vectors for an
                             ellipse.
    
    Returns:
      SpiceEllipse ellipse = The CSPICE ellipse defined by the input
                             vectors.
    """
    return cs1.cgv2el_vector(center, vec1, vec2)

__copy_attributes_from(cgv2el, cs1.cgv2el)
__copy_attributes_from(cgv2el_vector, cs1.cgv2el_vector)

#########################
# chbder
#########################

def chbder(cp, x2s, x, nderiv):
    """
    Return the value of a polynomial and its first `nderiv' derivatives,
    evaluated at the input `x', using the coefficients of the Chebyshev
    expansion of the polynomial.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbder_c.html
    
    Inputs:
      float[*] cp     = degp+1 Chebyshev polynomial coefficients.
      float[2] x2s    = Transformation parameters of polynomial.
      float    x      = Value for which the polynomial is to be evaluated.
      int      nderiv = The number of derivatives to compute.
    
    Returns:
      float    dpdxs  = Array of the derivatives of the polynomial.
    """
    return cs1.chbder(cp, x2s, x, nderiv)

def chbder_vector(cp, x2s, x, nderiv):
    """
    Return the value of a polynomial and its first `nderiv' derivatives,
    evaluated at the input `x', using the coefficients of the Chebyshev
    expansion of the polynomial.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbder_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] cp     = degp+1 Chebyshev polynomial coefficients.
      float[_,2] x2s    = Transformation parameters of polynomial.
      float[_]   x      = Value for which the polynomial is to be evaluated.
      int        nderiv = The number of derivatives to compute.
    
    Returns:
      float[_]   dpdxs  = Array of the derivatives of the polynomial.
    """
    return cs1.chbder_vector(cp, x2s, x, nderiv)

__copy_attributes_from(chbder, cs1.chbder)
__copy_attributes_from(chbder_vector, cs1.chbder_vector)

#########################
# chbigr
#########################

def chbigr(cp, x2s, x):
    """
    Evaluate an indefinite integral of a Chebyshev expansion at a specified
    point `x' and return the value of the input expansion at `x' as well.
    The constant of integration is selected to make the integral zero when
    `x' equals the abscissa value x2s[0].
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbigr_c.html
    
    Inputs:
      float[*] cp     = Chebyshev coefficients of input expansion.
      float[2] x2s    = Transformation parameters.
      float    x      = Abscissa value of evaluation.
    
    Returns:
      float    p      = Input expansion evaluated at `x'.
      float    itgrlp = Integral evaluated at `x'.
    """
    return cs1.chbigr(cp, x2s, x)

def chbigr_vector(cp, x2s, x):
    """
    Evaluate an indefinite integral of a Chebyshev expansion at a specified
    point `x' and return the value of the input expansion at `x' as well.
    The constant of integration is selected to make the integral zero when
    `x' equals the abscissa value x2s[0].
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbigr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] cp     = Chebyshev coefficients of input expansion.
      float[_,2] x2s    = Transformation parameters.
      float[_]   x      = Abscissa value of evaluation.
    
    Returns:
      float[_]   p      = Input expansion evaluated at `x'.
      float[_]   itgrlp = Integral evaluated at `x'.
    """
    return cs1.chbigr_vector(cp, x2s, x)

__copy_attributes_from(chbigr, cs1.chbigr)
__copy_attributes_from(chbigr_vector, cs1.chbigr_vector)

#########################
# chbint
#########################

def chbint(cp, x2s, x):
    """
    Return the value of a polynomial and its derivative, evaluated at the
    input `x', using the coefficients of the Chebyshev expansion of the
    polynomial.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbint_c.html
    
    Inputs:
      float[*] cp   = degp+1 Chebyshev polynomial coefficients.
      float[2] x2s  = Transformation parameters of polynomial.
      float    x    = Value for which the polynomial is to be evaluated
    
    Returns:
      float    p    = Value of the polynomial at `x'
      float    dpdx = Value of the derivative of the polynomial at X
    """
    return cs1.chbint(cp, x2s, x)

def chbint_vector(cp, x2s, x):
    """
    Return the value of a polynomial and its derivative, evaluated at the
    input `x', using the coefficients of the Chebyshev expansion of the
    polynomial.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbint_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] cp   = degp+1 Chebyshev polynomial coefficients.
      float[_,2] x2s  = Transformation parameters of polynomial.
      float[_]   x    = Value for which the polynomial is to be evaluated
    
    Returns:
      float[_]   p    = Value of the polynomial at `x'
      float[_]   dpdx = Value of the derivative of the polynomial at X
    """
    return cs1.chbint_vector(cp, x2s, x)

__copy_attributes_from(chbint, cs1.chbint)
__copy_attributes_from(chbint_vector, cs1.chbint_vector)

#########################
# chbval
#########################

def chbval(cp, x2s, x):
    """
    Return the value of a polynomial evaluated at the input `x' using the
    coefficients for the Chebyshev expansion of the polynomial.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbval_c.html
    
    Inputs:
      float[*] cp  = degp+1 Chebyshev polynomial coefficients.
      float[2] x2s = Transformation parameters of polynomial.
      float    x   = Value for which the polynomial is to be evaluated.
    
    Returns:
      float    p   = Value of the polynomial at `x'.
    """
    return cs1.chbval(cp, x2s, x)

def chbval_vector(cp, x2s, x):
    """
    Return the value of a polynomial evaluated at the input `x' using the
    coefficients for the Chebyshev expansion of the polynomial.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chbval_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] cp  = degp+1 Chebyshev polynomial coefficients.
      float[_,2] x2s = Transformation parameters of polynomial.
      float[_]   x   = Value for which the polynomial is to be evaluated.
    
    Returns:
      float[_]   p   = Value of the polynomial at `x'.
    """
    return cs1.chbval_vector(cp, x2s, x)

__copy_attributes_from(chbval, cs1.chbval)
__copy_attributes_from(chbval_vector, cs1.chbval_vector)

#########################
# chkin
#########################

def chkin(module):
    """
    Inform the CSPICE error handling mechanism of entry into a routine.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chkin_c.html
    
    Inputs:
      string module = The name of the calling routine.
    
    Returns: none
    """
    return cs1.chkin(module)

__copy_attributes_from(chkin, cs1.chkin)

#########################
# chkout
#########################

def chkout(module):
    """
    Inform the CSPICE error handling mechanism of exit from a routine.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/chkout_c.html
    
    Inputs:
      string module = The name of the calling routine.
    
    Returns: none
    """
    return cs1.chkout(module)

__copy_attributes_from(chkout, cs1.chkout)

#########################
# cidfrm
#########################

def cidfrm(cent):
    """
    Retrieve frame ID code and name to associate with a frame center.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cidfrm_c.html
    
    Inputs:
      int    cent   = An object ID to associate a frame with.
    
    Returns:
      int    frcode = The ID code of the frame associated with cent.
      string frname = The name of the frame with ID frcode.
      bool   found  = True if the requested information is available.
    
    Note: Raise SPICE(CKINSUFFDATA) condition if the requested information
    is unavailable.
    """
    return cs1.cidfrm(cent)

def cidfrm_error(cent):
    """
    Retrieve frame ID code and name to associate with a frame center.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cidfrm_c.html
    
    Inputs:
      int    cent   = An object ID to associate a frame with.
    
    Returns:
      int    frcode = The ID code of the frame associated with cent.
      string frname = The name of the frame with ID frcode.
    
    Note: Raise SPICE(CKINSUFFDATA) condition if the requested information
    is unavailable.  Raise KeyError(BODYIDNOTFOUND) if the requested frame
    information is unavailable.
    """
    return cs1.cidfrm_error(cent)

__copy_attributes_from(cidfrm, cs1.cidfrm)
__copy_attributes_from(cidfrm_error, cs1.cidfrm_error)

#########################
# ckcls
#########################

def ckcls(handle):
    """
    Close an open CK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckcls_c.html
    
    Inputs:
      int handle = Handle of the CK file to be closed.
    
    Returns: none
    """
    return cs1.ckcls(handle)

__copy_attributes_from(ckcls, cs1.ckcls)

#########################
# ckcov
#########################

def ckcov(ck, idcode, needav, level, tol, timsys, cover = 20000):
    """
    Find the coverage window for a specified object in a specified CK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckcov_c.html
    
    Inputs:
      string    ck     = Name of CK file.
      int       idcode = ID code of object.
      bool      needav = Flag indicating whether angular velocity is needed.
      string    level  = Coverage level: "SEGMENT" OR "INTERVAL".
      float     tol    = Tolerance in ticks.
      string    timsys = Time system used to represent coverage: "SCLK" or
                         "TDB".
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Returns:
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    """
    return cs1.ckcov(ck, idcode, needav, level, tol, timsys, cover)

def ckcov_error(ck, idcode, needav, level, tol, timsys, cover = 20000):
    """
    Find the coverage window for a specified object in a specified CK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckcov_c.html
    
    Inputs:
      string    ck     = Name of CK file.
      int       idcode = ID code of object.
      bool      needav = Flag indicating whether angular velocity is needed.
      string    level  = Coverage level: "SEGMENT" OR "INTERVAL".
      float     tol    = Tolerance in ticks.
      string    timsys = Time system used to represent coverage: "SCLK" or
                         "TDB".
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Returns:
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Note: Raise KeyError(BODYIDNOTFOUND) if the body code is not found in
    the C kernel.
    """
    return cs1.ckcov_error(ck, idcode, needav, level, tol, timsys, cover)

__copy_attributes_from(ckcov, cs1.ckcov)
__copy_attributes_from(ckcov_error, cs1.ckcov_error)

#########################
# ckfrot
#########################

def ckfrot(inst, et):
    """
    Find the position rotation matrix from a C-kernel (CK) frame with the
    specified frame class ID (CK ID) to the base frame of the highest
    priority CK segment containing orientation data for this CK frame at the
    time requested.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckfrot_c.html
    
    Inputs:
      int        inst   = Frame class ID (CK ID) of a CK frame.
      float      et     = Epoch measured in seconds past J2000 TDB.
    
    Returns:
      float[3,3] rotate = Rotation matrix from CK frame to frame `ref'.
      int        ref    = Frame ID of the base reference.
      bool       found  = True if the requested pointing is available.
    """
    return cs1.ckfrot(inst, et)

def ckfrot_error(inst, et):
    """
    Find the position rotation matrix from a C-kernel (CK) frame with the
    specified frame class ID (CK ID) to the base frame of the highest
    priority CK segment containing orientation data for this CK frame at the
    time requested.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckfrot_c.html
    
    Inputs:
      int        inst   = Frame class ID (CK ID) of a CK frame.
      float      et     = Epoch measured in seconds past J2000 TDB.
    
    Returns:
      float[3,3] rotate = Rotation matrix from CK frame to frame `ref'.
      int        ref    = Frame ID of the base reference.
    
    Note: Raise IOError(CKINSUFFDATA) if the requested information is
    unavailable.
    """
    return cs1.ckfrot_error(inst, et)

def ckfrot_vector(inst, et):
    """
    Find the position rotation matrix from a C-kernel (CK) frame with the
    specified frame class ID (CK ID) to the base frame of the highest
    priority CK segment containing orientation data for this CK frame at the
    time requested.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckfrot_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          inst   = Frame class ID (CK ID) of a CK frame.
      float[_]     et     = Epoch measured in seconds past J2000 TDB.
    
    Returns:
      float[_,3,3] rotate = Rotation matrix from CK frame to frame `ref'.
      int          ref    = Frame ID of the base reference.
      bool         found  = True if the requested pointing is available.
    """
    return cs1.ckfrot_vector(inst, et)

__copy_attributes_from(ckfrot, cs1.ckfrot)
__copy_attributes_from(ckfrot_error, cs1.ckfrot_error)
__copy_attributes_from(ckfrot_vector, cs1.ckfrot_vector)

#########################
# ckfxfm
#########################

def ckfxfm(inst, et):
    """
    Find the state transformation matrix from a C-kernel (CK) frame with the
    specified frame class ID (CK ID) to the base frame of the highest
    priority CK segment containing orientation and angular velocity data for
    this CK frame at the time requested.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckfxfm_c.html
    
    Inputs:
      int        inst  = Frame class ID (CK ID) of a CK frame.
      float      et    = Epoch measured in seconds past J2000 TDB.
    
    Returns:
      float[6,6] xform = Transformation from CK frame to frame `ref'.
      int        ref   = Frame ID of the base reference.
      bool       found = True if the requested pointing is available.
    """
    return cs1.ckfxfm(inst, et)

def ckfxfm_error(inst, et):
    """
    Find the state transformation matrix from a C-kernel (CK) frame with the
    specified frame class ID (CK ID) to the base frame of the highest
    priority CK segment containing orientation and angular velocity data for
    this CK frame at the time requested.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckfxfm_c.html
    
    Inputs:
      int        inst  = Frame class ID (CK ID) of a CK frame.
      float      et    = Epoch measured in seconds past J2000 TDB.
    
    Returns:
      float[6,6] xform = Transformation from CK frame to frame `ref'.
      int        ref   = Frame ID of the base reference.
    
    Note: Raise IOError(CKINSUFFDATA) if the requested information is
    unavailable.
    """
    return cs1.ckfxfm_error(inst, et)

def ckfxfm_vector(inst, et):
    """
    Find the state transformation matrix from a C-kernel (CK) frame with the
    specified frame class ID (CK ID) to the base frame of the highest
    priority CK segment containing orientation and angular velocity data for
    this CK frame at the time requested.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckfxfm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          inst  = Frame class ID (CK ID) of a CK frame.
      float[_]     et    = Epoch measured in seconds past J2000 TDB.
    
    Returns:
      float[_,6,6] xform = Transformation from CK frame to frame `ref'.
      int          ref   = Frame ID of the base reference.
      bool         found = True if the requested pointing is available.
    """
    return cs1.ckfxfm_vector(inst, et)

__copy_attributes_from(ckfxfm, cs1.ckfxfm)
__copy_attributes_from(ckfxfm_error, cs1.ckfxfm_error)
__copy_attributes_from(ckfxfm_vector, cs1.ckfxfm_vector)

#########################
# ckgp
#########################

def ckgp(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) for a specified spacecraft clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgp_c.html
    
    Inputs:
      int        inst   = NAIF ID of instrument, spacecraft, or structure.
      float      sclkdp = Encoded spacecraft clock time.
      float      tol    = Time tolerance.
      string     ref    = Reference frame.
    
    Returns:
      float[3,3] cmat   = C-matrix pointing data.
      float      clkout = Output encoded spacecraft clock time.
      bool       found  = True when requested pointing is available.
    """
    return cs1.ckgp(inst, sclkdp, tol, ref)

def ckgp_error(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) for a specified spacecraft clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgp_c.html
    
    Inputs:
      int        inst   = NAIF ID of instrument, spacecraft, or structure.
      float      sclkdp = Encoded spacecraft clock time.
      float      tol    = Time tolerance.
      string     ref    = Reference frame.
    
    Returns:
      float[3,3] cmat   = C-matrix pointing data.
      float      clkout = Output encoded spacecraft clock time.
    
    Note: Raise IOError(CKINSUFFDATA) if the requested pointing is
    unavailable.
    """
    return cs1.ckgp_error(inst, sclkdp, tol, ref)

def ckgp_vector(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) for a specified spacecraft clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          inst   = NAIF ID of instrument, spacecraft, or structure.
      float[_]     sclkdp = Encoded spacecraft clock time.
      float[_]     tol    = Time tolerance.
      string       ref    = Reference frame.
    
    Returns:
      float[_,3,3] cmat   = C-matrix pointing data.
      float[_]     clkout = Output encoded spacecraft clock time.
      bool         found  = True when requested pointing is available.
    """
    return cs1.ckgp_vector(inst, sclkdp, tol, ref)

def ckgp_vector_error(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) for a specified spacecraft clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          inst   = NAIF ID of instrument, spacecraft, or structure.
      float[_]     sclkdp = Encoded spacecraft clock time.
      float[_]     tol    = Time tolerance.
      string       ref    = Reference frame.
    
    Returns:
      float[_,3,3] cmat   = C-matrix pointing data.
      float[_]     clkout = Output encoded spacecraft clock time.
    
    Note: Raise IOError(CKINSUFFDATA) if the requested pointing is
    unavailable.
    """
    return cs1.ckgp_vector_error(inst, sclkdp, tol, ref)

__copy_attributes_from(ckgp, cs1.ckgp)
__copy_attributes_from(ckgp_error, cs1.ckgp_error)
__copy_attributes_from(ckgp_vector, cs1.ckgp_vector)
__copy_attributes_from(ckgp_vector_error, cs1.ckgp_vector_error)

#########################
# ckgpav
#########################

def ckgpav(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) and angular velocity for a specified spacecraft
    clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgpav_c.html
    
    Inputs:
      int        inst   = NAIF ID of instrument, spacecraft, or structure.
      float      sclkdp = Encoded spacecraft clock time.
      float      tol    = Time tolerance.
      string     ref    = Reference frame.
    
    Returns:
      float[3,3] cmat   = C-matrix pointing data.
      float[3]   av     = Angular velocity vector.
      float      clkout = Output encoded spacecraft clock time.
      bool       found  = True when requested pointing is available.
    """
    return cs1.ckgpav(inst, sclkdp, tol, ref)

def ckgpav_error(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) and angular velocity for a specified spacecraft
    clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgpav_c.html
    
    Inputs:
      int        inst   = NAIF ID of instrument, spacecraft, or structure.
      float      sclkdp = Encoded spacecraft clock time.
      float      tol    = Time tolerance.
      string     ref    = Reference frame.
    
    Returns:
      float[3,3] cmat   = C-matrix pointing data.
      float[3]   av     = Angular velocity vector.
      float      clkout = Output encoded spacecraft clock time.
    
    Note: Raise IOError(CKINSUFFDATA) if the requested pointing is
    unavailable.
    """
    return cs1.ckgpav_error(inst, sclkdp, tol, ref)

def ckgpav_vector(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) and angular velocity for a specified spacecraft
    clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgpav_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          inst   = NAIF ID of instrument, spacecraft, or structure.
      float[_]     sclkdp = Encoded spacecraft clock time.
      float[_]     tol    = Time tolerance.
      string       ref    = Reference frame.
    
    Returns:
      float[_,3,3] cmat   = C-matrix pointing data.
      float[_,3]   av     = Angular velocity vector.
      float[_]     clkout = Output encoded spacecraft clock time.
      bool         found  = True when requested pointing is available.
    """
    return cs1.ckgpav_vector(inst, sclkdp, tol, ref)

def ckgpav_vector_error(inst, sclkdp, tol, ref):
    """
    Get pointing (attitude) and angular velocity for a specified spacecraft
    clock time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgpav_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          inst   = NAIF ID of instrument, spacecraft, or structure.
      float[_]     sclkdp = Encoded spacecraft clock time.
      float[_]     tol    = Time tolerance.
      string       ref    = Reference frame.
    
    Returns:
      float[_,3,3] cmat   = C-matrix pointing data.
      float[_,3]   av     = Angular velocity vector.
      float[_]     clkout = Output encoded spacecraft clock time.
    
    Note: Raise IOError(CKINSUFFDATA) if the requested pointing is
    unavailable.
    """
    return cs1.ckgpav_vector_error(inst, sclkdp, tol, ref)

__copy_attributes_from(ckgpav, cs1.ckgpav)
__copy_attributes_from(ckgpav_error, cs1.ckgpav_error)
__copy_attributes_from(ckgpav_vector, cs1.ckgpav_vector)
__copy_attributes_from(ckgpav_vector_error, cs1.ckgpav_vector_error)

#########################
# ckgr02
#########################

def ckgr02(handle, descr, recno):
    """
    Return a specified pointing instance from a CK type 02 segment. The
    segment is identified by a CK file handle and segment descriptor.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgr02_c.html
    
    Inputs:
      int      handle = The handle of the CK file containing the segment.
      float[5] descr  = The segment descriptor.
      int      recno  = The number of the pointing record to be returned.
    
    Returns:
      float[*] record = The pointing record.
    """
    return cs1.ckgr02(handle, descr, recno)

__copy_attributes_from(ckgr02, cs1.ckgr02)

#########################
# ckgr03
#########################

def ckgr03(handle, descr, recno):
    """
    Return a specified pointing instance from a CK type 03 segment. The
    segment is identified by a CK file handle and segment descriptor.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckgr03_c.html
    
    Inputs:
      int      handle = The handle of the CK file containing the segment.
      float[5] descr  = The segment descriptor.
      int      recno  = The number of the pointing instance to be returned.
    
    Returns:
      float[*] record = The pointing record.
    """
    return cs1.ckgr03(handle, descr, recno)

__copy_attributes_from(ckgr03, cs1.ckgr03)

#########################
# cklpf
#########################

def cklpf(fname):
    """
    Load a CK pointing file for use by the CK readers. Return that file's
    handle, to be used by other CK routines to refer to the file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cklpf_c.html
    
    Inputs:
      string fname  = Name of the CK file to be loaded.
    
    Returns:
      int    handle = Loaded file's handle.
    """
    return cs1.cklpf(fname)

__copy_attributes_from(cklpf, cs1.cklpf)

#########################
# ckmeta
#########################

def ckmeta(ckid, meta):
    """
    Return (depending upon the user's request) the ID code of either the
    spacecraft or spacecraft clock associated with a C-Kernel ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckmeta_c.html
    
    Inputs:
      int    ckid   = The ID code for some C kernel object.
      string meta   = The kind of meta data requested "SPK" or "SCLK"
    
    Returns:
      int    idcode = The requested SCLK or spacecraft ID code.
    """
    return cs1.ckmeta(ckid, meta)

__copy_attributes_from(ckmeta, cs1.ckmeta)

#########################
# cknr02
#########################

def cknr02(handle, descr):
    """
    Return the number of pointing records in a CK type 02 segment. The
    segment is identified by a CK file handle and segment descriptor.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cknr02_c.html
    
    Inputs:
      int      handle = The handle of the CK file containing the segment.
      float[5] descr  = The descriptor of the type 2 segment.
    
    Returns:
      int      nrec   = The number of records in the segment.
    """
    return cs1.cknr02(handle, descr)

__copy_attributes_from(cknr02, cs1.cknr02)

#########################
# cknr03
#########################

def cknr03(handle, descr):
    """
    Return the number of pointing instances in a CK type 03 segment. The
    segment is identified by a CK file handle and segment descriptor.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cknr03_c.html
    
    Inputs:
      int      handle = The handle of the CK file containing the segment.
      float[5] descr  = The descriptor of the type 3 segment.
    
    Returns:
      int      nrec   = The number of pointing instances in the segment.
    """
    return cs1.cknr03(handle, descr)

__copy_attributes_from(cknr03, cs1.cknr03)

#########################
# ckobj
#########################

def ckobj(ck, bodids = 1000):
    """
    Find the set of ID codes of all objects in a specified CK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckobj_c.html
    
    Inputs:
      string    ck     = Name of CK file.
      SpiceCell bodids = Array of ID codes of objects in CK file.
    
    Returns:
      SpiceCell bodids = Array of ID codes of objects in CK file.
    """
    return cs1.ckobj(ck, bodids)

__copy_attributes_from(ckobj, cs1.ckobj)

#########################
# ckopn
#########################

def ckopn(fname, ifname, ncomch):
    """
    Open a new CK file, returning the handle of the opened file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckopn_c.html
    
    Inputs:
      string fname  = The name of the CK file to be opened.
      string ifname = The internal filename for the CK.
      int    ncomch = The number of characters to reserve for comments.
    
    Returns:
      int    handle = The handle of the opened CK file.
    """
    return cs1.ckopn(fname, ifname, ncomch)

__copy_attributes_from(ckopn, cs1.ckopn)

#########################
# ckupf
#########################

def ckupf(handle):
    """
    Unload a CK pointing file so that it will no longer be searched by the
    readers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckupf_c.html
    
    Inputs:
      int handle = Handle of CK file to be unloaded
    
    Returns: none
    """
    return cs1.ckupf(handle)

__copy_attributes_from(ckupf, cs1.ckupf)

#########################
# ckw01
#########################

def ckw01(handle, begtim, endtim, inst, ref, avflag, segid, sclkdp, quats, avvs):
    """
    Add a type 1 segment to a C-kernel.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckw01_c.html
    
    Inputs:
      int        handle = Handle of an open CK file.
      float      begtim = The beginning encoded SCLK of the segment.
      float      endtim = The ending encoded SCLK of the segment.
      int        inst   = The NAIF instrument ID code.
      string     ref    = The reference frame of the segment.
      bool       avflag = True if the segment will contain angular velocity.
      string     segid  = Segment identifier.
      float[*]   sclkdp = Encoded SCLK times.
      float[*,4] quats  = Quaternions representing instrument pointing.
      float[*,3] avvs   = Angular velocity vectors.
    
    Returns: none
    """
    return cs1.ckw01(handle, begtim, endtim, inst, ref, avflag, segid, sclkdp, quats, avvs)

__copy_attributes_from(ckw01, cs1.ckw01)

#########################
# ckw02
#########################

def ckw02(handle, begtim, endtim, inst, ref, segid, start, stop, quats, avvs, rates):
    """
    Write a type 2 segment to a C-kernel.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckw02_c.html
    
    Inputs:
      int        handle = Handle of an open CK file.
      float      begtim = The beginning encoded SCLK of the segment.
      float      endtim = The ending encoded SCLK of the segment.
      int        inst   = The NAIF instrument ID code.
      string     ref    = The reference frame of the segment.
      string     segid  = Segment identifier.
      float[*]   start  = Encoded SCLK interval start times.
      float[*]   stop   = Encoded SCLK interval stop times.
      float[*,4] quats  = Quaternions representing instrument pointing.
      float[*,3] avvs   = Angular velocity vectors.
      float[*]   rates  = Number of seconds per tick for each interval.
    
    Returns: none
    """
    return cs1.ckw02(handle, begtim, endtim, inst, ref, segid, start, stop, quats, avvs, rates)

__copy_attributes_from(ckw02, cs1.ckw02)

#########################
# ckw03
#########################

def ckw03(handle, begtim, endtim, inst, ref, avflag, segid, sclkdp, quats, avvs, nints, starts):
    """
    Add a type 3 segment to a C-kernel.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckw03_c.html
    
    Inputs:
      int        handle = Handle of an open CK file.
      float      begtim = The beginning encoded SCLK of the segment.
      float      endtim = The ending encoded SCLK of the segment.
      int        inst   = The NAIF instrument ID code.
      string     ref    = The reference frame of the segment.
      bool       avflag = True if the segment will contain angular velocity.
      string     segid  = Segment identifier.
      float[*]   sclkdp = Encoded SCLK times.
      float[*,4] quats  = Quaternions representing instrument pointing.
      float[*,3] avvs   = Angular velocity vectors.
      int        nints  = Number of intervals.
      float[*]   starts = Encoded SCLK interval start times.
    
    Returns: none
    """
    return cs1.ckw03(handle, begtim, endtim, inst, ref, avflag, segid, sclkdp, quats, avvs, nints, starts)

__copy_attributes_from(ckw03, cs1.ckw03)

#########################
# ckw05
#########################

def ckw05(handle, subtyp, degree, begtim, endtim, inst, ref, avflag, segid, sclkdp, packts, rate, nints, starts):
    """
    Write a type 5 segment to a CK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ckw05_c.html
    
    Inputs:
      int      handle = Handle of an open CK file.
      string   subtyp = CK type 5 subtype code.
      int      degree = Degree of interpolating polynomials.
      float    begtim = The beginning encoded SCLK of the segment.
      float    endtim = The ending encoded SCLK of the segment.
      int      inst   = The NAIF instrument ID code.
      string   ref    = The reference frame of the segment.
      bool     avflag = True if the segment will contain angular velocity.
      string   segid  = Segment identifier.
      float[*] sclkdp = Encoded SCLK times.
      float[*] packts = Array of packets.
      float    rate   = Nominal SCLK rate in seconds per tick.
      int      nints  = Number of intervals.
      float[*] starts = Encoded SCLK interval start times.
    
    Returns: none
    """
    return cs1.ckw05(handle, subtyp, degree, begtim, endtim, inst, ref, avflag, segid, sclkdp, packts, rate, nints, starts)

__copy_attributes_from(ckw05, cs1.ckw05)

#########################
# clight
#########################

def clight():
    """
    Return the speed of light in a vacuum (IAU official value, in km/sec).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/clight_c.html
    
    Inputs: none
    
    Returns:
      float c = The speed of light in vacuo (km/sec).
    """
    return cs1.clight()

__copy_attributes_from(clight, cs1.clight)

#########################
# clpool
#########################

def clpool():
    """
    Remove all variables from the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/clpool_c.html
    
    Inputs: none
    
    Returns: none
    """
    return cs1.clpool()

__copy_attributes_from(clpool, cs1.clpool)

#########################
# cmprss
#########################

def cmprss(delim, n, input):
    """
    Compress a character string by removing occurrences of more than N
    consecutive occurrences of a specified character.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cmprss_c.html
    
    Inputs:
      string delim  = Delimiter to be compressed.
      int    n      = Maximum consecutive occurrences of delim.
      string input  = Input string.
    
    Returns:
      string output = Compressed string.
    """
    return cs1.cmprss(delim, n, input)

__copy_attributes_from(cmprss, cs1.cmprss)

#########################
# cnmfrm
#########################

def cnmfrm(cname):
    """
    Retrieve frame ID code and name to associate with an object.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cnmfrm_c.html
    
    Inputs:
      string cname  = Name of the object to find a frame for.
    
    Returns:
      int    frcode = The ID code of the frame associated with cname.
      string frname = The name of the frame with ID frcode.
      bool   found  = True if the requested information is available.
    """
    return cs1.cnmfrm(cname)

def cnmfrm_error(cname):
    """
    Retrieve frame ID code and name to associate with an object.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cnmfrm_c.html
    
    Inputs:
      string cname  = Name of the object to find a frame for.
    
    Returns:
      int    frcode = The ID code of the frame associated with cname.
      string frname = The name of the frame with ID frcode.
    
    Note: Raise KeyError(BODYNAMENOTFOUND) if the requested frame
    information is unavailable.
    """
    return cs1.cnmfrm_error(cname)

__copy_attributes_from(cnmfrm, cs1.cnmfrm)
__copy_attributes_from(cnmfrm_error, cs1.cnmfrm_error)

#########################
# conics
#########################

def conics(elts, et):
    """
    Determine the state (position, velocity) of an orbiting body from a set
    of elliptic, hyperbolic, or parabolic orbital elements.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/conics_c.html
    
    Inputs:
      float[8] elts  = Conic elements.
      float    et    = Input time.
    
    Returns:
      float[6] state = State of orbiting body at et.
    """
    return cs1.conics(elts, et)

def conics_vector(elts, et):
    """
    Determine the state (position, velocity) of an orbiting body from a set
    of elliptic, hyperbolic, or parabolic orbital elements.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/conics_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,8] elts  = Conic elements.
      float[_]   et    = Input time.
    
    Returns:
      float[_,6] state = State of orbiting body at et.
    """
    return cs1.conics_vector(elts, et)

__copy_attributes_from(conics, cs1.conics)
__copy_attributes_from(conics_vector, cs1.conics_vector)

#########################
# convrt
#########################

def convrt(x, in_, out):
    """
    Take a measurement X, the units associated with X, and units to which X
    should be converted; return Y, the value of the measurement in the
    output units.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/convrt_c.html
    
    Inputs:
      float  x   = Number representing a measurement in some units.
      string in  = The units in which x is measured.
      string out = Desired units for the measurement.
    
    Returns:
      float  y   = The measurment in the desired units.
    """
    return cs1.convrt(x, in_, out)

def convrt_vector(x, in_, out):
    """
    Take a measurement X, the units associated with X, and units to which X
    should be converted; return Y, the value of the measurement in the
    output units.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/convrt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] x   = Number representing a measurement in some units.
      string   in  = The units in which x is measured.
      string   out = Desired units for the measurement.
    
    Returns:
      float[_] y   = The measurment in the desired units.
    """
    return cs1.convrt_vector(x, in_, out)

__copy_attributes_from(convrt, cs1.convrt)
__copy_attributes_from(convrt_vector, cs1.convrt_vector)

#########################
# cpos
#########################

def cpos(str, chars, start):
    """
    Find the first occurrence in a string of a character belonging to a
    collection of characters, starting at a specified location, searching
    forward.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cpos_c.html
    
    Inputs:
      string str   = Any character string.
      string chars = A collection of characters.
      int    start = Position to begin looking for one of chars.
    
    Returns:
      int    pos   = Position of character.
    """
    return cs1.cpos(str, chars, start)

__copy_attributes_from(cpos, cs1.cpos)

#########################
# cposr
#########################

def cposr(str, chars, start):
    """
    Find the first occurrence in a string of a character belonging to a
    collection of characters, starting at a specified location, searching in
    reverse.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cposr_c.html
    
    Inputs:
      string str   = Any character string.
      string chars = A collection of characters.
      int    start = Position to begin looking for one of chars.
    
    Returns:
      int    pos   = Position of character.
    """
    return cs1.cposr(str, chars, start)

__copy_attributes_from(cposr, cs1.cposr)

#########################
# cvpool
#########################

def cvpool(agent):
    """
    Indicate whether or not any watched kernel variables that have a
    specified agent on their notification list have been updated.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cvpool_c.html
    
    Inputs:
      string agent  = Name of the agent to check for notices.
    
    Returns:
      bool   update = True if variables for `agent' have been updated.
    """
    return cs1.cvpool(agent)

__copy_attributes_from(cvpool, cs1.cvpool)

#########################
# cyllat
#########################

def cyllat(r, lonc, z):
    """
    Convert from cylindrical to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cyllat_c.html
    
    Inputs:
      float r      = Distance of point from z axis.
      float lonc   = Cylindrical angle of point from XZ plane (radians).
      float z      = Height of point above XY plane.
    
    Returns:
      float radius = Distance of point from origin.
      float lon    = Longitude of point (radians).
      float lat    = Latitude of point (radians).
    """
    return cs1.cyllat(r, lonc, z)

def cyllat_vector(r, lonc, z):
    """
    Convert from cylindrical to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cyllat_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] r      = Distance of point from z axis.
      float[_] lonc   = Cylindrical angle of point from XZ plane (radians).
      float[_] z      = Height of point above XY plane.
    
    Returns:
      float[_] radius = Distance of point from origin.
      float[_] lon    = Longitude of point (radians).
      float[_] lat    = Latitude of point (radians).
    """
    return cs1.cyllat_vector(r, lonc, z)

__copy_attributes_from(cyllat, cs1.cyllat)
__copy_attributes_from(cyllat_vector, cs1.cyllat_vector)

#########################
# cylrec
#########################

def cylrec(r, lon, z):
    """
    Convert from cylindrical to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cylrec_c.html
    
    Inputs:
      float    r      = Distance of a point from z axis.
      float    lon    = Angle (radians) of a point from XZ plane.
      float    z      = Height of a point above XY plane.
    
    Returns:
      float[3] rectan = Rectangular coordinates of the point.
    """
    return cs1.cylrec(r, lon, z)

def cylrec_vector(r, lon, z):
    """
    Convert from cylindrical to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cylrec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   r      = Distance of a point from z axis.
      float[_]   lon    = Angle (radians) of a point from XZ plane.
      float[_]   z      = Height of a point above XY plane.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of the point.
    """
    return cs1.cylrec_vector(r, lon, z)

__copy_attributes_from(cylrec, cs1.cylrec)
__copy_attributes_from(cylrec_vector, cs1.cylrec_vector)

#########################
# cylsph
#########################

def cylsph(r, lonc, z):
    """
    Convert from cylindrical to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cylsph_c.html
    
    Inputs:
      float r      = Distance of point from z axis.
      float lonc   = Angle (radians) of point from XZ plane.
      float z      = Height of point above XY plane.
    
    Returns:
      float radius = Distance of point from origin.
      float colat  = Polar angle (co-latitude in radians) of point.
      float lon    = Azimuthal angle (longitude) of point (radians).
    """
    return cs1.cylsph(r, lonc, z)

def cylsph_vector(r, lonc, z):
    """
    Convert from cylindrical to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/cylsph_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] r      = Distance of point from z axis.
      float[_] lonc   = Angle (radians) of point from XZ plane.
      float[_] z      = Height of point above XY plane.
    
    Returns:
      float[_] radius = Distance of point from origin.
      float[_] colat  = Polar angle (co-latitude in radians) of point.
      float[_] lon    = Azimuthal angle (longitude) of point (radians).
    """
    return cs1.cylsph_vector(r, lonc, z)

__copy_attributes_from(cylsph, cs1.cylsph)
__copy_attributes_from(cylsph_vector, cs1.cylsph_vector)

#########################
# dafac
#########################

def dafac(handle, buffer):
    """
    Add comments from a buffer of character strings to the comment area of a
    binary DAF file, appending them to any comments which are already
    present in the file's comment area.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafac_c.html
    
    Inputs:
      int       handle = handle of a DAF opened with write access.
      string[*] buffer = Buffer of comments to put into the comment area.
    
    Returns: none
    """
    return cs1.dafac(handle, buffer)

__copy_attributes_from(dafac, cs1.dafac)

#########################
# dafbbs
#########################

def dafbbs(handle):
    """
    Begin a backward search for arrays in a DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafbbs_c.html
    
    Inputs:
      int handle = Handle of DAF to be searched.
    
    Returns: none
    """
    return cs1.dafbbs(handle)

__copy_attributes_from(dafbbs, cs1.dafbbs)

#########################
# dafbfs
#########################

def dafbfs(handle):
    """
    Begin a forward search for arrays in a DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafbfs_c.html
    
    Inputs:
      int handle = Handle of file to be searched.
    
    Returns: none
    """
    return cs1.dafbfs(handle)

__copy_attributes_from(dafbfs, cs1.dafbfs)

#########################
# dafcls
#########################

def dafcls(handle):
    """
    Close the DAF associated with a given handle.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafcls_c.html
    
    Inputs:
      int handle = Handle of DAF to be closed.
    
    Returns: none
    """
    return cs1.dafcls(handle)

__copy_attributes_from(dafcls, cs1.dafcls)

#########################
# dafcs
#########################

def dafcs(handle):
    """
    Select a DAF that already has a search in progress as the one to
    continue searching.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafcs_c.html
    
    Inputs:
      int handle = Handle of DAF to continue searching.
    
    Returns: none
    """
    return cs1.dafcs(handle)

__copy_attributes_from(dafcs, cs1.dafcs)

#########################
# dafdc
#########################

def dafdc(handle):
    """
    Delete the entire comment area of a specified DAF file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafdc_c.html
    
    Inputs:
      int handle = The handle of a binary DAF opened for writing.
    
    Returns: none
    """
    return cs1.dafdc(handle)

__copy_attributes_from(dafdc, cs1.dafdc)

#########################
# dafec
#########################

def dafec(handle):
    """
    Extract comments from the comment area of a binary DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafec_c.html
    
    Inputs:
      int       handle = Handle of binary DAF opened with read access.
    
    Returns:
      string[*] buffer = Buffer where extracted comment lines are placed.
    """
    return cs1.dafec(handle)

__copy_attributes_from(dafec, cs1.dafec)

#########################
# daffna
#########################

def daffna():
    """
    Find the next (forward) array in the current DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/daffna_c.html
    
    Inputs: none
    
    Returns:
      bool found = True if an array was found.
    """
    return cs1.daffna()

__copy_attributes_from(daffna, cs1.daffna)

#########################
# daffpa
#########################

def daffpa():
    """
    Find the previous (backward) array in the current DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/daffpa_c.html
    
    Inputs: none
    
    Returns:
      bool found = True if an array was found.
    """
    return cs1.daffpa()

__copy_attributes_from(daffpa, cs1.daffpa)

#########################
# dafgda
#########################

def dafgda(handle, begin, end):
    """
    Read the floating-point data bounded by two addresses within a DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafgda_c.html
    
    Inputs:
      int   handle = Handle of a DAF.
      int   begin  = Initial address within file.
      int   end    = Final address within file.
    
    Returns:
      float data   = Data contained between `begin' and `end'.
    """
    return cs1.dafgda(handle, begin, end)

__copy_attributes_from(dafgda, cs1.dafgda)

#########################
# dafgh
#########################

def dafgh():
    """
    Return (get) the handle of the DAF currently being searched.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafgh_c.html
    
    Inputs: none
    
    Returns:
      int handle = Handle for current DAF.
    """
    return cs1.dafgh()

__copy_attributes_from(dafgh, cs1.dafgh)

#########################
# dafgn
#########################

def dafgn():
    """
    Return (get) the name for the current array in the current DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafgn_c.html
    
    Inputs: none
    
    Returns:
      string name = Name of current array.
    """
    return cs1.dafgn()

__copy_attributes_from(dafgn, cs1.dafgn)

#########################
# dafgs
#########################

def dafgs():
    """
    Return (get) the summary for the current array in the current DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafgs_c.html
    
    Inputs: none
    
    Returns:
      float[*] sum = Summary for current array.
    """
    return cs1.dafgs()

__copy_attributes_from(dafgs, cs1.dafgs)

#########################
# dafgsr
#########################

def dafgsr(handle, recno, begin, end):
    """
    Read a portion of the contents of a summary record in a DAF file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafgsr_c.html
    
    Inputs:
      int      handle = Handle of DAF.
      int      recno  = Record number.
      int      begin  = First word to read from record.
      int      end    = Last word to read from record.
    
    Returns:
      float[*] data   = Contents of record.
      bool     found  = True if record is found.
    """
    return cs1.dafgsr(handle, recno, begin, end)

def dafgsr_error(handle, recno, begin, end):
    """
    Read a portion of the contents of a summary record in a DAF file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafgsr_c.html
    
    Inputs:
      int      handle = Handle of DAF.
      int      recno  = Record number.
      int      begin  = First word to read from record.
      int      end    = Last word to read from record.
    
    Returns:
      float[*] data   = Contents of record.
    
    Note: Raise IOError(DAFFRNOTFOUND) if the file read failed.
    """
    return cs1.dafgsr_error(handle, recno, begin, end)

__copy_attributes_from(dafgsr, cs1.dafgsr)
__copy_attributes_from(dafgsr_error, cs1.dafgsr_error)

#########################
# dafhsf
#########################

def dafhsf(handle):
    """
    Return the summary format associated with a handle.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafhsf_c.html
    
    Inputs:
      int handle = Handle of a DAF file.
    
    Returns:
      int nd     = Number of floating-point components in summaries.
      int ni     = Number of integer components in summaries.
    """
    return cs1.dafhsf(handle)

__copy_attributes_from(dafhsf, cs1.dafhsf)

#########################
# dafopr
#########################

def dafopr(fname):
    """
    Open a DAF for subsequent read requests.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafopr_c.html
    
    Inputs:
      string fname  = Name of DAF to be opened.
    
    Returns:
      int    handle = Handle assigned to DAF.
    """
    return cs1.dafopr(fname)

__copy_attributes_from(dafopr, cs1.dafopr)

#########################
# dafopw
#########################

def dafopw(fname):
    """
    Open a DAF for subsequent write requests.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafopw_c.html
    
    Inputs:
      string fname  = Name of DAF to be opened.
    
    Returns:
      int    handle = Handle assigned to DAF.
    """
    return cs1.dafopw(fname)

__copy_attributes_from(dafopw, cs1.dafopw)

#########################
# dafps
#########################

def dafps(dc, ic):
    """
    Pack (assemble) an array summary from its floating-point and integer
    components.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafps_c.html
    
    Inputs:
      float[*] dc  = Double precision components.
      int[*]   ic  = Integer components.
    
    Returns:
      float[*] sum = Array summary.
    """
    return cs1.dafps(dc, ic)

__copy_attributes_from(dafps, cs1.dafps)

#########################
# dafrfr
#########################

def dafrfr(handle):
    """
    Read the contents of the file record of a DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafrfr_c.html
    
    Inputs:
      int    handle = Handle of an open DAF file.
    
    Returns:
      int    nd     = Number of floating-point components in summaries.
      int    ni     = Number of integer components in summaries.
      string ifname = Internal file name.
      int    fward  = Forward list pointer.
      int    bward  = Backward list pointer.
      int    free   = Free address pointer.
    """
    return cs1.dafrfr(handle)

__copy_attributes_from(dafrfr, cs1.dafrfr)

#########################
# dafrs
#########################

def dafrs(sum):
    """
    Change the summary for the current array in the current DAF.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafrs_c.html
    
    Inputs:
      float[*] sum = New summary for current array.
    
    Returns: none
    """
    return cs1.dafrs(sum)

__copy_attributes_from(dafrs, cs1.dafrs)

#########################
# dafus
#########################

def dafus(sum, nd, ni):
    """
    Unpack an array summary into its floating-point and integer components.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dafus_c.html
    
    Inputs:
      float[*] sum = Array summary.
      int      nd  = Number of floating-point components.
      int      ni  = Number of integer components.
    
    Returns:
      float[*] dc  = Floating-point components.
      int[*]   ic  = Integer components.
    """
    return cs1.dafus(sum, nd, ni)

__copy_attributes_from(dafus, cs1.dafus)

#########################
# dasac
#########################

def dasac(handle, buffer):
    """
    Add comments from a buffer of character strings to the comment area of a
    binary DAS file, appending them to any comments which are already
    present in the file's comment area.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasac_c.html
    
    Inputs:
      int       handle = DAS handle of a file opened with write access.
      string[*] buffer = Buffer of lines to be put into the comment area.
    
    Returns: none
    """
    return cs1.dasac(handle, buffer)

__copy_attributes_from(dasac, cs1.dasac)

#########################
# dasadc
#########################

def dasadc(handle, n, bpos, epos, data):
    """
    Add character data to a DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasadc_c.html
    
    Inputs:
      int             handle = DAS file handle.
      int             n      = Number of characters to add to file.
      int             bpos   = Begin position of substrings in byte array.
      int             epos   = End position of substrings in byte array.
      byte_array[*,*] data   = Sequence of strings providing the set of
                               substrings to be added to the character data
                               in the DAS file.
    
    Returns: none
    """
    return cs1.dasadc(handle, n, bpos, epos, data)

__copy_attributes_from(dasadc, cs1.dasadc)

#########################
# dasadd
#########################

def dasadd(handle, data):
    """
    Add an array of floating-point numbers to a DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasadd_c.html
    
    Inputs:
      int      handle = DAS file handle.
      float[*] data   = Array of d.p. numbers to add.
    
    Returns: none
    """
    return cs1.dasadd(handle, data)

__copy_attributes_from(dasadd, cs1.dasadd)

#########################
# dasadi
#########################

def dasadi(handle, data):
    """
    Add an array of integers to a DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasadi_c.html
    
    Inputs:
      int    handle = DAS file handle.
      int[*] data   = Array of integers to add.
    
    Returns: none
    """
    return cs1.dasadi(handle, data)

__copy_attributes_from(dasadi, cs1.dasadi)

#########################
# dascls
#########################

def dascls(handle):
    """
    Close a DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dascls_c.html
    
    Inputs:
      int handle = Handle of an open DAS file.
    
    Returns: none
    """
    return cs1.dascls(handle)

__copy_attributes_from(dascls, cs1.dascls)

#########################
# dasdc
#########################

def dasdc(handle):
    """
    Delete the entire comment area of a previously opened binary DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasdc_c.html
    
    Inputs:
      int handle = The handle of a binary DAS file opened for writing.
    
    Returns: none
    """
    return cs1.dasdc(handle)

__copy_attributes_from(dasdc, cs1.dasdc)

#########################
# dasec
#########################

def dasec(handle):
    """
    Extract comments from the comment area of a binary DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasec_c.html
    
    Inputs:
      int       handle = Handle of binary DAS file open with read access.
    
    Returns:
      string[*] buffer = Buffer in which extracted comments are placed.
    """
    return cs1.dasec(handle)

__copy_attributes_from(dasec, cs1.dasec)

#########################
# dashfn
#########################

def dashfn(handle):
    """
    Return the name of the DAS file associated with a handle.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dashfn_c.html
    
    Inputs:
      int    handle = Handle of a DAS file.
    
    Returns:
      string fname  = Corresponding file name.
    """
    return cs1.dashfn(handle)

__copy_attributes_from(dashfn, cs1.dashfn)

#########################
# dashfs
#########################

def dashfs(handle):
    """
    Return a file summary for a specified DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dashfs_c.html
    
    Inputs:
      int    handle = Handle of a DAS file.
    
    Returns:
      int    nresvr = Number of reserved records in file.
      int    nresvc = Number of characters in use in reserved rec. area.
      int    ncomr  = Number of comment records in file.
      int    ncomc  = Number of characters in use in comment area.
      int    free   = Number of first free record.
      int[3] lastla = Array of last logical addresses for each data type.
      int[3] lastrc = Record number of last descriptor of each data type.
      int[3] lastwd = Word number of last descriptor of each data type.
    """
    return cs1.dashfs(handle)

__copy_attributes_from(dashfs, cs1.dashfs)

#########################
# daslla
#########################

def daslla(handle):
    """
    Return last DAS logical addresses of character, floating-point and
    integer type that are currently in use in a specified DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/daslla_c.html
    
    Inputs:
      int handle = DAS file handle.
    
    Returns:
      int lastc  = Last character address in use.
      int lastd  = Last floating-point address in use.
      int lasti  = Last integer address in use.
    """
    return cs1.daslla(handle)

__copy_attributes_from(daslla, cs1.daslla)

#########################
# dasllc
#########################

def dasllc(handle):
    """
    Close the DAS file associated with a given handle, without flushing
    buffered data or segregating the file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasllc_c.html
    
    Inputs:
      int handle = Handle of a DAS file to be closed.
    
    Returns: none
    """
    return cs1.dasllc(handle)

__copy_attributes_from(dasllc, cs1.dasllc)

#########################
# dasonw
#########################

def dasonw(fname, ftype, ifname, ncomr):
    """
    Open a new DAS file and set the file type.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasonw_c.html
    
    Inputs:
      string fname  = Name of a DAS file to be opened.
      string ftype  = Mnemonic code for type of data in the DAS file.
      string ifname = Internal file name.
      int    ncomr  = Number of comment records to allocate.
    
    Returns:
      int    handle = Handle assigned to the opened DAS file.
    """
    return cs1.dasonw(fname, ftype, ifname, ncomr)

__copy_attributes_from(dasonw, cs1.dasonw)

#########################
# dasopr
#########################

def dasopr(fname):
    """
    Open a DAS file for reading.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasopr_c.html
    
    Inputs:
      string fname  = Name of a DAS file to be opened.
    
    Returns:
      int    handle = Handle assigned to the opened DAS file.
    """
    return cs1.dasopr(fname)

__copy_attributes_from(dasopr, cs1.dasopr)

#########################
# dasops
#########################

def dasops():
    """
    Open a scratch DAS file for writing.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasops_c.html
    
    Inputs: none
    
    Returns:
      int handle = Handle assigned to a scratch DAS file.
    """
    return cs1.dasops()

__copy_attributes_from(dasops, cs1.dasops)

#########################
# dasopw
#########################

def dasopw(fname):
    """
    Open a DAS file for writing.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasopw_c.html
    
    Inputs:
      string fname  = Name of a DAS file to be opened.
    
    Returns:
      int    handle = Handle assigned to the opened DAS file.
    """
    return cs1.dasopw(fname)

__copy_attributes_from(dasopw, cs1.dasopw)

#########################
# dasrdc
#########################

def dasrdc(handle, first, last, bpos, epos, data = None):
    """
    Read character data from a range of DAS logical addresses.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasrdc_c.html
    
    Inputs:
      int             handle = DAS file handle.
      int             first  = Beginning of range of DAS character logical
                               addresses.
      int             last   = End of range of DAS character logical
                               addresses.
      int             bpos   = Beginning position of substrings.
      int             epos   = End position of substrings.
      byte_array[*,*] data   = Sequence of strings to be updated by the
                               character data in the DAS file.
    
    Returns:
      byte_array[*,*] data   = Sequence of strings to be updated by the
                               character data in the DAS file.
    """
    return cs1.dasrdc(handle, first, last, bpos, epos, data)

__copy_attributes_from(dasrdc, cs1.dasrdc)

#########################
# dasrdd
#########################

def dasrdd(handle, first, last):
    """
    Read floating-point data from a range of DAS logical addresses.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasrdd_c.html
    
    Inputs:
      int      handle = DAS file handle.
      int      first  = Beginning of range of DAS floating-point logical
                        addresses.
      int      last   = End of range of DAS floating-point logical
                        addresses.
    
    Returns:
      float[*] data   = Data having addresses `first' through `last'.
    """
    return cs1.dasrdd(handle, first, last)

__copy_attributes_from(dasrdd, cs1.dasrdd)

#########################
# dasrdi
#########################

def dasrdi(handle, first, last):
    """
    Read integer data from a range of DAS logical addresses.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasrdi_c.html
    
    Inputs:
      int    handle = DAS file handle.
      int    first  = Beginning of range of DAS integer logical addresses.
      int    last   = End of range of DAS integer logical addresses.
    
    Returns:
      int[*] data   = Data having addresses `first' through `last'.
    """
    return cs1.dasrdi(handle, first, last)

__copy_attributes_from(dasrdi, cs1.dasrdi)

#########################
# dasrfr
#########################

def dasrfr(handle):
    """
    Return the contents of the file record of a specified DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasrfr_c.html
    
    Inputs:
      int    handle = DAS file handle.
    
    Returns:
      string idword = ID word.
      string ifname = DAS internal file name.
      int    nresvr = Number of reserved records in file.
      int    nresvc = Number of characters in use in reserved rec. area.
      int    ncomr  = Number of comment records in file.
      int    ncomc  = Number of characters in use in comment area.
    """
    return cs1.dasrfr(handle)

__copy_attributes_from(dasrfr, cs1.dasrfr)

#########################
# dasudc
#########################

def dasudc(handle, first, last, bpos, epos, data):
    """
    Update character data in a specified range of DAS logical addresses with
    substrings of a character array.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasudc_c.html
    
    Inputs:
      int             handle = DAS file handle.
      int             first  = Beginning of range of DAS character logical
                               addresses.
      int             last   = End of range of DAS character logical
                               addresses.
      int             bpos   = Begin position of substrings in byte array.
      int             epos   = End position of substrings in byte array.
      byte_array[*,*] data   = Sequence of strings providing the set of
                               substrings to be updated in the character
                               data in the DAS file.
    
    Returns: none
    """
    return cs1.dasudc(handle, first, last, bpos, epos, data)

__copy_attributes_from(dasudc, cs1.dasudc)

#########################
# dasudd
#########################

def dasudd(handle, first, last, data):
    """
    Update data in a specified range of floating-point addresses in a DAS
    file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasudd_c.html
    
    Inputs:
      int      handle = DAS file handle.
      int      first  = Beginning of range of floating-point addresses to
                        write to.
      int      last   = End of range of floating-point addresses to write
                        to.
      float[*] data   = An array of d.p. numbers.
    
    Returns: none
    """
    return cs1.dasudd(handle, first, last, data)

__copy_attributes_from(dasudd, cs1.dasudd)

#########################
# dasudi
#########################

def dasudi(handle, first, last, data):
    """
    Update data in a specified range of integer addresses in a DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dasudi_c.html
    
    Inputs:
      int    handle = DAS file handle.
      int    first  = Beginning of range of integer addresses to write to.
      int    last   = End of range of integer addresses to write to.
      int[*] data   = An array of integers.
    
    Returns: none
    """
    return cs1.dasudi(handle, first, last, data)

__copy_attributes_from(dasudi, cs1.dasudi)

#########################
# daswbr
#########################

def daswbr(handle):
    """
    Write out all buffered records of a specified DAS file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/daswbr_c.html
    
    Inputs:
      int handle = Handle of DAS file.
    
    Returns: none
    """
    return cs1.daswbr(handle)

__copy_attributes_from(daswbr, cs1.daswbr)

#########################
# dazldr
#########################

def dazldr(x, y, z, azccw, elplsz):
    """
    Compute the Jacobian matrix of the transformation from rectangular to
    azimuth/elevation coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dazldr_c.html
    
    Inputs:
      float      x      = x-coordinate of point.
      float      y      = y-coordinate of point.
      float      z      = z-coordinate of point.
      bool       azccw  = Flag indicating how azimuth is measured, True for
                          counterclockwise, False for clockwise.
      bool       elplsz = Flag indicating how elevation is measured, True
                          for increasing toward +Z, False for -Z.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dazldr(x, y, z, azccw, elplsz)

def dazldr_vector(x, y, z, azccw, elplsz):
    """
    Compute the Jacobian matrix of the transformation from rectangular to
    azimuth/elevation coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dazldr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     x      = x-coordinate of point.
      float[_]     y      = y-coordinate of point.
      float[_]     z      = z-coordinate of point.
      bool         azccw  = Flag indicating how azimuth is measured, True
                            for counterclockwise, False for clockwise.
      bool         elplsz = Flag indicating how elevation is measured, True
                            for increasing toward +Z, False for -Z.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dazldr_vector(x, y, z, azccw, elplsz)

__copy_attributes_from(dazldr, cs1.dazldr)
__copy_attributes_from(dazldr_vector, cs1.dazldr_vector)

#########################
# dcyldr
#########################

def dcyldr(x, y, z):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to cylindrical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dcyldr_c.html
    
    Inputs:
      float      x      = X-coordinate of point.
      float      y      = Y-coordinate of point.
      float      z      = Z-coordinate of point.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dcyldr(x, y, z)

def dcyldr_vector(x, y, z):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to cylindrical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dcyldr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     x      = X-coordinate of point.
      float[_]     y      = Y-coordinate of point.
      float[_]     z      = Z-coordinate of point.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dcyldr_vector(x, y, z)

__copy_attributes_from(dcyldr, cs1.dcyldr)
__copy_attributes_from(dcyldr_vector, cs1.dcyldr_vector)

#########################
# deltet
#########################

def deltet(epoch, eptype):
    """
    Return the value of Delta ET (ET-UTC) for an input epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/deltet_c.html
    
    Inputs:
      float  epoch  = Input epoch (seconds past J2000).
      string eptype = Type of input epoch ("UTC" or "ET").
    
    Returns:
      float  delta  = Delta ET (ET-UTC) at input epoch.
    """
    return cs1.deltet(epoch, eptype)

def deltet_vector(epoch, eptype):
    """
    Return the value of Delta ET (ET-UTC) for an input epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/deltet_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] epoch  = Input epoch (seconds past J2000).
      string   eptype = Type of input epoch ("UTC" or "ET").
    
    Returns:
      float[_] delta  = Delta ET (ET-UTC) at input epoch.
    """
    return cs1.deltet_vector(epoch, eptype)

__copy_attributes_from(deltet, cs1.deltet)
__copy_attributes_from(deltet_vector, cs1.deltet_vector)

#########################
# det
#########################

def det(m1):
    """
    Compute the determinant of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/det_c.html
    
    Inputs:
      float[3,3] m1    = Matrix whose determinant is to be found.
    
    Returns:
      float      value = Value of the determinant.
    """
    return cs1.det(m1)

def det_vector(m1):
    """
    Compute the determinant of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/det_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1    = Matrix whose determinant is to be found.
    
    Returns:
      float[_]     value = Value of the determinant.
    """
    return cs1.det_vector(m1)

__copy_attributes_from(det, cs1.det)
__copy_attributes_from(det_vector, cs1.det_vector)

#########################
# dgeodr
#########################

def dgeodr(x, y, z, re, f):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to geodetic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dgeodr_c.html
    
    Inputs:
      float      x      = X-coordinate of point.
      float      y      = Y-coordinate of point.
      float      z      = Z-coordinate of point.
      float      re     = Equatorial radius of the reference spheroid.
      float      f      = Flattening coefficient.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dgeodr(x, y, z, re, f)

def dgeodr_vector(x, y, z, re, f):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to geodetic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dgeodr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     x      = X-coordinate of point.
      float[_]     y      = Y-coordinate of point.
      float[_]     z      = Z-coordinate of point.
      float[_]     re     = Equatorial radius of the reference spheroid.
      float[_]     f      = Flattening coefficient.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dgeodr_vector(x, y, z, re, f)

__copy_attributes_from(dgeodr, cs1.dgeodr)
__copy_attributes_from(dgeodr_vector, cs1.dgeodr_vector)

#########################
# diags2
#########################

def diags2(symmat):
    """
    Diagonalize a symmetric 2x2 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/diags2_c.html
    
    Inputs:
      float[2,2] symmat = A symmetric 2x2 matrix.
    
    Returns:
      float[2,2] diag   = A diagonal matrix similar to symmat.
      float[2,2] rotate = A rotation used as the similarity transformation.
    """
    return cs1.diags2(symmat)

def diags2_vector(symmat):
    """
    Diagonalize a symmetric 2x2 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/diags2_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,2,2] symmat = A symmetric 2x2 matrix.
    
    Returns:
      float[_,2,2] diag   = A diagonal matrix similar to symmat.
      float[_,2,2] rotate = A rotation used as the similarity
                            transformation.
    """
    return cs1.diags2_vector(symmat)

__copy_attributes_from(diags2, cs1.diags2)
__copy_attributes_from(diags2_vector, cs1.diags2_vector)

#########################
# dlabbs
#########################

def dlabbs(handle):
    """
    Begin a backward segment search in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlabbs_c.html
    
    Inputs:
      int           handle = Handle of open DLA file.
    
    Returns:
      SpiceDLADescr dladsc = Descriptor of last segment in DLA file.
      bool          found  = Flag indicating whether a segment was found.
    """
    return cs1.dlabbs(handle)

def dlabbs_error(handle):
    """
    Begin a backward segment search in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlabbs_c.html
    
    Inputs:
      int           handle = Handle of open DLA file.
    
    Returns:
      SpiceDLADescr dladsc = Descriptor of last segment in DLA file.
    
    Note: Raise IOError(DASFILEREADFAILED) if the file read failed.
    """
    return cs1.dlabbs_error(handle)

__copy_attributes_from(dlabbs, cs1.dlabbs)
__copy_attributes_from(dlabbs_error, cs1.dlabbs_error)

#########################
# dlabfs
#########################

def dlabfs(handle):
    """
    Begin a forward segment search in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlabfs_c.html
    
    Inputs:
      int           handle = Handle of open DLA file.
    
    Returns:
      SpiceDLADescr dladsc = Descriptor of first segment in DLA file.
      bool          found  = Flag indicating whether a segment was found.
    """
    return cs1.dlabfs(handle)

def dlabfs_error(handle):
    """
    Begin a forward segment search in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlabfs_c.html
    
    Inputs:
      int           handle = Handle of open DLA file.
    
    Returns:
      SpiceDLADescr dladsc = Descriptor of first segment in DLA file.
    
    Note: Raise IOError(DASFILEREADFAILED) if the file read failed.
    """
    return cs1.dlabfs_error(handle)

__copy_attributes_from(dlabfs, cs1.dlabfs)
__copy_attributes_from(dlabfs_error, cs1.dlabfs_error)

#########################
# dlabns
#########################

def dlabns(handle):
    """
    Begin a new segment in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlabns_c.html
    
    Inputs:
      int handle = Handle of open DLA file.
    
    Returns: none
    """
    return cs1.dlabns(handle)

__copy_attributes_from(dlabns, cs1.dlabns)

#########################
# dlaens
#########################

def dlaens(handle):
    """
    End a new segment in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlaens_c.html
    
    Inputs:
      int handle = Handle of open DLA file.
    
    Returns: none
    """
    return cs1.dlaens(handle)

__copy_attributes_from(dlaens, cs1.dlaens)

#########################
# dlafns
#########################

def dlafns(handle, dladsc):
    """
    Find the segment following a specified segment in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlafns_c.html
    
    Inputs:
      int                   handle = Handle of open DLA file.
      ConstSpiceDLADescr[*] dladsc = Descriptor of a DLA segment.
    
    Returns:
      SpiceDLADescr         nxtdsc = Descriptor of next segment in DLA file.
      bool                  found  = Flag indicating whether a segment was
                                     found.
    """
    return cs1.dlafns(handle, dladsc)

def dlafns_error(handle, dladsc):
    """
    Find the segment following a specified segment in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlafns_c.html
    
    Inputs:
      int                   handle = Handle of open DLA file.
      ConstSpiceDLADescr[*] dladsc = Descriptor of a DLA segment.
    
    Returns:
      SpiceDLADescr         nxtdsc = Descriptor of next segment in DLA file.
    
    Note: Raise IOError(DASFILEREADFAILED) if the file read failed.
    """
    return cs1.dlafns_error(handle, dladsc)

__copy_attributes_from(dlafns, cs1.dlafns)
__copy_attributes_from(dlafns_error, cs1.dlafns_error)

#########################
# dlafps
#########################

def dlafps(handle, dladsc):
    """
    Find the segment preceding a specified segment in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlafps_c.html
    
    Inputs:
      int                   handle = Handle of open DLA file.
      ConstSpiceDLADescr[*] dladsc = Descriptor of a segment in DLA file.
    
    Returns:
      SpiceDLADescr         prvdsc = Descriptor of previous segment in DLA
                                     file.
      bool                  found  = Flag indicating whether a segment was
                                     found.
    """
    return cs1.dlafps(handle, dladsc)

def dlafps_error(handle, dladsc):
    """
    Find the segment preceding a specified segment in a DLA file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlafps_c.html
    
    Inputs:
      int                   handle = Handle of open DLA file.
      ConstSpiceDLADescr[*] dladsc = Descriptor of a segment in DLA file.
    
    Returns:
      SpiceDLADescr         prvdsc = Descriptor of previous segment in DLA
                                     file.
    
    Note: Raise IOError(DASFILEREADFAILED) if the file read failed.
    """
    return cs1.dlafps_error(handle, dladsc)

__copy_attributes_from(dlafps, cs1.dlafps)
__copy_attributes_from(dlafps_error, cs1.dlafps_error)

#########################
# dlaopn
#########################

def dlaopn(fname, ftype, ifname, ncomch):
    """
    Open a new DLA file and set the file type.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlaopn_c.html
    
    Inputs:
      string fname  = Name of a DLA file to be opened.
      string ftype  = Mnemonic code for type of data in the DLA file.
      string ifname = Internal file name.
      int    ncomch = Number of comment characters to allocate.
    
    Returns:
      int    handle = Handle assigned to the opened DLA file.
    """
    return cs1.dlaopn(fname, ftype, ifname, ncomch)

__copy_attributes_from(dlaopn, cs1.dlaopn)

#########################
# dlatdr
#########################

def dlatdr(x, y, z):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlatdr_c.html
    
    Inputs:
      float      x      = X-coordinate of point.
      float      y      = Y-coordinate of point.
      float      z      = Z-coordinate of point.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dlatdr(x, y, z)

def dlatdr_vector(x, y, z):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dlatdr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     x      = X-coordinate of point.
      float[_]     y      = Y-coordinate of point.
      float[_]     z      = Z-coordinate of point.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dlatdr_vector(x, y, z)

__copy_attributes_from(dlatdr, cs1.dlatdr)
__copy_attributes_from(dlatdr_vector, cs1.dlatdr_vector)

#########################
# dnearp
#########################

def dnearp(state, a, b, c):
    """
    Compute the state (position and velocity) of an ellipsoid surface point
    nearest to the position component of a specified state.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dnearp_c.html
    
    Inputs:
      float[6] state = State of an object in body-fixed coordinates.
      float    a     = Length of semi-axis parallel to X-axis.
      float    b     = Length of semi-axis parallel to Y-axis.
      float    c     = Length on semi-axis parallel to Z-axis.
    
    Returns:
      float[6] dnear = State of the nearest point on the ellipsoid.
      float[2] dalt  = Altitude and derivative of altitude.
      bool     found = Flag that indicates whether `dnear' is degenerate.
    """
    return cs1.dnearp(state, a, b, c)

def dnearp_vector(state, a, b, c):
    """
    Compute the state (position and velocity) of an ellipsoid surface point
    nearest to the position component of a specified state.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dnearp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] state = State of an object in body-fixed coordinates.
      float[_]   a     = Length of semi-axis parallel to X-axis.
      float[_]   b     = Length of semi-axis parallel to Y-axis.
      float[_]   c     = Length on semi-axis parallel to Z-axis.
    
    Returns:
      float[_,6] dnear = State of the nearest point on the ellipsoid.
      float[_,2] dalt  = Altitude and derivative of altitude.
      bool       found = Flag that indicates whether `dnear' is degenerate.
    """
    return cs1.dnearp_vector(state, a, b, c)

__copy_attributes_from(dnearp, cs1.dnearp)
__copy_attributes_from(dnearp_vector, cs1.dnearp_vector)

#########################
# dp2hx
#########################

def dp2hx(number):
    """
    Convert a floating-point number to an equivalent character string using
    a base 16 "scientific notation."
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dp2hx_c.html
    
    Inputs:
      float  number = D.p. number to be converted.
    
    Returns:
      string hxstr  = Equivalent character string, left justified.
    """
    return cs1.dp2hx(number)

__copy_attributes_from(dp2hx, cs1.dp2hx)

#########################
# dpgrdr
#########################

def dpgrdr(body, x, y, z, re, f):
    """
    This routine computes the Jacobian matrix of the transformation from
    rectangular to planetographic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dpgrdr_c.html
    
    Inputs:
      string     body   = Body with which coordinate system is associated.
      float      x      = X-coordinate of point.
      float      y      = Y-coordinate of point.
      float      z      = Z-coordinate of point.
      float      re     = Equatorial radius of the reference spheroid.
      float      f      = Flattening coefficient.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dpgrdr(body, x, y, z, re, f)

def dpgrdr_vector(body, x, y, z, re, f):
    """
    This routine computes the Jacobian matrix of the transformation from
    rectangular to planetographic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dpgrdr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string       body   = Body with which coordinate system is associated.
      float[_]     x      = X-coordinate of point.
      float[_]     y      = Y-coordinate of point.
      float[_]     z      = Z-coordinate of point.
      float[_]     re     = Equatorial radius of the reference spheroid.
      float[_]     f      = Flattening coefficient.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dpgrdr_vector(body, x, y, z, re, f)

__copy_attributes_from(dpgrdr, cs1.dpgrdr)
__copy_attributes_from(dpgrdr_vector, cs1.dpgrdr_vector)

#########################
# dpmax
#########################

def dpmax():
    """
    Return the value of the largest (positive) number representable in a
    floating-point variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dpmax_c.html
    
    Inputs: none
    
    Returns:
      float value = The maximum respresentable floating-point number.
    """
    return cs1.dpmax()

__copy_attributes_from(dpmax, cs1.dpmax)

#########################
# dpmin
#########################

def dpmin():
    """
    Return the value of the smallest (negative) number representable in a
    floating-point variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dpmin_c.html
    
    Inputs: none
    
    Returns:
      float value = The minimum respresentable floating-point number.
    """
    return cs1.dpmin()

__copy_attributes_from(dpmin, cs1.dpmin)

#########################
# dpr
#########################

def dpr():
    """
    Return the number of degrees per radian.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dpr_c.html
    
    Inputs: none
    
    Returns:
      float value = The number of degrees per radian.
    """
    return cs1.dpr()

__copy_attributes_from(dpr, cs1.dpr)

#########################
# drdazl
#########################

def drdazl(range, az, el, azccw, elplsz):
    """
    Compute the Jacobian matrix of the transformation from azimuth/elevation
    to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdazl_c.html
    
    Inputs:
      float      range  = Distance of a point from the origin.
      float      az     = Azimuth of input point in radians.
      float      el     = Elevation of input point in radians.
      bool       azccw  = Flag indicating how azimuth is measured, True for
                          counterclockwise, False for clockwise.
      bool       elplsz = Flag indicating how elevation is measured, True
                          for increasing toward +Z, False for -Z.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdazl(range, az, el, azccw, elplsz)

def drdazl_vector(range, az, el, azccw, elplsz):
    """
    Compute the Jacobian matrix of the transformation from azimuth/elevation
    to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdazl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     range  = Distance of a point from the origin.
      float[_]     az     = Azimuth of input point in radians.
      float[_]     el     = Elevation of input point in radians.
      bool         azccw  = Flag indicating how azimuth is measured, True
                            for counterclockwise, False for clockwise.
      bool         elplsz = Flag indicating how elevation is measured, True
                            for increasing toward +Z, False for -Z.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdazl_vector(range, az, el, azccw, elplsz)

__copy_attributes_from(drdazl, cs1.drdazl)
__copy_attributes_from(drdazl_vector, cs1.drdazl_vector)

#########################
# drdcyl
#########################

def drdcyl(r, lon, z):
    """
    This routine computes the Jacobian of the transformation from
    cylindrical to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdcyl_c.html
    
    Inputs:
      float      r      = Distance of a point from the origin.
      float      lon    = Angle of the point from the xz plane in radians.
      float      z      = Height of the point above the xy plane.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdcyl(r, lon, z)

def drdcyl_vector(r, lon, z):
    """
    This routine computes the Jacobian of the transformation from
    cylindrical to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdcyl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     r      = Distance of a point from the origin.
      float[_]     lon    = Angle of the point from the xz plane in radians.
      float[_]     z      = Height of the point above the xy plane.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdcyl_vector(r, lon, z)

__copy_attributes_from(drdcyl, cs1.drdcyl)
__copy_attributes_from(drdcyl_vector, cs1.drdcyl_vector)

#########################
# drdgeo
#########################

def drdgeo(lon, lat, alt, re, f):
    """
    This routine computes the Jacobian of the transformation from geodetic
    to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdgeo_c.html
    
    Inputs:
      float      lon    = Geodetic longitude of point (radians).
      float      lat    = Geodetic latitude of point (radians).
      float      alt    = Altitude of point above the reference spheroid.
      float      re     = Equatorial radius of the reference spheroid.
      float      f      = Flattening coefficient.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdgeo(lon, lat, alt, re, f)

def drdgeo_vector(lon, lat, alt, re, f):
    """
    This routine computes the Jacobian of the transformation from geodetic
    to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdgeo_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     lon    = Geodetic longitude of point (radians).
      float[_]     lat    = Geodetic latitude of point (radians).
      float[_]     alt    = Altitude of point above the reference spheroid.
      float[_]     re     = Equatorial radius of the reference spheroid.
      float[_]     f      = Flattening coefficient.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdgeo_vector(lon, lat, alt, re, f)

__copy_attributes_from(drdgeo, cs1.drdgeo)
__copy_attributes_from(drdgeo_vector, cs1.drdgeo_vector)

#########################
# drdlat
#########################

def drdlat(r, lon, lat):
    """
    Compute the Jacobian of the transformation from latitudinal to
    rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdlat_c.html
    
    Inputs:
      float      r      = Distance of a point from the origin.
      float      lon    = Angle of the point from the XZ plane in radians.
      float      lat    = Angle of the point from the XY plane in radians.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdlat(r, lon, lat)

def drdlat_vector(r, lon, lat):
    """
    Compute the Jacobian of the transformation from latitudinal to
    rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdlat_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     r      = Distance of a point from the origin.
      float[_]     lon    = Angle of the point from the XZ plane in radians.
      float[_]     lat    = Angle of the point from the XY plane in radians.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdlat_vector(r, lon, lat)

__copy_attributes_from(drdlat, cs1.drdlat)
__copy_attributes_from(drdlat_vector, cs1.drdlat_vector)

#########################
# drdpgr
#########################

def drdpgr(body, lon, lat, alt, re, f):
    """
    This routine computes the Jacobian matrix of the transformation from
    planetographic to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdpgr_c.html
    
    Inputs:
      string     body   = Name of body with which coordinates are
                          associated.
      float      lon    = Planetographic longitude of a point (radians).
      float      lat    = Planetographic latitude of a point (radians).
      float      alt    = Altitude of a point above reference spheroid.
      float      re     = Equatorial radius of the reference spheroid.
      float      f      = Flattening coefficient.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdpgr(body, lon, lat, alt, re, f)

def drdpgr_vector(body, lon, lat, alt, re, f):
    """
    This routine computes the Jacobian matrix of the transformation from
    planetographic to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdpgr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string       body   = Name of body with which coordinates are
                            associated.
      float[_]     lon    = Planetographic longitude of a point (radians).
      float[_]     lat    = Planetographic latitude of a point (radians).
      float[_]     alt    = Altitude of a point above reference spheroid.
      float[_]     re     = Equatorial radius of the reference spheroid.
      float[_]     f      = Flattening coefficient.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdpgr_vector(body, lon, lat, alt, re, f)

__copy_attributes_from(drdpgr, cs1.drdpgr)
__copy_attributes_from(drdpgr_vector, cs1.drdpgr_vector)

#########################
# drdsph
#########################

def drdsph(r, colat, lon):
    """
    This routine computes the Jacobian of the transformation from spherical
    to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdsph_c.html
    
    Inputs:
      float      r      = Distance of a point from the origin.
      float      colat  = Angle of the point from the positive z-axis.
      float      lon    = Angle of the point from the xy plane.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdsph(r, colat, lon)

def drdsph_vector(r, colat, lon):
    """
    This routine computes the Jacobian of the transformation from spherical
    to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/drdsph_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     r      = Distance of a point from the origin.
      float[_]     colat  = Angle of the point from the positive z-axis.
      float[_]     lon    = Angle of the point from the xy plane.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.drdsph_vector(r, colat, lon)

__copy_attributes_from(drdsph, cs1.drdsph)
__copy_attributes_from(drdsph_vector, cs1.drdsph_vector)

#########################
# dskb02
#########################

def dskb02(handle, dladsc):
    """
    Return bookkeeping data from a DSK type 2 segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskb02_c.html
    
    Inputs:
      int                   handle = DSK file handle.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor.
    
    Returns:
      int                   nv     = Number of vertices in model.
      int                   np     = Number of plates in model.
      int                   nvxtot = Number of voxels in fine grid.
      float[3,2]            vtxbds = Vertex bounds.
      float                 voxsiz = Fine voxel edge length.
      float[3]              voxori = Fine voxel grid origin.
      int[3]                vgrext = Fine voxel grid extent.
      int                   cgscal = Coarse voxel grid scale.
      int                   vtxnpl = Size of vertex-plate correspondence
                                     list.
      int                   voxnpt = Size of voxel-plate pointer list.
      int                   voxnpl = Size of voxel-plate correspondence
                                     list.
    """
    return cs1.dskb02(handle, dladsc)

__copy_attributes_from(dskb02, cs1.dskb02)

#########################
# dskcls
#########################

def dskcls(handle, optmiz):
    """
    Close a DSK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskcls_c.html
    
    Inputs:
      int  handle = Handle assigned to the opened DSK file.
      bool optmiz = Flag indicating whether to segregate the DSK.
    
    Returns: none
    """
    return cs1.dskcls(handle, optmiz)

__copy_attributes_from(dskcls, cs1.dskcls)

#########################
# dskd02
#########################

def dskd02(handle, dladsc, item, start):
    """
    Fetch floating-point data from a type 2 DSK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskd02_c.html
    
    Inputs:
      int                   handle = DSK file handle.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor.
      int                   item   = Keyword identifying item to fetch.
      int                   start  = Start index.
    
    Returns:
      float[*]              values = Array containing requested item.
    """
    return cs1.dskd02(handle, dladsc, item, start)

__copy_attributes_from(dskd02, cs1.dskd02)

#########################
# dskgd
#########################

def dskgd(handle, dladsc):
    """
    Return the DSK descriptor from a DSK segment identified by a DAS handle
    and DLA descriptor.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskgd_c.html
    
    Inputs:
      int                   handle = Handle of a DSK file.
      ConstSpiceDLADescr[*] dladsc = DLA segment descriptor.
    
    Returns:
      SpiceDSKDescr         dskdsc = DSK segment descriptor.
    """
    return cs1.dskgd(handle, dladsc)

__copy_attributes_from(dskgd, cs1.dskgd)

#########################
# dskgtl
#########################

def dskgtl(keywrd):
    """
    Retrieve the value of a specified DSK tolerance or margin parameter.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskgtl_c.html
    
    Inputs:
      int   keywrd = Code specifying parameter to retrieve.
    
    Returns:
      float dpval  = Value of parameter.
    """
    return cs1.dskgtl(keywrd)

__copy_attributes_from(dskgtl, cs1.dskgtl)

#########################
# dski02
#########################

def dski02(handle, dladsc, item, start, room):
    """
    Fetch integer data from a type 2 DSK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dski02_c.html
    
    Inputs:
      int                   handle = DSK file handle.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor.
      int                   item   = Keyword identifying item to fetch.
      int                   start  = Start index.
      int                   room   = Amount of room in output array.
    
    Returns:
      int                   n      = Number of values returned.
      int                   values = Array containing requested item.
    """
    return cs1.dski02(handle, dladsc, item, start, room)

__copy_attributes_from(dski02, cs1.dski02)

#########################
# dskmi2
#########################

def dskmi2(vrtces, plates, finscl, corscl, worksz, voxpsz, voxlsz, makvtl, spxisz):
    """
    Make spatial index for a DSK type 2 segment. The index is returned as a
    pair of arrays, one of type int and one of type float. These arrays are
    suitable for use with the DSK type 2 writer dskw02.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskmi2_c.html
    
    Inputs:
      float[*,3] vrtces = Vertices.
      int[*,3]   plates = Plates.
      float      finscl = Fine voxel scale.
      int        corscl = Coarse voxel scale.
      int        worksz = Workspace size.
      int        voxpsz = Voxel-plate pointer array size.
      int        voxlsz = Voxel-plate list array size.
      bool       makvtl = Vertex-plate list flag.
      int        spxisz = Spatial index integer component size.
    
    Returns:
      float[*]   spaixd = Double precision component of spatial index.
      int[*]     spaixi = Integer component of spatial index.
    """
    return cs1.dskmi2(vrtces, plates, finscl, corscl, worksz, voxpsz, voxlsz, makvtl, spxisz)

__copy_attributes_from(dskmi2, cs1.dskmi2)

#########################
# dskn02
#########################

def dskn02(handle, dladsc, plid):
    """
    Compute the unit normal vector for a specified plate from a type 2 DSK
    segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskn02_c.html
    
    Inputs:
      int                   handle = DSK file handle.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor.
      int                   plid   = Plate ID.
    
    Returns:
      float[3]              normal = Plate's unit normal vector.
    """
    return cs1.dskn02(handle, dladsc, plid)

__copy_attributes_from(dskn02, cs1.dskn02)

#########################
# dskobj
#########################

def dskobj(dskfnm, bodids = 10000):
    """
    Find the set of body ID codes of all objects for which topographic data
    are provided in a specified DSK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskobj_c.html
    
    Inputs:
      string    dskfnm = Name of DSK file.
      SpiceCell bodids = Set of ID codes of objects in DSK file.
    
    Returns:
      SpiceCell bodids = Set of ID codes of objects in DSK file.
    """
    return cs1.dskobj(dskfnm, bodids)

__copy_attributes_from(dskobj, cs1.dskobj)

#########################
# dskopn
#########################

def dskopn(fname, ifname, ncomch):
    """
    Open a new DSK file for subsequent write operations.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskopn_c.html
    
    Inputs:
      string fname  = Name of a DSK file to be opened.
      string ifname = Internal file name.
      int    ncomch = Number of comment characters to allocate.
    
    Returns:
      int    handle = Handle assigned to the opened DSK file.
    """
    return cs1.dskopn(fname, ifname, ncomch)

__copy_attributes_from(dskopn, cs1.dskopn)

#########################
# dskp02
#########################

def dskp02(handle, dladsc, start, room = 100):
    """
    Fetch triangular plates from a type 2 DSK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskp02_c.html
    
    Inputs:
      int                   handle = DSK file handle.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor.
      int                   start  = Start index.
      int                   room   = Amount of room in output array.
    
    Returns:
      int[*,3]              plates = Array containing plates.
    """
    return cs1.dskp02(handle, dladsc, start, room)

__copy_attributes_from(dskp02, cs1.dskp02)

#########################
# dskrb2
#########################

def dskrb2(vrtces, plates, corsys, corpar):
    """
    Determine range bounds for a set of triangular plates to be stored in a
    type 2 DSK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskrb2_c.html
    
    Inputs:
      float[*,3] vrtces = Vertices.
      int[*,3]   plates = Plates.
      int        corsys = DSK coordinate system code.
      float[*]   corpar = DSK coordinate system parameters.
    
    Returns:
      float      mncor3 = Lower bound on range of third coordinate.
      float      mxcor3 = Upper bound on range of third coordinate.
    """
    return cs1.dskrb2(vrtces, plates, corsys, corpar)

__copy_attributes_from(dskrb2, cs1.dskrb2)

#########################
# dsksrf
#########################

def dsksrf(dskfnm, bodyid, srfids = 10000):
    """
    Find the set of surface ID codes for all surfaces associated with a
    given body in a specified DSK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dsksrf_c.html
    
    Inputs:
      string    dskfnm = Name of DSK file.
      int       bodyid = Integer body ID code.
      SpiceCell srfids = Set of ID codes of surfaces in DSK file.
    
    Returns:
      SpiceCell srfids = Set of ID codes of surfaces in DSK file.
    """
    return cs1.dsksrf(dskfnm, bodyid, srfids)

__copy_attributes_from(dsksrf, cs1.dsksrf)

#########################
# dskstl
#########################

def dskstl(keywrd, dpval):
    """
    Set the value of a specified DSK tolerance or margin parameter.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskstl_c.html
    
    Inputs:
      int   keywrd = Code specifying parameter to set.
      float dpval  = Value of parameter.
    
    Returns: none
    """
    return cs1.dskstl(keywrd, dpval)

__copy_attributes_from(dskstl, cs1.dskstl)

#########################
# dskv02
#########################

def dskv02(handle, dladsc, start, room = 100):
    """
    Fetch vertices from a type 2 DSK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskv02_c.html
    
    Inputs:
      int                   handle = DSK file handle.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor.
      int                   start  = Start index.
      int                   room   = Amount of room in output array.
    
    Returns:
      float[*,3]            vrtces = Array containing vertices.
    """
    return cs1.dskv02(handle, dladsc, start, room)

__copy_attributes_from(dskv02, cs1.dskv02)

#########################
# dskw02
#########################

def dskw02(handle, center, surfid, dclass, frame, corsys, corpar, mncor1, mxcor1, mncor2, mxcor2, mncor3, mxcor3, first, last, vrtces, plates, spaixd, spaixi):
    """
    Write a type 2 segment to a DSK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskw02_c.html
    
    Inputs:
      int        handle = Handle assigned to the opened DSK file.
      int        center = Central body ID code.
      int        surfid = Surface ID code.
      int        dclass = Data class.
      string     frame  = Reference frame.
      int        corsys = Coordinate system code.
      float[*]   corpar = Coordinate system parameters.
      float      mncor1 = Minimum value of first coordinate.
      float      mxcor1 = Maximum value of first coordinate.
      float      mncor2 = Minimum value of second coordinate.
      float      mxcor2 = Maximum value of second coordinate.
      float      mncor3 = Minimum value of third coordinate.
      float      mxcor3 = Maximum value of third coordinate.
      float      first  = Coverage start time.
      float      last   = Coverage stop time.
      float[*,3] vrtces = Vertices.
      int[*,3]   plates = Plates.
      float[*]   spaixd = Double precision component of spatial index.
      int[*]     spaixi = Integer component of spatial index.
    
    Returns: none
    """
    return cs1.dskw02(handle, center, surfid, dclass, frame, corsys, corpar, mncor1, mxcor1, mncor2, mxcor2, mncor3, mxcor3, first, last, vrtces, plates, spaixd, spaixi)

__copy_attributes_from(dskw02, cs1.dskw02)

#########################
# dskx02
#########################

def dskx02(handle, dladsc, vertex, raydir):
    """
    Determine the plate ID and body-fixed coordinates of the intersection of
    a specified ray with the surface defined by a type 2 DSK plate model.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskx02_c.html
    
    Inputs:
      int                   handle = Handle of DSK kernel containing plate
                                     model.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor of plate model segment.
      float[3]              vertex = Ray's vertex in the body fixed frame.
      float[3]              raydir = Ray direction in the body fixed frame.
    
    Returns:
      int                   plid   = ID code of the plate intersected by the
                                     ray.
      float[3]              xpt    = Intercept.
      bool                  found  = Flag indicating whether intercept
                                     exists.
    """
    return cs1.dskx02(handle, dladsc, vertex, raydir)

def dskx02_error(handle, dladsc, vertex, raydir):
    """
    Determine the plate ID and body-fixed coordinates of the intersection of
    a specified ray with the surface defined by a type 2 DSK plate model.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskx02_c.html
    
    Inputs:
      int                   handle = Handle of DSK kernel containing plate
                                     model.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor of plate model segment.
      float[3]              vertex = Ray's vertex in the body fixed frame.
      float[3]              raydir = Ray direction in the body fixed frame.
    
    Returns:
      int                   plid   = ID code of the plate intersected by the
                                     ray.
      float[3]              xpt    = Intercept.
    
    Note: Raise ValueError(NOINTERCEPT) if the intercept does not exist.
    """
    return cs1.dskx02_error(handle, dladsc, vertex, raydir)

__copy_attributes_from(dskx02, cs1.dskx02)
__copy_attributes_from(dskx02_error, cs1.dskx02_error)

#########################
# dskxsi
#########################

def dskxsi(pri, target, srflst, et, fixref, vertex, raydir):
    """
    Compute a ray-surface intercept using data provided by multiple loaded
    DSK segments. Return information about the source of the data defining
    the surface on which the intercept was found: DSK handle, DLA and DSK
    descriptors, and DSK data type-dependent parameters.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskxsi_c.html
    
    Inputs:
      bool          pri    = Data prioritization flag.
      string        target = Target body name.
      int[*]        srflst = Surface ID list.
      float         et     = Epoch, expressed as seconds past J2000 TDB.
      string        fixref = Name of target body-fixed reference frame.
      float[3]      vertex = Vertex of ray.
      float[3]      raydir = Direction vector of ray.
    
    Returns:
      float[3]      xpt    = Intercept point.
      int           handle = Handle of segment contributing surface data.
      SpiceDLADescr dladsc = DLA descriptor of segment.
      SpiceDSKDescr dskdsc = DSK descriptor of segment.
      float[*]      dc     = Double precision component of source info.
      int[*]        ic     = Integer component of source info.
      bool          found  = Found flag.
    """
    return cs1.dskxsi(pri, target, srflst, et, fixref, vertex, raydir)

def dskxsi_error(pri, target, srflst, et, fixref, vertex, raydir):
    """
    Compute a ray-surface intercept using data provided by multiple loaded
    DSK segments. Return information about the source of the data defining
    the surface on which the intercept was found: DSK handle, DLA and DSK
    descriptors, and DSK data type-dependent parameters.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskxsi_c.html
    
    Inputs:
      bool          pri    = Data prioritization flag.
      string        target = Target body name.
      int[*]        srflst = Surface ID list.
      float         et     = Epoch, expressed as seconds past J2000 TDB.
      string        fixref = Name of target body-fixed reference frame.
      float[3]      vertex = Vertex of ray.
      float[3]      raydir = Direction vector of ray.
    
    Returns:
      float[3]      xpt    = Intercept point.
      int           handle = Handle of segment contributing surface data.
      SpiceDLADescr dladsc = DLA descriptor of segment.
      SpiceDSKDescr dskdsc = DSK descriptor of segment.
      float[*]      dc     = Double precision component of source info.
      int[*]        ic     = Integer component of source info.
    
    Note: Raise ValueError(NOINTERCEPT) if the intercept does not exist.
    """
    return cs1.dskxsi_error(pri, target, srflst, et, fixref, vertex, raydir)

__copy_attributes_from(dskxsi, cs1.dskxsi)
__copy_attributes_from(dskxsi_error, cs1.dskxsi_error)

#########################
# dskxv
#########################

def dskxv(pri, target, srflst, et, fixref, vtxarr, dirarr):
    """
    Compute ray-surface intercepts for a set of rays, using data provided by
    multiple loaded DSK segments.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskxv_c.html
    
    Inputs:
      bool       pri    = Data prioritization flag.
      string     target = Target body name.
      int[*]     srflst = Surface ID list.
      float      et     = Epoch, expressed as seconds past J2000 TDB.
      string     fixref = Name of target body-fixed reference frame.
      float[*,3] vtxarr = Array of vertices of rays.
      float[*,3] dirarr = Array of direction vectors of rays.
    
    Returns:
      float[*,3] xptarr = Intercept point array.
      bool[*]    fndarr = Found flag array.
    """
    return cs1.dskxv(pri, target, srflst, et, fixref, vtxarr, dirarr)

__copy_attributes_from(dskxv, cs1.dskxv)

#########################
# dskz02
#########################

def dskz02(handle, dladsc):
    """
    Return plate model size parameters---plate count and vertex count---for
    a type 2 DSK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dskz02_c.html
    
    Inputs:
      int                   handle = DSK file handle.
      ConstSpiceDLADescr[*] dladsc = DLA descriptor.
    
    Returns:
      int                   nv     = Number of vertices.
      int                   np     = Number of plates.
    """
    return cs1.dskz02(handle, dladsc)

__copy_attributes_from(dskz02, cs1.dskz02)

#########################
# dsphdr
#########################

def dsphdr(x, y, z):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dsphdr_c.html
    
    Inputs:
      float      x      = x-coordinate of point.
      float      y      = y-coordinate of point.
      float      z      = z-coordinate of point.
    
    Returns:
      float[3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dsphdr(x, y, z)

def dsphdr_vector(x, y, z):
    """
    This routine computes the Jacobian of the transformation from
    rectangular to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dsphdr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     x      = x-coordinate of point.
      float[_]     y      = y-coordinate of point.
      float[_]     z      = z-coordinate of point.
    
    Returns:
      float[_,3,3] jacobi = Matrix of partial derivatives.
    """
    return cs1.dsphdr_vector(x, y, z)

__copy_attributes_from(dsphdr, cs1.dsphdr)
__copy_attributes_from(dsphdr_vector, cs1.dsphdr_vector)

#########################
# dtpool
#########################

def dtpool(name):
    """
    Return the data about a kernel pool variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dtpool_c.html
    
    Inputs:
      string name  = Name of the variable whose value is to be returned.
    
    Returns:
      bool   found = True if variable is in pool.
      int    n     = Number of values returned for name.
      string type  = Type of the variable: 'C', 'N', or 'X'.
    """
    return cs1.dtpool(name)

def dtpool_error(name):
    """
    Return the data about a kernel pool variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dtpool_c.html
    
    Inputs:
      string name = Name of the variable whose value is to be returned.
    
    Returns:
      int    n    = Number of values returned for name.
      string type = Type of the variable: 'C', 'N', or 'X'.
    
    Note: Raise KeyError(VARIABLENOTFOUND) if the requested variable is
    not in the kernel pool.
    """
    return cs1.dtpool_error(name)

__copy_attributes_from(dtpool, cs1.dtpool)
__copy_attributes_from(dtpool_error, cs1.dtpool_error)

#########################
# ducrss
#########################

def ducrss(s1, s2):
    """
    Compute the unit vector parallel to the cross product of two
    3-dimensional vectors and the derivative of this unit vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ducrss_c.html
    
    Inputs:
      float[6] s1   = Left hand state for cross product and derivative.
      float[6] s2   = Right hand state for cross product and derivative.
    
    Returns:
      float[6] sout = Unit vector and derivative of the cross product.
    """
    return cs1.ducrss(s1, s2)

def ducrss_vector(s1, s2):
    """
    Compute the unit vector parallel to the cross product of two
    3-dimensional vectors and the derivative of this unit vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ducrss_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] s1   = Left hand state for cross product and derivative.
      float[_,6] s2   = Right hand state for cross product and derivative.
    
    Returns:
      float[_,6] sout = Unit vector and derivative of the cross product.
    """
    return cs1.ducrss_vector(s1, s2)

__copy_attributes_from(ducrss, cs1.ducrss)
__copy_attributes_from(ducrss_vector, cs1.ducrss_vector)

#########################
# dvcrss
#########################

def dvcrss(s1, s2):
    """
    Compute the cross product of two 3-dimensional vectors and the
    derivative of this cross product.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvcrss_c.html
    
    Inputs:
      float[6] s1   = Left hand state for cross product and derivative.
      float[6] s2   = Right hand state for cross product and derivative.
    
    Returns:
      float[6] sout = State associated with cross product of positions.
    """
    return cs1.dvcrss(s1, s2)

def dvcrss_vector(s1, s2):
    """
    Compute the cross product of two 3-dimensional vectors and the
    derivative of this cross product.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvcrss_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] s1   = Left hand state for cross product and derivative.
      float[_,6] s2   = Right hand state for cross product and derivative.
    
    Returns:
      float[_,6] sout = State associated with cross product of positions.
    """
    return cs1.dvcrss_vector(s1, s2)

__copy_attributes_from(dvcrss, cs1.dvcrss)
__copy_attributes_from(dvcrss_vector, cs1.dvcrss_vector)

#########################
# dvdot
#########################

def dvdot(s1, s2):
    """
    Compute the derivative of the dot product of two position vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvdot_c.html
    
    Inputs:
      float[6] s1    = First state vector in the dot product.
      float[6] s2    = Second state vector in the dot product.
    
    Returns:
      float    value = The derivative of the dot product <s1,s2>
    """
    return cs1.dvdot(s1, s2)

def dvdot_vector(s1, s2):
    """
    Compute the derivative of the dot product of two position vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvdot_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] s1    = First state vector in the dot product.
      float[_,6] s2    = Second state vector in the dot product.
    
    Returns:
      float[_]   value = The derivative of the dot product <s1,s2>
    """
    return cs1.dvdot_vector(s1, s2)

__copy_attributes_from(dvdot, cs1.dvdot)
__copy_attributes_from(dvdot_vector, cs1.dvdot_vector)

#########################
# dvhat
#########################

def dvhat(s1):
    """
    Find the unit vector corresponding to a state vector and the derivative
    of the unit vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvhat_c.html
    
    Inputs:
      float[6] s1    = State to be normalized.
    
    Returns:
      float[6] state = Unit vector s1 / |s1|, and its time derivative.
    """
    return cs1.dvhat(s1)

def dvhat_vector(s1):
    """
    Find the unit vector corresponding to a state vector and the derivative
    of the unit vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvhat_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] s1    = State to be normalized.
    
    Returns:
      float[_,6] state = Unit vector s1 / |s1|, and its time derivative.
    """
    return cs1.dvhat_vector(s1)

__copy_attributes_from(dvhat, cs1.dvhat)
__copy_attributes_from(dvhat_vector, cs1.dvhat_vector)

#########################
# dvnorm
#########################

def dvnorm(state):
    """
    The derivative of the norm of a 3-vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvnorm_c.html
    
    Inputs:
      float[6] state = A 6-vector composed of three coordinates and their
                       derivatives.
    
    Returns:
      float    value = Derivative of the norm.
    """
    return cs1.dvnorm(state)

def dvnorm_vector(state):
    """
    The derivative of the norm of a 3-vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvnorm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] state = A 6-vector composed of three coordinates and their
                         derivatives.
    
    Returns:
      float[_]   value = Derivative of the norm.
    """
    return cs1.dvnorm_vector(state)

__copy_attributes_from(dvnorm, cs1.dvnorm)
__copy_attributes_from(dvnorm_vector, cs1.dvnorm_vector)

#########################
# dvpool
#########################

def dvpool(name):
    """
    Delete a variable from the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvpool_c.html
    
    Inputs:
      string name = Name of the kernel variable to be deleted.
    
    Returns: none
    """
    return cs1.dvpool(name)

__copy_attributes_from(dvpool, cs1.dvpool)

#########################
# dvsep
#########################

def dvsep(s1, s2):
    """
    Calculate the time derivative of the separation angle between two input
    states, S1 and S2.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvsep_c.html
    
    Inputs:
      float[6] s1    = State vector of the first body.
      float[6] s2    = State vector of the second body.
    
    Returns:
      float    value = Derivative of the separation angle between state
                       vectors.
    """
    return cs1.dvsep(s1, s2)

def dvsep_vector(s1, s2):
    """
    Calculate the time derivative of the separation angle between two input
    states, S1 and S2.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/dvsep_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] s1    = State vector of the first body.
      float[_,6] s2    = State vector of the second body.
    
    Returns:
      float[_]   value = Derivative of the separation angle between state
                         vectors.
    """
    return cs1.dvsep_vector(s1, s2)

__copy_attributes_from(dvsep, cs1.dvsep)
__copy_attributes_from(dvsep_vector, cs1.dvsep_vector)

#########################
# edlimb
#########################

def edlimb(a, b, c, viewpt):
    """
    Find the limb of a triaxial ellipsoid, viewed from a specified point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/edlimb_c.html
    
    Inputs:
      float        a      = Length of ellipsoid semi-axis lying on the
                            x-axis.
      float        b      = Length of ellipsoid semi-axis lying on the
                            y-axis.
      float        c      = Length of ellipsoid semi-axis lying on the
                            z-axis.
      float[3]     viewpt = Location of viewing point.
    
    Returns:
      SpiceEllipse limb   = Limb of ellipsoid as seen from viewing point.
    """
    return cs1.edlimb(a, b, c, viewpt)

def edlimb_vector(a, b, c, viewpt):
    """
    Find the limb of a triaxial ellipsoid, viewed from a specified point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/edlimb_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     a      = Length of ellipsoid semi-axis lying on the
                            x-axis.
      float[_]     b      = Length of ellipsoid semi-axis lying on the
                            y-axis.
      float[_]     c      = Length of ellipsoid semi-axis lying on the
                            z-axis.
      float[_,3]   viewpt = Location of viewing point.
    
    Returns:
      SpiceEllipse limb   = Limb of ellipsoid as seen from viewing point.
    """
    return cs1.edlimb_vector(a, b, c, viewpt)

__copy_attributes_from(edlimb, cs1.edlimb)
__copy_attributes_from(edlimb_vector, cs1.edlimb_vector)

#########################
# ednmpt
#########################

def ednmpt(a, b, c, normal):
    """
    Return the unique point on an ellipsoid's surface where the outward
    normal direction is a given vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ednmpt_c.html
    
    Inputs:
      float    a      = Length of the ellipsoid semi-axis along the X-axis.
      float    b      = Length of the ellipsoid semi-axis along the Y-axis.
      float    c      = Length of the ellipsoid semi-axis along the Z-axis.
      float[3] normal = Outward normal direction.
    
    Returns:
      float[3] point  = Point where outward normal is parallel to `normal'.
    """
    return cs1.ednmpt(a, b, c, normal)

def ednmpt_vector(a, b, c, normal):
    """
    Return the unique point on an ellipsoid's surface where the outward
    normal direction is a given vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ednmpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   a      = Length of the ellipsoid semi-axis along the
                          X-axis.
      float[_]   b      = Length of the ellipsoid semi-axis along the
                          Y-axis.
      float[_]   c      = Length of the ellipsoid semi-axis along the
                          Z-axis.
      float[_,3] normal = Outward normal direction.
    
    Returns:
      float[_,3] point  = Point where outward normal is parallel to
                          `normal'.
    """
    return cs1.ednmpt_vector(a, b, c, normal)

__copy_attributes_from(ednmpt, cs1.ednmpt)
__copy_attributes_from(ednmpt_vector, cs1.ednmpt_vector)

#########################
# edpnt
#########################

def edpnt(p, a, b, c):
    """
    Scale a point so that it lies on the surface of a specified triaxial
    ellipsoid that is centered at the origin and aligned with the Cartesian
    coordinate axes.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/edpnt_c.html
    
    Inputs:
      float[3] p  = A point in three-dimensional space.
      float    a  = Semi-axis length in the X direction.
      float    b  = Semi-axis length in the Y direction.
      float    c  = Semi-axis length in the Z direction.
    
    Returns:
      float[3] ep = Point on ellipsoid.
    """
    return cs1.edpnt(p, a, b, c)

def edpnt_vector(p, a, b, c):
    """
    Scale a point so that it lies on the surface of a specified triaxial
    ellipsoid that is centered at the origin and aligned with the Cartesian
    coordinate axes.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/edpnt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] p  = A point in three-dimensional space.
      float[_]   a  = Semi-axis length in the X direction.
      float[_]   b  = Semi-axis length in the Y direction.
      float[_]   c  = Semi-axis length in the Z direction.
    
    Returns:
      float[_,3] ep = Point on ellipsoid.
    """
    return cs1.edpnt_vector(p, a, b, c)

__copy_attributes_from(edpnt, cs1.edpnt)
__copy_attributes_from(edpnt_vector, cs1.edpnt_vector)

#########################
# edterm
#########################

def edterm(trmtyp, source, target, et, fixref, abcorr, obsrvr, npts):
    """
    Compute a set of points on the umbral or penumbral terminator of a
    specified target body, where the target shape is modeled as an
    ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/edterm_c.html
    
    Inputs:
      string     trmtyp = Terminator type, "UMBRAL" or "PENUMBRAL".
      string     source = Light source.
      string     target = Target body.
      float      et     = Observation epoch.
      string     fixref = Body-fixed frame associated with target.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          or "CN+S".
      string     obsrvr = Observer.
      int        npts   = Number of points in terminator set.
    
    Returns:
      float      trgepc = Epoch associated with target center.
      float[3]   obspos = Position of observer in body-fixed frame.
      float[*,3] trmpts = Array of terminator points.
    """
    return cs1.edterm(trmtyp, source, target, et, fixref, abcorr, obsrvr, npts)

__copy_attributes_from(edterm, cs1.edterm)

#########################
# ekacec
#########################

def ekacec(handle, segno, recno, column, cvals, isnull):
    """
    Add data to a character column in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekacec_c.html
    
    Inputs:
      int       handle = EK file handle.
      int       segno  = Index of segment containing record.
      int       recno  = Record to which data is to be added.
      string    column = Column name.
      string[*] cvals  = Character values to add to column.
      bool      isnull = Flag indicating whether column entry is null.
    
    Returns: none
    """
    return cs1.ekacec(handle, segno, recno, column, cvals, isnull)

__copy_attributes_from(ekacec, cs1.ekacec)

#########################
# ekaced
#########################

def ekaced(handle, segno, recno, column, dvals, isnull):
    """
    Add data to an floating-point column in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekaced_c.html
    
    Inputs:
      int      handle = EK file handle.
      int      segno  = Index of segment containing record.
      int      recno  = Record to which data is to be added.
      string   column = Column name.
      float[*] dvals  = Double precision values to add to column.
      bool     isnull = Flag indicating whether column entry is null.
    
    Returns: none
    """
    return cs1.ekaced(handle, segno, recno, column, dvals, isnull)

__copy_attributes_from(ekaced, cs1.ekaced)

#########################
# ekacei
#########################

def ekacei(handle, segno, recno, column, ivals, isnull):
    """
    Add data to an integer column in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekacei_c.html
    
    Inputs:
      int    handle = EK file handle.
      int    segno  = Index of segment containing record.
      int    recno  = Record to which data is to be added.
      string column = Column name.
      int[*] ivals  = Integer values to add to column.
      bool   isnull = Flag indicating whether column entry is null.
    
    Returns: none
    """
    return cs1.ekacei(handle, segno, recno, column, ivals, isnull)

__copy_attributes_from(ekacei, cs1.ekacei)

#########################
# ekaclc
#########################

def ekaclc(handle, segno, column, cvals, entszs, nlflgs, rcptrs):
    """
    Add an entire character column to an EK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekaclc_c.html
    
    Inputs:
      int       handle = EK file handle.
      int       segno  = Number of segment to add column to.
      string    column = Column name.
      string[*] cvals  = Character values to add to column.
      int[*]    entszs = Array of sizes of column entries.
      bool[*]   nlflgs = Array of null flags for column entries.
      int[*]    rcptrs = Record pointers for segment.
    
    Returns: none
    """
    return cs1.ekaclc(handle, segno, column, cvals, entszs, nlflgs, rcptrs)

__copy_attributes_from(ekaclc, cs1.ekaclc)

#########################
# ekacld
#########################

def ekacld(handle, segno, column, dvals, entszs, nlflgs, rcptrs):
    """
    Add an entire floating-point column to an EK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekacld_c.html
    
    Inputs:
      int      handle = EK file handle.
      int      segno  = Number of segment to add column to.
      string   column = Column name.
      float[*] dvals  = Double precision values to add to column.
      int[*]   entszs = Array of sizes of column entries.
      bool[*]  nlflgs = Array of null flags for column entries.
      int[*]   rcptrs = Record pointers for segment.
    
    Returns: none
    """
    return cs1.ekacld(handle, segno, column, dvals, entszs, nlflgs, rcptrs)

__copy_attributes_from(ekacld, cs1.ekacld)

#########################
# ekacli
#########################

def ekacli(handle, segno, column, ivals, entszs, nlflgs, rcptrs):
    """
    Add an entire integer column to an EK segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekacli_c.html
    
    Inputs:
      int     handle = EK file handle.
      int     segno  = Number of segment to add column to.
      string  column = Column name.
      int[*]  ivals  = Integer values to add to column.
      int[*]  entszs = Array of sizes of column entries.
      bool[*] nlflgs = Array of null flags for column entries.
      int[*]  rcptrs = Record pointers for segment.
    
    Returns: none
    """
    return cs1.ekacli(handle, segno, column, ivals, entszs, nlflgs, rcptrs)

__copy_attributes_from(ekacli, cs1.ekacli)

#########################
# ekappr
#########################

def ekappr(handle, segno):
    """
    Append a new, empty record at the end of a specified E-kernel segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekappr_c.html
    
    Inputs:
      int handle = File handle.
      int segno  = Segment number.
    
    Returns:
      int recno  = Number of appended record.
    """
    return cs1.ekappr(handle, segno)

__copy_attributes_from(ekappr, cs1.ekappr)

#########################
# ekbseg
#########################

def ekbseg(handle, tabnam, cnames, decls):
    """
    Start a new segment in an E-kernel.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekbseg_c.html
    
    Inputs:
      int       handle = File handle.
      string    tabnam = Table name.
      string[*] cnames = Names of columns.
      string[*] decls  = Declarations of columns.
    
    Returns:
      int       segno  = Segment number.
    """
    return cs1.ekbseg(handle, tabnam, cnames, decls)

__copy_attributes_from(ekbseg, cs1.ekbseg)

#########################
# ekccnt
#########################

def ekccnt(table):
    """
    Return the number of distinct columns in a specified, currently loaded
    table.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekccnt_c.html
    
    Inputs:
      string table  = Name of table.
    
    Returns:
      int    ccount = Count of distinct, currently loaded columns.
    """
    return cs1.ekccnt(table)

__copy_attributes_from(ekccnt, cs1.ekccnt)

#########################
# ekcii
#########################

def ekcii(table, cindex):
    """
    Return attribute information about a column belonging to a loaded EK
    table, specifying the column by table and index.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekcii_c.html
    
    Inputs:
      string table  = Name of table containing column.
      int    cindex = Index of column whose attributes are to be found.
    
    Returns:
      string column = Name of column.
      int    cclass = Column class code.
      int    dtype  = Data type code: 0 for character; 1 for floating-point;
                      2 for integer; 3 for time.
      int    strlen = String length.
      int    size   = Column entry size; this is the number of array
                      elements in a column entry.
      bool   indexd = True if the column is indexed; False otherwise.
      bool   nullok = True if the column may contain null values; False
                      otherwise.
    """
    return cs1.ekcii(table, cindex)

__copy_attributes_from(ekcii, cs1.ekcii)

#########################
# ekcls
#########################

def ekcls(handle):
    """
    Close an E-kernel.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekcls_c.html
    
    Inputs:
      int handle = EK file handle.
    
    Returns: none
    """
    return cs1.ekcls(handle)

__copy_attributes_from(ekcls, cs1.ekcls)

#########################
# ekdelr
#########################

def ekdelr(handle, segno, recno):
    """
    Delete a specified record from a specified E-kernel segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekdelr_c.html
    
    Inputs:
      int handle = File handle.
      int segno  = Segment number.
      int recno  = Record number.
    
    Returns: none
    """
    return cs1.ekdelr(handle, segno, recno)

__copy_attributes_from(ekdelr, cs1.ekdelr)

#########################
# ekffld
#########################

def ekffld(handle, segno, rcptrs):
    """
    Complete a fast write operation on a new E-kernel segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekffld_c.html
    
    Inputs:
      int    handle = File handle.
      int    segno  = Segment number.
      int[*] rcptrs = Record pointers.
    
    Returns: none
    """
    return cs1.ekffld(handle, segno, rcptrs)

__copy_attributes_from(ekffld, cs1.ekffld)

#########################
# ekfind
#########################

def ekfind(query):
    """
    Find E-kernel data that satisfy a set of constraints.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekfind_c.html
    
    Inputs:
      string query  = Query specifying data to be found.
    
    Returns:
      int    nmrows = Number of matching rows.
      bool   error  = Flag indicating whether query parsed correctly.
      string errmsg = Parse error description.
    """
    return cs1.ekfind(query)

def ekfind_error(query):
    """
    Find E-kernel data that satisfy a set of constraints.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekfind_c.html
    
    Inputs:
      string query  = Query specifying data to be found.
    
    Returns:
      int    nmrows = Number of matching rows.
    
    Note: Raise ValueError(INVALIDVALUE) if the query is invalid.
    """
    return cs1.ekfind_error(query)

__copy_attributes_from(ekfind, cs1.ekfind)
__copy_attributes_from(ekfind_error, cs1.ekfind_error)

#########################
# ekgc
#########################

def ekgc(selidx, row, elment):
    """
    Return an element of an entry in a column of character type in a
    specified row.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekgc_c.html
    
    Inputs:
      int    selidx = Index of parent column in SELECT clause.
      int    row    = Row to fetch from.
      int    elment = Index of element, within column entry, to fetch.
    
    Returns:
      string cdata  = Character string element of column entry.
      bool   null   = Flag indicating whether column entry was null.
      bool   found  = Flag indicating whether column was present in row.
    """
    return cs1.ekgc(selidx, row, elment)

def ekgc_error(selidx, row, elment):
    """
    Return an element of an entry in a column of character type in a
    specified row.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekgc_c.html
    
    Inputs:
      int    selidx = Index of parent column in SELECT clause.
      int    row    = Row to fetch from.
      int    elment = Index of element, within column entry, to fetch.
    
    Returns:
      string cdata  = Character string element of column entry.
      bool   null   = Flag indicating whether column entry was null.
    
    Note: Raise IndexError(INDEXOUTOFRANGE) if the column is not present
    in the row.
    """
    return cs1.ekgc_error(selidx, row, elment)

__copy_attributes_from(ekgc, cs1.ekgc)
__copy_attributes_from(ekgc_error, cs1.ekgc_error)

#########################
# ekgd
#########################

def ekgd(selidx, row, elment):
    """
    Return an element of an entry in a column of floating-point type in a
    specified row.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekgd_c.html
    
    Inputs:
      int   selidx = Index of parent column in SELECT clause.
      int   row    = Row to fetch from.
      int   elment = Index of element, within column entry, to fetch.
    
    Returns:
      float ddata  = Double precision element of column entry.
      bool  null   = Flag indicating whether column entry was null.
      bool  found  = Flag indicating whether column was present in row.
    """
    return cs1.ekgd(selidx, row, elment)

def ekgd_error(selidx, row, elment):
    """
    Return an element of an entry in a column of floating-point type in a
    specified row.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekgd_c.html
    
    Inputs:
      int   selidx = Index of parent column in SELECT clause.
      int   row    = Row to fetch from.
      int   elment = Index of element, within column entry, to fetch.
    
    Returns:
      float ddata  = Double precision element of column entry.
      bool  null   = Flag indicating whether column entry was null.
    
    Note: Raise IndexError(INDEXOUTOFRANGE) if the column is not present
    in the row.
    """
    return cs1.ekgd_error(selidx, row, elment)

__copy_attributes_from(ekgd, cs1.ekgd)
__copy_attributes_from(ekgd_error, cs1.ekgd_error)

#########################
# ekgi
#########################

def ekgi(selidx, row, elment):
    """
    Return an element of an entry in a column of integer type in a specified
    row.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekgi_c.html
    
    Inputs:
      int  selidx = Index of parent column in SELECT clause.
      int  row    = Row to fetch from.
      int  elment = Index of element, within column entry, to fetch.
    
    Returns:
      int  idata  = Integer element of column entry.
      bool null   = Flag indicating whether column entry was null.
      bool found  = Flag indicating whether column was present in row.
    """
    return cs1.ekgi(selidx, row, elment)

def ekgi_error(selidx, row, elment):
    """
    Return an element of an entry in a column of integer type in a specified
    row.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekgi_c.html
    
    Inputs:
      int  selidx = Index of parent column in SELECT clause.
      int  row    = Row to fetch from.
      int  elment = Index of element, within column entry, to fetch.
    
    Returns:
      int  idata  = Integer element of column entry.
      bool null   = Flag indicating whether column entry was null.
    
    Note: Raise IndexError(INDEXOUTOFRANGE) if the column is not present
    in the row.
    """
    return cs1.ekgi_error(selidx, row, elment)

__copy_attributes_from(ekgi, cs1.ekgi)
__copy_attributes_from(ekgi_error, cs1.ekgi_error)

#########################
# ekifld
#########################

def ekifld(handle, tabnam, nrows, cnames, decls):
    """
    Initialize a new E-kernel segment to allow fast writing.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekifld_c.html
    
    Inputs:
      int       handle = File handle.
      string    tabnam = Table name.
      int       nrows  = Number of rows in the segment.
      string[*] cnames = Names of columns.
      string[*] decls  = Declarations of columns.
    
    Returns:
      int       segno  = Segment number.
      int[*]    rcptrs = Array of record pointers.
    """
    return cs1.ekifld(handle, tabnam, nrows, cnames, decls)

__copy_attributes_from(ekifld, cs1.ekifld)

#########################
# ekinsr
#########################

def ekinsr(handle, segno, recno):
    """
    Add a new, empty record to a specified E-kernel segment at a specified
    index.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekinsr_c.html
    
    Inputs:
      int handle = File handle.
      int segno  = Segment number.
      int recno  = Record number.
    
    Returns: none
    """
    return cs1.ekinsr(handle, segno, recno)

__copy_attributes_from(ekinsr, cs1.ekinsr)

#########################
# eklef
#########################

def eklef(fname):
    """
    Load an EK file, making it accessible to the EK readers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eklef_c.html
    
    Inputs:
      string fname  = Name of EK file to load.
    
    Returns:
      int    handle = File handle of loaded EK file.
    """
    return cs1.eklef(fname)

__copy_attributes_from(eklef, cs1.eklef)

#########################
# eknelt
#########################

def eknelt(selidx, row):
    """
    Return the number of elements in a specified column entry in the current
    row.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eknelt_c.html
    
    Inputs:
      int selidx = Index of parent column in SELECT clause.
      int row    = Row containing element.
    
    Returns:
      int count  = Number of elements in column.
    """
    return cs1.eknelt(selidx, row)

__copy_attributes_from(eknelt, cs1.eknelt)

#########################
# eknseg
#########################

def eknseg(handle):
    """
    Return the number of segments in a specified EK.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eknseg_c.html
    
    Inputs:
      int handle = EK file handle.
    
    Returns:
      int count  = Numer of segments.
    """
    return cs1.eknseg(handle)

__copy_attributes_from(eknseg, cs1.eknseg)

#########################
# ekntab
#########################

def ekntab():
    """
    Return the number of loaded EK tables.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekntab_c.html
    
    Inputs: none
    
    Returns:
      int n = Number of loaded tables.
    """
    return cs1.ekntab()

__copy_attributes_from(ekntab, cs1.ekntab)

#########################
# ekopn
#########################

def ekopn(fname, ifname, ncomch):
    """
    Open a new E-kernel file and prepare the file for writing.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekopn_c.html
    
    Inputs:
      string fname  = Name of EK file.
      string ifname = Internal file name.
      int    ncomch = The number of characters to reserve for comments.
    
    Returns:
      int    handle = Handle attached to new EK file.
    """
    return cs1.ekopn(fname, ifname, ncomch)

__copy_attributes_from(ekopn, cs1.ekopn)

#########################
# ekopr
#########################

def ekopr(fname):
    """
    Open an existing E-kernel file for reading.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekopr_c.html
    
    Inputs:
      string fname  = Name of EK file.
    
    Returns:
      int    handle = Handle attached to EK file.
    """
    return cs1.ekopr(fname)

__copy_attributes_from(ekopr, cs1.ekopr)

#########################
# ekops
#########################

def ekops():
    """
    Open a scratch (temporary) E-kernel file and prepare the file for
    writing.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekops_c.html
    
    Inputs: none
    
    Returns:
      int handle = File handle attached to new EK file.
    """
    return cs1.ekops()

__copy_attributes_from(ekops, cs1.ekops)

#########################
# ekopw
#########################

def ekopw(fname):
    """
    Open an existing E-kernel file for writing.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekopw_c.html
    
    Inputs:
      string fname  = Name of EK file.
    
    Returns:
      int    handle = Handle attached to EK file.
    """
    return cs1.ekopw(fname)

__copy_attributes_from(ekopw, cs1.ekopw)

#########################
# ekpsel
#########################

def ekpsel(query):
    """
    Parse the SELECT clause of an EK query, returning full particulars
    concerning each selected item.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekpsel_c.html
    
    Inputs:
      string    query  = EK query.
    
    Returns:
      int[*]    xbegs  = Begin positions of expressions in SELECT clause.
      int[*]    xends  = End positions of expressions in SELECT clause.
      int[*]    xtypes = Data types of expressions.
      int[*]    xclass = Classes of expressions.
      string[*] tabs   = Names of tables qualifying SELECT columns.
      string[*] cols   = Names of columns in SELECT clause of `query'.
      bool      error  = Error flag.
      string    errmsg = Parse error message.
    """
    return cs1.ekpsel(query)

def ekpsel_error(query):
    """
    Parse the SELECT clause of an EK query, returning full particulars
    concerning each selected item.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekpsel_c.html
    
    Inputs:
      string    query  = EK query.
    
    Returns:
      int[*]    xbegs  = Begin positions of expressions in SELECT clause.
      int[*]    xends  = End positions of expressions in SELECT clause.
      int[*]    xtypes = Data types of expressions.
      int[*]    xclass = Classes of expressions.
      string[*] tabs   = Names of tables qualifying SELECT columns.
      string[*] cols   = Names of columns in SELECT clause of `query'.
    
    Note: Raise ValueError(INVALIDVALUE) if the query is invalid.
    """
    return cs1.ekpsel_error(query)

__copy_attributes_from(ekpsel, cs1.ekpsel)
__copy_attributes_from(ekpsel_error, cs1.ekpsel_error)

#########################
# ekrcec
#########################

def ekrcec(handle, segno, recno, column):
    """
    Read data from a character column in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekrcec_c.html
    
    Inputs:
      int       handle = Handle attached to EK file.
      int       segno  = Index of segment containing record.
      int       recno  = Record from which data is to be read.
      string    column = Column name.
    
    Returns:
      string[*] cvals  = Character values in column entry.
      bool      isnull = Flag indicating whether column entry is null.
    """
    return cs1.ekrcec(handle, segno, recno, column)

__copy_attributes_from(ekrcec, cs1.ekrcec)

#########################
# ekrced
#########################

def ekrced(handle, segno, recno, column):
    """
    Read data from a floating-point column in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekrced_c.html
    
    Inputs:
      int      handle = Handle attached to EK file.
      int      segno  = Index of segment containing record.
      int      recno  = Record from which data is to be read.
      string   column = Column name.
    
    Returns:
      float[*] dvals  = D.p. values in column entry.
      bool     isnull = Flag indicating whether column entry is null.
    """
    return cs1.ekrced(handle, segno, recno, column)

__copy_attributes_from(ekrced, cs1.ekrced)

#########################
# ekrcei
#########################

def ekrcei(handle, segno, recno, column):
    """
    Read data from an integer column in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekrcei_c.html
    
    Inputs:
      int    handle = Handle attached to EK file.
      int    segno  = Index of segment containing record.
      int    recno  = Record from which data is to be read.
      string column = Column name.
    
    Returns:
      int[*] ivals  = Integer values in column entry.
      bool   isnull = Flag indicating whether column entry is null.
    """
    return cs1.ekrcei(handle, segno, recno, column)

__copy_attributes_from(ekrcei, cs1.ekrcei)

#########################
# ekssum
#########################

def ekssum(handle, segno):
    """
    Return summary information for a specified segment in a specified EK.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekssum_c.html
    
    Inputs:
      int       handle = Handle of EK.
      int       segno  = Number of segment to be summarized.
    
    Returns:
      string    tabnam = The name of the table to which the segment belongs.
      int       nrows  = The number of rows in the segment.
      int       ncols  = The number of columns in the segment.
      string[*] cnames = Column names.
      int[*]    cclass = Column class codes.
      int[*]    dtype  = Data type codes: 0 for character; 1 for floating-
                         point; 2 for integer; 3 for time.
      int[*]    strln  = String lengths.
      int[*]    size   = Column entry sizes; this is the number of array
                         elements in a column entry.
      bool[*]   indexd = True if the column is indexed; False otherwise.
      bool[*]   nullok = True if the column may contain null values; False
                         otherwise.
    """
    return cs1.ekssum(handle, segno)

__copy_attributes_from(ekssum, cs1.ekssum)

#########################
# ektnam
#########################

def ektnam(n):
    """
    Return the name of a specified, loaded table.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ektnam_c.html
    
    Inputs:
      int    n     = Index of table.
    
    Returns:
      string table = Name of table.
    """
    return cs1.ektnam(n)

__copy_attributes_from(ektnam, cs1.ektnam)

#########################
# ekucec
#########################

def ekucec(handle, segno, recno, column, cvals, isnull):
    """
    Update a character column entry in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekucec_c.html
    
    Inputs:
      int       handle = EK file handle.
      int       segno  = Index of segment containing record.
      int       recno  = Record to which data is to be updated.
      string    column = Column name.
      string[*] cvals  = Character values comprising new column entry.
      bool      isnull = Flag indicating whether column entry is null.
    
    Returns: none
    """
    return cs1.ekucec(handle, segno, recno, column, cvals, isnull)

__copy_attributes_from(ekucec, cs1.ekucec)

#########################
# ekuced
#########################

def ekuced(handle, segno, recno, column, dvals, isnull):
    """
    Update a floating-point column entry in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekuced_c.html
    
    Inputs:
      int      handle = Handle attached to EK file.
      int      segno  = Index of segment containing record.
      int      recno  = Record in which entry is to be updated.
      string   column = Column name.
      float[*] dvals  = Double precision values comprising new column entry.
      bool     isnull = Flag indicating whether column entry is null.
    
    Returns: none
    """
    return cs1.ekuced(handle, segno, recno, column, dvals, isnull)

__copy_attributes_from(ekuced, cs1.ekuced)

#########################
# ekucei
#########################

def ekucei(handle, segno, recno, column, ivals, isnull):
    """
    Update an integer column entry in a specified EK record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekucei_c.html
    
    Inputs:
      int    handle = Handle attached to EK file.
      int    segno  = Index of segment containing record.
      int    recno  = Record in which entry is to be updated.
      string column = Column name.
      int[*] ivals  = Integer values comprising new column entry.
      bool   isnull = Flag indicating whether column entry is null.
    
    Returns: none
    """
    return cs1.ekucei(handle, segno, recno, column, ivals, isnull)

__copy_attributes_from(ekucei, cs1.ekucei)

#########################
# ekuef
#########################

def ekuef(handle):
    """
    Unload an EK file, making its contents inaccessible to the EK reader
    routines, and clearing space in order to allow other EK files to be
    loaded.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ekuef_c.html
    
    Inputs:
      int handle = Handle of EK file.
    
    Returns: none
    """
    return cs1.ekuef(handle)

__copy_attributes_from(ekuef, cs1.ekuef)

#########################
# el2cgv
#########################

def el2cgv(ellipse):
    """
    Convert a CSPICE ellipse to a center vector and two generating vectors.
    The selected generating vectors are semi-axes of the ellipse.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/el2cgv_c.html
    
    Inputs:
      ConstSpiceEllipse[*] ellipse = A CSPICE ellipse.
    
    Returns:
      float[3]             center  = Center of ellipse.
      float[3]             smajor  = Semimajor axis of ellipse.
      float[3]             sminor  = Semiminor axis of ellipse.
    """
    return cs1.el2cgv(ellipse)

def el2cgv_vector(ellipse):
    """
    Convert a CSPICE ellipse to a center vector and two generating vectors.
    The selected generating vectors are semi-axes of the ellipse.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/el2cgv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      ConstSpiceEllipse[*] ellipse = A CSPICE ellipse.
    
    Returns:
      float[_,3]           center  = Center of ellipse.
      float[_,3]           smajor  = Semimajor axis of ellipse.
      float[_,3]           sminor  = Semiminor axis of ellipse.
    """
    return cs1.el2cgv_vector(ellipse)

__copy_attributes_from(el2cgv, cs1.el2cgv)
__copy_attributes_from(el2cgv_vector, cs1.el2cgv_vector)

#########################
# eqncpv
#########################

def eqncpv(et, epoch, eqel, rapol, decpol):
    """
    Compute the state (position and velocity of an object whose trajectory
    is described via equinoctial elements relative to some fixed plane
    (usually the equatorial plane of some planet).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eqncpv_c.html
    
    Inputs:
      float    et     = Epoch in seconds past J2000 to find state.
      float    epoch  = Epoch of elements in seconds past J2000.
      float[9] eqel   = Array of equinoctial elements.
      float    rapol  = Right Ascension of the pole of the reference plane.
      float    decpol = Declination of the pole of the reference plane.
    
    Returns:
      float[6] state  = State of the object described by eqel.
    """
    return cs1.eqncpv(et, epoch, eqel, rapol, decpol)

def eqncpv_vector(et, epoch, eqel, rapol, decpol):
    """
    Compute the state (position and velocity of an object whose trajectory
    is described via equinoctial elements relative to some fixed plane
    (usually the equatorial plane of some planet).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eqncpv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   et     = Epoch in seconds past J2000 to find state.
      float[_]   epoch  = Epoch of elements in seconds past J2000.
      float[_,9] eqel   = Array of equinoctial elements.
      float[_]   rapol  = Right Ascension of the pole of the reference
                          plane.
      float[_]   decpol = Declination of the pole of the reference plane.
    
    Returns:
      float[_,6] state  = State of the object described by eqel.
    """
    return cs1.eqncpv_vector(et, epoch, eqel, rapol, decpol)

__copy_attributes_from(eqncpv, cs1.eqncpv)
__copy_attributes_from(eqncpv_vector, cs1.eqncpv_vector)

#########################
# erract
#########################

def erract(op = 'GET', action = ''):
    """
    Retrieve or set the default error action.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/erract_c.html
    
    Inputs:
      string op     = Operation: "GET" or "SET"; default is "GET".
      string action = Error response action, "EXCEPTION", "RUNTIME",
                      "RETURN", "ABORT", or "DEFAULT" (which is similar to
                      "ABORT"). Note that options "ABORT" and "DEFAULT" are
                      not supported in interactive Python. CSPICE options
                      "REPORT" and "IGNORE" are not safe and are not
                      supported under any circumstances.
    
    Returns:
      string action = Error response action, "EXCEPTION", "RUNTIME",
                      "RETURN", "ABORT", or "DEFAULT" (which is similar to
                      "ABORT"). Note that options "ABORT" and "DEFAULT" are
                      not supported in interactive Python. CSPICE options
                      "REPORT" and "IGNORE" are not safe and are not
                      supported under any circumstances.
    
    Note: As a special case, if a single argument is provided and it is
    one of the allowed actions, then "SET" is assumed.
    """
    return cs1.erract(op, action)

__copy_attributes_from(erract, cs1.erract)

#########################
# errch
#########################

def errch(marker, string):
    """
    Substitute a character string for the first occurrence of a marker in
    the current long error message.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/errch_c.html
    
    Inputs:
      string marker = A substring of the error message to be replaced.
      string string = The character string to substitute for marker.
    
    Returns: none
    """
    return cs1.errch(marker, string)

__copy_attributes_from(errch, cs1.errch)

#########################
# errdev
#########################

def errdev(op = 'GET', device = ''):
    """
    Retrieve or set the name of the current output device for error
    messages.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/errdev_c.html
    
    Inputs:
      string op     = The operation: "GET" or "SET"; default is "GET".
      string device = The device name; ignored on "GET". Options are a file
                      name, "SCREEN" and "NULL".
    
    Returns:
      string device = The device name; ignored on "GET". Options are a file
                      name, "SCREEN" and "NULL".
    
    Note: As a special case, if a single argument is provided, "SET" is
    assumed and the argument is interpreted as the device name.
    """
    return cs1.errdev(op, device)

__copy_attributes_from(errdev, cs1.errdev)

#########################
# errdp
#########################

def errdp(marker, number):
    """
    Substitute a floating-point number for the first occurrence of a marker
    found in the current long error message.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/errdp_c.html
    
    Inputs:
      string marker = A substring of the error message to be replaced.
      float  number = The d.p. number to substitute for marker.
    
    Returns: none
    """
    return cs1.errdp(marker, number)

__copy_attributes_from(errdp, cs1.errdp)

#########################
# errint
#########################

def errint(marker, number):
    """
    Substitute an integer for the first occurrence of a marker found in the
    current long error message.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/errint_c.html
    
    Inputs:
      string marker = A substring of the error message to be replaced.
      int    number = The integer to substitute for marker.
    
    Returns: none
    """
    return cs1.errint(marker, number)

__copy_attributes_from(errint, cs1.errint)

#########################
# errprt
#########################

def errprt(op = 'GET', list = ''):
    """
    Retrieve or set the list of error message items to be output when an
    error is detected.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/errprt_c.html
    
    Inputs:
      string op   = The operation: "GET" or "SET"; default is "GET".
      string list = Specification of error messages to be output, as a
                    single string containing comma-separated values. Options
                    are "SHORT", "LONG", "EXPLAIN", "TRACEBACK", "ALL",
                    "NONE", and "DEFAULT".
    
    Returns:
      string list = Specification of error messages to be output, as a
                    single string containing comma-separated values. Options
                    are "SHORT", "LONG", "EXPLAIN", "TRACEBACK", "ALL",
                    "NONE", and "DEFAULT".
    
    Note: As a special case, if a single argument is provided and is not
    "GET", then "SET" is assumed and this argument is interpreted as the
    list.
    """
    return cs1.errprt(op, list)

__copy_attributes_from(errprt, cs1.errprt)

#########################
# esrchc
#########################

def esrchc(value, array):
    """
    Search for a given value within a character string array. Return the
    index of the first equivalent array entry, or -1 if no equivalent
    element is found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/esrchc_c.html
    
    Inputs:
      string    value = Key value to be found in array.
      string[*] array = Character string array to search.
    
    Returns:
      int       index = Index of entry in array.
    """
    return cs1.esrchc(value, array)

__copy_attributes_from(esrchc, cs1.esrchc)

#########################
# et2lst
#########################

def et2lst(et, body, lon, type):
    """
    Given an ephemeris epoch, compute the local solar time for an object on
    the surface of a body at a specified longitude.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/et2lst_c.html
    
    Inputs:
      float  et   = Epoch in seconds past J2000 epoch.
      int    body = ID-code of the body of interest.
      float  lon  = Longitude of surface point (radians).
      string type = Type of longitude, "PLANETOCENTRIC", etc.
    
    Returns:
      int    hr   = Local hour on a "24 hour" clock.
      int    mn   = Minutes past the hour.
      int    sc   = Seconds past the minute.
      string time = String giving local time on 24 hour clock.
      string ampm = String giving time on AM/PM scale.
    """
    return cs1.et2lst(et, body, lon, type)

__copy_attributes_from(et2lst, cs1.et2lst)

#########################
# et2utc
#########################

def et2utc(et, format, prec):
    """
    Convert an input time from ephemeris seconds past J2000 to Calendar,
    Day-of-Year, or Julian Date format, UTC.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/et2utc_c.html
    
    Inputs:
      float  et     = Input epoch, given in ephemeris seconds past J2000.
      string format = Format of output epoch: "C" for calendar format; "D"
                      for day-of-year format; "J" for Julian date; "ISOC"
                      for ISO calendar format; "ISOD" for ISO day-of-year
                      format.
      int    prec   = Digits of precision in fractional seconds or days.
    
    Returns:
      string utcstr = Output time string, UTC.
    """
    return cs1.et2utc(et, format, prec)

__copy_attributes_from(et2utc, cs1.et2utc)

#########################
# etcal
#########################

def etcal(et):
    """
    Convert from an ephemeris epoch measured in seconds past the epoch of
    J2000 to a calendar string format using a formal calendar free of
    leapseconds.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/etcal_c.html
    
    Inputs:
      float  et     = Ephemeris time measured in seconds past J2000.
    
    Returns:
      string string = A standard calendar representation of et.
    """
    return cs1.etcal(et)

__copy_attributes_from(etcal, cs1.etcal)

#########################
# eul2m
#########################

def eul2m(angle3, angle2, angle1, axis3, axis2, axis1):
    """
    Construct a rotation matrix from a set of Euler angles.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eul2m_c.html
    
    Inputs:
      float      angle3 = Rotation angle about the third rotation axis
                          (radians).
      float      angle2 = Rotation angle about the second rotation axis
                          (radians).
      float      angle1 = Rotation angle about the first rotation axis
                          (radians).
      int        axis3  = Axis number (1, 2, or 3) of the third rotation
                          axis.
      int        axis2  = Axis number (1, 2, or 3) of the second rotation
                          axis.
      int        axis1  = Axis number (1, 2, or 3) of the first rotation
                          axis.
    
    Returns:
      float[3,3] rotmat = Product of the 3 rotations.
    """
    return cs1.eul2m(angle3, angle2, angle1, axis3, axis2, axis1)

def eul2m_vector(angle3, angle2, angle1, axis3, axis2, axis1):
    """
    Construct a rotation matrix from a set of Euler angles.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eul2m_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     angle3 = Rotation angle about the third rotation axis
                            (radians).
      float[_]     angle2 = Rotation angle about the second rotation axis
                            (radians).
      float[_]     angle1 = Rotation angle about the first rotation axis
                            (radians).
      int          axis3  = Axis number (1, 2, or 3) of the third rotation
                            axis.
      int          axis2  = Axis number (1, 2, or 3) of the second rotation
                            axis.
      int          axis1  = Axis number (1, 2, or 3) of the first rotation
                            axis.
    
    Returns:
      float[_,3,3] rotmat = Product of the 3 rotations.
    """
    return cs1.eul2m_vector(angle3, angle2, angle1, axis3, axis2, axis1)

__copy_attributes_from(eul2m, cs1.eul2m)
__copy_attributes_from(eul2m_vector, cs1.eul2m_vector)

#########################
# eul2xf
#########################

def eul2xf(eulang, axisa, axisb, axisc):
    """
    This routine computes a state transformation from an Euler angle
    factorization of a rotation and the derivatives of those Euler angles.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eul2xf_c.html
    
    Inputs:
      float[6]   eulang = An array of Euler angles and their derivatives.
      int        axisa  = Axis A of the Euler angle factorization.
      int        axisb  = Axis B of the Euler angle factorization.
      int        axisc  = Axis C of the Euler angle factorization.
    
    Returns:
      float[6,6] xform  = A state transformation matrix.
    """
    return cs1.eul2xf(eulang, axisa, axisb, axisc)

def eul2xf_vector(eulang, axisa, axisb, axisc):
    """
    This routine computes a state transformation from an Euler angle
    factorization of a rotation and the derivatives of those Euler angles.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eul2xf_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6]   eulang = An array of Euler angles and their derivatives.
      int          axisa  = Axis A of the Euler angle factorization.
      int          axisb  = Axis B of the Euler angle factorization.
      int          axisc  = Axis C of the Euler angle factorization.
    
    Returns:
      float[_,6,6] xform  = A state transformation matrix.
    """
    return cs1.eul2xf_vector(eulang, axisa, axisb, axisc)

__copy_attributes_from(eul2xf, cs1.eul2xf)
__copy_attributes_from(eul2xf_vector, cs1.eul2xf_vector)

#########################
# evsgp4
#########################

def evsgp4(et, geophs, elems):
    """
    Evaluate NORAD two-line element data for earth orbiting spacecraft. This
    evaluator uses algorithms as described in Vallado 2006 [4].
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/evsgp4_c.html
    
    Inputs:
      float    et     = Epoch in seconds past ephemeris epoch J2000.
      float[8] geophs = Geophysical constants
      float[*] elems  = Two-line element data
    
    Returns:
      float[6] state  = Evaluated state
    """
    return cs1.evsgp4(et, geophs, elems)

def evsgp4_vector(et, geophs, elems):
    """
    Evaluate NORAD two-line element data for earth orbiting spacecraft. This
    evaluator uses algorithms as described in Vallado 2006 [4].
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/evsgp4_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   et     = Epoch in seconds past ephemeris epoch J2000.
      float[_,8] geophs = Geophysical constants
      float[_,*] elems  = Two-line element data
    
    Returns:
      float[_,6] state  = Evaluated state
    """
    return cs1.evsgp4_vector(et, geophs, elems)

__copy_attributes_from(evsgp4, cs1.evsgp4)
__copy_attributes_from(evsgp4_vector, cs1.evsgp4_vector)

#########################
# expool
#########################

def expool(name):
    """
    Confirm the existence of a kernel variable in the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/expool_c.html
    
    Inputs:
      string name  = Name of the variable whose value is to be returned.
    
    Returns:
      bool   found = True when the variable is in the pool; False otherwise.
    """
    return cs1.expool(name)

__copy_attributes_from(expool, cs1.expool)

#########################
# failed
#########################

def failed():
    """
    True if an error condition has been signalled via sigerr. failed is the
    CSPICE status indicator.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/failed_c.html
    
    Inputs: none
    
    Returns:
      bool value = True if an error condition was detected inside CSPICE,
                   False otherwise.
    """
    return cs1.failed()

__copy_attributes_from(failed, cs1.failed)

#########################
# fovray
#########################

def fovray(inst, raydir, rframe, abcorr, obsrvr, et):
    """
    Determine if a specified ray is within the field-of-view (FOV) of a
    specified instrument at a given time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/fovray_c.html
    
    Inputs:
      string   inst   = Name or ID code string of the instrument.
      float[3] raydir = Ray's direction vector.
      string   rframe = Body-fixed, body-centered frame for target body.
      string   abcorr = Aberration correction, "NONE", "S", or "XS".
      string   obsrvr = Name or ID code string of the observer.
      float    et     = Time of the observation (seconds past J2000).
    
    Returns:
      bool     visibl = Visibility flag (True/False).
    """
    return cs1.fovray(inst, raydir, rframe, abcorr, obsrvr, et)

def fovray_vector(inst, raydir, rframe, abcorr, obsrvr, et):
    """
    Determine if a specified ray is within the field-of-view (FOV) of a
    specified instrument at a given time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/fovray_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     inst   = Name or ID code string of the instrument.
      float[_,3] raydir = Ray's direction vector.
      string     rframe = Body-fixed, body-centered frame for target body.
      string     abcorr = Aberration correction, "NONE", "S", or "XS".
      string     obsrvr = Name or ID code string of the observer.
      float[_]   et     = Time of the observation (seconds past J2000).
    
    Returns:
      bool       visibl = Visibility flag (True/False).
    """
    return cs1.fovray_vector(inst, raydir, rframe, abcorr, obsrvr, et)

__copy_attributes_from(fovray, cs1.fovray)
__copy_attributes_from(fovray_vector, cs1.fovray_vector)

#########################
# fovtrg
#########################

def fovtrg(inst, target, tshape, tframe, abcorr, obsrvr, et):
    """
    Determine if a specified ephemeris object is within the field-of-view
    (FOV) of a specified instrument at a given time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/fovtrg_c.html
    
    Inputs:
      string inst   = Name or ID code string of the instrument.
      string target = Name or ID code string of the target.
      string tshape = Type of shape model used for the target, "ELLIPSOID"
                      or "POINT".
      string tframe = Body-fixed, body-centered frame for target body.
      string abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                      "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string obsrvr = Name or ID code string of the observer.
      float  et     = Time of the observation (seconds past J2000).
    
    Returns:
      bool   visibl = Visibility flag (True or False).
    """
    return cs1.fovtrg(inst, target, tshape, tframe, abcorr, obsrvr, et)

def fovtrg_vector(inst, target, tshape, tframe, abcorr, obsrvr, et):
    """
    Determine if a specified ephemeris object is within the field-of-view
    (FOV) of a specified instrument at a given time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/fovtrg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string   inst   = Name or ID code string of the instrument.
      string   target = Name or ID code string of the target.
      string   tshape = Type of shape model used for the target, "ELLIPSOID"
                        or "POINT".
      string   tframe = Body-fixed, body-centered frame for target body.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obsrvr = Name or ID code string of the observer.
      float[_] et     = Time of the observation (seconds past J2000).
    
    Returns:
      bool     visibl = Visibility flag (True or False).
    """
    return cs1.fovtrg_vector(inst, target, tshape, tframe, abcorr, obsrvr, et)

__copy_attributes_from(fovtrg, cs1.fovtrg)
__copy_attributes_from(fovtrg_vector, cs1.fovtrg_vector)

#########################
# frame
#########################

def frame(x1):
    """
    Given a vector x, this routine builds a right handed orthonormal frame
    x,y,z where the output x is parallel to the input x.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/frame_c.html
    
    Inputs:
      float[3] x1 = Input vector.
    
    Returns:
      float[3] x  = A unit vector parallel to x1.
      float[3] y  = Unit vector in the plane orthogonal to x.
      float[3] z  = Unit vector given by x X y.
    """
    return cs1.frame(x1)

def frame_vector(x1):
    """
    Given a vector x, this routine builds a right handed orthonormal frame
    x,y,z where the output x is parallel to the input x.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/frame_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] x1 = Input vector.
    
    Returns:
      float[_,3] x  = A unit vector parallel to x1.
      float[_,3] y  = Unit vector in the plane orthogonal to x.
      float[_,3] z  = Unit vector given by x X y.
    """
    return cs1.frame_vector(x1)

__copy_attributes_from(frame, cs1.frame)
__copy_attributes_from(frame_vector, cs1.frame_vector)

#########################
# frinfo
#########################

def frinfo(frcode):
    """
    Retrieve the minimal attributes associated with a frame needed for
    converting transformations to and from it.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/frinfo_c.html
    
    Inputs:
      int  frcode = The idcode for some frame.
    
    Returns:
      int  cent   = The center of the frame.
      int  frclss = The class (type) of the frame.
      int  clssid = The idcode for the frame within its class.
      bool found  = True if the requested information is available.
    """
    return cs1.frinfo(frcode)

def frinfo_error(frcode):
    """
    Retrieve the minimal attributes associated with a frame needed for
    converting transformations to and from it.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/frinfo_c.html
    
    Inputs:
      int frcode = The idcode for some frame.
    
    Returns:
      int cent   = The center of the frame.
      int frclss = The class (type) of the frame.
      int clssid = The idcode for the frame within its class.
    
    Note: Raise KeyError(FRAMEIDNOTFOUND) if the requested frame is not
    found.
    """
    return cs1.frinfo_error(frcode)

__copy_attributes_from(frinfo, cs1.frinfo)
__copy_attributes_from(frinfo_error, cs1.frinfo_error)

#########################
# frmchg
#########################

def frmchg(frame1, frame2, et):
    """
    Return the state transformation matrix from one frame to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/frmchg.html
    
    Inputs:
      int        frame1 = The frame id-code for some reference frame.
      int        frame2 = The frame id-code for some reference frame.
      float      et     = An epoch in TDB seconds past J2000.
    
    Returns:
      float[6,6] xform  = A state transformation matrix.
    """
    return cs1.frmchg(frame1, frame2, et)

def frmchg_vector(frame1, frame2, et):
    """
    Return the state transformation matrix from one frame to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/frmchg.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          frame1 = The frame id-code for some reference frame.
      int          frame2 = The frame id-code for some reference frame.
      float[_]     et     = An epoch in TDB seconds past J2000.
    
    Returns:
      float[_,6,6] xform  = A state transformation matrix.
    """
    return cs1.frmchg_vector(frame1, frame2, et)

__copy_attributes_from(frmchg, cs1.frmchg)
__copy_attributes_from(frmchg_vector, cs1.frmchg_vector)

#########################
# frmnam
#########################

def frmnam(frcode):
    """
    Retrieve the name of a reference frame associated with a SPICE ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/frmnam_c.html
    
    Inputs:
      int    frcode = An integer code for a reference frame.
    
    Returns:
      string frname = The name associated with the reference frame; blank on
                      error.
    """
    return cs1.frmnam(frcode)

def frmnam_error(frcode):
    """
    Retrieve the name of a reference frame associated with a SPICE ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/frmnam_c.html
    
    Inputs:
      int    frcode = An integer code for a reference frame.
    
    Returns:
      string frname = The name associated with the reference frame; blank on
                      error.
    
    Note: Raise KeyError(FRAMEIDNOTFOUND) if the requested frame is not
    found.
    """
    return cs1.frmnam_error(frcode)

__copy_attributes_from(frmnam, cs1.frmnam)
__copy_attributes_from(frmnam_error, cs1.frmnam_error)

#########################
# furnsh
#########################

def furnsh(file):
    """
    Load one or more SPICE kernels into a program.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/furnsh_c.html
    
    Inputs:
      string file = Name of SPICE kernel file (text or binary).
    
    Returns: none
    """
    return cs1.furnsh(file)

__copy_attributes_from(furnsh, cs1.furnsh)

#########################
# gcpool
#########################

def gcpool(name = '', start = 0):
    """
    Return the character value(s) of a kernel variable from the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gcpool_c.html
    
    Inputs:
      string    name  = Name of the variable whose value is to be returned.
      int       start = Which component to start retrieving for name.
    
    Returns:
      string[*] cvals = Values associated with name.
      bool      found = True if variable is in pool.
    """
    return cs1.gcpool(name, start)

def gcpool_error(name = '', start = 0):
    """
    Return the character value(s) of a kernel variable from the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gcpool_c.html
    
    Inputs:
      string    name  = Name of the variable whose value is to be returned.
      int       start = Which component to start retrieving for name.
    
    Returns:
      string[*] cvals = Values associated with name.
    
    Note: Raise KeyError(VARIABLENOTFOUND) if the variable is not in the
    pool; TypeError(WRONGDATATYPE) if it has the wrong type;
    IndexError(INDEXOUTOFRANGE) if the start index is out of range.
    """
    return cs1.gcpool_error(name, start)

__copy_attributes_from(gcpool, cs1.gcpool)
__copy_attributes_from(gcpool_error, cs1.gcpool_error)

#########################
# gdpool
#########################

def gdpool(name = '', start = 0):
    """
    Return the floating-point value(s) of a kernel variable from the kernel
    pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gdpool_c.html
    
    Inputs:
      string   name   = Name of the variable whose value is to be returned.
      int      start  = Which component to start retrieving for name.
    
    Returns:
      float[*] values = Values associated with name.
      bool     found  = True if variable is in pool.
    """
    return cs1.gdpool(name, start)

def gdpool_error(name = '', start = 0):
    """
    Return the floating-point value(s) of a kernel variable from the kernel
    pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gdpool_c.html
    
    Inputs:
      string   name   = Name of the variable whose value is to be returned.
      int      start  = Which component to start retrieving for name.
    
    Returns:
      float[*] values = Values associated with name.
    
    Note: Raise KeyError(VARIABLENOTFOUND) if the variable is not in the
    pool; TypeError(WRONGDATATYPE) if it has the wrong type;
    IndexError(INDEXOUTOFRANGE) if the start index is out of range.
    """
    return cs1.gdpool_error(name, start)

__copy_attributes_from(gdpool, cs1.gdpool)
__copy_attributes_from(gdpool_error, cs1.gdpool_error)

#########################
# georec
#########################

def georec(lon, lat, alt, re, f):
    """
    Convert geodetic coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/georec_c.html
    
    Inputs:
      float    lon    = Geodetic longitude of point (radians).
      float    lat    = Geodetic latitude of point (radians).
      float    alt    = Altitude of point above the reference spheroid.
      float    re     = Equatorial radius of the reference spheroid.
      float    f      = Flattening coefficient.
    
    Returns:
      float[3] rectan = Rectangular coordinates of point.
    """
    return cs1.georec(lon, lat, alt, re, f)

def georec_vector(lon, lat, alt, re, f):
    """
    Convert geodetic coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/georec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   lon    = Geodetic longitude of point (radians).
      float[_]   lat    = Geodetic latitude of point (radians).
      float[_]   alt    = Altitude of point above the reference spheroid.
      float[_]   re     = Equatorial radius of the reference spheroid.
      float[_]   f      = Flattening coefficient.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of point.
    """
    return cs1.georec_vector(lon, lat, alt, re, f)

__copy_attributes_from(georec, cs1.georec)
__copy_attributes_from(georec_vector, cs1.georec_vector)

#########################
# getelm
#########################

def getelm(frstyr, lines):
    """
    Parse the "lines" of a two-line element set, returning the elements in
    units suitable for use in SPICE software.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/getelm_c.html
    
    Inputs:
      int       frstyr = Year of earliest representable two-line elements.
      string[2] lines  = A pair of "lines" containing two-line elements.
    
    Returns:
      float     epoch  = The epoch of the elements in seconds past J2000.
      float[*]  elems  = The elements converted to SPICE units.
    """
    return cs1.getelm(frstyr, lines)

__copy_attributes_from(getelm, cs1.getelm)

#########################
# getfat
#########################

def getfat(file):
    """
    Determine the file architecture and file type of most SPICE kernel
    files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/getfat_c.html
    
    Inputs:
      string file   = The name of a file to be examined.
    
    Returns:
      string arch   = The architecture of the kernel file.
      string kertyp = The type of the kernel file.
    """
    return cs1.getfat(file)

__copy_attributes_from(getfat, cs1.getfat)

#########################
# getfov
#########################

def getfov(instid):
    """
    This subroutine returns the field-of-view (FOV) configuration for a
    specified instrument.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/getfov_c.html
    
    Inputs:
      int        instid = NAIF ID of an instrument.
    
    Returns:
      string     shape  = Instrument FOV shape.
      string     frame  = Name of the frame in which FOV vectors are
                          defined.
      float[3]   bsight = Boresight vector.
      float[*,3] bounds = FOV boundary vectors.
    """
    return cs1.getfov(instid)

__copy_attributes_from(getfov, cs1.getfov)

#########################
# getfvn
#########################

def getfvn(inst):
    """
    Return the field-of-view (FOV) parameters for a specified instrument.
    The instrument is specified by name.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/getfvn_c.html
    
    Inputs:
      string     inst   = Name of an instrument.
    
    Returns:
      string     shape  = Instrument FOV shape.
      string     frame  = Name of the frame in which FOV vectors are
                          defined.
      float[3]   bsight = Boresight vector.
      float[*,3] bounds = FOV boundary vectors.
    """
    return cs1.getfvn(inst)

__copy_attributes_from(getfvn, cs1.getfvn)

#########################
# getmsg
#########################

def getmsg(option):
    """
    Retrieve the current short error message, the explanation of the short
    error message, or the long error message.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/getmsg_c.html
    
    Inputs:
      string option = Indicates type of error message, "SHORT", "LONG", or
                      "EXPLAIN".
    
    Returns:
      string msg    = The error message to be retrieved.
    """
    return cs1.getmsg(option)

__copy_attributes_from(getmsg, cs1.getmsg)

#########################
# gfdist
#########################

def gfdist(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Return the time window over which a specified constraint on
    observer-target distance is met.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfdist_c.html
    
    Inputs:
      string       target  = Name of the target body.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      string       relate  = Relational operator.
      float        refval  = Reference value.
      float        adjust  = Adjustment value for absolute extrema searches.
      float        step    = Step size used for locating extrema and roots.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is confined.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfdist(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfdist, cs1.gfdist)

#########################
# gfevnt
#########################

def gfevnt(step, gquant, qpnams, qcpars, qdpars, qipars, qlpars, op, refval, tol, adjust, rpt, nintvls, cnfine, result = 2000):
    """
    Determine time intervals when a specified geometric quantity satisfies a
    specified mathematical condition.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfevnt_c.html
    
    Inputs:
      float        step    = Time step for searching.
      string       gquant  = Type of geometric quantity.
      string[*]    qpnams  = Names of quantity definition parameters.
      string[*]    qcpars  = Array of character quantity definition
                             parameters.
      float[*]     qdpars  = Array of floating-point quantity definition
                             parameters.
      int[*]       qipars  = Array of integer quantity definition
                             parameters.
      bool[*]      qlpars  = Array of logical quantity definition
                             parameters.
      string       op      = Operator that either looks for an extreme value
                             (max, min, local, absolute) or compares the
                             geometric quantity value and a number.
      float        refval  = Reference value.
      float        tol     = Convergence tolerance in seconds
      float        adjust  = Absolute extremum adjustment value.
      bool         rpt     = Progress reporter on (True) or off (False).
      int          nintvls = Workspace window interval count
      SpiceCell[*] cnfine  = SPICE window to which the search is restricted.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfevnt(step, gquant, qpnams, qcpars, qdpars, qipars, qlpars, op, refval, tol, adjust, rpt, nintvls, cnfine, result)

__copy_attributes_from(gfevnt, cs1.gfevnt)

#########################
# gffove
#########################

def gffove(inst, tshape, raydir, target, tframe, abcorr, obsrvr, tol, step, rpt, cnfine, result = 2000):
    """
    Determine time intervals when a specified target body or ray intersects
    the space bounded by the field-of-view (FOV) of a specified instrument.
    Report progress and handle interrupts if so commanded.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gffove_c.html
    
    Inputs:
      string       inst   = Name of the instrument.
      string       tshape = Type of shape model used for target body.
      float[3]     raydir = Ray's direction vector.
      string       target = Name of the target body.
      string       tframe = Body-fixed, body-centered frame for target body.
      string       abcorr = Aberration correction flag.
      string       obsrvr = Name of the observing body.
      float        tol    = Convergence tolerance in seconds.
      float        step   = Time step for searching.
      bool         rpt    = Progress report flag.
      SpiceCell[*] cnfine = SPICE window to which the search is restricted.
      SpiceCell    result = SPICE window containing results.
    
    Returns:
      SpiceCell    result = SPICE window containing results.
    """
    return cs1.gffove(inst, tshape, raydir, target, tframe, abcorr, obsrvr, tol, step, rpt, cnfine, result)

__copy_attributes_from(gffove, cs1.gffove)

#########################
# gfilum
#########################

def gfilum(method, angtyp, target, illmn, fixref, abcorr, obsrvr, spoint, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Return the time window over which a specified constraint on the observed
    phase, solar incidence, or emission angle at a specified target body
    surface point is met.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfilum_c.html
    
    Inputs:
      string       method  = Computation method.
      string       angtyp  = Type of illumination angle.
      string       target  = Name of the target body.
      string       illmn   = Name of the illumination source.
      string       fixref  = Body-fixed, body-centered target body frame.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      float[3]     spoint  = Body-fixed coordinates of a target surface
                             point.
      string       relate  = Relational operator.
      float        refval  = Reference value.
      float        adjust  = Adjustment value for absolute extrema searches.
      float        step    = Step size used for locating extrema and roots.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is confined.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfilum(method, angtyp, target, illmn, fixref, abcorr, obsrvr, spoint, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfilum, cs1.gfilum)

#########################
# gfocce
#########################

def gfocce(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, tol, step, rpt, cnfine, result = 2000):
    """
    Determine time intervals when an observer sees one target occulted by
    another. Report progress and handle interrupts if so commanded. The
    surfaces of the target bodies may be represented by triaxial ellipsoids
    or by topographic data provided by DSK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfocce_c.html
    
    Inputs:
      string       occtyp = Type of occultation.
      string       front  = Name of body occulting the other.
      string       fshape = Type of shape model used for front body.
      string       fframe = Body-fixed, body-centered frame for front body.
      string       back   = Name of body occulted by the other.
      string       bshape = Type of shape model used for back body.
      string       bframe = Body-fixed, body-centered frame for back body.
      string       abcorr = Aberration correction flag.
      string       obsrvr = Name of the observing body.
      float        tol    = Convergence tolerance in seconds.
      float        step   = Time step for searching.
      bool         rpt    = Progress report flag.
      SpiceCell[*] cnfine = SPICE window to which the search is restricted.
      SpiceCell    result = SPICE window containing results.
    
    Returns:
      SpiceCell    result = SPICE window containing results.
    """
    return cs1.gfocce(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, tol, step, rpt, cnfine, result)

__copy_attributes_from(gfocce, cs1.gfocce)

#########################
# gfoclt
#########################

def gfoclt(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, step, cnfine, result = 2000):
    """
    Determine time intervals when an observer sees one target occulted by,
    or in transit across, another. The surfaces of the target bodies may be
    represented by triaxial ellipsoids or by topographic data provided by
    DSK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfoclt_c.html
    
    Inputs:
      string       occtyp = Type of occultation.
      string       front  = Name of body occulting the other.
      string       fshape = Type of shape model used for front body.
      string       fframe = Body-fixed, body-centered frame for front body.
      string       back   = Name of body occulted by the other.
      string       bshape = Type of shape model used for back body.
      string       bframe = Body-fixed, body-centered frame for back body.
      string       abcorr = Aberration correction flag.
      string       obsrvr = Name of the observing body.
      float        step   = Step size in seconds for finding occultation
                            events.
      SpiceCell[*] cnfine = SPICE window to which the search is restricted.
      SpiceCell    result = SPICE window containing results.
    
    Returns:
      SpiceCell    result = SPICE window containing results.
    """
    return cs1.gfoclt(occtyp, front, fshape, fframe, back, bshape, bframe, abcorr, obsrvr, step, cnfine, result)

__copy_attributes_from(gfoclt, cs1.gfoclt)

#########################
# gfpa
#########################

def gfpa(target, illmn, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Determine time intervals for which a specified constraint on the phase
    angle between an illumination source, a target, and observer body
    centers is met.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfpa_c.html
    
    Inputs:
      string       target  = Name of the target body.
      string       illmn   = Name of the illuminating body.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      string       relate  = Relational operator.
      float        refval  = Reference value.
      float        adjust  = Adjustment value for absolute extrema searches.
      float        step    = Step size used for locating extrema and roots.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is confined.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfpa(target, illmn, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfpa, cs1.gfpa)

#########################
# gfposc
#########################

def gfposc(target, frame, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Determine time intervals for which a coordinate of an observer-target
    position vector satisfies a numerical constraint.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfposc_c.html
    
    Inputs:
      string       target  = Name of the target body.
      string       frame   = Name of the reference frame for coordinate
                             calculations.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      string       crdsys  = Name of the coordinate system containing
                             `coord'.
      string       coord   = Name of the coordinate of interest.
      string       relate  = Relational operator.
      float        refval  = Reference value.
      float        adjust  = Adjustment value for absolute extrema searches.
      float        step    = Step size used for locating extrema and roots.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is confined.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfposc(target, frame, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfposc, cs1.gfposc)

#########################
# gfrfov
#########################

def gfrfov(inst, raydir, rframe, abcorr, obsrvr, step, cnfine, result = 2000):
    """
    Determine time intervals when a specified ray intersects the space
    bounded by the field-of-view (FOV) of a specified instrument.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfrfov_c.html
    
    Inputs:
      string       inst   = Name of the instrument.
      float[3]     raydir = Ray's direction vector.
      string       rframe = Reference frame of ray's direction vector.
      string       abcorr = Aberration correction flag.
      string       obsrvr = Name of the observing body.
      float        step   = Step size in seconds for finding FOV events.
      SpiceCell[*] cnfine = SPICE window to which the search is restricted.
      SpiceCell    result = SPICE window containing results.
    
    Returns:
      SpiceCell    result = SPICE window containing results.
    """
    return cs1.gfrfov(inst, raydir, rframe, abcorr, obsrvr, step, cnfine, result)

__copy_attributes_from(gfrfov, cs1.gfrfov)

#########################
# gfrr
#########################

def gfrr(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Determine time intervals for which a specified constraint on the
    observer-target range rate is met.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfrr_c.html
    
    Inputs:
      string       target  = Name of the target body.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      string       relate  = Relational operator.
      float        refval  = Reference value.
      float        adjust  = Adjustment value for absolute extrema searches.
      float        step    = Step size used for locating extrema and roots.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is confined.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfrr(target, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfrr, cs1.gfrr)

#########################
# gfsep
#########################

def gfsep(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Determine time intervals when the angular separation between the
    position vectors of two target bodies relative to an observer satisfies
    a numerical relationship.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfsep_c.html
    
    Inputs:
      string       targ1   = Name of first body.
      string       shape1  = Name of shape model describing the first body.
      string       frame1  = The body-fixed reference frame of the first
                             body.
      string       targ2   = Name of second body.
      string       shape2  = Name of the shape model describing the second
                             body.
      string       frame2  = The body-fixed reference frame of the second
                             body.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      string       relate  = Operator that either looks for an extreme value
                             (max, min, local, absolute) or compares the
                             angular separation value and `refval'.
      float        refval  = Reference value.
      float        adjust  = Absolute extremum adjustment value.
      float        step    = Step size in seconds for finding angular
                             separation events.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is restricted.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfsep(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfsep, cs1.gfsep)

#########################
# gfsntc
#########################

def gfsntc(target, fixref, method, abcorr, obsrvr, dref, dvec, crdsys, coord, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Determine time intervals for which a coordinate of an surface intercept
    position vector satisfies a numerical constraint.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfsntc_c.html
    
    Inputs:
      string       target  = Name of the target body.
      string       fixref  = Body fixed frame associated with `target'.
      string       method  = Name of method type for surface intercept
                             calculation.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      string       dref    = Reference frame of direction vector `dvec'.
      float[3]     dvec    = Pointing direction vector from `obsrvr'.
      string       crdsys  = Name of the coordinate system containing
                             `coord'.
      string       coord   = Name of the coordinate of interest.
      string       relate  = Relational operator.
      float        refval  = Reference value.
      float        adjust  = Adjustment value for absolute extrema searches.
      float        step    = Step size used for locating extrema and roots.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is confined.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfsntc(target, fixref, method, abcorr, obsrvr, dref, dvec, crdsys, coord, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfsntc, cs1.gfsntc)

#########################
# gfstol
#########################

def gfstol(value):
    """
    Override the default GF convergence value used in the high level GF
    routines.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfstol_c.html
    
    Inputs:
      float value = Double precision value returned or to store.
    
    Returns: none
    """
    return cs1.gfstol(value)

__copy_attributes_from(gfstol, cs1.gfstol)

#########################
# gfsubc
#########################

def gfsubc(target, fixref, method, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step, nintvls, cnfine, result = 2000):
    """
    Determine time intervals for which a coordinate of an subpoint position
    vector satisfies a numerical constraint.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gfsubc_c.html
    
    Inputs:
      string       target  = Name of the target body.
      string       fixref  = Body fixed frame associated with `target'.
      string       method  = Name of method type for subpoint calculation.
      string       abcorr  = Aberration correction flag.
      string       obsrvr  = Name of the observing body.
      string       crdsys  = Name of the coordinate system containing
                             `coord'.
      string       coord   = Name of the coordinate of interest.
      string       relate  = Relational operator.
      float        refval  = Reference value.
      float        adjust  = Adjustment value for absolute extrema searches.
      float        step    = Step size used for locating extrema and roots.
      int          nintvls = Workspace window interval count.
      SpiceCell[*] cnfine  = SPICE window to which the search is confined.
      SpiceCell    result  = SPICE window containing results.
    
    Returns:
      SpiceCell    result  = SPICE window containing results.
    """
    return cs1.gfsubc(target, fixref, method, abcorr, obsrvr, crdsys, coord, relate, refval, adjust, step, nintvls, cnfine, result)

__copy_attributes_from(gfsubc, cs1.gfsubc)

#########################
# gftfov
#########################

def gftfov(inst, target, tshape, tframe, abcorr, obsrvr, step, cnfine, result = 20000):
    """
    Determine time intervals when a specified ephemeris object intersects
    the space bounded by the field-of-view (FOV) of a specified instrument.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gftfov_c.html
    
    Inputs:
      string       inst   = Name of the instrument.
      string       target = Name of the target body.
      string       tshape = Type of shape model used for target body.
      string       tframe = Body-fixed, body-centered frame for target body.
      string       abcorr = Aberration correction flag.
      string       obsrvr = Name of the observing body.
      float        step   = Step size in seconds for finding FOV events.
      SpiceCell[*] cnfine = SPICE window to which the search is restricted.
      SpiceCell    result = SPICE window containing results.
    
    Returns:
      SpiceCell    result = SPICE window containing results.
    """
    return cs1.gftfov(inst, target, tshape, tframe, abcorr, obsrvr, step, cnfine, result)

__copy_attributes_from(gftfov, cs1.gftfov)

#########################
# gipool
#########################

def gipool(name = '', start = 0):
    """
    Return the integer value of a kernel variable from the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gipool_c.html
    
    Inputs:
      string name  = Name of the variable whose value is to be returned.
      int    start = Which component to start retrieving for name.
    
    Returns:
      int[*] ivals = Values associated with name.
      bool   found = True if variable is in pool.
    """
    return cs1.gipool(name, start)

def gipool_error(name = '', start = 0):
    """
    Return the integer value of a kernel variable from the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gipool_c.html
    
    Inputs:
      string name  = Name of the variable whose value is to be returned.
      int    start = Which component to start retrieving for name.
    
    Returns:
      int[*] ivals = Values associated with name.
    
    Note: Raise KeyError(VARIABLENOTFOUND) if the variable is not in the
    pool; TypeError(WRONGDATATYPE) if it has the wrong type;
    IndexError(INDEXOUTOFRANGE) if the start index is out of range.
    """
    return cs1.gipool_error(name, start)

__copy_attributes_from(gipool, cs1.gipool)
__copy_attributes_from(gipool_error, cs1.gipool_error)

#########################
# gnpool
#########################

def gnpool(name = '', start = 0):
    """
    Return names of kernel variables matching a specified template.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gnpool_c.html
    
    Inputs:
      string    name  = Template that names should match.
      int       start = Index of first matching name to retrieve.
    
    Returns:
      string[*] kvars = Kernel pool variables whose names match name.
      bool      found = True if there is at least one match.
    
    Note: Raise a SPICE error condition if the variable is not in the
    pool, if it has the wrong type, or if the start index is out of range.
    """
    return cs1.gnpool(name, start)

def gnpool_error(name = '', start = 0):
    """
    Return names of kernel variables matching a specified template.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/gnpool_c.html
    
    Inputs:
      string    name  = Template that names should match.
      int       start = Index of first matching name to retrieve.
    
    Returns:
      string[*] kvars = Kernel pool variables whose names match name.
    
    Note: Raise a SPICE error condition if the variable is not in the
    pool, if it has the wrong type, or if the start index is out of range.
    Raise KeyError(VARIABLENOTFOUND) if the variable is not in the pool;
    TypeError(WRONGDATATYPE) if it has the wrong type;
    IndexError(INDEXOUTOFRANGE) if the start index is out of range.
    """
    return cs1.gnpool_error(name, start)

__copy_attributes_from(gnpool, cs1.gnpool)
__copy_attributes_from(gnpool_error, cs1.gnpool_error)

#########################
# halfpi
#########################

def halfpi():
    """
    Return half the value of pi (the ratio of the circumference of a circle
    to its diameter).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/halfpi_c.html
    
    Inputs: none
    
    Returns:
      float value = Half the value of pi.
    """
    return cs1.halfpi()

__copy_attributes_from(halfpi, cs1.halfpi)

#########################
# hrmesp
#########################

def hrmesp(first, step, yvals, x):
    """
    Evaluate, at a specified point, a Hermite interpolating polynomial for a
    specified set of equally spaced abscissa values and corresponding pairs
    of function and function derivative values.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/hrmesp_c.html
    
    Inputs:
      float    first = First abscissa value.
      float    step  = Step size.
      float[*] yvals = Ordinate and derivative values.
      float    x     = Point at which to interpolate the polynomial.
    
    Returns:
      float    f     = Interpolated function value at `x'.
      float    df    = Interpolated function's derivative at `x'.
    """
    return cs1.hrmesp(first, step, yvals, x)

def hrmesp_vector(first, step, yvals, x):
    """
    Evaluate, at a specified point, a Hermite interpolating polynomial for a
    specified set of equally spaced abscissa values and corresponding pairs
    of function and function derivative values.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/hrmesp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   first = First abscissa value.
      float[_]   step  = Step size.
      float[_,*] yvals = Ordinate and derivative values.
      float[_]   x     = Point at which to interpolate the polynomial.
    
    Returns:
      float[_]   f     = Interpolated function value at `x'.
      float[_]   df    = Interpolated function's derivative at `x'.
    """
    return cs1.hrmesp_vector(first, step, yvals, x)

__copy_attributes_from(hrmesp, cs1.hrmesp)
__copy_attributes_from(hrmesp_vector, cs1.hrmesp_vector)

#########################
# hrmint
#########################

def hrmint(xvals, yvals, x):
    """
    Evaluate a Hermite interpolating polynomial at a specified abscissa
    value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/hrmint_c.html
    
    Inputs:
      float[*]   xvals = Abscissa values.
      float[*,2] yvals = Ordinate and derivative values.
      float      x     = Point at which to interpolate the polynomial.
    
    Returns:
      float      f     = Interpolated function value at `x'.
      float      df    = Interpolated function's derivative at `x'.
    """
    return cs1.hrmint(xvals, yvals, x)

def hrmint_vector(xvals, yvals, x):
    """
    Evaluate a Hermite interpolating polynomial at a specified abscissa
    value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/hrmint_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] xvals = Abscissa values.
      float[*,2] yvals = Ordinate and derivative values.
      float[_]   x     = Point at which to interpolate the polynomial.
    
    Returns:
      float[_]   f     = Interpolated function value at `x'.
      float[_]   df    = Interpolated function's derivative at `x'.
    """
    return cs1.hrmint_vector(xvals, yvals, x)

__copy_attributes_from(hrmint, cs1.hrmint)
__copy_attributes_from(hrmint_vector, cs1.hrmint_vector)

#########################
# hx2dp
#########################

def hx2dp(string):
    """
    Convert a string representing a floating-point number in a base 16
    "scientific notation" into its equivalent double precision number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/hx2dp_c.html
    
    Inputs:
      string string = Hex form string to convert to floating-point.
    
    Returns:
      float  number = Double precision value to be returned.
      bool   error  = A logical flag which is True on error.
      string errmsg = A descriptive error message.
    """
    return cs1.hx2dp(string)

def hx2dp_error(string):
    """
    Convert a string representing a floating-point number in a base 16
    "scientific notation" into its equivalent double precision number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/hx2dp_c.html
    
    Inputs:
      string string = Hex form string to convert to floating-point.
    
    Returns:
      float  number = Double precision value to be returned.
    
    Note: Raise ValueError(INVALIDVALUE) if the hex string is invalid.
    """
    return cs1.hx2dp_error(string)

__copy_attributes_from(hx2dp, cs1.hx2dp)
__copy_attributes_from(hx2dp_error, cs1.hx2dp_error)

#########################
# ident
#########################

def ident():
    """
    Return the 3x3 identity matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ident_c.html
    
    Inputs: none
    
    Returns:
      float[3,3] matrix = is the 3x3 identity matrix.
    """
    return cs1.ident()

__copy_attributes_from(ident, cs1.ident)

#########################
# illum
#########################

def illum(target, et, abcorr, obsrvr, spoint):
    """
    Find the illumination angles at a specified surface point of a target
    body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/illum_c.html
    
    Inputs:
      string   target = Name of target body.
      float    et     = Epoch in ephemeris seconds past J2000.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        or "CN+S".
      string   obsrvr = Name of observing body.
      float[3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float    phase  = Phase angle at the surface point.
      float    solar  = Solar incidence angle at the surface point.
      float    emissn = Emission angle at the surface point.
    """
    return cs1.illum(target, et, abcorr, obsrvr, spoint)

def illum_vector(target, et, abcorr, obsrvr, spoint):
    """
    Find the illumination angles at a specified surface point of a target
    body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/illum_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     target = Name of target body.
      float[_]   et     = Epoch in ephemeris seconds past J2000.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          or "CN+S".
      string     obsrvr = Name of observing body.
      float[_,3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float[_]   phase  = Phase angle at the surface point.
      float[_]   solar  = Solar incidence angle at the surface point.
      float[_]   emissn = Emission angle at the surface point.
    """
    return cs1.illum_vector(target, et, abcorr, obsrvr, spoint)

__copy_attributes_from(illum, cs1.illum)
__copy_attributes_from(illum_vector, cs1.illum_vector)

#########################
# illumf
#########################

def illumf(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint):
    """
    Compute the illumination angles---phase, incidence, and emission---at a
    specified point on a target body. Return logical flags indicating
    whether the surface point is visible from the observer's position and
    whether the surface point is illuminated.
    
    The target body's surface is represented using topographic data provided
    by DSK files, or by a reference ellipsoid.
    
    The illumination source is a specified ephemeris object.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/illumf_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      string   ilusrc = Name of illumination source.
      float    et     = Epoch in TDB seconds past J2000 TDB.
      string   fixref = Body-fixed, body-centered target body frame.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obsrvr = Name of observing body.
      float[3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float    trgepc = Target surface point epoch.
      float[3] srfvec = Vector from observer to target surface point.
      float    phase  = Phase angle at the surface point.
      float    incdnc = Source incidence angle at the surface point.
      float    emissn = Emission angle at the surface point.
      bool     visibl = Visibility flag, True if visible.
      bool     lit    = Illumination flag, True if illuminated.
    """
    return cs1.illumf(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint)

def illumf_vector(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint):
    """
    Compute the illumination angles---phase, incidence, and emission---at a
    specified point on a target body. Return logical flags indicating
    whether the surface point is visible from the observer's position and
    whether the surface point is illuminated.
    
    The target body's surface is represented using topographic data provided
    by DSK files, or by a reference ellipsoid.
    
    The illumination source is a specified ephemeris object.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/illumf_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      string     ilusrc = Name of illumination source.
      float[_]   et     = Epoch in TDB seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     obsrvr = Name of observing body.
      float[_,3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float[_]   trgepc = Target surface point epoch.
      float[_,3] srfvec = Vector from observer to target surface point.
      float[_]   phase  = Phase angle at the surface point.
      float[_]   incdnc = Source incidence angle at the surface point.
      float[_]   emissn = Emission angle at the surface point.
      bool       visibl = Visibility flag, True if visible.
      bool       lit    = Illumination flag, True if illuminated.
    """
    return cs1.illumf_vector(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint)

__copy_attributes_from(illumf, cs1.illumf)
__copy_attributes_from(illumf_vector, cs1.illumf_vector)

#########################
# illumg
#########################

def illumg(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint):
    """
    Find the illumination angles (phase, incidence, and emission) at a
    specified surface point of a target body.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    The illumination source is a specified ephemeris object.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/illumg_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      string   ilusrc = Name of illumination source.
      float    et     = Epoch in TDB seconds past J2000 TDB.
      string   fixref = Body-fixed, body-centered target body frame.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obsrvr = Name of observing body.
      float[3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float    trgepc = Target surface point epoch.
      float[3] srfvec = Vector from observer to target surface point.
      float    phase  = Phase angle at the surface point.
      float    incdnc = Source incidence angle at the surface point.
      float    emissn = Emission angle at the surface point.
    """
    return cs1.illumg(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint)

def illumg_vector(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint):
    """
    Find the illumination angles (phase, incidence, and emission) at a
    specified surface point of a target body.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    The illumination source is a specified ephemeris object.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/illumg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      string     ilusrc = Name of illumination source.
      float[_]   et     = Epoch in TDB seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     obsrvr = Name of observing body.
      float[_,3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float[_]   trgepc = Target surface point epoch.
      float[_,3] srfvec = Vector from observer to target surface point.
      float[_]   phase  = Phase angle at the surface point.
      float[_]   incdnc = Source incidence angle at the surface point.
      float[_]   emissn = Emission angle at the surface point.
    """
    return cs1.illumg_vector(method, target, ilusrc, et, fixref, abcorr, obsrvr, spoint)

__copy_attributes_from(illumg, cs1.illumg)
__copy_attributes_from(illumg_vector, cs1.illumg_vector)

#########################
# ilumin
#########################

def ilumin(method, target, et, fixref, abcorr, obsrvr, spoint):
    """
    Find the illumination angles (phase, solar incidence, and emission) at a
    specified surface point of a target body.
    
    This routine supersedes illum.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ilumin_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      float    et     = Epoch in TDB seconds past J2000 TDB.
      string   fixref = Body-fixed, body-centered target body frame.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obsrvr = Name of observing body.
      float[3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float    trgepc = Target surface point epoch.
      float[3] srfvec = Vector from observer to target surface point.
      float    phase  = Phase angle at the surface point.
      float    incdnc = Solar incidence angle at the surface point.
      float    emissn = Emission angle at the surface point.
    """
    return cs1.ilumin(method, target, et, fixref, abcorr, obsrvr, spoint)

def ilumin_vector(method, target, et, fixref, abcorr, obsrvr, spoint):
    """
    Find the illumination angles (phase, solar incidence, and emission) at a
    specified surface point of a target body.
    
    This routine supersedes illum.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ilumin_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float[_]   et     = Epoch in TDB seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     obsrvr = Name of observing body.
      float[_,3] spoint = Body-fixed coordinates of a target surface point.
    
    Returns:
      float[_]   trgepc = Target surface point epoch.
      float[_,3] srfvec = Vector from observer to target surface point.
      float[_]   phase  = Phase angle at the surface point.
      float[_]   incdnc = Solar incidence angle at the surface point.
      float[_]   emissn = Emission angle at the surface point.
    """
    return cs1.ilumin_vector(method, target, et, fixref, abcorr, obsrvr, spoint)

__copy_attributes_from(ilumin, cs1.ilumin)
__copy_attributes_from(ilumin_vector, cs1.ilumin_vector)

#########################
# inedpl
#########################

def inedpl(a, b, c, plane):
    """
    Find the intersection of a triaxial ellipsoid and a plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/inedpl_c.html
    
    Inputs:
      float              a       = Length of ellipsoid semi-axis lying on
                                   the x-axis.
      float              b       = Length of ellipsoid semi-axis lying on
                                   the y-axis.
      float              c       = Length of ellipsoid semi-axis lying on
                                   the z-axis.
      ConstSpicePlane[*] plane   = Plane that intersects ellipsoid.
    
    Returns:
      SpiceEllipse       ellipse = Intersection ellipse, when found is True.
      bool               found   = Flag indicating whether ellipse was
                                   found.
    """
    return cs1.inedpl(a, b, c, plane)

def inedpl_vector(a, b, c, plane):
    """
    Find the intersection of a triaxial ellipsoid and a plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/inedpl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]           a       = Length of ellipsoid semi-axis lying on
                                   the x-axis.
      float[_]           b       = Length of ellipsoid semi-axis lying on
                                   the y-axis.
      float[_]           c       = Length of ellipsoid semi-axis lying on
                                   the z-axis.
      ConstSpicePlane[*] plane   = Plane that intersects ellipsoid.
    
    Returns:
      SpiceEllipse       ellipse = Intersection ellipse, when found is True.
      bool               found   = Flag indicating whether ellipse was
                                   found.
    """
    return cs1.inedpl_vector(a, b, c, plane)

__copy_attributes_from(inedpl, cs1.inedpl)
__copy_attributes_from(inedpl_vector, cs1.inedpl_vector)

#########################
# inelpl
#########################

def inelpl(ellips, plane):
    """
    Find the intersection of an ellipse and a plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/inelpl_c.html
    
    Inputs:
      ConstSpiceEllipse[*] ellips = A CSPICE ellipse.
      ConstSpicePlane[*]   plane  = A CSPICE plane.
    
    Returns:
      int                  nxpts  = Number of intersection points of plane
                                    and ellipse.
      float[3]             xpt1   = First intersection point.
      float[3]             xpt2   = Second intersection point.
    """
    return cs1.inelpl(ellips, plane)

def inelpl_vector(ellips, plane):
    """
    Find the intersection of an ellipse and a plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/inelpl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      ConstSpiceEllipse[*] ellips = A CSPICE ellipse.
      ConstSpicePlane[*]   plane  = A CSPICE plane.
    
    Returns:
      int                  nxpts  = Number of intersection points of plane
                                    and ellipse.
      float[_,3]           xpt1   = First intersection point.
      float[_,3]           xpt2   = Second intersection point.
    """
    return cs1.inelpl_vector(ellips, plane)

__copy_attributes_from(inelpl, cs1.inelpl)
__copy_attributes_from(inelpl_vector, cs1.inelpl_vector)

#########################
# inrypl
#########################

def inrypl(vertex, dir, plane):
    """
    Find the intersection of a ray and a plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/inrypl_c.html
    
    Inputs:
      float[3]           vertex = Vertex vector of ray.
      float[3]           dir    = Direction vector of ray.
      ConstSpicePlane[*] plane  = A CSPICE plane.
    
    Returns:
      int                nxpts  = Number of intersection points of ray and
                                  plane.
      float[3]           xpt    = Intersection point, if nxpts = 1.
    """
    return cs1.inrypl(vertex, dir, plane)

def inrypl_vector(vertex, dir, plane):
    """
    Find the intersection of a ray and a plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/inrypl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]         vertex = Vertex vector of ray.
      float[_,3]         dir    = Direction vector of ray.
      ConstSpicePlane[*] plane  = A CSPICE plane.
    
    Returns:
      int                nxpts  = Number of intersection points of ray and
                                  plane.
      float[_,3]         xpt    = Intersection point, if nxpts = 1.
    """
    return cs1.inrypl_vector(vertex, dir, plane)

__copy_attributes_from(inrypl, cs1.inrypl)
__copy_attributes_from(inrypl_vector, cs1.inrypl_vector)

#########################
# intmax
#########################

def intmax():
    """
    Return the value of the largest (positive) number representable in an
    integer variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/intmax_c.html
    
    Inputs: none
    
    Returns:
      int value = The largest positive number that can be represented in an
                  integer variable.
    """
    return cs1.intmax()

__copy_attributes_from(intmax, cs1.intmax)

#########################
# intmin
#########################

def intmin():
    """
    Return the value of the smallest (negative) number representable in an
    integer variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/intmin_c.html
    
    Inputs: none
    
    Returns:
      int value = The smallest (negative) number that can be represented in
                  an integer variable.
    """
    return cs1.intmin()

__copy_attributes_from(intmin, cs1.intmin)

#########################
# invert
#########################

def invert(m1):
    """
    Generate the inverse of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invert_c.html
    
    Inputs:
      float[3,3] m1     = Matrix to be inverted.
    
    Returns:
      float[3,3] matrix = Inverted matrix (m1)**-1. If m1 is singular, then
                          matrix will be size zero.
    """
    return cs1.invert(m1)

def invert_error(m1):
    """
    Generate the inverse of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invert_c.html
    
    Inputs:
      float[3,3] m1     = Matrix to be inverted.
    
    Returns:
      float[3,3] matrix = Inverted matrix (m1)**-1. If m1 is singular, then
                          matrix will be size zero.
    
    Note: Raise ValueError(SINGULARMATRIX) if the matrix is singular.
    """
    return cs1.invert_error(m1)

def invert_vector(m1):
    """
    Generate the inverse of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invert_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = Matrix to be inverted.
    
    Returns:
      float[_,3,3] matrix = Inverted matrix (m1)**-1. If m1 is singular,
                            then matrix will be size zero.
    """
    return cs1.invert_vector(m1)

def invert_vector_error(m1):
    """
    Generate the inverse of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invert_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = Matrix to be inverted.
    
    Returns:
      float[_,3,3] matrix = Inverted matrix (m1)**-1. If m1 is singular,
                            then matrix will be size zero.
    
    Note: Raise ValueError(SINGULARMATRIX) if the matrix is singular.
    """
    return cs1.invert_vector_error(m1)

__copy_attributes_from(invert, cs1.invert)
__copy_attributes_from(invert_error, cs1.invert_error)
__copy_attributes_from(invert_vector, cs1.invert_vector)
__copy_attributes_from(invert_vector_error, cs1.invert_vector_error)

#########################
# invort
#########################

def invort(m):
    """
    Given a matrix, construct the matrix whose rows are the columns of the
    first divided by the length squared of the the corresponding columns of
    the input matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invort_c.html
    
    Inputs:
      float[3,3] m   = A 3x3 matrix.
    
    Returns:
      float[3,3] mit = Matrix after transposition and scaling of rows.
    """
    return cs1.invort(m)

def invort_vector(m):
    """
    Given a matrix, construct the matrix whose rows are the columns of the
    first divided by the length squared of the the corresponding columns of
    the input matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invort_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m   = A 3x3 matrix.
    
    Returns:
      float[_,3,3] mit = Matrix after transposition and scaling of rows.
    """
    return cs1.invort_vector(m)

__copy_attributes_from(invort, cs1.invort)
__copy_attributes_from(invort_vector, cs1.invort_vector)

#########################
# invstm
#########################

def invstm(mat):
    """
    Return the inverse of a state transformation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invstm_c.html
    
    Inputs:
      float[6,6] mat    = A state transformation matrix.
    
    Returns:
      float[6,6] invmat = The inverse of `mat'.
    """
    return cs1.invstm(mat)

def invstm_vector(mat):
    """
    Return the inverse of a state transformation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/invstm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6,6] mat    = A state transformation matrix.
    
    Returns:
      float[_,6,6] invmat = The inverse of `mat'.
    """
    return cs1.invstm_vector(mat)

__copy_attributes_from(invstm, cs1.invstm)
__copy_attributes_from(invstm_vector, cs1.invstm_vector)

#########################
# isordv
#########################

def isordv(array):
    """
    Determine whether an array of n items contains the integers 0 through
    n-1.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/isordv_c.html
    
    Inputs:
      int[*] array = Array of integers.
    
    Returns:
      bool   flag  = True if the condition is satisfied; False otherwise.
    """
    return cs1.isordv(array)

__copy_attributes_from(isordv, cs1.isordv)

#########################
# isrchc
#########################

def isrchc(value, array):
    """
    Search for a given value within a character string array. Return the
    index of the first matching array entry, or -1 if the key value was not
    found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/isrchc_c.html
    
    Inputs:
      string    value = Key value to be found in array.
      string[*] array = Character string array to search.
    
    Returns:
      int       index = Index of matching array entry.
    """
    return cs1.isrchc(value, array)

__copy_attributes_from(isrchc, cs1.isrchc)

#########################
# isrchd
#########################

def isrchd(value, array):
    """
    Search for a given value within a floating-point array. Return the index
    of the first matching array entry, or -1 if the key value was not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/isrchd_c.html
    
    Inputs:
      float    value = Key value to be found in array.
      float[*] array = Double Precision array to search.
    
    Returns:
      int      index = Index of matching array entry.
    """
    return cs1.isrchd(value, array)

__copy_attributes_from(isrchd, cs1.isrchd)

#########################
# isrchi
#########################

def isrchi(value, array):
    """
    Search for a given value within an integer array. Return the index of
    the first matching array entry, or -1 if the key value was not found.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/isrchi_c.html
    
    Inputs:
      int    value = Key value to be found in array.
      int[*] array = Integer array to search.
    
    Returns:
      int    index = Index of matching array entry.
    """
    return cs1.isrchi(value, array)

__copy_attributes_from(isrchi, cs1.isrchi)

#########################
# isrot
#########################

def isrot(m, ntol, dtol):
    """
    Indicate whether a 3x3 matrix is a rotation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/isrot_c.html
    
    Inputs:
      float[3,3] m     = A matrix to be tested.
      float      ntol  = Tolerance for the norms of the columns of m.
      float      dtol  = Tolerance for the determinant of a matrix whose
                         columns are the unitized columns of m.
    
    Returns:
      bool       value = True if and only if m is a rotation matrix.
    """
    return cs1.isrot(m, ntol, dtol)

def isrot_vector(m, ntol, dtol):
    """
    Indicate whether a 3x3 matrix is a rotation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/isrot_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m     = A matrix to be tested.
      float[_]     ntol  = Tolerance for the norms of the columns of m.
      float[_]     dtol  = Tolerance for the determinant of a matrix whose
                           columns are the unitized columns of m.
    
    Returns:
      bool         value = True if and only if m is a rotation matrix.
    """
    return cs1.isrot_vector(m, ntol, dtol)

__copy_attributes_from(isrot, cs1.isrot)
__copy_attributes_from(isrot_vector, cs1.isrot_vector)

#########################
# iswhsp
#########################

def iswhsp(string):
    """
    Return a boolean value indicating whether a string contains only white
    space characters.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/iswhsp_c.html
    
    Inputs:
      string string = String to be tested.
    
    Returns:
      bool   flag   = True if the condition is satisfied; False otherwise.
    """
    return cs1.iswhsp(string)

__copy_attributes_from(iswhsp, cs1.iswhsp)

#########################
# j1900
#########################

def j1900():
    """
    Return the Julian Date of 1899 DEC 31 12:00:00 (1900 JAN 0.5).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j1900_c.html
    
    Inputs: none
    
    Returns:
      float jd = Julian Date of 1899 DEC 31 12:00:00 (1900 JAN 0.5).
    """
    return cs1.j1900()

__copy_attributes_from(j1900, cs1.j1900)

#########################
# j1950
#########################

def j1950():
    """
    Return the Julian Date of 1950 JAN 01 00:00:00 (1950 JAN 1.0).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j1950_c.html
    
    Inputs: none
    
    Returns:
      float jd = Julian Date of 1950 JAN 01 00:00:00 (1950 JAN 1.0).
    """
    return cs1.j1950()

__copy_attributes_from(j1950, cs1.j1950)

#########################
# j2000
#########################

def j2000():
    """
    Return the Julian Date of 2000 JAN 01 12:00:00 (2000 JAN 1.5).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j2000_c.html
    
    Inputs: none
    
    Returns:
      float jd = Julian Date of 2000 JAN 01 12:00:00 (2000 JAN 1.5).
    """
    return cs1.j2000()

__copy_attributes_from(j2000, cs1.j2000)

#########################
# j2100
#########################

def j2100():
    """
    Return the Julian Date of 2100 JAN 01 12:00:00 (2100 JAN 1.5).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/j2100_c.html
    
    Inputs: none
    
    Returns:
      float jd = Julian Date of 2100 JAN 01 12:00:00 (2100 JAN 1.5).
    """
    return cs1.j2100()

__copy_attributes_from(j2100, cs1.j2100)

#########################
# jyear
#########################

def jyear():
    """
    Return the number of seconds in a julian year.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/jyear_c.html
    
    Inputs: none
    
    Returns:
      float value = The number of seconds in a julian year.
    """
    return cs1.jyear()

__copy_attributes_from(jyear, cs1.jyear)

#########################
# kclear
#########################

def kclear():
    """
    Clear the KEEPER subsystem: unload all kernels, clear the kernel pool,
    and re-initialize the subsystem. Existing watches on kernel variables
    are retained.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/kclear_c.html
    
    Inputs: none
    
    Returns: none
    """
    return cs1.kclear()

__copy_attributes_from(kclear, cs1.kclear)

#########################
# kdata
#########################

def kdata(which = 0, kind = 'ALL'):
    """
    Return data for the nth kernel that is among a list of specified kernel
    types.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/kdata_c.html
    
    Inputs:
      int    which  = Index of kernel to fetch from the list of kernels.
      string kind   = The kind of kernel to which fetches are limited.
    
    Returns:
      string file   = The name of the kernel file.
      string filtyp = The type of the kernel, one of "SPK", "SK", "DSK",
                      "PCK", "EK", "TEXT", "META", or "ALL". Default is
                      "ALL". To get multiple kinds, join them inside a
                      string, separated by spaces.
      string srcfil = Name of the source file used to load `file'.
      int    handle = The handle attached to `file'.
      bool   found  = True if the specified file could be located.
    """
    return cs1.kdata(which, kind)

def kdata_error(which = 0, kind = 'ALL'):
    """
    Return data for the nth kernel that is among a list of specified kernel
    types.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/kdata_c.html
    
    Inputs:
      int    which  = Index of kernel to fetch from the list of kernels.
      string kind   = The kind of kernel to which fetches are limited.
    
    Returns:
      string file   = The name of the kernel file.
      string filtyp = The type of the kernel, one of "SPK", "SK", "DSK",
                      "PCK", "EK", "TEXT", "META", or "ALL". Default is
                      "ALL". To get multiple kinds, join them inside a
                      string, separated by spaces.
      string srcfil = Name of the source file used to load `file'.
      int    handle = The handle attached to `file'.
    
    Note: Raise IOError(FILENOTFOUND) if the specified file could be
    located.
    """
    return cs1.kdata_error(which, kind)

__copy_attributes_from(kdata, cs1.kdata)
__copy_attributes_from(kdata_error, cs1.kdata_error)

#########################
# kinfo
#########################

def kinfo(file):
    """
    Return information about a loaded kernel specified by name.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/kinfo_c.html
    
    Inputs:
      string file   = Name of a kernel to fetch information for
    
    Returns:
      string filtyp = The type of the kernel, one of "SPK", "SK", "DSK",
                      "PCK", "EK", "TEXT", "META", or "ALL".
      string srcfil = Name of the source file used to load `file'.
      int    handle = The handle attached to `file'.
      bool   found  = True if the specified file could be located.
    """
    return cs1.kinfo(file)

def kinfo_error(file):
    """
    Return information about a loaded kernel specified by name.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/kinfo_c.html
    
    Inputs:
      string file   = Name of a kernel to fetch information for
    
    Returns:
      string filtyp = The type of the kernel, one of "SPK", "SK", "DSK",
                      "PCK", "EK", "TEXT", "META", or "ALL".
      string srcfil = Name of the source file used to load `file'.
      int    handle = The handle attached to `file'.
    
    Note: Raise IOError(FILENOTFOUND) if the specified file could be
    located.
    """
    return cs1.kinfo_error(file)

__copy_attributes_from(kinfo, cs1.kinfo)
__copy_attributes_from(kinfo_error, cs1.kinfo_error)

#########################
# kplfrm
#########################

def kplfrm(frmcls, ids = 1000):
    """
    Return an array containing the frame IDs of all reference frames of a
    given class having specifications in the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/kplfrm_c.html
    
    Inputs:
      int frmcls = Frame class (-1 = all; 1 = built-in inertial; 2 = PCK-
                   based; 3 = CK-based; 4 = fixed rotational; 5 = dynamic).
      int ids    = Array of ID codes of frames of the specified class.
    
    Returns:
      int ids    = Array of ID codes of frames of the specified class.
    """
    return cs1.kplfrm(frmcls, ids)

__copy_attributes_from(kplfrm, cs1.kplfrm)

#########################
# ktotal
#########################

def ktotal(kind = 'ALL'):
    """
    Return the number of kernels of a specified type that are currently
    loaded via the furnsh_c interface.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ktotal_c.html
    
    Inputs:
      string kind  = The kind of kernels to count, one of "SPK", "SK",
                     "DSK", "PCK", "EK", "TEXT", "META", or "ALL". To count
                     multiple kinds, join them inside a string, separated by
                     spaces. Default is "ALL".
    
    Returns:
      int    count = The number of kernels of type `kind'.
    """
    return cs1.ktotal(kind)

__copy_attributes_from(ktotal, cs1.ktotal)

#########################
# kxtrct
#########################

def kxtrct(keywd, terms, wordsq):
    """
    Locate a keyword in a string and extract the substring from the
    beginning of the first word following the keyword to the beginning of
    the first subsequent recognized terminator of a list.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/kxtrct_c.html
    
    Inputs:
      string    keywd  = Word that marks the beginning of text of interest.
      string[*] terms  = Set of words, any of which marks the end of text.
      string    wordsq = String containing a sequence of words.
    
    Returns:
      string    wordsq = String containing a sequence of words.
      bool      found  = True if the keyword is found in the string.
      string    substr = String from end of `keywd' to beginning of first
                         `terms' item found.
    """
    return cs1.kxtrct(keywd, terms, wordsq)

__copy_attributes_from(kxtrct, cs1.kxtrct)

#########################
# latcyl
#########################

def latcyl(radius, lon, lat):
    """
    Convert from latitudinal coordinates to cylindrical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/latcyl_c.html
    
    Inputs:
      float radius = Distance of a point from the origin.
      float lon    = Angle of the point from the XZ plane in radians.
      float lat    = Angle of the point from the XY plane in radians.
    
    Returns:
      float r      = Distance of the point from the z axis.
      float lonc   = Angle of the point from the XZ plane in radians.
      float z      = Height of the point above the XY plane.
    """
    return cs1.latcyl(radius, lon, lat)

def latcyl_vector(radius, lon, lat):
    """
    Convert from latitudinal coordinates to cylindrical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/latcyl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] radius = Distance of a point from the origin.
      float[_] lon    = Angle of the point from the XZ plane in radians.
      float[_] lat    = Angle of the point from the XY plane in radians.
    
    Returns:
      float[_] r      = Distance of the point from the z axis.
      float[_] lonc   = Angle of the point from the XZ plane in radians.
      float[_] z      = Height of the point above the XY plane.
    """
    return cs1.latcyl_vector(radius, lon, lat)

__copy_attributes_from(latcyl, cs1.latcyl)
__copy_attributes_from(latcyl_vector, cs1.latcyl_vector)

#########################
# latrec
#########################

def latrec(radius, lon, lat):
    """
    Convert from latitudinal coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/latrec_c.html
    
    Inputs:
      float    radius = Distance of a point from the origin.
      float    lon    = Longitude of point in radians.
      float    lat    = Latitude of point in radians.
    
    Returns:
      float[3] rectan = Rectangular coordinates of the point.
    """
    return cs1.latrec(radius, lon, lat)

def latrec_vector(radius, lon, lat):
    """
    Convert from latitudinal coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/latrec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   radius = Distance of a point from the origin.
      float[_]   lon    = Longitude of point in radians.
      float[_]   lat    = Latitude of point in radians.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of the point.
    """
    return cs1.latrec_vector(radius, lon, lat)

__copy_attributes_from(latrec, cs1.latrec)
__copy_attributes_from(latrec_vector, cs1.latrec_vector)

#########################
# latsph
#########################

def latsph(radius, lon, lat):
    """
    Convert from latitudinal coordinates to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/latsph_c.html
    
    Inputs:
      float radius = Distance of a point from the origin.
      float lon    = Angle of the point from the XZ plane in radians.
      float lat    = Angle of the point from the XY plane in radians.
    
    Returns:
      float rho    = Distance of the point from the origin.
      float colat  = Angle of the point from positive z axis (radians).
      float lon2   = Angle of the point from the XZ plane (radians).
    """
    return cs1.latsph(radius, lon, lat)

def latsph_vector(radius, lon, lat):
    """
    Convert from latitudinal coordinates to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/latsph_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] radius = Distance of a point from the origin.
      float[_] lon    = Angle of the point from the XZ plane in radians.
      float[_] lat    = Angle of the point from the XY plane in radians.
    
    Returns:
      float[_] rho    = Distance of the point from the origin.
      float[_] colat  = Angle of the point from positive z axis (radians).
      float[_] lon2   = Angle of the point from the XZ plane (radians).
    """
    return cs1.latsph_vector(radius, lon, lat)

__copy_attributes_from(latsph, cs1.latsph)
__copy_attributes_from(latsph_vector, cs1.latsph_vector)

#########################
# latsrf
#########################

def latsrf(method, target, et, fixref, lonlat):
    """
    Map array of planetocentric longitude/latitude coordinate pairs to
    surface points on a specified target body.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/latsrf_c.html
    
    Inputs:
      string     method = Computation method: "ELLIPSOID" or
                          "DSK/UNPRIORITIZED[/SURFACES = <surface list>]".
      string     target = Name of target body.
      float      et     = Epoch in TDB seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      float[*,2] lonlat = Array of longitude/latitude coordinate pairs.
    
    Returns:
      float[*,3] srfpts = Array of surface points.
    """
    return cs1.latsrf(method, target, et, fixref, lonlat)

__copy_attributes_from(latsrf, cs1.latsrf)

#########################
# ldpool
#########################

def ldpool(filename):
    """
    Load the variables contained in a NAIF ASCII kernel file into the kernel
    pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ldpool_c.html
    
    Inputs:
      string filename = Name of the kernel file.
    
    Returns: none
    """
    return cs1.ldpool(filename)

__copy_attributes_from(ldpool, cs1.ldpool)

#########################
# lgresp
#########################

def lgresp(first, step, yvals, x):
    """
    Evaluate a Lagrange interpolating polynomial for a specified set of
    coordinate pairs whose first components are equally spaced, at a
    specified abscissa value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lgresp_c.html
    
    Inputs:
      float    first = First abscissa value.
      float    step  = Step size.
      float[*] yvals = Ordinate values.
      float    x     = Point at which to interpolate the polynomial.
    
    Returns:
      float    value = Value of Lagrange polynomial.
    """
    return cs1.lgresp(first, step, yvals, x)

def lgresp_vector(first, step, yvals, x):
    """
    Evaluate a Lagrange interpolating polynomial for a specified set of
    coordinate pairs whose first components are equally spaced, at a
    specified abscissa value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lgresp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   first = First abscissa value.
      float[_]   step  = Step size.
      float[_,*] yvals = Ordinate values.
      float[_]   x     = Point at which to interpolate the polynomial.
    
    Returns:
      float[_]   value = Value of Lagrange polynomial.
    """
    return cs1.lgresp_vector(first, step, yvals, x)

__copy_attributes_from(lgresp, cs1.lgresp)
__copy_attributes_from(lgresp_vector, cs1.lgresp_vector)

#########################
# lgrind
#########################

def lgrind(xvals, yvals, x):
    """
    Evaluate a Lagrange interpolating polynomial, for a specified set of
    coordinate pairs, at a specified abscissa value. Return both the value
    of the polynomial and its derivative.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lgrind_c.html
    
    Inputs:
      float[*] xvals = Abscissa values.
      float[*] yvals = Ordinate values.
      float    x     = Point at which to interpolate the polynomial.
    
    Returns:
      float    p     = Polynomial value at `x'.
      float    dp    = Polynomial derivative at `x'.
    """
    return cs1.lgrind(xvals, yvals, x)

def lgrind_vector(xvals, yvals, x):
    """
    Evaluate a Lagrange interpolating polynomial, for a specified set of
    coordinate pairs, at a specified abscissa value. Return both the value
    of the polynomial and its derivative.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lgrind_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] xvals = Abscissa values.
      float[_,*] yvals = Ordinate values.
      float[_]   x     = Point at which to interpolate the polynomial.
    
    Returns:
      float[_]   p     = Polynomial value at `x'.
      float[_]   dp    = Polynomial derivative at `x'.
    """
    return cs1.lgrind_vector(xvals, yvals, x)

__copy_attributes_from(lgrind, cs1.lgrind)
__copy_attributes_from(lgrind_vector, cs1.lgrind_vector)

#########################
# lgrint
#########################

def lgrint(xvals, yvals, x):
    """
    Evaluate a Lagrange interpolating polynomial for a specified set of
    coordinate pairs, at a specified abscissa value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lgrint_c.html
    
    Inputs:
      float[*] xvals = Abscissa values.
      float[*] yvals = Ordinate values.
      float    x     = Point at which to interpolate the polynomial.
    
    Returns:
      float    value = Value of Lagrange polynomial.
    """
    return cs1.lgrint(xvals, yvals, x)

def lgrint_vector(xvals, yvals, x):
    """
    Evaluate a Lagrange interpolating polynomial for a specified set of
    coordinate pairs, at a specified abscissa value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lgrint_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] xvals = Abscissa values.
      float[_,*] yvals = Ordinate values.
      float[_]   x     = Point at which to interpolate the polynomial.
    
    Returns:
      float[_]   value = Value of Lagrange polynomial.
    """
    return cs1.lgrint_vector(xvals, yvals, x)

__copy_attributes_from(lgrint, cs1.lgrint)
__copy_attributes_from(lgrint_vector, cs1.lgrint_vector)

#########################
# limbpt
#########################

def limbpt(method, target, et, fixref, abcorr, corloc, obsrvr, refvec, rolstp, ncuts, schstp, soltol, maxn):
    """
    Find limb points on a target body. The limb is the set of points of
    tangency on the target of rays emanating from the observer. The caller
    specifies half-planes bounded by the observer-target center vector in
    which to search for limb points.
    
    The surface of the target body may be represented either by a triaxial
    ellipsoid or by topographic data.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/limbpt_c.html
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float      et     = Epoch in ephemeris seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     corloc = Aberration correction locus.
      string     obsrvr = Name of observing body.
      float[3]   refvec = Reference vector for cutting half-planes.
      float      rolstp = Roll angular step for cutting half-planes.
      int        ncuts  = Number of cutting half-planes.
      float      schstp = Angular step size for searching.
      float      soltol = Solution convergence tolerance.
      int        maxn   = Maximum number of entries in output arrays.
    
    Returns:
      int[*]     npts   = Counts of limb points corresponding to cuts.
      float[*,3] points = Limb points.
      float[*]   epochs = Times associated with limb points.
      float[*,3] tangts = Tangent vectors emanating from the observer.
    """
    return cs1.limbpt(method, target, et, fixref, abcorr, corloc, obsrvr, refvec, rolstp, ncuts, schstp, soltol, maxn)

__copy_attributes_from(limbpt, cs1.limbpt)

#########################
# lmpool
#########################

def lmpool(cvals):
    """
    Load the variables contained in an internal buffer into the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lmpool_c.html
    
    Inputs:
      string[*] cvals = An array that contains a SPICE text kernel.
    
    Returns: none
    """
    return cs1.lmpool(cvals)

__copy_attributes_from(lmpool, cs1.lmpool)

#########################
# lparse
#########################

def lparse(list, delim):
    """
    Parse a list of items delimited by a single character.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lparse_c.html
    
    Inputs:
      string    list  = List of items delimited by delim.
      string    delim = Single character used to delimit items.
    
    Returns:
      string[*] items = Items in the list, left justified.
    """
    return cs1.lparse(list, delim)

__copy_attributes_from(lparse, cs1.lparse)

#########################
# lparsm
#########################

def lparsm(list, delims):
    """
    Parse a list of items separated by multiple delimiters.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lparsm_c.html
    
    Inputs:
      string    list   = List of items delimited by delims.
      string    delims = Single characters which delimit items.
    
    Returns:
      string[*] items  = Items in the list, left justified.
    """
    return cs1.lparsm(list, delims)

__copy_attributes_from(lparsm, cs1.lparsm)

#########################
# lspcn
#########################

def lspcn(body, et, abcorr):
    """
    Compute L_s, the planetocentric longitude of the sun, as seen from a
    specified body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lspcn_c.html
    
    Inputs:
      string body   = Name of central body.
      float  et     = Epoch in seconds past J2000 TDB.
      string abcorr = Aberration correction, "NONE", "LT", or "LT+S".
    
    Returns:
      float  value  = The value of L_s for the specified body at the
                      specified time.
    """
    return cs1.lspcn(body, et, abcorr)

def lspcn_vector(body, et, abcorr):
    """
    Compute L_s, the planetocentric longitude of the sun, as seen from a
    specified body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lspcn_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string   body   = Name of central body.
      float[_] et     = Epoch in seconds past J2000 TDB.
      string   abcorr = Aberration correction, "NONE", "LT", or "LT+S".
    
    Returns:
      float[_] value  = The value of L_s for the specified body at the
                        specified time.
    """
    return cs1.lspcn_vector(body, et, abcorr)

__copy_attributes_from(lspcn, cs1.lspcn)
__copy_attributes_from(lspcn_vector, cs1.lspcn_vector)

#########################
# lstlec
#########################

def lstlec(string, array):
    """
    Find the index of the largest array element less than or equal to a
    given character string in an ordered array of character strings.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lstlec_c.html
    
    Inputs:
      string    string = Upper bound value to search against.
      string[*] array  = Array of possible lower bounds.
    
    Returns:
      int       index  = Index of element in array.
    """
    return cs1.lstlec(string, array)

__copy_attributes_from(lstlec, cs1.lstlec)

#########################
# lstled
#########################

def lstled(x, array):
    """
    Find the index of the largest array element less than or equal to a
    given number `x' in an array of non-decreasing numbers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lstled_c.html
    
    Inputs:
      float    x     = Upper bound value to search against.
      float[*] array = Array of possible lower bounds.
    
    Returns:
      int      index = Index of element in array.
    """
    return cs1.lstled(x, array)

__copy_attributes_from(lstled, cs1.lstled)

#########################
# lstlei
#########################

def lstlei(x, array):
    """
    Find the index of the largest array element less than or equal to a
    given integer `x' in an array of non-decreasing integers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lstlei_c.html
    
    Inputs:
      int    x     = Upper bound value to search against.
      int[*] array = Array of possible lower bounds.
    
    Returns:
      int    index = Index of element in array.
    """
    return cs1.lstlei(x, array)

__copy_attributes_from(lstlei, cs1.lstlei)

#########################
# lstltc
#########################

def lstltc(string, array):
    """
    Find the index of the largest array element less than a given character
    string in an ordered array of character strings.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lstltc_c.html
    
    Inputs:
      string    string = Upper bound value to search against.
      string[*] array  = Array of possible lower bounds.
    
    Returns:
      int       index  = Index of element in array.
    """
    return cs1.lstltc(string, array)

__copy_attributes_from(lstltc, cs1.lstltc)

#########################
# lstltd
#########################

def lstltd(x, array):
    """
    Find the index of the largest array element less than a given number `x'
    in an array of non-decreasing numbers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lstltd_c.html
    
    Inputs:
      float    x     = Upper bound value to search against.
      float[*] array = Array of possible lower bounds.
    
    Returns:
      int      index = Index of element in array.
    """
    return cs1.lstltd(x, array)

__copy_attributes_from(lstltd, cs1.lstltd)

#########################
# lstlti
#########################

def lstlti(x, array):
    """
    Find the index of the largest array element less than a given integer
    `x' in an array of non-decreasing integers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lstlti_c.html
    
    Inputs:
      int    x     = Upper bound value to search against.
      int[*] array = Array of possible lower bounds.
    
    Returns:
      int    index = Index of element in array.
    """
    return cs1.lstlti(x, array)

__copy_attributes_from(lstlti, cs1.lstlti)

#########################
# ltime
#########################

def ltime(etobs, obs, dir, targ):
    """
    Compute the transmission (or reception) time of a signal at a specified
    target, given the reception (or transmission) time at a specified
    observer. Also return the elapsed time between transmission and
    reception.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ltime_c.html
    
    Inputs:
      float  etobs  = Epoch of a signal at some observer.
      int    obs    = NAIF ID of some observer.
      string dir    = Direction the signal travels ("->" or "<-").
      int    targ   = NAIF ID of the target object.
    
    Returns:
      float  ettarg = Epoch of the signal at the target.
      float  elapsd = Time between transmit and receipt of the signal.
    """
    return cs1.ltime(etobs, obs, dir, targ)

def ltime_vector(etobs, obs, dir, targ):
    """
    Compute the transmission (or reception) time of a signal at a specified
    target, given the reception (or transmission) time at a specified
    observer. Also return the elapsed time between transmission and
    reception.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ltime_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] etobs  = Epoch of a signal at some observer.
      int      obs    = NAIF ID of some observer.
      string   dir    = Direction the signal travels ("->" or "<-").
      int      targ   = NAIF ID of the target object.
    
    Returns:
      float[_] ettarg = Epoch of the signal at the target.
      float[_] elapsd = Time between transmit and receipt of the signal.
    """
    return cs1.ltime_vector(etobs, obs, dir, targ)

__copy_attributes_from(ltime, cs1.ltime)
__copy_attributes_from(ltime_vector, cs1.ltime_vector)

#########################
# lx4dec
#########################

def lx4dec(string, first):
    """
    Scan a string from a specified starting position for the end of a
    decimal number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lx4dec_c.html
    
    Inputs:
      string string = Any character string.
      int    first  = First character to scan from in string.
    
    Returns:
      int    last   = Last character that is part of a decimal number.
      int    nchar  = Number of characters in the decimal number.
    """
    return cs1.lx4dec(string, first)

__copy_attributes_from(lx4dec, cs1.lx4dec)

#########################
# lx4num
#########################

def lx4num(string, first):
    """
    Scan a string from a specified starting position for the end of a
    number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lx4num_c.html
    
    Inputs:
      string string = Any character string.
      int    first  = First character to scan from in string.
    
    Returns:
      int    last   = Last character that is part of a number.
      int    nchar  = Number of characters in the number.
    """
    return cs1.lx4num(string, first)

__copy_attributes_from(lx4num, cs1.lx4num)

#########################
# lx4sgn
#########################

def lx4sgn(string, first):
    """
    Scan a string from a specified starting position for the end of a signed
    integer.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lx4sgn_c.html
    
    Inputs:
      string string = Any character string.
      int    first  = First character to scan from in string.
    
    Returns:
      int    last   = Last character that is part of a signed integer.
      int    nchar  = Number of characters in the signed integer.
    """
    return cs1.lx4sgn(string, first)

__copy_attributes_from(lx4sgn, cs1.lx4sgn)

#########################
# lx4uns
#########################

def lx4uns(string, first):
    """
    Scan a string from a specified starting position for the end of an
    unsigned integer.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lx4uns_c.html
    
    Inputs:
      string string = Any character string.
      int    first  = First character to scan from in string.
    
    Returns:
      int    last   = Last character that is part of an unsigned integer.
      int    nchar  = Number of characters in the unsigned integer.
    """
    return cs1.lx4uns(string, first)

__copy_attributes_from(lx4uns, cs1.lx4uns)

#########################
# lxqstr
#########################

def lxqstr(string, qchar, first):
    """
    Scan (lex) a quoted string.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/lxqstr_c.html
    
    Inputs:
      string string = String to be scanned.
      string qchar  = Quote delimiter character.
      int    first  = Character position at which to start scanning.
    
    Returns:
      int    last   = Character position of end of token.
      int    nchar  = Number of characters in token.
    """
    return cs1.lxqstr(string, qchar, first)

__copy_attributes_from(lxqstr, cs1.lxqstr)

#########################
# m2eul
#########################

def m2eul(r, axis3, axis2, axis1):
    """
    Factor a rotation matrix as a product of three rotations about specified
    coordinate axes.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/m2eul_c.html
    
    Inputs:
      float[3,3] r      = A rotation matrix to be factored.
      int        axis3  = Number of the third rotation axis.
      int        axis2  = Number of the second rotation axis.
      int        axis1  = Number of the first rotation axis.
    
    Returns:
      float      angle3 = Third Euler angle, in radians.
      float      angle2 = Second Euler angle, in radians.
      float      angle1 = First Euler angle, in radians.
    """
    return cs1.m2eul(r, axis3, axis2, axis1)

def m2eul_vector(r, axis3, axis2, axis1):
    """
    Factor a rotation matrix as a product of three rotations about specified
    coordinate axes.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/m2eul_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] r      = A rotation matrix to be factored.
      int          axis3  = Number of the third rotation axis.
      int          axis2  = Number of the second rotation axis.
      int          axis1  = Number of the first rotation axis.
    
    Returns:
      float[_]     angle3 = Third Euler angle, in radians.
      float[_]     angle2 = Second Euler angle, in radians.
      float[_]     angle1 = First Euler angle, in radians.
    """
    return cs1.m2eul_vector(r, axis3, axis2, axis1)

__copy_attributes_from(m2eul, cs1.m2eul)
__copy_attributes_from(m2eul_vector, cs1.m2eul_vector)

#########################
# m2q
#########################

def m2q(r):
    """
    Find a unit quaternion corresponding to a specified rotation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/m2q_c.html
    
    Inputs:
      float[3,3] r = A rotation matrix.
    
    Returns:
      float[4]   q = A unit quaternion representing r.
    """
    return cs1.m2q(r)

def m2q_vector(r):
    """
    Find a unit quaternion corresponding to a specified rotation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/m2q_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] r = A rotation matrix.
    
    Returns:
      float[_,4]   q = A unit quaternion representing r.
    """
    return cs1.m2q_vector(r)

__copy_attributes_from(m2q, cs1.m2q)
__copy_attributes_from(m2q_vector, cs1.m2q_vector)

#########################
# matchi
#########################

def matchi(string, templ, wstr, wchr):
    """
    Determine whether a string is matched by a template containing wild
    cards. The pattern comparison is case-insensitive.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/matchi_c.html
    
    Inputs:
      string string = String to be tested.
      string templ  = Template (with wild cards) to test against string.
      string wstr   = Wild string token.
      string wchr   = Wild character token.
    
    Returns:
      bool   flag   = True if the string matches; False otherwise.
    """
    return cs1.matchi(string, templ, wstr, wchr)

__copy_attributes_from(matchi, cs1.matchi)

#########################
# matchw
#########################

def matchw(string, templ, wstr, wchr):
    """
    Determine whether a string is matched by a template containing wild
    cards. The comparison is case-sensitive.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/matchw_c.html
    
    Inputs:
      string string = String to be tested.
      string templ  = Template (with wild cards) to test against string.
      string wstr   = Wild string token.
      string wchr   = Wild character token.
    
    Returns:
      bool   flag   = True if the string matches; False otherwise.
    """
    return cs1.matchw(string, templ, wstr, wchr)

__copy_attributes_from(matchw, cs1.matchw)

#########################
# mequ
#########################

def mequ(m1):
    """
    Set one 3x3 matrix equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mequ_c.html
    
    Inputs:
      float[3,3] m1     = Input matrix.
    
    Returns:
      float[3,3] matrix = Output matrix equal to m1.
    """
    return cs1.mequ(m1)

def mequ_vector(m1):
    """
    Set one 3x3 matrix equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mequ_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = Input matrix.
    
    Returns:
      float[_,3,3] matrix = Output matrix equal to m1.
    """
    return cs1.mequ_vector(m1)

__copy_attributes_from(mequ, cs1.mequ)
__copy_attributes_from(mequ_vector, cs1.mequ_vector)

#########################
# mequg
#########################

def mequg(m1):
    """
    Set one matrix of arbitrary size equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mequg_c.html
    
    Inputs:
      float[*,*] m1     = Input matrix.
    
    Returns:
      float[*,*] matrix = Output matrix equal to m1.
    """
    return cs1.mequg(m1)

def mequg_vector(m1):
    """
    Set one matrix of arbitrary size equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mequg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*,*] m1     = Input matrix.
    
    Returns:
      float[_,*,*] matrix = Output matrix equal to m1.
    """
    return cs1.mequg_vector(m1)

__copy_attributes_from(mequg, cs1.mequg)
__copy_attributes_from(mequg_vector, cs1.mequg_vector)

#########################
# mtxm
#########################

def mtxm(m1, m2):
    """
    Multiply the transpose of a 3x3 matrix and a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxm_c.html
    
    Inputs:
      float[3,3] m1 = 3x3 matrix.
      float[3,3] m2 = 3x3 matrix.
    
    Returns:
      float[3,3] m3 = The product m1 transpose times m2.
    """
    return cs1.mtxm(m1, m2)

def mtxm_vector(m1, m2):
    """
    Multiply the transpose of a 3x3 matrix and a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1 = 3x3 matrix.
      float[_,3,3] m2 = 3x3 matrix.
    
    Returns:
      float[_,3,3] m3 = The product m1 transpose times m2.
    """
    return cs1.mtxm_vector(m1, m2)

__copy_attributes_from(mtxm, cs1.mtxm)
__copy_attributes_from(mtxm_vector, cs1.mtxm_vector)

#########################
# mtxmg
#########################

def mtxmg(m1, m2):
    """
    Multiply the transpose of a matrix with another matrix, both of
    arbitrary size. (The dimensions of the matrices must be compatible with
    this multiplication.)
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxmg_c.html
    
    Inputs:
      float[*,*] m1 = First input matrix.
      float[*,*] m2 = Second input matrix.
    
    Returns:
      float[*,*] m3 = Transpose of m1 times m2.
    """
    return cs1.mtxmg(m1, m2)

def mtxmg_vector(m1, m2):
    """
    Multiply the transpose of a matrix with another matrix, both of
    arbitrary size. (The dimensions of the matrices must be compatible with
    this multiplication.)
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxmg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*,*] m1 = First input matrix.
      float[_,*,*] m2 = Second input matrix.
    
    Returns:
      float[_,*,*] m3 = Transpose of m1 times m2.
    """
    return cs1.mtxmg_vector(m1, m2)

__copy_attributes_from(mtxmg, cs1.mtxmg)
__copy_attributes_from(mtxmg_vector, cs1.mtxmg_vector)

#########################
# mtxv
#########################

def mtxv(m1, v1):
    """
    Multiply the transpose of a 3x3 matrix on the left with a vector on the
    right.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxv_c.html
    
    Inputs:
      float[3,3] m1     = 3x3 matrix.
      float[3]   v1     = 3-dimensional vector.
    
    Returns:
      float[3]   vector = The product m1**t * v.
    """
    return cs1.mtxv(m1, v1)

def mtxv_vector(m1, v1):
    """
    Multiply the transpose of a 3x3 matrix on the left with a vector on the
    right.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = 3x3 matrix.
      float[_,3]   v1     = 3-dimensional vector.
    
    Returns:
      float[_,3]   vector = The product m1**t * v.
    """
    return cs1.mtxv_vector(m1, v1)

__copy_attributes_from(mtxv, cs1.mtxv)
__copy_attributes_from(mtxv_vector, cs1.mtxv_vector)

#########################
# mtxvg
#########################

def mtxvg(m1, v2):
    """
    Multiply the transpose of a matrix and a vector of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxvg_c.html
    
    Inputs:
      float[*,*] m1 = Left-hand matrix to be multiplied.
      float[*]   v2 = Right-hand vector to be multiplied.
    
    Returns:
      float      v3 = Product vector m1 transpose * v2.
    """
    return cs1.mtxvg(m1, v2)

def mtxvg_vector(m1, v2):
    """
    Multiply the transpose of a matrix and a vector of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mtxvg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*,*] m1 = Left-hand matrix to be multiplied.
      float[_,*]   v2 = Right-hand vector to be multiplied.
    
    Returns:
      float[_]     v3 = Product vector m1 transpose * v2.
    """
    return cs1.mtxvg_vector(m1, v2)

__copy_attributes_from(mtxvg, cs1.mtxvg)
__copy_attributes_from(mtxvg_vector, cs1.mtxvg_vector)

#########################
# mxm
#########################

def mxm(m1, m2):
    """
    Multiply two 3x3 matrices.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxm_c.html
    
    Inputs:
      float[3,3] m1     = 3x3 matrix.
      float[3,3] m2     = 3x3 matrix.
    
    Returns:
      float[3,3] matrix = 3x3 product m1*m2.
    """
    return cs1.mxm(m1, m2)

def mxm_vector(m1, m2):
    """
    Multiply two 3x3 matrices.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = 3x3 matrix.
      float[_,3,3] m2     = 3x3 matrix.
    
    Returns:
      float[_,3,3] matrix = 3x3 product m1*m2.
    """
    return cs1.mxm_vector(m1, m2)

__copy_attributes_from(mxm, cs1.mxm)
__copy_attributes_from(mxm_vector, cs1.mxm_vector)

#########################
# mxmg
#########################

def mxmg(m1, m2):
    """
    Multiply two matrices of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxmg_c.html
    
    Inputs:
      float[*,*] m1 = First matrix.
      float[*,*] m2 = Second matrix.
    
    Returns:
      float[*,*] m3 = The product m1 times m2.
    """
    return cs1.mxmg(m1, m2)

def mxmg_vector(m1, m2):
    """
    Multiply two matrices of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxmg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*,*] m1 = First matrix.
      float[_,*,*] m2 = Second matrix.
    
    Returns:
      float[_,*,*] m3 = The product m1 times m2.
    """
    return cs1.mxmg_vector(m1, m2)

__copy_attributes_from(mxmg, cs1.mxmg)
__copy_attributes_from(mxmg_vector, cs1.mxmg_vector)

#########################
# mxmt
#########################

def mxmt(m1, m2):
    """
    Multiply a 3x3 matrix and the transpose of another 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxmt_c.html
    
    Inputs:
      float[3,3] m1 = 3x3 matrix.
      float[3,3] m2 = 3x3 matrix.
    
    Returns:
      float[3,3] m3 = The product m1 times m2 transpose.
    """
    return cs1.mxmt(m1, m2)

def mxmt_vector(m1, m2):
    """
    Multiply a 3x3 matrix and the transpose of another 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxmt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1 = 3x3 matrix.
      float[_,3,3] m2 = 3x3 matrix.
    
    Returns:
      float[_,3,3] m3 = The product m1 times m2 transpose.
    """
    return cs1.mxmt_vector(m1, m2)

__copy_attributes_from(mxmt, cs1.mxmt)
__copy_attributes_from(mxmt_vector, cs1.mxmt_vector)

#########################
# mxmtg
#########################

def mxmtg(m1, m2):
    """
    Multiply a matrix and the transpose of a matrix, both of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxmtg_c.html
    
    Inputs:
      float[*,*] m1 = Left-hand matrix to be multiplied.
      float[*,*] m2 = Right-hand matrix whose transpose is to be multiplied
    
    Returns:
      float[*,*] m3 = Product matrix.
    """
    return cs1.mxmtg(m1, m2)

def mxmtg_vector(m1, m2):
    """
    Multiply a matrix and the transpose of a matrix, both of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxmtg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*,*] m1 = Left-hand matrix to be multiplied.
      float[_,*,*] m2 = Right-hand matrix whose transpose is to be
                        multiplied
    
    Returns:
      float[_,*,*] m3 = Product matrix.
    """
    return cs1.mxmtg_vector(m1, m2)

__copy_attributes_from(mxmtg, cs1.mxmtg)
__copy_attributes_from(mxmtg_vector, cs1.mxmtg_vector)

#########################
# mxv
#########################

def mxv(m1, v1):
    """
    Multiply a 3x3 matrix with a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxv_c.html
    
    Inputs:
      float[3,3] m1     = 3x3 matrix.
      float[3]   v1     = 3-dimensional vector.
    
    Returns:
      float[3]   vector = The product m1*vin.
    """
    return cs1.mxv(m1, v1)

def mxv_vector(m1, v1):
    """
    Multiply a 3x3 matrix with a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = 3x3 matrix.
      float[_,3]   v1     = 3-dimensional vector.
    
    Returns:
      float[_,3]   vector = The product m1*vin.
    """
    return cs1.mxv_vector(m1, v1)

__copy_attributes_from(mxv, cs1.mxv)
__copy_attributes_from(mxv_vector, cs1.mxv_vector)

#########################
# mxvg
#########################

def mxvg(m1, v2):
    """
    Multiply a matrix and a vector of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxvg_c.html
    
    Inputs:
      float[*,*] m1 = Left-hand matrix to be multiplied.
      float[*]   v2 = Right-hand vector to be multiplied.
    
    Returns:
      float      v3 = Product vector m1*v2.
    """
    return cs1.mxvg(m1, v2)

def mxvg_vector(m1, v2):
    """
    Multiply a matrix and a vector of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/mxvg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*,*] m1 = Left-hand matrix to be multiplied.
      float[_,*]   v2 = Right-hand vector to be multiplied.
    
    Returns:
      float[_]     v3 = Product vector m1*v2.
    """
    return cs1.mxvg_vector(m1, v2)

__copy_attributes_from(mxvg, cs1.mxvg)
__copy_attributes_from(mxvg_vector, cs1.mxvg_vector)

#########################
# namfrm
#########################

def namfrm(frname):
    """
    Look up the frame ID code associated with a string.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/namfrm_c.html
    
    Inputs:
      string frname = The name of some reference frame.
    
    Returns:
      int    frcode = The SPICE ID code of the frame.
    """
    return cs1.namfrm(frname)

def namfrm_error(frname):
    """
    Look up the frame ID code associated with a string.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/namfrm_c.html
    
    Inputs:
      string frname = The name of some reference frame.
    
    Returns:
      int    frcode = The SPICE ID code of the frame.
    
    Note: Raise KeyError(FRAMENAMENOTFOUND) if the frame name is not
    recognized.
    """
    return cs1.namfrm_error(frname)

__copy_attributes_from(namfrm, cs1.namfrm)
__copy_attributes_from(namfrm_error, cs1.namfrm_error)

#########################
# ncpos
#########################

def ncpos(str, chars, start):
    """
    Find the first occurrence in a string of a character NOT belonging to a
    collection of characters, starting at a specified location, searching
    forward.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ncpos_c.html
    
    Inputs:
      string str   = Any character string.
      string chars = A collection of characters.
      int    start = Position to begin looking for one not in chars.
    
    Returns:
      int    index = Index of character in string.
    """
    return cs1.ncpos(str, chars, start)

__copy_attributes_from(ncpos, cs1.ncpos)

#########################
# ncposr
#########################

def ncposr(str, chars, start):
    """
    Find the first occurrence in a string of a character NOT belonging to a
    collection of characters, starting at a specified location, searching in
    reverse.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ncposr_c.html
    
    Inputs:
      string str   = Any character string.
      string chars = A collection of characters.
      int    start = Position to begin looking for one of chars.
    
    Returns:
      int    index = Index of character in string.
    """
    return cs1.ncposr(str, chars, start)

__copy_attributes_from(ncposr, cs1.ncposr)

#########################
# nearpt
#########################

def nearpt(positn, a, b, c):
    """
    This routine locates the point on the surface of an ellipsoid that is
    nearest to a specified position. It also returns the altitude of the
    position above the ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nearpt_c.html
    
    Inputs:
      float[3] positn = Position of a point in bodyfixed frame.
      float    a      = Length of semi-axis parallel to x-axis.
      float    b      = Length of semi-axis parallel to y-axis.
      float    c      = Length on semi-axis parallel to z-axis.
    
    Returns:
      float[3] npoint = Point on the ellipsoid closest to positn.
      float    alt    = Altitude of positn above the ellipsoid.
    """
    return cs1.nearpt(positn, a, b, c)

def nearpt_vector(positn, a, b, c):
    """
    This routine locates the point on the surface of an ellipsoid that is
    nearest to a specified position. It also returns the altitude of the
    position above the ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nearpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] positn = Position of a point in bodyfixed frame.
      float[_]   a      = Length of semi-axis parallel to x-axis.
      float[_]   b      = Length of semi-axis parallel to y-axis.
      float[_]   c      = Length on semi-axis parallel to z-axis.
    
    Returns:
      float[_,3] npoint = Point on the ellipsoid closest to positn.
      float[_]   alt    = Altitude of positn above the ellipsoid.
    """
    return cs1.nearpt_vector(positn, a, b, c)

__copy_attributes_from(nearpt, cs1.nearpt)
__copy_attributes_from(nearpt_vector, cs1.nearpt_vector)

#########################
# nextwd
#########################

def nextwd(string):
    """
    Return the next word in a given character string, and left justify the
    rest of the string.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nextwd_c.html
    
    Inputs:
      string string = Input character string.
    
    Returns:
      string next   = The next word in the string.
      string rest   = The remaining part of `string', left-justified.
    """
    return cs1.nextwd(string)

__copy_attributes_from(nextwd, cs1.nextwd)

#########################
# npedln
#########################

def npedln(a, b, c, linept, linedr):
    """
    Find nearest point on a triaxial ellipsoid to a specified line, and the
    distance from the ellipsoid to the line.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/npedln_c.html
    
    Inputs:
      float    a      = Length of ellipsoid's semi-axis in the x direction.
      float    b      = Length of ellipsoid's semi-axis in the y direction.
      float    c      = Length of ellipsoid's semi-axis in the z direction.
      float[3] linept = Point on line.
      float[3] linedr = Direction vector of line.
    
    Returns:
      float[3] pnear  = Nearest point on ellipsoid to line.
      float    dist   = Distance of ellipsoid from line.
    """
    return cs1.npedln(a, b, c, linept, linedr)

def npedln_vector(a, b, c, linept, linedr):
    """
    Find nearest point on a triaxial ellipsoid to a specified line, and the
    distance from the ellipsoid to the line.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/npedln_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   a      = Length of ellipsoid's semi-axis in the x
                          direction.
      float[_]   b      = Length of ellipsoid's semi-axis in the y
                          direction.
      float[_]   c      = Length of ellipsoid's semi-axis in the z
                          direction.
      float[_,3] linept = Point on line.
      float[_,3] linedr = Direction vector of line.
    
    Returns:
      float[_,3] pnear  = Nearest point on ellipsoid to line.
      float[_]   dist   = Distance of ellipsoid from line.
    """
    return cs1.npedln_vector(a, b, c, linept, linedr)

__copy_attributes_from(npedln, cs1.npedln)
__copy_attributes_from(npedln_vector, cs1.npedln_vector)

#########################
# npelpt
#########################

def npelpt(point, ellips):
    """
    Find the nearest point on an ellipse to a specified point, both in
    three-dimensional space, and find the distance between the ellipse and
    the point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/npelpt_c.html
    
    Inputs:
      float[3]             point  = Point whose distance to an ellipse is to
                                    be found.
      ConstSpiceEllipse[*] ellips = A CSPICE ellipse.
    
    Returns:
      float[3]             pnear  = Nearest point on ellipse to input point.
      float                dist   = Distance of input point to ellipse.
    """
    return cs1.npelpt(point, ellips)

def npelpt_vector(point, ellips):
    """
    Find the nearest point on an ellipse to a specified point, both in
    three-dimensional space, and find the distance between the ellipse and
    the point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/npelpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]           point  = Point whose distance to an ellipse is to
                                    be found.
      ConstSpiceEllipse[*] ellips = A CSPICE ellipse.
    
    Returns:
      float[_,3]           pnear  = Nearest point on ellipse to input point.
      float[_]             dist   = Distance of input point to ellipse.
    """
    return cs1.npelpt_vector(point, ellips)

__copy_attributes_from(npelpt, cs1.npelpt)
__copy_attributes_from(npelpt_vector, cs1.npelpt_vector)

#########################
# nplnpt
#########################

def nplnpt(linpt, lindir, point):
    """
    Find the nearest point on a line to a specified point, and find the
    distance between the two points.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nplnpt_c.html
    
    Inputs:
      float[3] linpt  = Point on a line.
      float[3] lindir = The line's direction vector.
      float[3] point  = A second point.
    
    Returns:
      float[3] pnear  = Nearest point on the line to point.
      float    dist   = Distance between point and pnear.
    """
    return cs1.nplnpt(linpt, lindir, point)

def nplnpt_vector(linpt, lindir, point):
    """
    Find the nearest point on a line to a specified point, and find the
    distance between the two points.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nplnpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] linpt  = Point on a line.
      float[_,3] lindir = The line's direction vector.
      float[_,3] point  = A second point.
    
    Returns:
      float[_,3] pnear  = Nearest point on the line to point.
      float[_]   dist   = Distance between point and pnear.
    """
    return cs1.nplnpt_vector(linpt, lindir, point)

__copy_attributes_from(nplnpt, cs1.nplnpt)
__copy_attributes_from(nplnpt_vector, cs1.nplnpt_vector)

#########################
# nthwd
#########################

def nthwd(string, nth):
    """
    Return the nth word in a character string, and its location in the
    string.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nthwd_c.html
    
    Inputs:
      string string = Input character string.
      int    nth    = Index of the word to be returned.
    
    Returns:
      string word   = The `nth' word in `string'.
      int    loc    = Location of `word' in `string'.
    """
    return cs1.nthwd(string, nth)

__copy_attributes_from(nthwd, cs1.nthwd)

#########################
# nvc2pl
#########################

def nvc2pl(normal, constant):
    """
    Make a CSPICE plane from a normal vector and a constant.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nvc2pl_c.html
    
    Inputs:
      float[3]   normal   = A normal vector defining a plane.
      float      constant = A constant defining a plane.
    
    Returns:
      SpicePlane plane    = A CSPICE plane structure representing the plane.
    """
    return cs1.nvc2pl(normal, constant)

def nvc2pl_vector(normal, constant):
    """
    Make a CSPICE plane from a normal vector and a constant.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nvc2pl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] normal   = A normal vector defining a plane.
      float[_]   constant = A constant defining a plane.
    
    Returns:
      SpicePlane plane    = A CSPICE plane structure representing the plane.
    """
    return cs1.nvc2pl_vector(normal, constant)

__copy_attributes_from(nvc2pl, cs1.nvc2pl)
__copy_attributes_from(nvc2pl_vector, cs1.nvc2pl_vector)

#########################
# nvp2pl
#########################

def nvp2pl(normal, point):
    """
    Make a CSPICE plane from a normal vector and a point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nvp2pl_c.html
    
    Inputs:
      float[3]   normal = A normal vector defining a plane.
      float[3]   point  = A point on the plane.
    
    Returns:
      SpicePlane plane  = A CSPICE plane structure representing the plane.
    """
    return cs1.nvp2pl(normal, point)

def nvp2pl_vector(normal, point):
    """
    Make a CSPICE plane from a normal vector and a point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/nvp2pl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] normal = A normal vector defining a plane.
      float[_,3] point  = A point on the plane.
    
    Returns:
      SpicePlane plane  = A CSPICE plane structure representing the plane.
    """
    return cs1.nvp2pl_vector(normal, point)

__copy_attributes_from(nvp2pl, cs1.nvp2pl)
__copy_attributes_from(nvp2pl_vector, cs1.nvp2pl_vector)

#########################
# occult
#########################

def occult(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, et):
    """
    Determines the occultation condition (not occulted, partially, etc.) of
    one target relative to another target as seen by an observer at a given
    time.
    
    The surfaces of the target bodies may be represented by triaxial
    ellipsoids or by topographic data provided by DSK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/occult_c.html
    
    Inputs:
      string targ1  = Name or ID of first target.
      string shape1 = Type of shape model used for first target.
      string frame1 = Body-fixed, body-centered frame for first body.
      string targ2  = Name or ID of second target.
      string shape2 = Type of shape model used for second target.
      string frame2 = Body-fixed, body-centered frame for second body.
      string abcorr = Aberration correction, "NONE", "LT", "CN", "XLT", or
                      "XCN".
      string obsrvr = Name or ID of the observer.
      float  et     = Time of the observation (seconds past J2000).
    
    Returns:
      int    ocltid = Occultation identification code.
    """
    return cs1.occult(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, et)

def occult_vector(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, et):
    """
    Determines the occultation condition (not occulted, partially, etc.) of
    one target relative to another target as seen by an observer at a given
    time.
    
    The surfaces of the target bodies may be represented by triaxial
    ellipsoids or by topographic data provided by DSK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/occult_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string   targ1  = Name or ID of first target.
      string   shape1 = Type of shape model used for first target.
      string   frame1 = Body-fixed, body-centered frame for first body.
      string   targ2  = Name or ID of second target.
      string   shape2 = Type of shape model used for second target.
      string   frame2 = Body-fixed, body-centered frame for second body.
      string   abcorr = Aberration correction, "NONE", "LT", "CN", "XLT", or
                        "XCN".
      string   obsrvr = Name or ID of the observer.
      float[_] et     = Time of the observation (seconds past J2000).
    
    Returns:
      int      ocltid = Occultation identification code.
    """
    return cs1.occult_vector(targ1, shape1, frame1, targ2, shape2, frame2, abcorr, obsrvr, et)

__copy_attributes_from(occult, cs1.occult)
__copy_attributes_from(occult_vector, cs1.occult_vector)

#########################
# orderc
#########################

def orderc(array):
    """
    Determine the order of elements in an array of character strings.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/orderc_c.html
    
    Inputs:
      string[*] array  = Input array.
    
    Returns:
      int       iorder = Order vector for array.
    """
    return cs1.orderc(array)

__copy_attributes_from(orderc, cs1.orderc)

#########################
# orderd
#########################

def orderd(array):
    """
    Determine the order of elements in a floating-point array.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/orderd_c.html
    
    Inputs:
      float[*] array  = Input array.
    
    Returns:
      int      iorder = Order vector for array.
    """
    return cs1.orderd(array)

__copy_attributes_from(orderd, cs1.orderd)

#########################
# orderi
#########################

def orderi(array):
    """
    Determine the order of elements in an integer array.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/orderi_c.html
    
    Inputs:
      int[*] array  = Input array.
    
    Returns:
      int    iorder = Order vector for array.
    """
    return cs1.orderi(array)

__copy_attributes_from(orderi, cs1.orderi)

#########################
# oscelt
#########################

def oscelt(state, et, mu):
    """
    Determine the set of osculating conic orbital elements that corresponds
    to the state (position, velocity) of a body at some epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/oscelt_c.html
    
    Inputs:
      float[6] state = State of body at epoch of elements.
      float    et    = Epoch of elements.
      float    mu    = Gravitational parameter (GM) of primary body.
    
    Returns:
      float[8] elts  = Equivalent conic elements.
    """
    return cs1.oscelt(state, et, mu)

def oscelt_vector(state, et, mu):
    """
    Determine the set of osculating conic orbital elements that corresponds
    to the state (position, velocity) of a body at some epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/oscelt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] state = State of body at epoch of elements.
      float[_]   et    = Epoch of elements.
      float[_]   mu    = Gravitational parameter (GM) of primary body.
    
    Returns:
      float[_,8] elts  = Equivalent conic elements.
    """
    return cs1.oscelt_vector(state, et, mu)

__copy_attributes_from(oscelt, cs1.oscelt)
__copy_attributes_from(oscelt_vector, cs1.oscelt_vector)

#########################
# oscltx
#########################

def oscltx(state, et, mu):
    """
    Determine the set of osculating conic orbital elements that corresponds
    to the state (position, velocity) of a body at some epoch. In addition
    to the classical elements, return the true anomaly, semi-major axis, and
    period, if applicable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/oscltx_c.html
    
    Inputs:
      float[6] state = State of body at epoch of elements.
      float    et    = Epoch of elements.
      float    mu    = Gravitational parameter (GM) of primary body.
    
    Returns:
      float[*] elts  = Extended set of classical conic elements.
    """
    return cs1.oscltx(state, et, mu)

def oscltx_vector(state, et, mu):
    """
    Determine the set of osculating conic orbital elements that corresponds
    to the state (position, velocity) of a body at some epoch. In addition
    to the classical elements, return the true anomaly, semi-major axis, and
    period, if applicable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/oscltx_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] state = State of body at epoch of elements.
      float[_]   et    = Epoch of elements.
      float[_]   mu    = Gravitational parameter (GM) of primary body.
    
    Returns:
      float[_,*] elts  = Extended set of classical conic elements.
    """
    return cs1.oscltx_vector(state, et, mu)

__copy_attributes_from(oscltx, cs1.oscltx)
__copy_attributes_from(oscltx_vector, cs1.oscltx_vector)

#########################
# pckcls
#########################

def pckcls(handle):
    """
    Close an open PCK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pckcls_c.html
    
    Inputs:
      int handle = Handle of the PCK file to be closed.
    
    Returns: none
    """
    return cs1.pckcls(handle)

__copy_attributes_from(pckcls, cs1.pckcls)

#########################
# pckcov
#########################

def pckcov(pck, idcode, cover = 2000):
    """
    Find the coverage window for a specified reference frame in a specified
    binary PCK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pckcov_c.html
    
    Inputs:
      string    pck    = Name of PCK file.
      int       idcode = Class ID code of PCK reference frame.
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Returns:
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    """
    return cs1.pckcov(pck, idcode, cover)

def pckcov_error(pck, idcode, cover = 2000):
    """
    Find the coverage window for a specified reference frame in a specified
    binary PCK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pckcov_c.html
    
    Inputs:
      string    pck    = Name of PCK file.
      int       idcode = Class ID code of PCK reference frame.
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Returns:
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Note: Raise KeyError(FRAMEIDNOTFOUND) if the frame is not found.
    """
    return cs1.pckcov_error(pck, idcode, cover)

__copy_attributes_from(pckcov, cs1.pckcov)
__copy_attributes_from(pckcov_error, cs1.pckcov_error)

#########################
# pckfrm
#########################

def pckfrm(pck, ids = 2000):
    """
    Find the set of reference frame class ID codes of all frames in a
    specified binary PCK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pckfrm_c.html
    
    Inputs:
      string    pck = Name of PCK file.
      SpiceCell ids = Array of frame class ID codes for frames in PCK file.
    
    Returns:
      SpiceCell ids = Array of frame class ID codes for frames in PCK file.
    """
    return cs1.pckfrm(pck, ids)

__copy_attributes_from(pckfrm, cs1.pckfrm)

#########################
# pcklof
#########################

def pcklof(fname):
    """
    Load a binary PCK file for use by the readers. Return the handle of the
    loaded file which is used by other PCK routines to refer to the file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pcklof_c.html
    
    Inputs:
      string fname  = Name of the file to be loaded.
    
    Returns:
      int    handle = Loaded file's handle.
    """
    return cs1.pcklof(fname)

__copy_attributes_from(pcklof, cs1.pcklof)

#########################
# pckopn
#########################

def pckopn(name, ifname, ncomch):
    """
    Create a new PCK file, returning the handle of the opened file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pckopn_c.html
    
    Inputs:
      string name   = The name of the PCK file to be opened.
      string ifname = The internal filename for the PCK.
      int    ncomch = The number of characters to reserve for comments.
    
    Returns:
      int    handle = The handle of the opened PCK file.
    """
    return cs1.pckopn(name, ifname, ncomch)

__copy_attributes_from(pckopn, cs1.pckopn)

#########################
# pckuof
#########################

def pckuof(handle):
    """
    Unload a binary PCK file so that it will no longer be searched by the
    readers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pckuof_c.html
    
    Inputs:
      int handle = Handle of file to be unloaded
    
    Returns: none
    """
    return cs1.pckuof(handle)

__copy_attributes_from(pckuof, cs1.pckuof)

#########################
# pckw02
#########################

def pckw02(handle, clssid, frame, first, last, segid, intlen, n, polydg, cdata, btime):
    """
    Write a type 2 segment to a PCK binary file given the file handle, frame
    class ID, base frame, time range covered by the segment, and the
    Chebyshev polynomial coefficients.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pckw02_c.html
    
    Inputs:
      int      handle = Handle of binary PCK file open for writing.
      int      clssid = Frame class ID of body-fixed frame.
      string   frame  = Name of base reference frame.
      float    first  = Start time of interval covered by segment.
      float    last   = End time of interval covered by segment.
      string   segid  = Segment identifier.
      float    intlen = Length of time covered by logical record.
      int      n      = Number of logical records in segment.
      int      polydg = Chebyshev polynomial degree.
      float[*] cdata  = Array of Chebyshev coefficients.
      float    btime  = Begin time of first logical record.
    
    Returns: none
    """
    return cs1.pckw02(handle, clssid, frame, first, last, segid, intlen, n, polydg, cdata, btime)

__copy_attributes_from(pckw02, cs1.pckw02)

#########################
# pcpool
#########################

def pcpool(name, cvals):
    """
    This entry point provides toolkit programmers a method for
    programmatically inserting character data into the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pcpool_c.html
    
    Inputs:
      string    name  = The kernel pool name to associate with cvals.
      string[*] cvals = An array of strings to insert into the kernel pool.
    
    Returns: none
    """
    return cs1.pcpool(name, cvals)

__copy_attributes_from(pcpool, cs1.pcpool)

#########################
# pdpool
#########################

def pdpool(name, dvals):
    """
    This entry point provides toolkit programmers a method for
    programmatically inserting floating-point data into the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pdpool_c.html
    
    Inputs:
      string   name  = The kernel pool name to associate with dvals.
      float[*] dvals = An array of values to insert into the kernel pool.
    
    Returns: none
    """
    return cs1.pdpool(name, dvals)

__copy_attributes_from(pdpool, cs1.pdpool)

#########################
# pgrrec
#########################

def pgrrec(body, lon, lat, alt, re, f):
    """
    Convert planetographic coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pgrrec_c.html
    
    Inputs:
      string   body   = Body with which coordinate system is associated.
      float    lon    = Planetographic longitude of a point (radians).
      float    lat    = Planetographic latitude of a point (radians).
      float    alt    = Altitude of a point above reference spheroid.
      float    re     = Equatorial radius of the reference spheroid.
      float    f      = Flattening coefficient.
    
    Returns:
      float[3] rectan = Rectangular coordinates of the point.
    """
    return cs1.pgrrec(body, lon, lat, alt, re, f)

def pgrrec_vector(body, lon, lat, alt, re, f):
    """
    Convert planetographic coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pgrrec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     body   = Body with which coordinate system is associated.
      float[_]   lon    = Planetographic longitude of a point (radians).
      float[_]   lat    = Planetographic latitude of a point (radians).
      float[_]   alt    = Altitude of a point above reference spheroid.
      float[_]   re     = Equatorial radius of the reference spheroid.
      float[_]   f      = Flattening coefficient.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of the point.
    """
    return cs1.pgrrec_vector(body, lon, lat, alt, re, f)

__copy_attributes_from(pgrrec, cs1.pgrrec)
__copy_attributes_from(pgrrec_vector, cs1.pgrrec_vector)

#########################
# phaseq
#########################

def phaseq(et, target, illmn, obsrvr, abcorr):
    """
    Compute the apparent phase angle for a target, observer, illuminator set
    of ephemeris objects.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/phaseq_c.html
    
    Inputs:
      float  et     = Ephemeris seconds past J2000 TDB.
      string target = Target body name.
      string illmn  = Illuminating body name.
      string obsrvr = Observer body.
      string abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN", or
                      "CN+S".
    
    Returns:
      float  value  = Value of the phase angle.
    """
    return cs1.phaseq(et, target, illmn, obsrvr, abcorr)

def phaseq_vector(et, target, illmn, obsrvr, abcorr):
    """
    Compute the apparent phase angle for a target, observer, illuminator set
    of ephemeris objects.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/phaseq_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] et     = Ephemeris seconds past J2000 TDB.
      string   target = Target body name.
      string   illmn  = Illuminating body name.
      string   obsrvr = Observer body.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        or "CN+S".
    
    Returns:
      float[_] value  = Value of the phase angle.
    """
    return cs1.phaseq_vector(et, target, illmn, obsrvr, abcorr)

__copy_attributes_from(phaseq, cs1.phaseq)
__copy_attributes_from(phaseq_vector, cs1.phaseq_vector)

#########################
# pi
#########################

def pi():
    """
    Return the value of pi (the ratio of the circumference of a circle to
    its diameter).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pi_c.html
    
    Inputs: none
    
    Returns:
      float value = The value of pi.
    """
    return cs1.pi()

__copy_attributes_from(pi, cs1.pi)

#########################
# pipool
#########################

def pipool(name, ivals):
    """
    This entry point provides toolkit programmers a method for
    programmatically inserting integer data into the kernel pool.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pipool_c.html
    
    Inputs:
      string name  = The kernel pool name to associate with values.
      int[*] ivals = An array of integers to insert into the pool.
    
    Returns: none
    """
    return cs1.pipool(name, ivals)

__copy_attributes_from(pipool, cs1.pipool)

#########################
# pjelpl
#########################

def pjelpl(elin, plane):
    """
    Project an ellipse onto a plane, orthogonally.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pjelpl_c.html
    
    Inputs:
      ConstSpiceEllipse[*] elin  = A CSPICE ellipse to be projected.
      ConstSpicePlane[*]   plane = A plane onto which elin is to be
                                   projected.
    
    Returns:
      SpiceEllipse         elout = A CSPICE ellipse resulting from the
                                   projection.
    """
    return cs1.pjelpl(elin, plane)

def pjelpl_vector(elin, plane):
    """
    Project an ellipse onto a plane, orthogonally.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pjelpl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      ConstSpiceEllipse[*] elin  = A CSPICE ellipse to be projected.
      ConstSpicePlane[*]   plane = A plane onto which elin is to be
                                   projected.
    
    Returns:
      SpiceEllipse         elout = A CSPICE ellipse resulting from the
                                   projection.
    """
    return cs1.pjelpl_vector(elin, plane)

__copy_attributes_from(pjelpl, cs1.pjelpl)
__copy_attributes_from(pjelpl_vector, cs1.pjelpl_vector)

#########################
# pl2nvc
#########################

def pl2nvc(plane):
    """
    Return a unit normal vector and constant that define a specified plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pl2nvc_c.html
    
    Inputs:
      ConstSpicePlane[*] plane    = A CSPICE plane.
    
    Returns:
      float[3]           normal   = A unit normal vector defining the
                                    geometric plane.
      float              constant = The constant defining the geometric
                                    plane.
    """
    return cs1.pl2nvc(plane)

def pl2nvc_vector(plane):
    """
    Return a unit normal vector and constant that define a specified plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pl2nvc_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      ConstSpicePlane[*] plane    = A CSPICE plane.
    
    Returns:
      float[_,3]         normal   = A unit normal vector defining the
                                    geometric plane.
      float[_]           constant = The constant defining the geometric
                                    plane.
    """
    return cs1.pl2nvc_vector(plane)

__copy_attributes_from(pl2nvc, cs1.pl2nvc)
__copy_attributes_from(pl2nvc_vector, cs1.pl2nvc_vector)

#########################
# pl2nvp
#########################

def pl2nvp(plane):
    """
    Return a unit normal vector and point that define a specified plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pl2nvp_c.html
    
    Inputs:
      ConstSpicePlane[*] plane  = A CSPICE plane.
    
    Returns:
      float[3]           normal = A unit normal vector defining the
                                  geometric plane.
      float[3]           point  = A point on the geometric plane.
    """
    return cs1.pl2nvp(plane)

def pl2nvp_vector(plane):
    """
    Return a unit normal vector and point that define a specified plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pl2nvp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      ConstSpicePlane[*] plane  = A CSPICE plane.
    
    Returns:
      float[_,3]         normal = A unit normal vector defining the
                                  geometric plane.
      float[_,3]         point  = A point on the geometric plane.
    """
    return cs1.pl2nvp_vector(plane)

__copy_attributes_from(pl2nvp, cs1.pl2nvp)
__copy_attributes_from(pl2nvp_vector, cs1.pl2nvp_vector)

#########################
# pl2psv
#########################

def pl2psv(plane):
    """
    Return a point and two orthogonal spanning vectors that generate a
    specified plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pl2psv_c.html
    
    Inputs:
      ConstSpicePlane[*] plane = A CSPICE plane.
    
    Returns:
      float[3]           point = A point in the input plane.
      float[3]           span1 = The first of two vectors spanning the input
                                 plane.
      float[3]           span2 = The second of two vectors spanning the
                                 input plane.
    """
    return cs1.pl2psv(plane)

def pl2psv_vector(plane):
    """
    Return a point and two orthogonal spanning vectors that generate a
    specified plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pl2psv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      ConstSpicePlane[*] plane = A CSPICE plane.
    
    Returns:
      float[_,3]         point = A point in the input plane.
      float[_,3]         span1 = The first of two vectors spanning the input
                                 plane.
      float[_,3]         span2 = The second of two vectors spanning the
                                 input plane.
    """
    return cs1.pl2psv_vector(plane)

__copy_attributes_from(pl2psv, cs1.pl2psv)
__copy_attributes_from(pl2psv_vector, cs1.pl2psv_vector)

#########################
# pltar
#########################

def pltar(vrtces, plates):
    """
    Compute the total area of a collection of triangular plates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltar_c.html
    
    Inputs:
      float[*,3] vrtces = Array of vertices.
      int[*,3]   plates = Array of plates defined by the indices of three
                          vertices. Indices start at 1.
    
    Returns:
      float      area   = Total area of plates.
    """
    return cs1.pltar(vrtces, plates)

__copy_attributes_from(pltar, cs1.pltar)

#########################
# pltexp
#########################

def pltexp(iverts, delta):
    """
    Expand a triangular plate by a specified amount. The expanded plate is
    co-planar with, and has the same orientation as, the original. The
    centroids of the two plates coincide.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltexp_c.html
    
    Inputs:
      float[3,3] iverts = Vertices of the plate to be expanded.
      float      delta  = Fraction by which the plate is to be expanded.
    
    Returns:
      float[3,3] overts = Vertices of the expanded plate.
    """
    return cs1.pltexp(iverts, delta)

def pltexp_vector(iverts, delta):
    """
    Expand a triangular plate by a specified amount. The expanded plate is
    co-planar with, and has the same orientation as, the original. The
    centroids of the two plates coincide.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltexp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] iverts = Vertices of the plate to be expanded.
      float[_]     delta  = Fraction by which the plate is to be expanded.
    
    Returns:
      float[_,3,3] overts = Vertices of the expanded plate.
    """
    return cs1.pltexp_vector(iverts, delta)

__copy_attributes_from(pltexp, cs1.pltexp)
__copy_attributes_from(pltexp_vector, cs1.pltexp_vector)

#########################
# pltnp
#########################

def pltnp(point, v1, v2, v3):
    """
    Find the nearest point on a triangular plate to a given point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltnp_c.html
    
    Inputs:
      float[3] point = A point in 3-dimensional space.
      float[3] v1    = First vertex of a triangular plate.
      float[3] v2    = Second vertex of a triangular plate.
      float[3] v3    = Third vertex of a triangular plate.
    
    Returns:
      float[3] pnear = Nearest point on the plate to `point'.
      float    dist  = Distance between `pnear' and `point'.
    """
    return cs1.pltnp(point, v1, v2, v3)

def pltnp_vector(point, v1, v2, v3):
    """
    Find the nearest point on a triangular plate to a given point.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltnp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] point = A point in 3-dimensional space.
      float[_,3] v1    = First vertex of a triangular plate.
      float[_,3] v2    = Second vertex of a triangular plate.
      float[_,3] v3    = Third vertex of a triangular plate.
    
    Returns:
      float[_,3] pnear = Nearest point on the plate to `point'.
      float[_]   dist  = Distance between `pnear' and `point'.
    """
    return cs1.pltnp_vector(point, v1, v2, v3)

__copy_attributes_from(pltnp, cs1.pltnp)
__copy_attributes_from(pltnp_vector, cs1.pltnp_vector)

#########################
# pltnrm
#########################

def pltnrm(v1, v2, v3):
    """
    Compute an outward normal vector of a triangular plate. The vector does
    not necessarily have unit length.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltnrm_c.html
    
    Inputs:
      float[3] v1     = First vertex of a plate.
      float[3] v2     = Second vertex of a plate.
      float[3] v3     = Third vertex of a plate.
    
    Returns:
      float[3] normal = Plate's outward normal vector.
    """
    return cs1.pltnrm(v1, v2, v3)

def pltnrm_vector(v1, v2, v3):
    """
    Compute an outward normal vector of a triangular plate. The vector does
    not necessarily have unit length.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltnrm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1     = First vertex of a plate.
      float[_,3] v2     = Second vertex of a plate.
      float[_,3] v3     = Third vertex of a plate.
    
    Returns:
      float[_,3] normal = Plate's outward normal vector.
    """
    return cs1.pltnrm_vector(v1, v2, v3)

__copy_attributes_from(pltnrm, cs1.pltnrm)
__copy_attributes_from(pltnrm_vector, cs1.pltnrm_vector)

#########################
# pltvol
#########################

def pltvol(vrtces, plates):
    """
    Compute the volume of a three-dimensional region bounded by a collection
    of triangular plates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pltvol_c.html
    
    Inputs:
      float[*,3] vrtces = Array of vertices.
      int[*,3]   plates = Array of plates defined by the indices of three
                          vertices. Indices start at 1.
    
    Returns:
      float      volume = The volume of the spatial region bounded by the
                          plates.
    """
    return cs1.pltvol(vrtces, plates)

__copy_attributes_from(pltvol, cs1.pltvol)

#########################
# polyds
#########################

def polyds(coeffs, nderiv, t):
    """
    Compute the value of a polynomial and its first `nderiv' derivatives at
    the value `t'.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/polyds_c.html
    
    Inputs:
      float[*] coeffs = Coefficients of the polynomial to be evaluated.
      int      nderiv = Number of derivatives to compute.
      float    t      = Point to evaluate the polynomial and derivatives
    
    Returns:
      float[*] p      = Value of polynomial and derivatives.
    """
    return cs1.polyds(coeffs, nderiv, t)

def polyds_vector(coeffs, nderiv, t):
    """
    Compute the value of a polynomial and its first `nderiv' derivatives at
    the value `t'.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/polyds_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] coeffs = Coefficients of the polynomial to be evaluated.
      int        nderiv = Number of derivatives to compute.
      float[_]   t      = Point to evaluate the polynomial and derivatives
    
    Returns:
      float[_,*] p      = Value of polynomial and derivatives.
    """
    return cs1.polyds_vector(coeffs, nderiv, t)

__copy_attributes_from(polyds, cs1.polyds)
__copy_attributes_from(polyds_vector, cs1.polyds_vector)

#########################
# pos
#########################

def pos(str, substr, start):
    """
    Find the first occurrence in a string of a substring, starting at a
    specified location, searching forward.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pos_c.html
    
    Inputs:
      string str    = Any character string.
      string substr = Substring to locate in the character string.
      int    start  = Position to begin looking for substr in str.
    
    Returns:
      int    index  = Index of substring in string.
    """
    return cs1.pos(str, substr, start)

__copy_attributes_from(pos, cs1.pos)

#########################
# posr
#########################

def posr(str, substr, start):
    """
    Find the first occurrence in a string of a substring, starting at a
    specified location, searching backward.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/posr_c.html
    
    Inputs:
      string str    = Any character string.
      string substr = Substring to locate in the character string.
      int    start  = Position to begin looking for substr in str.
    
    Returns:
      int    index  = Index of substring in string.
    """
    return cs1.posr(str, substr, start)

__copy_attributes_from(posr, cs1.posr)

#########################
# prompt
#########################

def prompt(dspmsg):
    """
    Prompt a user for keyboard input.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/prompt_c.html
    
    Inputs:
      string dspmsg = The prompt string to display when asking for input.
    
    Returns:
      string buffer = The string containing the response typed by a user.
    """
    return cs1.prompt(dspmsg)

__copy_attributes_from(prompt, cs1.prompt)

#########################
# prop2b
#########################

def prop2b(gm, pvinit, dt):
    """
    Given a central mass and the state of massless body at time t_0, this
    routine determines the state as predicted by a two-body force model at
    time t_0 + dt.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/prop2b_c.html
    
    Inputs:
      float    gm     = Gravity of the central mass.
      float[6] pvinit = Initial state from which to propagate a state.
      float    dt     = Time offset from initial state to propagate to.
    
    Returns:
      float[6] pvprop = The propagated state.
    """
    return cs1.prop2b(gm, pvinit, dt)

def prop2b_vector(gm, pvinit, dt):
    """
    Given a central mass and the state of massless body at time t_0, this
    routine determines the state as predicted by a two-body force model at
    time t_0 + dt.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/prop2b_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   gm     = Gravity of the central mass.
      float[_,6] pvinit = Initial state from which to propagate a state.
      float[_]   dt     = Time offset from initial state to propagate to.
    
    Returns:
      float[_,6] pvprop = The propagated state.
    """
    return cs1.prop2b_vector(gm, pvinit, dt)

__copy_attributes_from(prop2b, cs1.prop2b)
__copy_attributes_from(prop2b_vector, cs1.prop2b_vector)

#########################
# prsdp
#########################

def prsdp(string):
    """
    Parse a string as a floating-point number, encapsulating error handling.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/prsdp_c.html
    
    Inputs:
      string string = String representing a numeric value.
    
    Returns:
      float  dpval  = D.p. value obtained by parsing `string'.
    """
    return cs1.prsdp(string)

__copy_attributes_from(prsdp, cs1.prsdp)

#########################
# prsint
#########################

def prsint(string):
    """
    Parse a string as an integer, encapsulating error handling.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/prsint_c.html
    
    Inputs:
      string string = String representing a numeric value.
    
    Returns:
      int    intval = Integer value obtained by parsing `string'.
    """
    return cs1.prsint(string)

__copy_attributes_from(prsint, cs1.prsint)

#########################
# psv2pl
#########################

def psv2pl(point, span1, span2):
    """
    Make a CSPICE plane from a point and two spanning vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/psv2pl_c.html
    
    Inputs:
      float[3]   point = A point in the plane.
      float[3]   span1 = The first of two vectors spanning the plane.
      float[3]   span2 = The second of two vectors spanning the plane.
    
    Returns:
      SpicePlane plane = A CSPICE plane representing the plane.
    """
    return cs1.psv2pl(point, span1, span2)

def psv2pl_vector(point, span1, span2):
    """
    Make a CSPICE plane from a point and two spanning vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/psv2pl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] point = A point in the plane.
      float[_,3] span1 = The first of two vectors spanning the plane.
      float[_,3] span2 = The second of two vectors spanning the plane.
    
    Returns:
      SpicePlane plane = A CSPICE plane representing the plane.
    """
    return cs1.psv2pl_vector(point, span1, span2)

__copy_attributes_from(psv2pl, cs1.psv2pl)
__copy_attributes_from(psv2pl_vector, cs1.psv2pl_vector)

#########################
# pxform
#########################

def pxform(from_, to, et):
    """
    Return the matrix that transforms position vectors from one specified
    frame to another at a specified epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pxform_c.html
    
    Inputs:
      string     from   = Name of the frame to transform from.
      string     to     = Name of the frame to transform to.
      float      et     = Epoch of the rotation matrix.
    
    Returns:
      float[3,3] rotate = A rotation matrix.
    """
    return cs1.pxform(from_, to, et)

def pxform_vector(from_, to, et):
    """
    Return the matrix that transforms position vectors from one specified
    frame to another at a specified epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pxform_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string       from   = Name of the frame to transform from.
      string       to     = Name of the frame to transform to.
      float[_]     et     = Epoch of the rotation matrix.
    
    Returns:
      float[_,3,3] rotate = A rotation matrix.
    """
    return cs1.pxform_vector(from_, to, et)

__copy_attributes_from(pxform, cs1.pxform)
__copy_attributes_from(pxform_vector, cs1.pxform_vector)

#########################
# pxfrm2
#########################

def pxfrm2(from_, to, etfrom, etto):
    """
    Return the 3x3 matrix that transforms position vectors from one
    specified frame at a specified epoch to another specified frame at
    another specified epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pxfrm2_c.html
    
    Inputs:
      string     from   = Name of the frame to transform from.
      string     to     = Name of the frame to transform to.
      float      etfrom = Evaluation time of `from' frame.
      float      etto   = Evaluation time of `to' frame.
    
    Returns:
      float[3,3] rotate = A position transformation matrix from frame `from'
                          to frame `to'.
    """
    return cs1.pxfrm2(from_, to, etfrom, etto)

def pxfrm2_vector(from_, to, etfrom, etto):
    """
    Return the 3x3 matrix that transforms position vectors from one
    specified frame at a specified epoch to another specified frame at
    another specified epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/pxfrm2_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string       from   = Name of the frame to transform from.
      string       to     = Name of the frame to transform to.
      float[_]     etfrom = Evaluation time of `from' frame.
      float[_]     etto   = Evaluation time of `to' frame.
    
    Returns:
      float[_,3,3] rotate = A position transformation matrix from frame
                            `from' to frame `to'.
    """
    return cs1.pxfrm2_vector(from_, to, etfrom, etto)

__copy_attributes_from(pxfrm2, cs1.pxfrm2)
__copy_attributes_from(pxfrm2_vector, cs1.pxfrm2_vector)

#########################
# q2m
#########################

def q2m(q):
    """
    Find the rotation matrix corresponding to a specified unit quaternion.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/q2m_c.html
    
    Inputs:
      float[4]   q      = A unit quaternion.
    
    Returns:
      float[3,3] matrix = A rotation matrix corresponding to q.
    """
    return cs1.q2m(q)

def q2m_vector(q):
    """
    Find the rotation matrix corresponding to a specified unit quaternion.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/q2m_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,4]   q      = A unit quaternion.
    
    Returns:
      float[_,3,3] matrix = A rotation matrix corresponding to q.
    """
    return cs1.q2m_vector(q)

__copy_attributes_from(q2m, cs1.q2m)
__copy_attributes_from(q2m_vector, cs1.q2m_vector)

#########################
# qcktrc
#########################

def qcktrc():
    """
    Return a string containing a traceback.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/qcktrc_c.html
    
    Inputs: none
    
    Returns:
      string trace = A traceback string.
    """
    return cs1.qcktrc()

__copy_attributes_from(qcktrc, cs1.qcktrc)

#########################
# qderiv
#########################

def qderiv(f0, f2, delta):
    """
    Estimate the derivative of a function by finding the derivative of a
    quadratic approximating function. This derivative estimate is equivalent
    to that found by computing the average of forward and backward
    differences.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/qderiv_c.html
    
    Inputs:
      float[*] f0    = Function values at left endpoint.
      float[*] f2    = Function values at right endpoint.
      float    delta = Separation of abscissa points.
    
    Returns:
      float[*] dfdt  = Derivative vector.
    """
    return cs1.qderiv(f0, f2, delta)

__copy_attributes_from(qderiv, cs1.qderiv)

#########################
# qdq2av
#########################

def qdq2av(q, dq):
    """
    Derive angular velocity from a unit quaternion and its derivative with
    respect to time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/qdq2av_c.html
    
    Inputs:
      float[4] q  = Unit SPICE quaternion.
      float[4] dq = Derivative of `q' with respect to time.
    
    Returns:
      float[3] av = Angular velocity defined by `q' and `dq'.
    """
    return cs1.qdq2av(q, dq)

def qdq2av_vector(q, dq):
    """
    Derive angular velocity from a unit quaternion and its derivative with
    respect to time.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/qdq2av_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,4] q  = Unit SPICE quaternion.
      float[_,4] dq = Derivative of `q' with respect to time.
    
    Returns:
      float[_,3] av = Angular velocity defined by `q' and `dq'.
    """
    return cs1.qdq2av_vector(q, dq)

__copy_attributes_from(qdq2av, cs1.qdq2av)
__copy_attributes_from(qdq2av_vector, cs1.qdq2av_vector)

#########################
# qxq
#########################

def qxq(q1, q2):
    """
    Multiply two quaternions.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/qxq_c.html
    
    Inputs:
      float[4] q1   = First SPICE quaternion factor.
      float[4] q2   = Second SPICE quaternion factor.
    
    Returns:
      float[4] qout = Product of `q1' and `q2'.
    """
    return cs1.qxq(q1, q2)

def qxq_vector(q1, q2):
    """
    Multiply two quaternions.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/qxq_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,4] q1   = First SPICE quaternion factor.
      float[_,4] q2   = Second SPICE quaternion factor.
    
    Returns:
      float[_,4] qout = Product of `q1' and `q2'.
    """
    return cs1.qxq_vector(q1, q2)

__copy_attributes_from(qxq, cs1.qxq)
__copy_attributes_from(qxq_vector, cs1.qxq_vector)

#########################
# radrec
#########################

def radrec(range, ra, dec):
    """
    Convert from range, right ascension, and declination to rectangular
    coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/radrec_c.html
    
    Inputs:
      float    range  = Distance of a point from the origin.
      float    ra     = Right ascension of point in radians.
      float    dec    = Declination of point in radians.
    
    Returns:
      float[3] rectan = Rectangular coordinates of the point.
    """
    return cs1.radrec(range, ra, dec)

def radrec_vector(range, ra, dec):
    """
    Convert from range, right ascension, and declination to rectangular
    coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/radrec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   range  = Distance of a point from the origin.
      float[_]   ra     = Right ascension of point in radians.
      float[_]   dec    = Declination of point in radians.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of the point.
    """
    return cs1.radrec_vector(range, ra, dec)

__copy_attributes_from(radrec, cs1.radrec)
__copy_attributes_from(radrec_vector, cs1.radrec_vector)

#########################
# rav2xf
#########################

def rav2xf(rot, av):
    """
    This routine determines from a state transformation matrix the
    associated rotation matrix and angular velocity of the rotation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rav2xf_c.html
    
    Inputs:
      float[3,3] rot   = Rotation matrix.
      float[3]   av    = Angular velocity vector.
    
    Returns:
      float[6,6] xform = State transformation associated with rot and av.
    """
    return cs1.rav2xf(rot, av)

def rav2xf_vector(rot, av):
    """
    This routine determines from a state transformation matrix the
    associated rotation matrix and angular velocity of the rotation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rav2xf_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] rot   = Rotation matrix.
      float[_,3]   av    = Angular velocity vector.
    
    Returns:
      float[_,6,6] xform = State transformation associated with rot and av.
    """
    return cs1.rav2xf_vector(rot, av)

__copy_attributes_from(rav2xf, cs1.rav2xf)
__copy_attributes_from(rav2xf_vector, cs1.rav2xf_vector)

#########################
# raxisa
#########################

def raxisa(matrix):
    """
    Compute the axis of the rotation given by an input matrix and the angle
    of the rotation about that axis.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/raxisa_c.html
    
    Inputs:
      float[3,3] matrix = 3x3 rotation matrix.
    
    Returns:
      float[3]   axis   = Axis of the rotation.
      float      angle  = Angle through which the rotation is performed.
    """
    return cs1.raxisa(matrix)

def raxisa_vector(matrix):
    """
    Compute the axis of the rotation given by an input matrix and the angle
    of the rotation about that axis.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/raxisa_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] matrix = 3x3 rotation matrix.
    
    Returns:
      float[_,3]   axis   = Axis of the rotation.
      float[_]     angle  = Angle through which the rotation is performed.
    """
    return cs1.raxisa_vector(matrix)

__copy_attributes_from(raxisa, cs1.raxisa)
__copy_attributes_from(raxisa_vector, cs1.raxisa_vector)

#########################
# recazl
#########################

def recazl(rectan, azccw, elplsz):
    """
    Convert rectangular coordinates of a point to range, azimuth and
    elevation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recazl_c.html
    
    Inputs:
      float[3] rectan = Rectangular coordinates of a point.
      bool     azccw  = Flag indicating how azimuth is measured, True for
                        counterclockwise, False for clockwise.
      bool     elplsz = Flag indicating how elevation is measured, True for
                        increasing toward +Z, False for -Z.
    
    Returns:
      float    range  = Distance of the point from the origin.
      float    az     = Azimuth in radians.
      float    el     = Elevation in radians.
    """
    return cs1.recazl(rectan, azccw, elplsz)

def recazl_vector(rectan, azccw, elplsz):
    """
    Convert rectangular coordinates of a point to range, azimuth and
    elevation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recazl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] rectan = Rectangular coordinates of a point.
      bool       azccw  = Flag indicating how azimuth is measured, True for
                          counterclockwise, False for clockwise.
      bool       elplsz = Flag indicating how elevation is measured, True
                          for increasing toward +Z, False for -Z.
    
    Returns:
      float[_]   range  = Distance of the point from the origin.
      float[_]   az     = Azimuth in radians.
      float[_]   el     = Elevation in radians.
    """
    return cs1.recazl_vector(rectan, azccw, elplsz)

__copy_attributes_from(recazl, cs1.recazl)
__copy_attributes_from(recazl_vector, cs1.recazl_vector)

#########################
# reccyl
#########################

def reccyl(rectan):
    """
    Convert from rectangular to cylindrical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reccyl_c.html
    
    Inputs:
      float[3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float    r      = Distance of the point from z axis.
      float    lon    = Angle (radians) of the point from XZ plane.
      float    z      = Height of the point above XY plane.
    """
    return cs1.reccyl(rectan)

def reccyl_vector(rectan):
    """
    Convert from rectangular to cylindrical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reccyl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float[_]   r      = Distance of the point from z axis.
      float[_]   lon    = Angle (radians) of the point from XZ plane.
      float[_]   z      = Height of the point above XY plane.
    """
    return cs1.reccyl_vector(rectan)

__copy_attributes_from(reccyl, cs1.reccyl)
__copy_attributes_from(reccyl_vector, cs1.reccyl_vector)

#########################
# recgeo
#########################

def recgeo(rectan, re, f):
    """
    Convert from rectangular coordinates to geodetic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recgeo_c.html
    
    Inputs:
      float[3] rectan = Rectangular coordinates of a point.
      float    re     = Equatorial radius of the reference spheroid.
      float    f      = Flattening coefficient.
    
    Returns:
      float    lon    = Geodetic longitude of the point (radians).
      float    lat    = Geodetic latitude of the point (radians).
      float    alt    = Altitude of the point above reference spheroid.
    """
    return cs1.recgeo(rectan, re, f)

def recgeo_vector(rectan, re, f):
    """
    Convert from rectangular coordinates to geodetic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recgeo_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] rectan = Rectangular coordinates of a point.
      float[_]   re     = Equatorial radius of the reference spheroid.
      float[_]   f      = Flattening coefficient.
    
    Returns:
      float[_]   lon    = Geodetic longitude of the point (radians).
      float[_]   lat    = Geodetic latitude of the point (radians).
      float[_]   alt    = Altitude of the point above reference spheroid.
    """
    return cs1.recgeo_vector(rectan, re, f)

__copy_attributes_from(recgeo, cs1.recgeo)
__copy_attributes_from(recgeo_vector, cs1.recgeo_vector)

#########################
# reclat
#########################

def reclat(rectan):
    """
    Convert from rectangular coordinates to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reclat_c.html
    
    Inputs:
      float[3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float    radius = Distance of the point from the origin.
      float    lon    = Longitude of the point in radians.
      float    lat    = Latitude of the point in radians.
    """
    return cs1.reclat(rectan)

def reclat_vector(rectan):
    """
    Convert from rectangular coordinates to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reclat_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float[_]   radius = Distance of the point from the origin.
      float[_]   lon    = Longitude of the point in radians.
      float[_]   lat    = Latitude of the point in radians.
    """
    return cs1.reclat_vector(rectan)

__copy_attributes_from(reclat, cs1.reclat)
__copy_attributes_from(reclat_vector, cs1.reclat_vector)

#########################
# recpgr
#########################

def recpgr(body, rectan, re, f):
    """
    Convert rectangular coordinates to planetographic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recpgr_c.html
    
    Inputs:
      string   body   = Body with which coordinate system is associated.
      float[3] rectan = Rectangular coordinates of a point.
      float    re     = Equatorial radius of the reference spheroid.
      float    f      = Flattening coefficient.
    
    Returns:
      float    lon    = Planetographic longitude of the point (radians).
      float    lat    = Planetographic latitude of the point (radians).
      float    alt    = Altitude of the point above reference spheroid.
    """
    return cs1.recpgr(body, rectan, re, f)

def recpgr_vector(body, rectan, re, f):
    """
    Convert rectangular coordinates to planetographic coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recpgr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     body   = Body with which coordinate system is associated.
      float[_,3] rectan = Rectangular coordinates of a point.
      float[_]   re     = Equatorial radius of the reference spheroid.
      float[_]   f      = Flattening coefficient.
    
    Returns:
      float[_]   lon    = Planetographic longitude of the point (radians).
      float[_]   lat    = Planetographic latitude of the point (radians).
      float[_]   alt    = Altitude of the point above reference spheroid.
    """
    return cs1.recpgr_vector(body, rectan, re, f)

__copy_attributes_from(recpgr, cs1.recpgr)
__copy_attributes_from(recpgr_vector, cs1.recpgr_vector)

#########################
# recrad
#########################

def recrad(rectan):
    """
    Convert rectangular coordinates to range, right ascension, and
    declination.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recrad_c.html
    
    Inputs:
      float[3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float    range  = Distance of the point from the origin.
      float    ra     = Right ascension in radians.
      float    dec    = Declination in radians.
    """
    return cs1.recrad(rectan)

def recrad_vector(rectan):
    """
    Convert rectangular coordinates to range, right ascension, and
    declination.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recrad_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float[_]   range  = Distance of the point from the origin.
      float[_]   ra     = Right ascension in radians.
      float[_]   dec    = Declination in radians.
    """
    return cs1.recrad_vector(rectan)

__copy_attributes_from(recrad, cs1.recrad)
__copy_attributes_from(recrad_vector, cs1.recrad_vector)

#########################
# recsph
#########################

def recsph(rectan):
    """
    Convert from rectangular coordinates to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recsph_c.html
    
    Inputs:
      float[3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float    r      = Distance of the point from the origin.
      float    colat  = Angle of the point from the positive Z-axis.
      float    lon    = Longitude of the point in radians.
    """
    return cs1.recsph(rectan)

def recsph_vector(rectan):
    """
    Convert from rectangular coordinates to spherical coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/recsph_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] rectan = Rectangular coordinates of a point.
    
    Returns:
      float[_]   r      = Distance of the point from the origin.
      float[_]   colat  = Angle of the point from the positive Z-axis.
      float[_]   lon    = Longitude of the point in radians.
    """
    return cs1.recsph_vector(rectan)

__copy_attributes_from(recsph, cs1.recsph)
__copy_attributes_from(recsph_vector, cs1.recsph_vector)

#########################
# refchg
#########################

def refchg(frame1, frame2, et):
    """
    Return the transformation matrix from one frame to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/refchg.html
    
    Inputs:
      int        frame1 = The frame id-code for some reference frame.
      int        frame2 = The frame id-code for some reference frame.
      float      et     = An epoch in TDB seconds past J2000.
    
    Returns:
      float[3,3] rotate = A rotation matrix.
    """
    return cs1.refchg(frame1, frame2, et)

def refchg_vector(frame1, frame2, et):
    """
    Return the transformation matrix from one frame to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/refchg.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int          frame1 = The frame id-code for some reference frame.
      int          frame2 = The frame id-code for some reference frame.
      float[_]     et     = An epoch in TDB seconds past J2000.
    
    Returns:
      float[_,3,3] rotate = A rotation matrix.
    """
    return cs1.refchg_vector(frame1, frame2, et)

__copy_attributes_from(refchg, cs1.refchg)
__copy_attributes_from(refchg_vector, cs1.refchg_vector)

#########################
# reordc
#########################

def reordc(iorder, array):
    """
    Reorder the elements of an array of character strings according to a
    given order vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reordc_c.html
    
    Inputs:
      int[*]    iorder = Order vector to be used to re-order array.
      string[*] array  = Array to be re-ordered.
    
    Returns:
      string[*] array  = Array to be re-ordered.
    """
    return cs1.reordc(iorder, array)

__copy_attributes_from(reordc, cs1.reordc)

#########################
# reordd
#########################

def reordd(iorder, array):
    """
    Reorder the elements of a floating-point array according to a given
    order vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reordd_c.html
    
    Inputs:
      int[*] iorder = Order vector to be used to re-order array.
      float  array  = Array to be re-ordered.
    
    Returns:
      float  array  = Array to be re-ordered.
    """
    return cs1.reordd(iorder, array)

__copy_attributes_from(reordd, cs1.reordd)

#########################
# reordi
#########################

def reordi(iorder, array):
    """
    Reorder the elements of an integer array according to a given order
    vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reordi_c.html
    
    Inputs:
      int[*] iorder = Order vector to be used to re-order array.
      int    array  = Array to be re-ordered.
    
    Returns:
      int    array  = Array to be re-ordered.
    """
    return cs1.reordi(iorder, array)

__copy_attributes_from(reordi, cs1.reordi)

#########################
# reordl
#########################

def reordl(iorder, array):
    """
    Reorder the elements of a logical array according to a given order
    vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reordl_c.html
    
    Inputs:
      int[*] iorder = Order vector to be used to re-order array.
      bool   array  = Array to be re-ordered.
    
    Returns:
      bool   array  = Array to be re-ordered.
    """
    return cs1.reordl(iorder, array)

__copy_attributes_from(reordl, cs1.reordl)

#########################
# repmc
#########################

def repmc(in_, marker, value):
    """
    Replace a marker with a character string.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/repmc_c.html
    
    Inputs:
      string in     = Input string.
      string marker = Marker to be replaced.
      string value  = Replacement value.
    
    Returns:
      string out    = Output string.
    """
    return cs1.repmc(in_, marker, value)

__copy_attributes_from(repmc, cs1.repmc)

#########################
# repmct
#########################

def repmct(in_, marker, value, repcase):
    """
    Replace a marker with the text representation of a cardinal number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/repmct_c.html
    
    Inputs:
      string in      = Input string.
      string marker  = Marker to be replaced.
      int    value   = Replacement value.
      string repcase = Case of replacement text: "U" for UPPPERCASE; "L" for
                       lowercase; "C" for Capitalized.
    
    Returns:
      string out     = Output string.
    """
    return cs1.repmct(in_, marker, value, repcase)

__copy_attributes_from(repmct, cs1.repmct)

#########################
# repmd
#########################

def repmd(in_, marker, value, sigdig):
    """
    Replace a marker with a floating-point number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/repmd_c.html
    
    Inputs:
      string in     = Input string.
      string marker = Marker to be replaced.
      float  value  = Replacement value.
      int    sigdig = Significant digits in replacement text.
    
    Returns:
      string out    = Output string.
    """
    return cs1.repmd(in_, marker, value, sigdig)

__copy_attributes_from(repmd, cs1.repmd)

#########################
# repmf
#########################

def repmf(in_, marker, value, sigdig, format):
    """
    Replace a marker in a string with a formatted floating-point value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/repmf_c.html
    
    Inputs:
      string in     = Input string.
      string marker = Marker to be replaced.
      float  value  = Replacement value.
      int    sigdig = Significant digits in replacement text.
      string format = Format: 'E' or 'F'.
    
    Returns:
      string out    = Output string.
    """
    return cs1.repmf(in_, marker, value, sigdig, format)

__copy_attributes_from(repmf, cs1.repmf)

#########################
# repmi
#########################

def repmi(in_, marker, value):
    """
    Replace a marker with an integer.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/repmi_c.html
    
    Inputs:
      string in     = Input string.
      string marker = Marker to be replaced.
      int    value  = Replacement value.
    
    Returns:
      string out    = Output string.
    """
    return cs1.repmi(in_, marker, value)

__copy_attributes_from(repmi, cs1.repmi)

#########################
# repml
#########################

def repml(in_, marker, value, rtcase):
    """
    Replace a marker with the text representation of a logical value.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/repml_c.html
    
    Inputs:
      string in     = Input string.
      string marker = Marker to be replaced.
      bool   value  = Replacement logical value.
      string rtcase = Case of replacement text.
    
    Returns:
      string out    = Output string.
    """
    return cs1.repml(in_, marker, value, rtcase)

__copy_attributes_from(repml, cs1.repml)

#########################
# repmot
#########################

def repmot(in_, marker, value, repcase):
    """
    Replace a marker with the text representation of an ordinal number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/repmot_c.html
    
    Inputs:
      string in      = Input string.
      string marker  = Marker to be replaced.
      int    value   = Replacement value.
      string repcase = Case of replacement text: "U" for UPPERCASE; "L" for
                       lowercase; "C" for Capitalized.
    
    Returns:
      string out     = Output string.
    """
    return cs1.repmot(in_, marker, value, repcase)

__copy_attributes_from(repmot, cs1.repmot)

#########################
# reset
#########################

def reset():
    """
    Reset the CSPICE error status to a value of "no error." as a result, the
    status routine, failed, will return a value of False.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/reset_c.html
    
    Inputs: none
    
    Returns: none
    """
    return cs1.reset()

__copy_attributes_from(reset, cs1.reset)

#########################
# return
#########################

def return_():
    """
    Return True if CSPICE routines should return immediately upon entry.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/return_c.html
    
    Inputs: none
    
    Returns:
      bool status = True if the routine should return immediately.
    """
    return cs1.return_()

__copy_attributes_from(return_, cs1.return_)

#########################
# rotate
#########################

def rotate(angle, iaxis):
    """
    Calculate the 3x3 rotation matrix generated by a rotation of a specified
    angle about a specified axis. This rotation is thought of as rotating
    the coordinate system.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rotate_c.html
    
    Inputs:
      float      angle  = Angle of rotation (radians).
      int        iaxis  = Axis of rotation (X=1, Y=2, Z=3).
    
    Returns:
      float[3,3] matrix = Resulting rotation matrix [angle] iaxis.
    """
    return cs1.rotate(angle, iaxis)

def rotate_vector(angle, iaxis):
    """
    Calculate the 3x3 rotation matrix generated by a rotation of a specified
    angle about a specified axis. This rotation is thought of as rotating
    the coordinate system.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rotate_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]     angle  = Angle of rotation (radians).
      int          iaxis  = Axis of rotation (X=1, Y=2, Z=3).
    
    Returns:
      float[_,3,3] matrix = Resulting rotation matrix [angle] iaxis.
    """
    return cs1.rotate_vector(angle, iaxis)

__copy_attributes_from(rotate, cs1.rotate)
__copy_attributes_from(rotate_vector, cs1.rotate_vector)

#########################
# rotmat
#########################

def rotmat(m1, angle, iaxis):
    """
    This function applies a rotation of angle radians about axis iaxis to a
    matrix. This rotation is thought of as rotating the coordinate system.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rotmat_c.html
    
    Inputs:
      float[3,3] m1     = Matrix to be rotated.
      float      angle  = Angle of rotation (radians).
      int        iaxis  = Axis of rotation (X=1, Y=2, Z=3).
    
    Returns:
      float[3,3] matrix = Resulting rotated matrix.
    """
    return cs1.rotmat(m1, angle, iaxis)

def rotmat_vector(m1, angle, iaxis):
    """
    This function applies a rotation of angle radians about axis iaxis to a
    matrix. This rotation is thought of as rotating the coordinate system.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rotmat_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = Matrix to be rotated.
      float[_]     angle  = Angle of rotation (radians).
      int          iaxis  = Axis of rotation (X=1, Y=2, Z=3).
    
    Returns:
      float[_,3,3] matrix = Resulting rotated matrix.
    """
    return cs1.rotmat_vector(m1, angle, iaxis)

__copy_attributes_from(rotmat, cs1.rotmat)
__copy_attributes_from(rotmat_vector, cs1.rotmat_vector)

#########################
# rotvec
#########################

def rotvec(v1, angle, iaxis):
    """
    Transform a vector to a new coordinate system rotated by angle radians
    about axis iaxis. This transformation rotates v1 by -angle radians about
    the specified axis.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rotvec_c.html
    
    Inputs:
      float[3] v1     = Vector whose coordinate system is to be rotated.
      float    angle  = Angle of rotation in radians.
      int      iaxis  = Axis of rotation (X=1, Y=2, Z=3).
    
    Returns:
      float[3] vector = Resulting vector [angle].
    """
    return cs1.rotvec(v1, angle, iaxis)

def rotvec_vector(v1, angle, iaxis):
    """
    Transform a vector to a new coordinate system rotated by angle radians
    about axis iaxis. This transformation rotates v1 by -angle radians about
    the specified axis.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rotvec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1     = Vector whose coordinate system is to be rotated.
      float[_]   angle  = Angle of rotation in radians.
      int        iaxis  = Axis of rotation (X=1, Y=2, Z=3).
    
    Returns:
      float[_,3] vector = Resulting vector [angle].
    """
    return cs1.rotvec_vector(v1, angle, iaxis)

__copy_attributes_from(rotvec, cs1.rotvec)
__copy_attributes_from(rotvec_vector, cs1.rotvec_vector)

#########################
# rpd
#########################

def rpd():
    """
    Return the number of radians per degree.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rpd_c.html
    
    Inputs: none
    
    Returns:
      float value = The number of radians per degree.
    """
    return cs1.rpd()

__copy_attributes_from(rpd, cs1.rpd)

#########################
# rquad
#########################

def rquad(a, b, c):
    """
    Find the roots of a quadratic equation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rquad_c.html
    
    Inputs:
      float    a     = Coefficient of quadratic term.
      float    b     = Coefficient of linear term.
      float    c     = Constant.
    
    Returns:
      float[2] root1 = Root built from positive discriminant term.
      float[2] root2 = Root built from negative discriminant term.
    """
    return cs1.rquad(a, b, c)

def rquad_vector(a, b, c):
    """
    Find the roots of a quadratic equation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/rquad_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   a     = Coefficient of quadratic term.
      float[_]   b     = Coefficient of linear term.
      float[_]   c     = Constant.
    
    Returns:
      float[_,2] root1 = Root built from positive discriminant term.
      float[_,2] root2 = Root built from negative discriminant term.
    """
    return cs1.rquad_vector(a, b, c)

__copy_attributes_from(rquad, cs1.rquad)
__copy_attributes_from(rquad_vector, cs1.rquad_vector)

#########################
# saelgv
#########################

def saelgv(vec1, vec2):
    """
    Find semi-axis vectors of an ellipse generated by two arbitrary
    three-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/saelgv_c.html
    
    Inputs:
      float[3] vec1   = First of two vectors used to generate an ellipse.
      float[3] vec2   = Second of two vectors used to generate an ellipse.
    
    Returns:
      float[3] smajor = Semi-major axis of ellipse.
      float[3] sminor = Semi-minor axis of ellipse.
    """
    return cs1.saelgv(vec1, vec2)

def saelgv_vector(vec1, vec2):
    """
    Find semi-axis vectors of an ellipse generated by two arbitrary
    three-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/saelgv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] vec1   = First of two vectors used to generate an ellipse.
      float[_,3] vec2   = Second of two vectors used to generate an ellipse.
    
    Returns:
      float[_,3] smajor = Semi-major axis of ellipse.
      float[_,3] sminor = Semi-minor axis of ellipse.
    """
    return cs1.saelgv_vector(vec1, vec2)

__copy_attributes_from(saelgv, cs1.saelgv)
__copy_attributes_from(saelgv_vector, cs1.saelgv_vector)

#########################
# scdecd
#########################

def scdecd(sc, sclkdp):
    """
    Convert floating-point encoding of spacecraft clock time into a
    character representation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/scdecd_c.html
    
    Inputs:
      int    sc     = NAIF spacecraft identification code.
      float  sclkdp = Encoded representation of a spacecraft clock count.
    
    Returns:
      string sclkch = Character representation of a clock count.
    """
    return cs1.scdecd(sc, sclkdp)

__copy_attributes_from(scdecd, cs1.scdecd)

#########################
# sce2c
#########################

def sce2c(sc, et):
    """
    Convert ephemeris seconds past j2000 (ET) to continuous encoded
    spacecraft clock (`ticks'). Non-integral tick values may be returned.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sce2c_c.html
    
    Inputs:
      int   sc     = NAIF spacecraft ID code.
      float et     = Ephemeris time, seconds past j2000.
    
    Returns:
      float sclkdp = SCLK, encoded as ticks since spacecraft clock start.
                     sclkdp need not be integral.
    """
    return cs1.sce2c(sc, et)

def sce2c_vector(sc, et):
    """
    Convert ephemeris seconds past j2000 (ET) to continuous encoded
    spacecraft clock (`ticks'). Non-integral tick values may be returned.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sce2c_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int      sc     = NAIF spacecraft ID code.
      float[_] et     = Ephemeris time, seconds past j2000.
    
    Returns:
      float[_] sclkdp = SCLK, encoded as ticks since spacecraft clock start.
                        sclkdp need not be integral.
    """
    return cs1.sce2c_vector(sc, et)

__copy_attributes_from(sce2c, cs1.sce2c)
__copy_attributes_from(sce2c_vector, cs1.sce2c_vector)

#########################
# sce2s
#########################

def sce2s(sc, et):
    """
    Convert an epoch specified as ephemeris seconds past J2000 (ET) to a
    character string representation of a spacecraft clock value (SCLK).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sce2s_c.html
    
    Inputs:
      int    sc     = NAIF spacecraft clock ID code.
      float  et     = Ephemeris time, specified as seconds past J2000.
    
    Returns:
      string sclkch = An SCLK string.
    """
    return cs1.sce2s(sc, et)

__copy_attributes_from(sce2s, cs1.sce2s)

#########################
# sce2t
#########################

def sce2t(sc, et):
    """
    Convert ephemeris seconds past J2000 (ET) to integral encoded spacecraft
    clock (`ticks'). For conversion to fractional ticks, (required for
    C-kernel production), see the routine sce2c.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sce2t_c.html
    
    Inputs:
      int   sc     = NAIF spacecraft ID code.
      float et     = Ephemeris time, seconds past J2000.
    
    Returns:
      float sclkdp = SCLK, encoded as ticks since spacecraft clock start.
    """
    return cs1.sce2t(sc, et)

def sce2t_vector(sc, et):
    """
    Convert ephemeris seconds past J2000 (ET) to integral encoded spacecraft
    clock (`ticks'). For conversion to fractional ticks, (required for
    C-kernel production), see the routine sce2c.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sce2t_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int      sc     = NAIF spacecraft ID code.
      float[_] et     = Ephemeris time, seconds past J2000.
    
    Returns:
      float[_] sclkdp = SCLK, encoded as ticks since spacecraft clock start.
    """
    return cs1.sce2t_vector(sc, et)

__copy_attributes_from(sce2t, cs1.sce2t)
__copy_attributes_from(sce2t_vector, cs1.sce2t_vector)

#########################
# scencd
#########################

def scencd(sc, sclkch):
    """
    Encode character representation of spacecraft clock time into a
    floating-point number.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/scencd_c.html
    
    Inputs:
      int    sc     = NAIF spacecraft identification code.
      string sclkch = Character representation of a spacecraft clock.
    
    Returns:
      float  sclkdp = Encoded representation of the clock count.
    """
    return cs1.scencd(sc, sclkch)

__copy_attributes_from(scencd, cs1.scencd)

#########################
# scfmt
#########################

def scfmt(sc, ticks):
    """
    Convert encoded spacecraft clock ticks to character clock format.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/scfmt_c.html
    
    Inputs:
      int    sc     = NAIF spacecraft identification code.
      float  ticks  = Encoded representation of a spacecraft clock count.
    
    Returns:
      string clkstr = Character representation of a clock count.
    """
    return cs1.scfmt(sc, ticks)

__copy_attributes_from(scfmt, cs1.scfmt)

#########################
# scpart
#########################

def scpart(sc):
    """
    Get spacecraft clock partition information from a spacecraft clock
    kernel file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/scpart_c.html
    
    Inputs:
      int      sc     = NAIF spacecraft identification code.
    
    Returns:
      float[*] pstart = Array of partition start times.
      float[*] pstop  = Array of partition stop times.
    """
    return cs1.scpart(sc)

__copy_attributes_from(scpart, cs1.scpart)

#########################
# scs2e
#########################

def scs2e(sc, sclkch):
    """
    Convert a spacecraft clock string to ephemeris seconds past J2000 (ET).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/scs2e_c.html
    
    Inputs:
      int    sc     = NAIF integer code for a spacecraft.
      string sclkch = An SCLK string.
    
    Returns:
      float  et     = Ephemeris time, seconds past J2000.
    """
    return cs1.scs2e(sc, sclkch)

__copy_attributes_from(scs2e, cs1.scs2e)

#########################
# sct2e
#########################

def sct2e(sc, sclkdp):
    """
    Convert encoded spacecraft clock (`ticks') to ephemeris seconds past
    J2000 (ET).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sct2e_c.html
    
    Inputs:
      int   sc     = NAIF spacecraft ID code.
      float sclkdp = SCLK, encoded as ticks since spacecraft clock start.
    
    Returns:
      float et     = Ephemeris time, seconds past J2000.
    """
    return cs1.sct2e(sc, sclkdp)

def sct2e_vector(sc, sclkdp):
    """
    Convert encoded spacecraft clock (`ticks') to ephemeris seconds past
    J2000 (ET).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sct2e_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int      sc     = NAIF spacecraft ID code.
      float[_] sclkdp = SCLK, encoded as ticks since spacecraft clock start.
    
    Returns:
      float[_] et     = Ephemeris time, seconds past J2000.
    """
    return cs1.sct2e_vector(sc, sclkdp)

__copy_attributes_from(sct2e, cs1.sct2e)
__copy_attributes_from(sct2e_vector, cs1.sct2e_vector)

#########################
# sctiks
#########################

def sctiks(sc, clkstr):
    """
    Convert a spacecraft clock format string to number of "ticks".
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sctiks_c.html
    
    Inputs:
      int    sc     = NAIF spacecraft identification code.
      string clkstr = Character representation of a spacecraft clock.
    
    Returns:
      float  ticks  = Number of ticks represented by the clock string.
    """
    return cs1.sctiks(sc, clkstr)

__copy_attributes_from(sctiks, cs1.sctiks)

#########################
# setmsg
#########################

def setmsg(message):
    """
    Set the value of the current long error message.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/setmsg_c.html
    
    Inputs:
      string message = A long error message.
    
    Returns: none
    """
    return cs1.setmsg(message)

__copy_attributes_from(setmsg, cs1.setmsg)

#########################
# shellc
#########################

def shellc(array):
    """
    Sort an array of character strings according to the ASCII collating
    sequence using the Shell Sort algorithm.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/shellc_c.html
    
    Inputs:
      string[*] array = The array.
    
    Returns:
      string[*] array = The array.
    """
    return cs1.shellc(array)

__copy_attributes_from(shellc, cs1.shellc)

#########################
# shelld
#########################

def shelld(array):
    """
    Sort a floating-point array using the Shell Sort algorithm.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/shelld_c.html
    
    Inputs:
      float array = The array to be sorted.
    
    Returns:
      float array = The array to be sorted.
    """
    return cs1.shelld(array)

__copy_attributes_from(shelld, cs1.shelld)

#########################
# shelli
#########################

def shelli(array):
    """
    Sort an integer array using the Shell Sort algorithm.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/shelli_c.html
    
    Inputs:
      int array = The array.
    
    Returns:
      int array = The array.
    """
    return cs1.shelli(array)

__copy_attributes_from(shelli, cs1.shelli)

#########################
# sigerr
#########################

def sigerr(msg):
    """
    Inform the CSPICE error processing mechanism that an error has occurred,
    and specify the type of error.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sigerr_c.html
    
    Inputs:
      string msg = A short error message.
    
    Returns: none
    """
    return cs1.sigerr(msg)

__copy_attributes_from(sigerr, cs1.sigerr)

#########################
# sincpt
#########################

def sincpt(method, target, et, fixref, abcorr, obsrvr, dref, dvec):
    """
    Given an observer and a direction vector defining a ray, compute the
    surface intercept of the ray on a target body at a specified epoch,
    optionally corrected for light time and stellar aberration.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    This routine supersedes srfxpt.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sincpt_c.html
    
    Inputs:
      string   method = Computation method: "ELLIPSOID" or
                        "DSK/UNPRIORITIZED[/SURFACES = <surface list>]".
      string   target = Name of target body.
      float    et     = Epoch in TDB seconds past J2000 TDB.
      string   fixref = Body-fixed, body-centered target body frame.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obsrvr = Name of observing body.
      string   dref   = Reference frame of ray's direction vector.
      float[3] dvec   = Ray's direction vector.
    
    Returns:
      float[3] spoint = Surface intercept point on the target body.
      float    trgepc = Intercept epoch.
      float[3] srfvec = Vector from observer to intercept point.
      bool     found  = Flag indicating whether intercept was found.
    """
    return cs1.sincpt(method, target, et, fixref, abcorr, obsrvr, dref, dvec)

def sincpt_vector(method, target, et, fixref, abcorr, obsrvr, dref, dvec):
    """
    Given an observer and a direction vector defining a ray, compute the
    surface intercept of the ray on a target body at a specified epoch,
    optionally corrected for light time and stellar aberration.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    This routine supersedes srfxpt.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sincpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method: "ELLIPSOID" or
                          "DSK/UNPRIORITIZED[/SURFACES = <surface list>]".
      string     target = Name of target body.
      float[_]   et     = Epoch in TDB seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     obsrvr = Name of observing body.
      string     dref   = Reference frame of ray's direction vector.
      float[_,3] dvec   = Ray's direction vector.
    
    Returns:
      float[_,3] spoint = Surface intercept point on the target body.
      float[_]   trgepc = Intercept epoch.
      float[_,3] srfvec = Vector from observer to intercept point.
      bool       found  = Flag indicating whether intercept was found.
    """
    return cs1.sincpt_vector(method, target, et, fixref, abcorr, obsrvr, dref, dvec)

__copy_attributes_from(sincpt, cs1.sincpt)
__copy_attributes_from(sincpt_vector, cs1.sincpt_vector)

#########################
# spd
#########################

def spd():
    """
    Return the number of seconds in a day.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spd_c.html
    
    Inputs: none
    
    Returns:
      float value = The number of seconds in a day.
    """
    return cs1.spd()

__copy_attributes_from(spd, cs1.spd)

#########################
# sphcyl
#########################

def sphcyl(radius, colat, lon):
    """
    This routine converts from spherical coordinates to cylindrical
    coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sphcyl_c.html
    
    Inputs:
      float radius = Distance of point from origin.
      float colat  = Polar angle (co-latitude in radians) of point.
      float lon    = Azimuthal angle (longitude) of point (radians).
    
    Returns:
      float r      = Distance of point from z axis.
      float lon2   = angle (radians) of point from XZ plane.
      float z      = Height of point above XY plane.
    """
    return cs1.sphcyl(radius, colat, lon)

def sphcyl_vector(radius, colat, lon):
    """
    This routine converts from spherical coordinates to cylindrical
    coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sphcyl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] radius = Distance of point from origin.
      float[_] colat  = Polar angle (co-latitude in radians) of point.
      float[_] lon    = Azimuthal angle (longitude) of point (radians).
    
    Returns:
      float[_] r      = Distance of point from z axis.
      float[_] lon2   = angle (radians) of point from XZ plane.
      float[_] z      = Height of point above XY plane.
    """
    return cs1.sphcyl_vector(radius, colat, lon)

__copy_attributes_from(sphcyl, cs1.sphcyl)
__copy_attributes_from(sphcyl_vector, cs1.sphcyl_vector)

#########################
# sphlat
#########################

def sphlat(r, colat, lon):
    """
    Convert from spherical coordinates to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sphlat_c.html
    
    Inputs:
      float r      = Distance of the point from the origin.
      float colat  = Angle of the point from positive z axis (radians).
      float lon    = Angle of the point from the XZ plane (radians).
    
    Returns:
      float radius = Distance of a point from the origin.
      float lon2   = Angle of the point from the XZ plane in radians.
      float lat    = Angle of the point from the XY plane in radians.
    """
    return cs1.sphlat(r, colat, lon)

def sphlat_vector(r, colat, lon):
    """
    Convert from spherical coordinates to latitudinal coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sphlat_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] r      = Distance of the point from the origin.
      float[_] colat  = Angle of the point from positive z axis (radians).
      float[_] lon    = Angle of the point from the XZ plane (radians).
    
    Returns:
      float[_] radius = Distance of a point from the origin.
      float[_] lon2   = Angle of the point from the XZ plane in radians.
      float[_] lat    = Angle of the point from the XY plane in radians.
    """
    return cs1.sphlat_vector(r, colat, lon)

__copy_attributes_from(sphlat, cs1.sphlat)
__copy_attributes_from(sphlat_vector, cs1.sphlat_vector)

#########################
# sphrec
#########################

def sphrec(r, colat, lon):
    """
    Convert from spherical coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sphrec_c.html
    
    Inputs:
      float    r      = Distance of a point from the origin.
      float    colat  = Angle of the point from the positive Z-axis.
      float    lon    = Angle of the point from the XZ plane in radians.
    
    Returns:
      float[3] rectan = Rectangular coordinates of the point.
    """
    return cs1.sphrec(r, colat, lon)

def sphrec_vector(r, colat, lon):
    """
    Convert from spherical coordinates to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sphrec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   r      = Distance of a point from the origin.
      float[_]   colat  = Angle of the point from the positive Z-axis.
      float[_]   lon    = Angle of the point from the XZ plane in radians.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of the point.
    """
    return cs1.sphrec_vector(r, colat, lon)

__copy_attributes_from(sphrec, cs1.sphrec)
__copy_attributes_from(sphrec_vector, cs1.sphrec_vector)

#########################
# spk14a
#########################

def spk14a(handle, ncsets, coeffs, epochs):
    """
    Add data to a type 14 SPK segment associated with `handle'.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spk14a_c.html
    
    Inputs:
      int      handle = The handle of an SPK file open for writing.
      int      ncsets = The number of coefficient sets and epochs.
      float[*] coeffs = The collection of coefficient sets.
      float[*] epochs = The epochs associated with the coefficient sets.
    
    Returns: none
    """
    return cs1.spk14a(handle, ncsets, coeffs, epochs)

__copy_attributes_from(spk14a, cs1.spk14a)

#########################
# spk14b
#########################

def spk14b(handle, segid, body, center, frame, first, last, chbdeg):
    """
    Begin a type 14 SPK segment in the SPK file associated with `handle'.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spk14b_c.html
    
    Inputs:
      int    handle = The handle of an SPK file open for writing.
      string segid  = The string to use for segment identifier.
      int    body   = The NAIF ID code for the body of the segment.
      int    center = The center of motion for body.
      string frame  = The reference frame for this segment.
      float  first  = The first epoch for which the segment is valid.
      float  last   = The last epoch for which the segment is valid.
      int    chbdeg = The degree of the Chebyshev Polynomial used.
    
    Returns: none
    """
    return cs1.spk14b(handle, segid, body, center, frame, first, last, chbdeg)

__copy_attributes_from(spk14b, cs1.spk14b)

#########################
# spk14e
#########################

def spk14e(handle):
    """
    End the type 14 SPK segment currently being written to the SPK file
    associated with `handle'.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spk14e_c.html
    
    Inputs:
      int handle = The handle of an SPK file open for writing.
    
    Returns: none
    """
    return cs1.spk14e(handle)

__copy_attributes_from(spk14e, cs1.spk14e)

#########################
# spkacs
#########################

def spkacs(targ, et, ref, abcorr, obs):
    """
    Return the state (position and velocity) of a target body relative to an
    observer, optionally corrected for light time and stellar aberration,
    expressed relative to an inertial reference frame.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkacs_c.html
    
    Inputs:
      int      targ   = Target body.
      float    et     = Observer epoch.
      string   ref    = Inertial reference frame of output state.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      int      obs    = Observer.
    
    Returns:
      float[6] starg  = State of target.
      float    lt     = One way light time between observer and target.
      float    dlt    = Derivative of light time with respect to time.
    """
    return cs1.spkacs(targ, et, ref, abcorr, obs)

def spkacs_vector(targ, et, ref, abcorr, obs):
    """
    Return the state (position and velocity) of a target body relative to an
    observer, optionally corrected for light time and stellar aberration,
    expressed relative to an inertial reference frame.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkacs_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ   = Target body.
      float[_]   et     = Observer epoch.
      string     ref    = Inertial reference frame of output state.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      int        obs    = Observer.
    
    Returns:
      float[_,6] starg  = State of target.
      float[_]   lt     = One way light time between observer and target.
      float[_]   dlt    = Derivative of light time with respect to time.
    """
    return cs1.spkacs_vector(targ, et, ref, abcorr, obs)

__copy_attributes_from(spkacs, cs1.spkacs)
__copy_attributes_from(spkacs_vector, cs1.spkacs_vector)

#########################
# spkapo
#########################

def spkapo(targ, et, ref, sobs, abcorr):
    """
    Return the position of a target body relative to an observer, optionally
    corrected for light time and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkapo_c.html
    
    Inputs:
      int      targ   = Target body.
      float    et     = Observer epoch.
      string   ref    = Inertial reference frame of observer's state.
      float[6] sobs   = State of observer wrt. solar system barycenter.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
    
    Returns:
      float[3] ptarg  = Position of target.
      float    lt     = One way light time between observer and target.
    """
    return cs1.spkapo(targ, et, ref, sobs, abcorr)

def spkapo_vector(targ, et, ref, sobs, abcorr):
    """
    Return the position of a target body relative to an observer, optionally
    corrected for light time and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkapo_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ   = Target body.
      float[_]   et     = Observer epoch.
      string     ref    = Inertial reference frame of observer's state.
      float[_,6] sobs   = State of observer wrt. solar system barycenter.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
    
    Returns:
      float[_,3] ptarg  = Position of target.
      float[_]   lt     = One way light time between observer and target.
    """
    return cs1.spkapo_vector(targ, et, ref, sobs, abcorr)

__copy_attributes_from(spkapo, cs1.spkapo)
__copy_attributes_from(spkapo_vector, cs1.spkapo_vector)

#########################
# spkapp
#########################

def spkapp(targ, et, ref, sobs, abcorr):
    """
    Return the state (position and velocity) of a target body relative to an
    observer, optionally corrected for light time and stellar aberration.
    
    WARNING: For aberration-corrected states, the velocity is not precisely
    equal to the time derivative of the position. Use spkaps instead.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkapp_c.html
    
    Inputs:
      int      targ   = Target body.
      float    et     = Observer epoch.
      string   ref    = Inertial reference frame of observer's state.
      float[6] sobs   = State of observer wrt. solar system barycenter.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
    
    Returns:
      float[6] starg  = State of target.
      float    lt     = One way light time between observer and target.
    """
    return cs1.spkapp(targ, et, ref, sobs, abcorr)

def spkapp_vector(targ, et, ref, sobs, abcorr):
    """
    Return the state (position and velocity) of a target body relative to an
    observer, optionally corrected for light time and stellar aberration.
    
    WARNING: For aberration-corrected states, the velocity is not precisely
    equal to the time derivative of the position. Use spkaps instead.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkapp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ   = Target body.
      float[_]   et     = Observer epoch.
      string     ref    = Inertial reference frame of observer's state.
      float[_,6] sobs   = State of observer wrt. solar system barycenter.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
    
    Returns:
      float[_,6] starg  = State of target.
      float[_]   lt     = One way light time between observer and target.
    """
    return cs1.spkapp_vector(targ, et, ref, sobs, abcorr)

__copy_attributes_from(spkapp, cs1.spkapp)
__copy_attributes_from(spkapp_vector, cs1.spkapp_vector)

#########################
# spkaps
#########################

def spkaps(targ, et, ref, abcorr, stobs, accobs):
    """
    Given the state and acceleration of an observer relative to the solar
    system barycenter, return the state (position and velocity) of a target
    body relative to the observer, optionally corrected for light time and
    stellar aberration. All input and output vectors are expressed relative
    to an inertial reference frame.
    
    This routine supersedes spkapp.
    
    SPICE users normally should call the high-level API routines spkezr or
    spkez rather than this routine.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkaps_c.html
    
    Inputs:
      int      targ   = Target body.
      float    et     = Observer epoch.
      string   ref    = Inertial reference frame of output state.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      float[6] stobs  = State of the observer relative to the SSB.
      float[3] accobs = Acceleration of the observer relative to the SSB.
    
    Returns:
      float[6] starg  = State of target.
      float    lt     = One way light time between observer and target.
      float    dlt    = Derivative of light time with respect to time.
    """
    return cs1.spkaps(targ, et, ref, abcorr, stobs, accobs)

def spkaps_vector(targ, et, ref, abcorr, stobs, accobs):
    """
    Given the state and acceleration of an observer relative to the solar
    system barycenter, return the state (position and velocity) of a target
    body relative to the observer, optionally corrected for light time and
    stellar aberration. All input and output vectors are expressed relative
    to an inertial reference frame.
    
    This routine supersedes spkapp.
    
    SPICE users normally should call the high-level API routines spkezr or
    spkez rather than this routine.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkaps_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ   = Target body.
      float[_]   et     = Observer epoch.
      string     ref    = Inertial reference frame of output state.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      float[_,6] stobs  = State of the observer relative to the SSB.
      float[_,3] accobs = Acceleration of the observer relative to the SSB.
    
    Returns:
      float[_,6] starg  = State of target.
      float[_]   lt     = One way light time between observer and target.
      float[_]   dlt    = Derivative of light time with respect to time.
    """
    return cs1.spkaps_vector(targ, et, ref, abcorr, stobs, accobs)

__copy_attributes_from(spkaps, cs1.spkaps)
__copy_attributes_from(spkaps_vector, cs1.spkaps_vector)

#########################
# spkcls
#########################

def spkcls(handle):
    """
    Close an open SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcls_c.html
    
    Inputs:
      int handle = Handle of the SPK file to be closed.
    
    Returns: none
    """
    return cs1.spkcls(handle)

__copy_attributes_from(spkcls, cs1.spkcls)

#########################
# spkcov
#########################

def spkcov(spk, idcode, cover = 2000):
    """
    Find the coverage window for a specified ephemeris object in a specified
    SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcov_c.html
    
    Inputs:
      string    spk    = Name of SPK file.
      int       idcode = ID code of ephemeris object.
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Returns:
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    """
    return cs1.spkcov(spk, idcode, cover)

def spkcov_error(spk, idcode, cover = 2000):
    """
    Find the coverage window for a specified ephemeris object in a specified
    SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcov_c.html
    
    Inputs:
      string    spk    = Name of SPK file.
      int       idcode = ID code of ephemeris object.
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Returns:
      SpiceCell cover  = Array giving start/stop time pairs for the
                         intervals covered.
    
    Note: Raise KeyError(BODYIDNOTFOUND) if the body is not found.
    """
    return cs1.spkcov_error(spk, idcode, cover)

__copy_attributes_from(spkcov, cs1.spkcov)
__copy_attributes_from(spkcov_error, cs1.spkcov_error)

#########################
# spkcpo
#########################

def spkcpo(target, et, outref, refloc, abcorr, obspos, obsctr, obsref):
    """
    Return the state of a specified target relative to an "observer," where
    the observer has constant position in a specified reference frame. The
    observer's position is provided by the calling program rather than by
    loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcpo_c.html
    
    Inputs:
      string   target = Name of target ephemeris object.
      float    et     = Observation epoch.
      string   outref = Reference frame of output state.
      string   refloc = Output reference frame evaluation locus.
      string   abcorr = Aberration correction.
      float[3] obspos = Observer position relative to center of motion.
      string   obsctr = Center of motion of observer.
      string   obsref = Frame of observer position.
    
    Returns:
      float[6] state  = State of target with respect to observer.
      float    lt     = One way light time between target and observer.
    """
    return cs1.spkcpo(target, et, outref, refloc, abcorr, obspos, obsctr, obsref)

def spkcpo_vector(target, et, outref, refloc, abcorr, obspos, obsctr, obsref):
    """
    Return the state of a specified target relative to an "observer," where
    the observer has constant position in a specified reference frame. The
    observer's position is provided by the calling program rather than by
    loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcpo_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     target = Name of target ephemeris object.
      float[_]   et     = Observation epoch.
      string     outref = Reference frame of output state.
      string     refloc = Output reference frame evaluation locus.
      string     abcorr = Aberration correction.
      float[_,3] obspos = Observer position relative to center of motion.
      string     obsctr = Center of motion of observer.
      string     obsref = Frame of observer position.
    
    Returns:
      float[_,6] state  = State of target with respect to observer.
      float[_]   lt     = One way light time between target and observer.
    """
    return cs1.spkcpo_vector(target, et, outref, refloc, abcorr, obspos, obsctr, obsref)

__copy_attributes_from(spkcpo, cs1.spkcpo)
__copy_attributes_from(spkcpo_vector, cs1.spkcpo_vector)

#########################
# spkcpt
#########################

def spkcpt(trgpos, trgctr, trgref, et, outref, refloc, abcorr, obsrvr):
    """
    Return the state, relative to a specified observer, of a target having
    constant position in a specified reference frame. The target's position
    is provided by the calling program rather than by loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcpt_c.html
    
    Inputs:
      float[3] trgpos = Target position relative to center of motion.
      string   trgctr = Center of motion of target.
      string   trgref = Frame of target position.
      float    et     = Observation epoch.
      string   outref = Reference frame of output state.
      string   refloc = Output reference frame evaluation locus.
      string   abcorr = Aberration correction.
      string   obsrvr = Name of observing ephemeris object.
    
    Returns:
      float[6] state  = State of target with respect to observer.
      float    lt     = One way light time between target and observer.
    """
    return cs1.spkcpt(trgpos, trgctr, trgref, et, outref, refloc, abcorr, obsrvr)

def spkcpt_vector(trgpos, trgctr, trgref, et, outref, refloc, abcorr, obsrvr):
    """
    Return the state, relative to a specified observer, of a target having
    constant position in a specified reference frame. The target's position
    is provided by the calling program rather than by loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] trgpos = Target position relative to center of motion.
      string     trgctr = Center of motion of target.
      string     trgref = Frame of target position.
      float[_]   et     = Observation epoch.
      string     outref = Reference frame of output state.
      string     refloc = Output reference frame evaluation locus.
      string     abcorr = Aberration correction.
      string     obsrvr = Name of observing ephemeris object.
    
    Returns:
      float[_,6] state  = State of target with respect to observer.
      float[_]   lt     = One way light time between target and observer.
    """
    return cs1.spkcpt_vector(trgpos, trgctr, trgref, et, outref, refloc, abcorr, obsrvr)

__copy_attributes_from(spkcpt, cs1.spkcpt)
__copy_attributes_from(spkcpt_vector, cs1.spkcpt_vector)

#########################
# spkcvo
#########################

def spkcvo(target, et, outref, refloc, abcorr, obssta, obsepc, obsctr, obsref):
    """
    Return the state of a specified target relative to an "observer," where
    the observer has constant velocity in a specified reference frame. The
    observer's state is provided by the calling program rather than by
    loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcvo_c.html
    
    Inputs:
      string   target = Name of target ephemeris object.
      float    et     = Observation epoch.
      string   outref = Reference frame of output state.
      string   refloc = Output reference frame evaluation locus.
      string   abcorr = Aberration correction.
      float[6] obssta = Observer state relative to center of motion.
      float    obsepc = Epoch of observer state.
      string   obsctr = Center of motion of observer.
      string   obsref = Frame of observer state.
    
    Returns:
      float[6] state  = State of target with respect to observer.
      float    lt     = One way light time between target and observer.
    """
    return cs1.spkcvo(target, et, outref, refloc, abcorr, obssta, obsepc, obsctr, obsref)

def spkcvo_vector(target, et, outref, refloc, abcorr, obssta, obsepc, obsctr, obsref):
    """
    Return the state of a specified target relative to an "observer," where
    the observer has constant velocity in a specified reference frame. The
    observer's state is provided by the calling program rather than by
    loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcvo_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     target = Name of target ephemeris object.
      float[_]   et     = Observation epoch.
      string     outref = Reference frame of output state.
      string     refloc = Output reference frame evaluation locus.
      string     abcorr = Aberration correction.
      float[_,6] obssta = Observer state relative to center of motion.
      float[_]   obsepc = Epoch of observer state.
      string     obsctr = Center of motion of observer.
      string     obsref = Frame of observer state.
    
    Returns:
      float[_,6] state  = State of target with respect to observer.
      float[_]   lt     = One way light time between target and observer.
    """
    return cs1.spkcvo_vector(target, et, outref, refloc, abcorr, obssta, obsepc, obsctr, obsref)

__copy_attributes_from(spkcvo, cs1.spkcvo)
__copy_attributes_from(spkcvo_vector, cs1.spkcvo_vector)

#########################
# spkcvt
#########################

def spkcvt(trgsta, trgepc, trgctr, trgref, et, outref, refloc, abcorr, obsrvr):
    """
    Return the state, relative to a specified observer, of a target having
    constant velocity in a specified reference frame. The target's state is
    provided by the calling program rather than by loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcvt_c.html
    
    Inputs:
      float[6] trgsta = Target state relative to center of motion.
      float    trgepc = Epoch of target state.
      string   trgctr = Center of motion of target.
      string   trgref = Frame of target state.
      float    et     = Observation epoch.
      string   outref = Reference frame of output state.
      string   refloc = Output reference frame evaluation locus.
      string   abcorr = Aberration correction.
      string   obsrvr = Name of observing ephemeris object.
    
    Returns:
      float[6] state  = State of target with respect to observer.
      float    lt     = One way light time between target and observer.
    """
    return cs1.spkcvt(trgsta, trgepc, trgctr, trgref, et, outref, refloc, abcorr, obsrvr)

def spkcvt_vector(trgsta, trgepc, trgctr, trgref, et, outref, refloc, abcorr, obsrvr):
    """
    Return the state, relative to a specified observer, of a target having
    constant velocity in a specified reference frame. The target's state is
    provided by the calling program rather than by loaded SPK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkcvt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] trgsta = Target state relative to center of motion.
      float[_]   trgepc = Epoch of target state.
      string     trgctr = Center of motion of target.
      string     trgref = Frame of target state.
      float[_]   et     = Observation epoch.
      string     outref = Reference frame of output state.
      string     refloc = Output reference frame evaluation locus.
      string     abcorr = Aberration correction.
      string     obsrvr = Name of observing ephemeris object.
    
    Returns:
      float[_,6] state  = State of target with respect to observer.
      float[_]   lt     = One way light time between target and observer.
    """
    return cs1.spkcvt_vector(trgsta, trgepc, trgctr, trgref, et, outref, refloc, abcorr, obsrvr)

__copy_attributes_from(spkcvt, cs1.spkcvt)
__copy_attributes_from(spkcvt_vector, cs1.spkcvt_vector)

#########################
# spkez
#########################

def spkez(targ, et, ref, abcorr, obs):
    """
    Return the state (position and velocity) of a target body relative to an
    observing body, optionally corrected for light time (planetary
    aberration) and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkez_c.html
    
    Inputs:
      int      targ   = Target body.
      float    et     = Observer epoch.
      string   ref    = Reference frame of output state vector.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      int      obs    = Observing body.
    
    Returns:
      float[6] starg  = State of target.
      float    lt     = One way light time between observer and target.
    """
    return cs1.spkez(targ, et, ref, abcorr, obs)

def spkez_vector(targ, et, ref, abcorr, obs):
    """
    Return the state (position and velocity) of a target body relative to an
    observing body, optionally corrected for light time (planetary
    aberration) and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkez_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ   = Target body.
      float[_]   et     = Observer epoch.
      string     ref    = Reference frame of output state vector.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      int        obs    = Observing body.
    
    Returns:
      float[_,6] starg  = State of target.
      float[_]   lt     = One way light time between observer and target.
    """
    return cs1.spkez_vector(targ, et, ref, abcorr, obs)

__copy_attributes_from(spkez, cs1.spkez)
__copy_attributes_from(spkez_vector, cs1.spkez_vector)

#########################
# spkezp
#########################

def spkezp(targ, et, ref, abcorr, obs):
    """
    Return the position of a target body relative to an observing body,
    optionally corrected for light time (planetary aberration) and stellar
    aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkezp_c.html
    
    Inputs:
      int      targ   = Target body NAIF ID code.
      float    et     = Observer epoch.
      string   ref    = Reference frame of output position vector.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      int      obs    = Observing body NAIF ID code.
    
    Returns:
      float[3] ptarg  = Position of target.
      float    lt     = One way light time between observer and target.
    """
    return cs1.spkezp(targ, et, ref, abcorr, obs)

def spkezp_vector(targ, et, ref, abcorr, obs):
    """
    Return the position of a target body relative to an observing body,
    optionally corrected for light time (planetary aberration) and stellar
    aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkezp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ   = Target body NAIF ID code.
      float[_]   et     = Observer epoch.
      string     ref    = Reference frame of output position vector.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      int        obs    = Observing body NAIF ID code.
    
    Returns:
      float[_,3] ptarg  = Position of target.
      float[_]   lt     = One way light time between observer and target.
    """
    return cs1.spkezp_vector(targ, et, ref, abcorr, obs)

__copy_attributes_from(spkezp, cs1.spkezp)
__copy_attributes_from(spkezp_vector, cs1.spkezp_vector)

#########################
# spkezr
#########################

def spkezr(targ, et, ref, abcorr, obs):
    """
    Return the state (position and velocity) of a target body relative to an
    observing body, optionally corrected for light time (planetary
    aberration) and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkezr_c.html
    
    Inputs:
      string   targ   = Target body name.
      float    et     = Observer epoch.
      string   ref    = Reference frame of output state vector.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obs    = Observing body name.
    
    Returns:
      float[6] starg  = State of target.
      float    lt     = One way light time between observer and target.
    """
    return cs1.spkezr(targ, et, ref, abcorr, obs)

def spkezr_vector(targ, et, ref, abcorr, obs):
    """
    Return the state (position and velocity) of a target body relative to an
    observing body, optionally corrected for light time (planetary
    aberration) and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkezr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     targ   = Target body name.
      float[_]   et     = Observer epoch.
      string     ref    = Reference frame of output state vector.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     obs    = Observing body name.
    
    Returns:
      float[_,6] starg  = State of target.
      float[_]   lt     = One way light time between observer and target.
    """
    return cs1.spkezr_vector(targ, et, ref, abcorr, obs)

__copy_attributes_from(spkezr, cs1.spkezr)
__copy_attributes_from(spkezr_vector, cs1.spkezr_vector)

#########################
# spkgeo
#########################

def spkgeo(targ, et, ref, obs):
    """
    Compute the geometric state (position and velocity) of a target body
    relative to an observing body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkgeo_c.html
    
    Inputs:
      int      targ  = Target body code.
      float    et    = Target epoch.
      string   ref   = Target reference frame name.
      int      obs   = Observing body code.
    
    Returns:
      float[6] state = State of target.
      float    lt    = Light time.
    """
    return cs1.spkgeo(targ, et, ref, obs)

def spkgeo_vector(targ, et, ref, obs):
    """
    Compute the geometric state (position and velocity) of a target body
    relative to an observing body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkgeo_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ  = Target body code.
      float[_]   et    = Target epoch.
      string     ref   = Target reference frame name.
      int        obs   = Observing body code.
    
    Returns:
      float[_,6] state = State of target.
      float[_]   lt    = Light time.
    """
    return cs1.spkgeo_vector(targ, et, ref, obs)

__copy_attributes_from(spkgeo, cs1.spkgeo)
__copy_attributes_from(spkgeo_vector, cs1.spkgeo_vector)

#########################
# spkgps
#########################

def spkgps(targ, et, ref, obs):
    """
    Compute the geometric position of a target body relative to an observing
    body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkgps_c.html
    
    Inputs:
      int      targ = Target body code.
      float    et   = Target epoch.
      string   ref  = Target reference frame name.
      int      obs  = Observing body code.
    
    Returns:
      float[3] pos  = Position of target.
      float    lt   = Light time.
    """
    return cs1.spkgps(targ, et, ref, obs)

def spkgps_vector(targ, et, ref, obs):
    """
    Compute the geometric position of a target body relative to an observing
    body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkgps_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ = Target body code.
      float[_]   et   = Target epoch.
      string     ref  = Target reference frame name.
      int        obs  = Observing body code.
    
    Returns:
      float[_,3] pos  = Position of target.
      float[_]   lt   = Light time.
    """
    return cs1.spkgps_vector(targ, et, ref, obs)

__copy_attributes_from(spkgps, cs1.spkgps)
__copy_attributes_from(spkgps_vector, cs1.spkgps_vector)

#########################
# spklef
#########################

def spklef(fname):
    """
    Load an ephemeris file for use by the readers. Return that file's
    handle, to be used by other SPK routines to refer to the file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spklef_c.html
    
    Inputs:
      string fname  = Name of the file to be loaded.
    
    Returns:
      int    handle = Loaded file's handle.
    """
    return cs1.spklef(fname)

__copy_attributes_from(spklef, cs1.spklef)

#########################
# spkltc
#########################

def spkltc(targ, et, ref, abcorr, stobs):
    """
    Return the state (position and velocity) of a target body relative to an
    observer, optionally corrected for light time, expressed relative to an
    inertial reference frame.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkltc_c.html
    
    Inputs:
      int      targ   = Target body code.
      float    et     = Observer epoch.
      string   ref    = Inertial reference frame name of output state.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      float[6] stobs  = State of the observer relative to the SSB.
    
    Returns:
      float[6] starg  = State of target.
      float    lt     = One way light time between observer and target.
      float    dlt    = Derivative of light time with respect to time.
    """
    return cs1.spkltc(targ, et, ref, abcorr, stobs)

def spkltc_vector(targ, et, ref, abcorr, stobs):
    """
    Return the state (position and velocity) of a target body relative to an
    observer, optionally corrected for light time, expressed relative to an
    inertial reference frame.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkltc_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ   = Target body code.
      float[_]   et     = Observer epoch.
      string     ref    = Inertial reference frame name of output state.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      float[_,6] stobs  = State of the observer relative to the SSB.
    
    Returns:
      float[_,6] starg  = State of target.
      float[_]   lt     = One way light time between observer and target.
      float[_]   dlt    = Derivative of light time with respect to time.
    """
    return cs1.spkltc_vector(targ, et, ref, abcorr, stobs)

__copy_attributes_from(spkltc, cs1.spkltc)
__copy_attributes_from(spkltc_vector, cs1.spkltc_vector)

#########################
# spkobj
#########################

def spkobj(spk, ids = 1000):
    """
    Find the set of ID codes of all objects in a specified SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkobj_c.html
    
    Inputs:
      string spk = Name of SPK file.
      int    ids = Array of ID codes of objects in SPK file.
    
    Returns:
      int    ids = Array of ID codes of objects in SPK file.
    """
    return cs1.spkobj(spk, ids)

__copy_attributes_from(spkobj, cs1.spkobj)

#########################
# spkopa
#########################

def spkopa(file):
    """
    Open an existing SPK file for subsequent write.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkopa_c.html
    
    Inputs:
      string file   = The name of an existing SPK file.
    
    Returns:
      int    handle = Handle attached to the SPK file opened to append.
    """
    return cs1.spkopa(file)

__copy_attributes_from(spkopa, cs1.spkopa)

#########################
# spkopn
#########################

def spkopn(fname, ifname, ncomch):
    """
    Create a new SPK file, returning the handle of the opened file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkopn_c.html
    
    Inputs:
      string fname  = The name of the new SPK file to be created.
      string ifname = The internal filename for the SPK file.
      int    ncomch = The number of characters to reserve for comments.
    
    Returns:
      int    handle = The handle of the opened SPK file.
    """
    return cs1.spkopn(fname, ifname, ncomch)

__copy_attributes_from(spkopn, cs1.spkopn)

#########################
# spkpds
#########################

def spkpds(body, center, frame, type, first, last):
    """
    Perform routine error checks and if all check pass, pack the descriptor
    for an SPK segment
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkpds_c.html
    
    Inputs:
      int      body   = The NAIF ID code for the body of the segment.
      int      center = The center of motion for body.
      string   frame  = The frame for this segment.
      int      type   = The type of SPK segment to create.
      float    first  = The first epoch for which the segment is valid.
      float    last   = The last epoch for which the segment is valid.
    
    Returns:
      float[5] descr  = An SPK segment descriptor.
    """
    return cs1.spkpds(body, center, frame, type, first, last)

__copy_attributes_from(spkpds, cs1.spkpds)

#########################
# spkpos
#########################

def spkpos(targ, et, ref, abcorr, obs):
    """
    Return the position of a target body relative to an observing body,
    optionally corrected for light time (planetary aberration) and stellar
    aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkpos_c.html
    
    Inputs:
      string   targ   = Target body name.
      float    et     = Observer epoch.
      string   ref    = Reference frame of output position vector.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obs    = Observing body name.
    
    Returns:
      float[3] ptarg  = Position of target.
      float    lt     = One way light time between observer and target.
    """
    return cs1.spkpos(targ, et, ref, abcorr, obs)

def spkpos_vector(targ, et, ref, abcorr, obs):
    """
    Return the position of a target body relative to an observing body,
    optionally corrected for light time (planetary aberration) and stellar
    aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkpos_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     targ   = Target body name.
      float[_]   et     = Observer epoch.
      string     ref    = Reference frame of output position vector.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     obs    = Observing body name.
    
    Returns:
      float[_,3] ptarg  = Position of target.
      float[_]   lt     = One way light time between observer and target.
    """
    return cs1.spkpos_vector(targ, et, ref, abcorr, obs)

__copy_attributes_from(spkpos, cs1.spkpos)
__copy_attributes_from(spkpos_vector, cs1.spkpos_vector)

#########################
# spkpvn
#########################

def spkpvn(handle, descr, et):
    """
    Return, for a specified SPK segment and time, the state (position and
    velocity) of the segment's target body relative to its center of motion.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkpvn_c.html
    
    Inputs:
      int      handle = File handle.
      float[5] descr  = Segment descriptor.
      float    et     = Evaluation epoch.
    
    Returns:
      int      ref    = Segment reference frame ID code.
      float[6] state  = Output state vector.
      int      center = Center of state.
    """
    return cs1.spkpvn(handle, descr, et)

__copy_attributes_from(spkpvn, cs1.spkpvn)

#########################
# spksfs
#########################

def spksfs(body, et):
    """
    Search through loaded SPK files to find the highest-priority segment
    applicable to the body and time specified and buffer searched segments
    in the process, to attempt to avoid re-reading files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spksfs_c.html
    
    Inputs:
      int      body   = Body ID.
      float    et     = Ephemeris time.
    
    Returns:
      int      handle = Handle of file containing the applicable segment.
      float[5] descr  = Descriptor of the applicable segment.
      string   ident  = Identifier of the applicable segment.
      bool     found  = Indicates whether or not a segment was found.
    """
    return cs1.spksfs(body, et)

def spksfs_error(body, et):
    """
    Search through loaded SPK files to find the highest-priority segment
    applicable to the body and time specified and buffer searched segments
    in the process, to attempt to avoid re-reading files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spksfs_c.html
    
    Inputs:
      int      body   = Body ID.
      float    et     = Ephemeris time.
    
    Returns:
      int      handle = Handle of file containing the applicable segment.
      float[5] descr  = Descriptor of the applicable segment.
      string   ident  = Identifier of the applicable segment.
    
    Note: Raise IOError(SPKINSUFFDATA) if the requested information is
    unavailable.
    """
    return cs1.spksfs_error(body, et)

__copy_attributes_from(spksfs, cs1.spksfs)
__copy_attributes_from(spksfs_error, cs1.spksfs_error)

#########################
# spkssb
#########################

def spkssb(targ, et, ref):
    """
    Return the state (position and velocity) of a target body relative to
    the solar system barycenter.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkssb_c.html
    
    Inputs:
      int      targ  = Target body code.
      float    et    = Target epoch.
      string   ref   = Target reference frame name.
    
    Returns:
      float[6] starg = State of target.
    """
    return cs1.spkssb(targ, et, ref)

def spkssb_vector(targ, et, ref):
    """
    Return the state (position and velocity) of a target body relative to
    the solar system barycenter.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkssb_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        targ  = Target body code.
      float[_]   et    = Target epoch.
      string     ref   = Target reference frame name.
    
    Returns:
      float[_,6] starg = State of target.
    """
    return cs1.spkssb_vector(targ, et, ref)

__copy_attributes_from(spkssb, cs1.spkssb)
__copy_attributes_from(spkssb_vector, cs1.spkssb_vector)

#########################
# spksub
#########################

def spksub(handle, descr, ident, begin, end, newh):
    """
    Extract a subset of the data in an SPK segment into a separate segment.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spksub_c.html
    
    Inputs:
      int      handle = Handle of source segment.
      float[5] descr  = Descriptor of source segment.
      string   ident  = Identifier of source segment.
      float    begin  = Beginning (initial epoch) of subset.
      float    end    = End (final epoch) of subset.
      int      newh   = Handle of new segment.
    
    Returns: none
    """
    return cs1.spksub(handle, descr, ident, begin, end, newh)

__copy_attributes_from(spksub, cs1.spksub)

#########################
# spkuds
#########################

def spkuds(descr):
    """
    Unpack the contents of an SPK segment descriptor.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkuds_c.html
    
    Inputs:
      float[5] descr  = An SPK segment descriptor.
    
    Returns:
      int      body   = The NAIF ID code for the body of the segment.
      int      center = The center of motion for `body'.
      int      frame  = The code for the frame of this segment.
      int      type   = The type of SPK segment.
      float    first  = The first epoch for which the segment is valid.
      float    last   = The last epoch for which the segment is valid.
      int      baddrs = Beginning DAF address of the segment.
      int      eaddrs = Ending DAF address of the segment.
    """
    return cs1.spkuds(descr)

__copy_attributes_from(spkuds, cs1.spkuds)

#########################
# spkuef
#########################

def spkuef(handle):
    """
    Unload an ephemeris file so that it will no longer be searched by the
    readers.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkuef_c.html
    
    Inputs:
      int handle = Handle of file to be unloaded
    
    Returns: none
    """
    return cs1.spkuef(handle)

__copy_attributes_from(spkuef, cs1.spkuef)

#########################
# spkw02
#########################

def spkw02(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, btime):
    """
    Write a type 2 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw02_c.html
    
    Inputs:
      int      handle = Handle of an SPK file open for writing.
      int      body   = Body code for ephemeris object.
      int      center = Body code for the center of motion of the body.
      string   frame  = The reference frame of the states.
      float    first  = First valid time for which states can be computed.
      float    last   = Last valid time for which states can be computed.
      string   segid  = Segment identifier.
      float    intlen = Length of time covered by logical record.
      int      n      = Number of coefficient sets.
      int      polydg = Chebyshev polynomial degree.
      float[*] cdata  = Array of Chebyshev coefficients.
      float    btime  = Begin time of first logical record.
    
    Returns: none
    """
    return cs1.spkw02(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, btime)

__copy_attributes_from(spkw02, cs1.spkw02)

#########################
# spkw03
#########################

def spkw03(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, btime):
    """
    Write a type 3 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw03_c.html
    
    Inputs:
      int      handle = Handle of SPK file open for writing.
      int      body   = NAIF code for ephemeris object.
      int      center = NAIF code for the center of motion of the body.
      string   frame  = Reference frame name.
      float    first  = Start time of interval covered by segment.
      float    last   = End time of interval covered by segment.
      string   segid  = Segment identifier.
      float    intlen = Length of time covered by record.
      int      n      = Number of records in segment.
      int      polydg = Chebyshev polynomial degree.
      float[*] cdata  = Array of Chebyshev coefficients.
      float    btime  = Begin time of first record.
    
    Returns: none
    """
    return cs1.spkw03(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, btime)

__copy_attributes_from(spkw03, cs1.spkw03)

#########################
# spkw05
#########################

def spkw05(handle, body, center, frame, first, last, segid, gm, n, states, epochs):
    """
    Write an SPK segment of type 5 given a time-ordered set of discrete
    states and epochs, and the gravitational parameter of a central body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw05_c.html
    
    Inputs:
      int        handle = Handle of an SPK file open for writing.
      int        body   = Body code for ephemeris object.
      int        center = Body code for the center of motion of the body.
      string     frame  = The reference frame of the states.
      float      first  = First valid time for which states can be computed.
      float      last   = Last valid time for which states can be computed.
      string     segid  = Segment identifier.
      float      gm     = Gravitational parameter of central body.
      int        n      = Number of states and epochs.
      float[*,6] states = States.
      float[*]   epochs = Epochs.
    
    Returns: none
    """
    return cs1.spkw05(handle, body, center, frame, first, last, segid, gm, n, states, epochs)

__copy_attributes_from(spkw05, cs1.spkw05)

#########################
# spkw08
#########################

def spkw08(handle, body, center, frame, first, last, segid, degree, n, states, begtim, step):
    """
    Write a type 8 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw08_c.html
    
    Inputs:
      int        handle = Handle of an SPK file open for writing.
      int        body   = NAIF code for an ephemeris object.
      int        center = NAIF code for center of motion of BODY.
      string     frame  = Reference frame name.
      float      first  = Start time of interval covered by segment.
      float      last   = End time of interval covered by segment.
      string     segid  = Segment identifier.
      int        degree = Degree of interpolating polynomials.
      int        n      = Number of states.
      float[*,6] states = Array of states.
      float      begtim = Epoch of first state in states array.
      float      step   = Time step separating epochs of states.
    
    Returns: none
    """
    return cs1.spkw08(handle, body, center, frame, first, last, segid, degree, n, states, begtim, step)

__copy_attributes_from(spkw08, cs1.spkw08)

#########################
# spkw09
#########################

def spkw09(handle, body, center, frame, first, last, segid, degree, n, states, epochs):
    """
    Write a type 9 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw09_c.html
    
    Inputs:
      int        handle = Handle of an SPK file open for writing.
      int        body   = NAIF code for an ephemeris object.
      int        center = NAIF code for center of motion of body.
      string     frame  = Reference frame name.
      float      first  = Start time of interval covered by segment.
      float      last   = End time of interval covered by segment.
      string     segid  = Segment identifier.
      int        degree = Degree of interpolating polynomials.
      int        n      = Number of states.
      float[*,6] states = Array of states.
      float[*]   epochs = Array of epochs corresponding to states.
    
    Returns: none
    """
    return cs1.spkw09(handle, body, center, frame, first, last, segid, degree, n, states, epochs)

__copy_attributes_from(spkw09, cs1.spkw09)

#########################
# spkw10
#########################

def spkw10(handle, body, center, frame, first, last, segid, consts, n, elems, epochs):
    """
    Write an SPK type 10 segment to the file specified by the input
    `handle'.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw10_c.html
    
    Inputs:
      int      handle = The handle of a DAF file open for writing.
      int      body   = The NAIF ID code for the body of the segment.
      int      center = The center of motion for `body'.
      string   frame  = The reference frame for this segment.
      float    first  = The first epoch for which the segment is valid.
      float    last   = The last epoch for which the segment is valid.
      string   segid  = The string to use for segment identifier.
      float[8] consts = Array of geophysical constants for the segment.
      int      n      = The number of element/epoch pairs to be stored
      float[*] elems  = The collection of "two-line" element sets.
      float[*] epochs = The epochs associated with the element sets.
    
    Returns: none
    """
    return cs1.spkw10(handle, body, center, frame, first, last, segid, consts, n, elems, epochs)

__copy_attributes_from(spkw10, cs1.spkw10)

#########################
# spkw12
#########################

def spkw12(handle, body, center, frame, first, last, segid, degree, n, states, begtim, step):
    """
    Write a type 12 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw12_c.html
    
    Inputs:
      int        handle = Handle of an SPK file open for writing.
      int        body   = NAIF code for an ephemeris object.
      int        center = NAIF code for center of motion of body.
      string     frame  = Reference frame name.
      float      first  = Start time of interval covered by segment.
      float      last   = End time of interval covered by segment.
      string     segid  = Segment identifier.
      int        degree = Degree of interpolating polynomials.
      int        n      = Number of states.
      float[*,6] states = Array of states.
      float      begtim = Epoch of first state in states array.
      float      step   = Time step separating epochs of states.
    
    Returns: none
    """
    return cs1.spkw12(handle, body, center, frame, first, last, segid, degree, n, states, begtim, step)

__copy_attributes_from(spkw12, cs1.spkw12)

#########################
# spkw13
#########################

def spkw13(handle, body, center, frame, first, last, segid, degree, n, states, epochs):
    """
    Write a type 13 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw13_c.html
    
    Inputs:
      int        handle = Handle of an SPK file open for writing.
      int        body   = NAIF code for an ephemeris object.
      int        center = NAIF code for center of motion of body.
      string     frame  = Reference frame name.
      float      first  = Start time of interval covered by segment.
      float      last   = End time of interval covered by segment.
      string     segid  = Segment identifier.
      int        degree = Degree of interpolating polynomials.
      int        n      = Number of states.
      float[*,6] states = Array of states.
      float[*]   epochs = Array of epochs corresponding to states.
    
    Returns: none
    """
    return cs1.spkw13(handle, body, center, frame, first, last, segid, degree, n, states, epochs)

__copy_attributes_from(spkw13, cs1.spkw13)

#########################
# spkw15
#########################

def spkw15(handle, body, center, frame, first, last, segid, epoch, tp, pa, p, ecc, j2flg, pv, gm, j2, radius):
    """
    Write an SPK segment of type 15 given a type 15 data record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw15_c.html
    
    Inputs:
      int      handle = Handle of an SPK file open for writing.
      int      body   = Body code for ephemeris object.
      int      center = Body code for the center of motion of the body.
      string   frame  = The reference frame of the states.
      float    first  = First valid time for which states can be computed.
      float    last   = Last valid time for which states can be computed.
      string   segid  = Segment identifier.
      float    epoch  = Epoch of the periapse.
      float[3] tp     = Trajectory pole vector.
      float[3] pa     = Periapsis vector.
      float    p      = Semi-latus rectum.
      float    ecc    = Eccentricity.
      float    j2flg  = J2 processing flag.
      float[3] pv     = Central body pole vector.
      float    gm     = Central body GM.
      float    j2     = Central body J2.
      float    radius = Equatorial radius of central body.
    
    Returns: none
    """
    return cs1.spkw15(handle, body, center, frame, first, last, segid, epoch, tp, pa, p, ecc, j2flg, pv, gm, j2, radius)

__copy_attributes_from(spkw15, cs1.spkw15)

#########################
# spkw17
#########################

def spkw17(handle, body, center, frame, first, last, segid, epoch, eqel, rapol, decpol):
    """
    Write an SPK segment of type 17 given a type 17 data record.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw17_c.html
    
    Inputs:
      int      handle = Handle of an SPK file open for writing.
      int      body   = Body code for ephemeris object.
      int      center = Body code for the center of motion of the body.
      string   frame  = The reference frame of the states.
      float    first  = First valid time for which states can be computed.
      float    last   = Last valid time for which states can be computed.
      string   segid  = Segment identifier.
      float    epoch  = Epoch of elements in seconds past J2000.
      float[9] eqel   = Array of equinoctial elements.
      float    rapol  = Right Ascension of the reference plane's pole.
      float    decpol = Declination of the reference plane's pole.
    
    Returns: none
    """
    return cs1.spkw17(handle, body, center, frame, first, last, segid, epoch, eqel, rapol, decpol)

__copy_attributes_from(spkw17, cs1.spkw17)

#########################
# spkw18
#########################

def spkw18(handle, subtyp, body, center, frame, first, last, segid, degree, n, packts, epochs):
    """
    Write a type 18 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw18_c.html
    
    Inputs:
      int      handle = Handle of an SPK file open for writing.
      string   subtyp = SPK type 18 subtype code.
      int      body   = NAIF code for an ephemeris object.
      int      center = NAIF code for center of motion of `body'.
      string   frame  = Reference frame name.
      float    first  = Start time of interval covered by segment.
      float    last   = End time of interval covered by segment.
      string   segid  = Segment identifier.
      int      degree = Degree of interpolating polynomials.
      int      n      = Number of packets.
      float[*] packts = Array of packets.
      float[*] epochs = Array of epochs corresponding to packets.
    
    Returns: none
    """
    return cs1.spkw18(handle, subtyp, body, center, frame, first, last, segid, degree, n, packts, epochs)

__copy_attributes_from(spkw18, cs1.spkw18)

#########################
# spkw20
#########################

def spkw20(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, dscale, tscale, initjd, initfr):
    """
    Write a type 20 segment to an SPK file.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkw20_c.html
    
    Inputs:
      int      handle = Handle of SPK file open for writing.
      int      body   = NAIF code for ephemeris object.
      int      center = NAIF code for the center of motion of the body.
      string   frame  = Reference frame name.
      float    first  = Start time of interval covered by segment.
      float    last   = End time of interval covered by segment.
      string   segid  = Segment identifier.
      float    intlen = Length of time covered by logical record (days).
      int      n      = Number of logical records in segment.
      int      polydg = Chebyshev polynomial degree.
      float[*] cdata  = Array of Chebyshev coefficients and positions.
      float    dscale = Distance scale of data.
      float    tscale = Time scale of data.
      float    initjd = Integer part of begin time (TDB Julian date) of
                        first record.
      float    initfr = Fractional part of begin time (TDB Julian date) of
                        first record.
    
    Returns: none
    """
    return cs1.spkw20(handle, body, center, frame, first, last, segid, intlen, n, polydg, cdata, dscale, tscale, initjd, initfr)

__copy_attributes_from(spkw20, cs1.spkw20)

#########################
# srfc2s
#########################

def srfc2s(code, bodyid):
    """
    Translate a surface ID code, together with a body ID code, to the
    corresponding surface name. If no such name exists, return a string
    representation of the surface ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfc2s_c.html
    
    Inputs:
      surface_code code   = Integer surface ID code to translate to a
                            string.
      int          bodyid = ID code of body associated with surface.
    
    Returns:
      surface_name srfstr = String corresponding to surface ID code.
      bool         isname = Logical flag indicating output is a surface
                            name.
    """
    return cs1.srfc2s(code, bodyid)

def srfc2s_error(code, bodyid):
    """
    Translate a surface ID code, together with a body ID code, to the
    corresponding surface name. If no such name exists, return a string
    representation of the surface ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfc2s_c.html
    
    Inputs:
      surface_code code   = Integer surface ID code to translate to a
                            string.
      int          bodyid = ID code of body associated with surface.
    
    Returns:
      surface_name srfstr = String corresponding to surface ID code.
      bool         isname = Logical flag indicating output is a surface
                            name.
    
    Note: Raise KeyError(NOTRANSLATION) if surface not found.
    """
    return cs1.srfc2s_error(code, bodyid)

__copy_attributes_from(srfc2s, cs1.srfc2s)
__copy_attributes_from(srfc2s_error, cs1.srfc2s_error)

#########################
# srfcss
#########################

def srfcss(code, bodstr):
    """
    Translate a surface ID code, together with a body string, to the
    corresponding surface name. If no such surface name exists, return a
    string representation of the surface ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfcss_c.html
    
    Inputs:
      surface_code code   = Integer surface ID code to translate to a
                            string.
      string       bodstr = Name or ID of body associated with surface.
    
    Returns:
      surface_name srfstr = String corresponding to surface ID code.
      bool         isname = Flag indicating whether output is a surface
                            name.
    """
    return cs1.srfcss(code, bodstr)

def srfcss_error(code, bodstr):
    """
    Translate a surface ID code, together with a body string, to the
    corresponding surface name. If no such surface name exists, return a
    string representation of the surface ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfcss_c.html
    
    Inputs:
      surface_code code   = Integer surface ID code to translate to a
                            string.
      string       bodstr = Name or ID of body associated with surface.
    
    Returns:
      surface_name srfstr = String corresponding to surface ID code.
    
    Note: Raise KeyError(NOTRANSLATION) if surface not found.
    """
    return cs1.srfcss_error(code, bodstr)

__copy_attributes_from(srfcss, cs1.srfcss)
__copy_attributes_from(srfcss_error, cs1.srfcss_error)

#########################
# srfnrm
#########################

def srfnrm(method, target, et, fixref, srfpts):
    """
    Map array of surface points on a specified target body to the
    corresponding unit length outward surface normal vectors.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfnrm_c.html
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float      et     = Epoch in TDB seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      float[*,3] srfpts = Array of surface points.
    
    Returns:
      float[*,3] normls = Array of outward, unit length normal vectors.
    """
    return cs1.srfnrm(method, target, et, fixref, srfpts)

__copy_attributes_from(srfnrm, cs1.srfnrm)

#########################
# srfrec
#########################

def srfrec(body, lon, lat):
    """
    Convert planetocentric latitude and longitude of a surface point on a
    specified body to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfrec_c.html
    
    Inputs:
      int      body   = NAIF integer code of an extended body.
      float    lon    = Longitude of point in radians.
      float    lat    = Latitude of point in radians.
    
    Returns:
      float[3] rectan = Rectangular coordinates of the point.
    """
    return cs1.srfrec(body, lon, lat)

def srfrec_vector(body, lon, lat):
    """
    Convert planetocentric latitude and longitude of a surface point on a
    specified body to rectangular coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfrec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      int        body   = NAIF integer code of an extended body.
      float[_]   lon    = Longitude of point in radians.
      float[_]   lat    = Latitude of point in radians.
    
    Returns:
      float[_,3] rectan = Rectangular coordinates of the point.
    """
    return cs1.srfrec_vector(body, lon, lat)

__copy_attributes_from(srfrec, cs1.srfrec)
__copy_attributes_from(srfrec_vector, cs1.srfrec_vector)

#########################
# srfs2c
#########################

def srfs2c(srfstr, bodstr):
    """
    Translate a surface string, together with a body string, to the
    corresponding surface ID code. The input strings may contain names or
    integer ID codes.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfs2c_c.html
    
    Inputs:
      surface_name srfstr = Surface name or ID string.
      string       bodstr = Body name or ID string.
    
    Returns:
      surface_code code   = Integer surface ID code.
      bool         found  = Flag indicating whether surface ID was found.
    """
    return cs1.srfs2c(srfstr, bodstr)

def srfs2c_error(srfstr, bodstr):
    """
    Translate a surface string, together with a body string, to the
    corresponding surface ID code. The input strings may contain names or
    integer ID codes.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfs2c_c.html
    
    Inputs:
      surface_name srfstr = Surface name or ID string.
      string       bodstr = Body name or ID string.
    
    Returns:
      surface_code code   = Integer surface ID code.
    
    Note: Raise KeyError(NOTRANSLATION) if surface not found.
    """
    return cs1.srfs2c_error(srfstr, bodstr)

__copy_attributes_from(srfs2c, cs1.srfs2c)
__copy_attributes_from(srfs2c_error, cs1.srfs2c_error)

#########################
# srfscc
#########################

def srfscc(srfstr, bodyid):
    """
    Translate a surface string, together with a body ID code, to the
    corresponding surface ID code. The input surface string may contain a
    name or an integer ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfscc_c.html
    
    Inputs:
      surface_name srfstr = Surface name or ID string.
      int          bodyid = Body ID code.
    
    Returns:
      surface_code code   = Integer surface ID code.
      bool         found  = Flag indicating whether surface ID was found.
    """
    return cs1.srfscc(srfstr, bodyid)

def srfscc_error(srfstr, bodyid):
    """
    Translate a surface string, together with a body ID code, to the
    corresponding surface ID code. The input surface string may contain a
    name or an integer ID code.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfscc_c.html
    
    Inputs:
      surface_name srfstr = Surface name or ID string.
      int          bodyid = Body ID code.
    
    Returns:
      surface_code code   = Integer surface ID code.
    
    Note: Raise KeyError(NOTRANSLATION) if surface not found.
    """
    return cs1.srfscc_error(srfstr, bodyid)

__copy_attributes_from(srfscc, cs1.srfscc)
__copy_attributes_from(srfscc_error, cs1.srfscc_error)

#########################
# srfxpt
#########################

def srfxpt(method, target, et, abcorr, obsrvr, dref, dvec):
    """
    Given an observer and a direction vector defining a ray, compute the
    surface intercept point of the ray on a target body at a specified
    epoch, optionally corrected for light time and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfxpt_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      float    et     = Epoch in ephemeris seconds past J2000 TDB.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string   obsrvr = Name of observing body.
      string   dref   = Reference frame of input direction vector.
      float[3] dvec   = Ray's direction vector.
    
    Returns:
      float[3] spoint = Surface intercept point on the target body.
      float    dist   = Distance from the observer to the intercept point.
      float    trgepc = Intercept epoch.
      float[3] obspos = Observer position relative to target center.
      bool     found  = Flag indicating whether intercept was found.
    """
    return cs1.srfxpt(method, target, et, abcorr, obsrvr, dref, dvec)

def srfxpt_vector(method, target, et, abcorr, obsrvr, dref, dvec):
    """
    Given an observer and a direction vector defining a ray, compute the
    surface intercept point of the ray on a target body at a specified
    epoch, optionally corrected for light time and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/srfxpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float[_]   et     = Epoch in ephemeris seconds past J2000 TDB.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          "CN+S", "XLT", "XLT+S", "XCN", or "XCN+S".
      string     obsrvr = Name of observing body.
      string     dref   = Reference frame of input direction vector.
      float[_,3] dvec   = Ray's direction vector.
    
    Returns:
      float[_,3] spoint = Surface intercept point on the target body.
      float[_]   dist   = Distance from the observer to the intercept point.
      float[_]   trgepc = Intercept epoch.
      float[_,3] obspos = Observer position relative to target center.
      bool       found  = Flag indicating whether intercept was found.
    """
    return cs1.srfxpt_vector(method, target, et, abcorr, obsrvr, dref, dvec)

__copy_attributes_from(srfxpt, cs1.srfxpt)
__copy_attributes_from(srfxpt_vector, cs1.srfxpt_vector)

#########################
# stcf01
#########################

def stcf01(catnam, westra, eastra, sthdec, nthdec):
    """
    Search through a type 1 star catalog and return the number of stars
    within a specified RA - DEC rectangle.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/stcf01.html
    
    Inputs:
      string catnam = Catalog table name.
      float  westra = Western most right ascension in radians.
      float  eastra = Eastern most right ascension in radians.
      float  sthdec = Southern most declination in radians.
      float  nthdec = Northern most declination in radians.
    
    Returns:
      int    nstars = Number of stars found.
    """
    return cs1.stcf01(catnam, westra, eastra, sthdec, nthdec)

__copy_attributes_from(stcf01, cs1.stcf01)

#########################
# stcg01
#########################

def stcg01(index):
    """
    Get data for a single star from a SPICE type 1 star catalog.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/stcg01.html
    
    Inputs:
      int    index  = Star index.
    
    Returns:
      float  ra     = Right ascension in radians.
      float  dec    = Declination in radians.
      float  rasig  = Right ascension uncertainty in radians.
      float  decsig = Declination uncertainty in radians.
      int    catnum = Catalog number.
      string sptype = Spectral type.
      float  vmag   = Visual magnitude.
    """
    return cs1.stcg01(index)

__copy_attributes_from(stcg01, cs1.stcg01)

#########################
# stcl01
#########################

def stcl01(catfnm):
    """
    Load SPICE type 1 star catalog and return the catalog's table name.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/stcl01.html
    
    Inputs:
      string catfnm = Catalog file name.
    
    Returns:
      string tabnam = Catalog table name.
      int    handle = Catalog file handle.
    """
    return cs1.stcl01(catfnm)

__copy_attributes_from(stcl01, cs1.stcl01)

#########################
# stelab
#########################

def stelab(pobj, vobs):
    """
    Correct the apparent position of an object for stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/stelab_c.html
    
    Inputs:
      float[3] pobj   = Position of an object with respect to the observer.
      float[3] vobs   = Velocity of the observer with respect to the Solar
                        System barycenter.
    
    Returns:
      float[3] appobj = Apparent position of the object with respect to the
                        observer, corrected for stellar aberration.
    """
    return cs1.stelab(pobj, vobs)

def stelab_vector(pobj, vobs):
    """
    Correct the apparent position of an object for stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/stelab_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] pobj   = Position of an object with respect to the
                          observer.
      float[_,3] vobs   = Velocity of the observer with respect to the Solar
                          System barycenter.
    
    Returns:
      float[_,3] appobj = Apparent position of the object with respect to
                          the observer, corrected for stellar aberration.
    """
    return cs1.stelab_vector(pobj, vobs)

__copy_attributes_from(stelab, cs1.stelab)
__copy_attributes_from(stelab_vector, cs1.stelab_vector)

#########################
# stlabx
#########################

def stlabx(pobj, vobs):
    """
    Correct the position of a target for the stellar aberration effect on
    radiation transmitted from a specified observer to the target.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/stlabx_c.html
    
    Inputs:
      float[3] pobj   = Position of an object with respect to the observer.
      float[3] vobs   = Velocity of the observer with respect to the Solar
                        System barycenter.
    
    Returns:
      float[3] corpos = Corrected position of the object.
    """
    return cs1.stlabx(pobj, vobs)

def stlabx_vector(pobj, vobs):
    """
    Correct the position of a target for the stellar aberration effect on
    radiation transmitted from a specified observer to the target.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/stlabx_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] pobj   = Position of an object with respect to the
                          observer.
      float[_,3] vobs   = Velocity of the observer with respect to the Solar
                          System barycenter.
    
    Returns:
      float[_,3] corpos = Corrected position of the object.
    """
    return cs1.stlabx_vector(pobj, vobs)

__copy_attributes_from(stlabx, cs1.stlabx)
__copy_attributes_from(stlabx_vector, cs1.stlabx_vector)

#########################
# stpool
#########################

def stpool(item, nth, contin):
    """
    Retrieve the nth string from the kernel pool variable, where the string
    may be continued across several components of the kernel pool variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/stpool_c.html
    
    Inputs:
      string item   = Name of the kernel pool variable.
      int    nth    = Index of the full string to retrieve.
      string contin = Character sequence used to indicate continuation.
    
    Returns:
      string string = A full string concatenated across continuations.
      bool   found  = Flag indicating success or failure of request.
    """
    return cs1.stpool(item, nth, contin)

def stpool_error(item, nth, contin):
    """
    Retrieve the nth string from the kernel pool variable, where the string
    may be continued across several components of the kernel pool variable.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/stpool_c.html
    
    Inputs:
      string item   = Name of the kernel pool variable.
      int    nth    = Index of the full string to retrieve.
      string contin = Character sequence used to indicate continuation.
    
    Returns:
      string string = A full string concatenated across continuations.
    
    Note: Raise KeyError(VARIABLENOTFOUND) if the variable is not in the
    pool; TypeError(WRONGDATATYPE) if it has the wrong type;
    IndexError(INDEXOUTOFRANGE) if the start index is out of range.
    """
    return cs1.stpool_error(item, nth, contin)

__copy_attributes_from(stpool, cs1.stpool)
__copy_attributes_from(stpool_error, cs1.stpool_error)

#########################
# str2et
#########################

def str2et(str):
    """
    Convert a string representing an epoch to a floating-point value
    representing the number of TDB seconds past the J2000 epoch
    corresponding to the input epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/str2et_c.html
    
    Inputs:
      string str = A string representing an epoch.
    
    Returns:
      float  et  = The equivalent value in seconds past J2000, TDB.
    """
    return cs1.str2et(str)

__copy_attributes_from(str2et, cs1.str2et)

#########################
# subpnt
#########################

def subpnt(method, target, et, fixref, abcorr, obsrvr):
    """
    Compute the rectangular coordinates of the sub-observer point on a
    target body at a specified epoch, optionally corrected for light time
    and stellar aberration.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    This routine supersedes subpt.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subpnt_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      float    et     = Epoch in TDB seconds past J2000 TDB.
      string   fixref = Body-fixed, body-centered target body frame.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        or "CN+S".
      string   obsrvr = Name of observing body.
    
    Returns:
      float[3] spoint = Sub-observer point on the target body.
      float    trgepc = Sub-observer point epoch.
      float[3] srfvec = Vector from observer to sub-observer point.
    """
    return cs1.subpnt(method, target, et, fixref, abcorr, obsrvr)

def subpnt_vector(method, target, et, fixref, abcorr, obsrvr):
    """
    Compute the rectangular coordinates of the sub-observer point on a
    target body at a specified epoch, optionally corrected for light time
    and stellar aberration.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    This routine supersedes subpt.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subpnt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float[_]   et     = Epoch in TDB seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          or "CN+S".
      string     obsrvr = Name of observing body.
    
    Returns:
      float[_,3] spoint = Sub-observer point on the target body.
      float[_]   trgepc = Sub-observer point epoch.
      float[_,3] srfvec = Vector from observer to sub-observer point.
    """
    return cs1.subpnt_vector(method, target, et, fixref, abcorr, obsrvr)

__copy_attributes_from(subpnt, cs1.subpnt)
__copy_attributes_from(subpnt_vector, cs1.subpnt_vector)

#########################
# subpt
#########################

def subpt(method, target, et, abcorr, obsrvr):
    """
    Compute the rectangular coordinates of the sub-observer point on a
    target body at a particular epoch, optionally corrected for planetary
    (light time) and stellar aberration. Return these coordinates expressed
    in the body-fixed frame associated with the target body. Also, return
    the observer's altitude above the target body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subpt_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      float    et     = Epoch in ephemeris seconds past J2000 TDB.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        or "CN+S".
      string   obsrvr = Name of observing body.
    
    Returns:
      float[3] spoint = Sub-observer point on the target body.
      float    alt    = Altitude of the observer above the target body.
    """
    return cs1.subpt(method, target, et, abcorr, obsrvr)

def subpt_vector(method, target, et, abcorr, obsrvr):
    """
    Compute the rectangular coordinates of the sub-observer point on a
    target body at a particular epoch, optionally corrected for planetary
    (light time) and stellar aberration. Return these coordinates expressed
    in the body-fixed frame associated with the target body. Also, return
    the observer's altitude above the target body.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float[_]   et     = Epoch in ephemeris seconds past J2000 TDB.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          or "CN+S".
      string     obsrvr = Name of observing body.
    
    Returns:
      float[_,3] spoint = Sub-observer point on the target body.
      float[_]   alt    = Altitude of the observer above the target body.
    """
    return cs1.subpt_vector(method, target, et, abcorr, obsrvr)

__copy_attributes_from(subpt, cs1.subpt)
__copy_attributes_from(subpt_vector, cs1.subpt_vector)

#########################
# subslr
#########################

def subslr(method, target, et, fixref, abcorr, obsrvr):
    """
    Compute the rectangular coordinates of the sub-solar point on a target
    body at a specified epoch, optionally corrected for light time and
    stellar aberration.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    This routine supersedes subsol.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subslr_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      float    et     = Epoch in ephemeris seconds past J2000 TDB.
      string   fixref = Body-fixed, body-centered target body frame.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        or "CN+S".
      string   obsrvr = Name of observing body.
    
    Returns:
      float[3] spoint = Sub-solar point on the target body.
      float    trgepc = Sub-solar point epoch.
      float[3] srfvec = Vector from observer to sub-solar point.
    """
    return cs1.subslr(method, target, et, fixref, abcorr, obsrvr)

def subslr_vector(method, target, et, fixref, abcorr, obsrvr):
    """
    Compute the rectangular coordinates of the sub-solar point on a target
    body at a specified epoch, optionally corrected for light time and
    stellar aberration.
    
    The surface of the target body may be represented by a triaxial
    ellipsoid or by topographic data provided by DSK files.
    
    This routine supersedes subsol.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subslr_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float[_]   et     = Epoch in ephemeris seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          or "CN+S".
      string     obsrvr = Name of observing body.
    
    Returns:
      float[_,3] spoint = Sub-solar point on the target body.
      float[_]   trgepc = Sub-solar point epoch.
      float[_,3] srfvec = Vector from observer to sub-solar point.
    """
    return cs1.subslr_vector(method, target, et, fixref, abcorr, obsrvr)

__copy_attributes_from(subslr, cs1.subslr)
__copy_attributes_from(subslr_vector, cs1.subslr_vector)

#########################
# subsol
#########################

def subsol(method, target, et, abcorr, obsrvr):
    """
    Determine the coordinates of the sub-solar point on a target body as
    seen by a specified observer at a specified epoch, optionally corrected
    for planetary (light time) and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subsol_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      float    et     = Epoch in ephemeris seconds past J2000 TDB.
      string   abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                        or "CN+S".
      string   obsrvr = Name of observing body.
    
    Returns:
      float[3] spoint = Sub-solar point on the target body.
    """
    return cs1.subsol(method, target, et, abcorr, obsrvr)

def subsol_vector(method, target, et, abcorr, obsrvr):
    """
    Determine the coordinates of the sub-solar point on a target body as
    seen by a specified observer at a specified epoch, optionally corrected
    for planetary (light time) and stellar aberration.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/subsol_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float[_]   et     = Epoch in ephemeris seconds past J2000 TDB.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          or "CN+S".
      string     obsrvr = Name of observing body.
    
    Returns:
      float[_,3] spoint = Sub-solar point on the target body.
    """
    return cs1.subsol_vector(method, target, et, abcorr, obsrvr)

__copy_attributes_from(subsol, cs1.subsol)
__copy_attributes_from(subsol_vector, cs1.subsol_vector)

#########################
# sumad
#########################

def sumad(array):
    """
    Return the sum of the elements of a floating-point array.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sumad_c.html
    
    Inputs:
      float[*] array = Input array.
    
    Returns:
      float    sum   = Sum of elements.
    """
    return cs1.sumad(array)

__copy_attributes_from(sumad, cs1.sumad)

#########################
# sumai
#########################

def sumai(array):
    """
    Return the sum of the elements of an integer array.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sumai_c.html
    
    Inputs:
      int[*] array = Input array.
    
    Returns:
      int    sum   = Sum of elements.
    """
    return cs1.sumai(array)

__copy_attributes_from(sumai, cs1.sumai)

#########################
# surfnm
#########################

def surfnm(a, b, c, point):
    """
    This routine computes the outward-pointing, unit normal vector from a
    point on the surface of an ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/surfnm_c.html
    
    Inputs:
      float    a      = Length of the ellisoid semi-axis along the x-axis.
      float    b      = Length of the ellisoid semi-axis along the y-axis.
      float    c      = Length of the ellisoid semi-axis along the z-axis.
      float[3] point  = Body-fixed coordinates of a point on the ellipsoid.
    
    Returns:
      float[3] normal = Outward pointing unit normal to ellipsoid at point.
    """
    return cs1.surfnm(a, b, c, point)

__copy_attributes_from(surfnm, cs1.surfnm)

#########################
# surfpt
#########################

def surfpt(positn, u, a, b, c):
    """
    Determine the intersection of a line-of-sight vector with the surface of
    an ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/surfpt_c.html
    
    Inputs:
      float[3] positn = Position of the observer in body-fixed frame.
      float[3] u      = Vector from the observer in some direction.
      float    a      = Length of the ellipsoid semi-axis along the x-axis.
      float    b      = Length of the ellipsoid semi-axis along the y-axis.
      float    c      = Length of the ellipsoid semi-axis along the z-axis.
    
    Returns:
      float[3] point  = Point on the ellipsoid pointed to by u.
      bool     found  = Flag indicating if u points at the ellipsoid.
    """
    return cs1.surfpt(positn, u, a, b, c)

def surfpt_vector(positn, u, a, b, c):
    """
    Determine the intersection of a line-of-sight vector with the surface of
    an ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/surfpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] positn = Position of the observer in body-fixed frame.
      float[_,3] u      = Vector from the observer in some direction.
      float[_]   a      = Length of the ellipsoid semi-axis along the
                          x-axis.
      float[_]   b      = Length of the ellipsoid semi-axis along the
                          y-axis.
      float[_]   c      = Length of the ellipsoid semi-axis along the
                          z-axis.
    
    Returns:
      float[_,3] point  = Point on the ellipsoid pointed to by u.
      bool       found  = Flag indicating if u points at the ellipsoid.
    """
    return cs1.surfpt_vector(positn, u, a, b, c)

__copy_attributes_from(surfpt, cs1.surfpt)
__copy_attributes_from(surfpt_vector, cs1.surfpt_vector)

#########################
# surfpv
#########################

def surfpv(stvrtx, stdir, a, b, c):
    """
    Find the state (position and velocity) of the surface intercept defined
    by a specified ray, ray velocity, and ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/surfpv_c.html
    
    Inputs:
      float[6] stvrtx = State of ray's vertex.
      float[6] stdir  = State of ray's direction vector.
      float    a      = Length of ellipsoid semi-axis along the x-axis.
      float    b      = Length of ellipsoid semi-axis along the y-axis.
      float    c      = Length of ellipsoid semi-axis along the z-axis.
    
    Returns:
      float[6] stx    = State of surface intercept.
      bool     found  = Flag indicating whether intercept state was found.
    """
    return cs1.surfpv(stvrtx, stdir, a, b, c)

def surfpv_vector(stvrtx, stdir, a, b, c):
    """
    Find the state (position and velocity) of the surface intercept defined
    by a specified ray, ray velocity, and ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/surfpv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] stvrtx = State of ray's vertex.
      float[_,6] stdir  = State of ray's direction vector.
      float[_]   a      = Length of ellipsoid semi-axis along the x-axis.
      float[_]   b      = Length of ellipsoid semi-axis along the y-axis.
      float[_]   c      = Length of ellipsoid semi-axis along the z-axis.
    
    Returns:
      float[_,6] stx    = State of surface intercept.
      bool       found  = Flag indicating whether intercept state was found.
    """
    return cs1.surfpv_vector(stvrtx, stdir, a, b, c)

__copy_attributes_from(surfpv, cs1.surfpv)
__copy_attributes_from(surfpv_vector, cs1.surfpv_vector)

#########################
# swpool
#########################

def swpool(agent, names):
    """
    Add a name to the list of agents to notify whenever a member of a list
    of kernel variables is updated.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/swpool_c.html
    
    Inputs:
      string    agent = The name of an agent to be notified after updates.
      string[*] names = Variable names whose update causes the notice.
    
    Returns: none
    """
    return cs1.swpool(agent, names)

__copy_attributes_from(swpool, cs1.swpool)

#########################
# sxform
#########################

def sxform(from_, to, et):
    """
    Return the state transformation matrix from one frame to another at a
    specified epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sxform_c.html
    
    Inputs:
      string     from  = Name of the frame to transform from.
      string     to    = Name of the frame to transform to.
      float      et    = Epoch of the state transformation matrix.
    
    Returns:
      float[6,6] xform = A state transformation matrix.
    """
    return cs1.sxform(from_, to, et)

def sxform_vector(from_, to, et):
    """
    Return the state transformation matrix from one frame to another at a
    specified epoch.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/sxform_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string       from  = Name of the frame to transform from.
      string       to    = Name of the frame to transform to.
      float[_]     et    = Epoch of the state transformation matrix.
    
    Returns:
      float[_,6,6] xform = A state transformation matrix.
    """
    return cs1.sxform_vector(from_, to, et)

__copy_attributes_from(sxform, cs1.sxform)
__copy_attributes_from(sxform_vector, cs1.sxform_vector)

#########################
# szpool
#########################

def szpool(name):
    """
    Return the kernel pool size limitations.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/szpool_c.html
    
    Inputs:
      string name  = Name of the parameter to be returned, one of "MAXVAR",
                     "MAXLEN", "MAXVAL", "MXNOTE", "MAXAGT", "MAXCHR", or
                     "MAXLIN".
    
    Returns:
      int    n     = Value of parameter specified by name.
      bool   found = True if name is recognized.
    """
    return cs1.szpool(name)

def szpool_error(name):
    """
    Return the kernel pool size limitations.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/szpool_c.html
    
    Inputs:
      string name = Name of the parameter to be returned, one of "MAXVAR",
                    "MAXLEN", "MAXVAL", "MXNOTE", "MAXAGT", "MAXCHR", or
                    "MAXLIN".
    
    Returns:
      int    n    = Value of parameter specified by name.
    
    Note: Raise KeyError(KERNELVARNOTFOUND) if the parameter name is not
    recognized.
    """
    return cs1.szpool_error(name)

__copy_attributes_from(szpool, cs1.szpool)
__copy_attributes_from(szpool_error, cs1.szpool_error)

#########################
# tangpt
#########################

def tangpt(method, target, et, fixref, abcorr, corloc, obsrvr, dref, dvec):
    """
    Compute, for a given observer, ray emanating from the observer, and
    target, the "tangent point": the point on the ray nearest to the
    target's surface. Also compute the point on the target's surface nearest
    to the tangent point. The locations of both points are optionally
    corrected for light time and stellar aberration. The surface shape is
    modeled as a triaxial ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tangpt_c.html
    
    Inputs:
      string   method = Computation method.
      string   target = Name of target body.
      float    et     = Epoch in ephemeris seconds past J2000 TDB.
      string   fixref = Body-fixed, body-centered target body frame.
      string   abcorr = Aberration correction.
      string   corloc = Aberration correction locus: "TANGENT POINT" or
                        "SURFACE POINT".
      string   obsrvr = Name of observing body.
      string   dref   = Reference frame of ray direction vector.
      float[3] dvec   = Ray direction vector.
    
    Returns:
      float[3] tanpt  = "Tangent point": point on ray nearest to surface.
      float    alt    = Altitude of tangent point above surface.
      float    range  = Distance of tangent point from observer.
      float[3] srfpt  = Point on surface nearest to tangent point.
      float    trgepc = Epoch associated with correction locus.
      float[3] srfvec = Vector from observer to surface point `srfpt'.
    """
    return cs1.tangpt(method, target, et, fixref, abcorr, corloc, obsrvr, dref, dvec)

def tangpt_vector(method, target, et, fixref, abcorr, corloc, obsrvr, dref, dvec):
    """
    Compute, for a given observer, ray emanating from the observer, and
    target, the "tangent point": the point on the ray nearest to the
    target's surface. Also compute the point on the target's surface nearest
    to the tangent point. The locations of both points are optionally
    corrected for light time and stellar aberration. The surface shape is
    modeled as a triaxial ellipsoid.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tangpt_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string     method = Computation method.
      string     target = Name of target body.
      float[_]   et     = Epoch in ephemeris seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction.
      string     corloc = Aberration correction locus: "TANGENT POINT" or
                          "SURFACE POINT".
      string     obsrvr = Name of observing body.
      string     dref   = Reference frame of ray direction vector.
      float[_,3] dvec   = Ray direction vector.
    
    Returns:
      float[_,3] tanpt  = "Tangent point": point on ray nearest to surface.
      float[_]   alt    = Altitude of tangent point above surface.
      float[_]   range  = Distance of tangent point from observer.
      float[_,3] srfpt  = Point on surface nearest to tangent point.
      float[_]   trgepc = Epoch associated with correction locus.
      float[_,3] srfvec = Vector from observer to surface point `srfpt'.
    """
    return cs1.tangpt_vector(method, target, et, fixref, abcorr, corloc, obsrvr, dref, dvec)

__copy_attributes_from(tangpt, cs1.tangpt)
__copy_attributes_from(tangpt_vector, cs1.tangpt_vector)

#########################
# termpt
#########################

def termpt(method, ilusrc, target, et, fixref, abcorr, corloc, obsrvr, refvec, rolstp, ncuts, schstp, soltol, maxn):
    """
    Find terminator points on a target body. The caller specifies
    half-planes, bounded by the illumination source center-target center
    vector, in which to search for terminator points.
    
    The terminator can be either umbral or penumbral. The umbral terminator
    is the boundary of the region on the target surface where no light from
    the source is visible. The penumbral terminator is the boundary of the
    region on the target surface where none of the light from the source is
    blocked by the target itself.
    
    The surface of the target body may be represented either by a triaxial
    ellipsoid or by topographic data.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/termpt_c.html
    
    Inputs:
      string     method = Computation method.
      string     ilusrc = Illumination source.
      string     target = Name of target body.
      float      et     = Epoch in ephemeris seconds past J2000 TDB.
      string     fixref = Body-fixed, body-centered target body frame.
      string     abcorr = Aberration correction, "NONE", "LT", "LT+S", "CN",
                          or "CN+S".
      string     corloc = Aberration correction locus.
      string     obsrvr = Name of observing body.
      float[3]   refvec = Reference vector for cutting half-planes.
      float      rolstp = Roll angular step for cutting half-planes.
      int        ncuts  = Number of cutting planes.
      float      schstp = Angular step size for searching.
      float      soltol = Solution convergence tolerance.
      int        maxn   = Maximum number of entries in output arrays.
    
    Returns:
      int[*]     npts   = Counts of terminator points corresponding to cuts.
      float[*,3] points = Terminator points.
      float[*]   epochs = Times associated with terminator points.
      float[*,3] trmvcs = Terminator vectors emanating from the observer.
    """
    return cs1.termpt(method, ilusrc, target, et, fixref, abcorr, corloc, obsrvr, refvec, rolstp, ncuts, schstp, soltol, maxn)

__copy_attributes_from(termpt, cs1.termpt)

#########################
# timdef
#########################

def timdef(action = 'GET', item = '', value = ''):
    """
    Set and retrieve the defaults associated with calendar input strings.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/timdef_c.html
    
    Inputs:
      string action = Action to take, "SET" or "GET".
      string item   = Default item of interest, "CALENDAR", "SYSTEM", or
                      "ZONE".
      string value  = Value associated with the default item. CALENDAR can
                      be "GREGORIAN", "JULIAN", or "MIXED"; SYSTEM can be
                      "TDB", "TDT", "TT", or "UTC"; ZONE can be "EST",
                      "EDT", "CST", "CDT", "MST", "MDT", "PST", "PDT",
                      "UTC+h", "UTC-h", "UTC+h:m", or "UTC-h:m", where h is
                      hours (0-12) and m is minutes (0-59).
    
    Returns:
      string value  = Value associated with the default item. CALENDAR can
                      be "GREGORIAN", "JULIAN", or "MIXED"; SYSTEM can be
                      "TDB", "TDT", "TT", or "UTC"; ZONE can be "EST",
                      "EDT", "CST", "CDT", "MST", "MDT", "PST", "PDT",
                      "UTC+h", "UTC-h", "UTC+h:m", or "UTC-h:m", where h is
                      hours (0-12) and m is minutes (0-59).
    """
    return cs1.timdef(action, item, value)

__copy_attributes_from(timdef, cs1.timdef)

#########################
# timout
#########################

def timout(et, pictur):
    """
    This routine converts an input epoch represented in TDB seconds past the
    TDB epoch of J2000 to a character string formatted to the specifications
    of a user's format picture.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/timout_c.html
    
    Inputs:
      float  et     = An epoch in seconds past the ephemeris epoch J2000.
      string pictur = A format specification for the output string.
    
    Returns:
      string output = A string representation of the input epoch.
    """
    return cs1.timout(et, pictur)

__copy_attributes_from(timout, cs1.timout)

#########################
# tipbod
#########################

def tipbod(ref, body, et):
    """
    Return a 3x3 matrix that transforms positions in inertial coordinates to
    positions in body-equator-and-prime-meridian coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tipbod_c.html
    
    Inputs:
      string     ref  = Name of the inertial reference frame to transform
                        from.
      int        body = ID code of the body.
      float      et   = Epoch of transformation.
    
    Returns:
      float[3,3] tipm = Transformation (position), inertial to prime
                        meridian.
    """
    return cs1.tipbod(ref, body, et)

def tipbod_vector(ref, body, et):
    """
    Return a 3x3 matrix that transforms positions in inertial coordinates to
    positions in body-equator-and-prime-meridian coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tipbod_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string       ref  = Name of the inertial reference frame to transform
                          from.
      int          body = ID code of the body.
      float[_]     et   = Epoch of transformation.
    
    Returns:
      float[_,3,3] tipm = Transformation (position), inertial to prime
                          meridian.
    """
    return cs1.tipbod_vector(ref, body, et)

__copy_attributes_from(tipbod, cs1.tipbod)
__copy_attributes_from(tipbod_vector, cs1.tipbod_vector)

#########################
# tisbod
#########################

def tisbod(ref, body, et):
    """
    Return a 6x6 matrix that transforms states in inertial coordinates to
    states in body-equator-and-prime-meridian coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tisbod_c.html
    
    Inputs:
      string     ref   = Name of the inertial reference frame to transform
                         from.
      int        body  = ID code of the body.
      float      et    = Epoch of transformation.
    
    Returns:
      float[6,6] tsipm = Transformation (state), inertial to prime meridian.
    """
    return cs1.tisbod(ref, body, et)

def tisbod_vector(ref, body, et):
    """
    Return a 6x6 matrix that transforms states in inertial coordinates to
    states in body-equator-and-prime-meridian coordinates.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tisbod_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      string       ref   = Name of the inertial reference frame to transform
                           from.
      int          body  = ID code of the body.
      float[_]     et    = Epoch of transformation.
    
    Returns:
      float[_,6,6] tsipm = Transformation (state), inertial to prime
                           meridian.
    """
    return cs1.tisbod_vector(ref, body, et)

__copy_attributes_from(tisbod, cs1.tisbod)
__copy_attributes_from(tisbod_vector, cs1.tisbod_vector)

#########################
# tkfram
#########################

def tkfram(frcode):
    """
    Find the position rotation matrix from a Text Kernel (TK) frame with the
    specified frame class ID to its base frame.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tkfram_c.html
    
    Inputs:
      int        frcode = Frame class ID of a TK frame.
    
    Returns:
      float[3,3] rot    = Rotation matrix from TK frame to frame `frame'.
      int        frame  = Frame ID of the base reference.
      bool       found  = True if the rotation could be determined.
    """
    return cs1.tkfram(frcode)

def tkfram_error(frcode):
    """
    Find the position rotation matrix from a Text Kernel (TK) frame with the
    specified frame class ID to its base frame.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tkfram_c.html
    
    Inputs:
      int        frcode = Frame class ID of a TK frame.
    
    Returns:
      float[3,3] rot    = Rotation matrix from TK frame to frame `frame'.
      int        frame  = Frame ID of the base reference.
    
    Note: Raise KeyError(FRAMEIDNOTFOUND) if the frame transformation
    could not be found.
    """
    return cs1.tkfram_error(frcode)

__copy_attributes_from(tkfram, cs1.tkfram)
__copy_attributes_from(tkfram_error, cs1.tkfram_error)

#########################
# tkvrsn
#########################

def tkvrsn(item = 'TOOLKIT'):
    """
    Given an item such as the Toolkit or an entry point name, return the
    latest version string.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tkvrsn_c.html
    
    Inputs:
      string item  = Item for which a version string is desired; default is
                     "TOOLKIT".
    
    Returns:
      string value = Version string.
    """
    return cs1.tkvrsn(item)

__copy_attributes_from(tkvrsn, cs1.tkvrsn)

#########################
# tparch
#########################

def tparch(type):
    """
    Restrict the set of strings that are recognized by SPICE time parsing
    routines to those that have standard values for all time components.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tparch_c.html
    
    Inputs:
      string type = String: Use "YES" to restrict time inputs.
    
    Returns: none
    """
    return cs1.tparch(type)

__copy_attributes_from(tparch, cs1.tparch)

#########################
# tparse
#########################

def tparse(string):
    """
    Parse a time string and return seconds past the J2000 epoch on a formal
    calendar.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tparse_c.html
    
    Inputs:
      string string = Input time string, UTC.
    
    Returns:
      float  sp2000 = Equivalent UTC seconds past J2000.
      string errmsg = Descriptive error message.
    """
    return cs1.tparse(string)

def tparse_error(string):
    """
    Parse a time string and return seconds past the J2000 epoch on a formal
    calendar.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tparse_c.html
    
    Inputs:
      string string = Input time string, UTC.
    
    Returns:
      float  sp2000 = Equivalent UTC seconds past J2000.
    
    Note: Raise ValueError(INVALIDTIMESTRING) if the sample string is
    invalid.
    """
    return cs1.tparse_error(string)

__copy_attributes_from(tparse, cs1.tparse)
__copy_attributes_from(tparse_error, cs1.tparse_error)

#########################
# tpictr
#########################

def tpictr(sample):
    """
    Given a sample time string, create a time format picture suitable for
    use by the routine timout.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tpictr_c.html
    
    Inputs:
      string sample = A sample time string.
    
    Returns:
      string pictur = A format picture that describes sample.
      bool   ok     = Flag indicating whether sample parsed successfully.
      string errmsg = Diagnostic returned if sample cannot be parsed.
    """
    return cs1.tpictr(sample)

def tpictr_error(sample):
    """
    Given a sample time string, create a time format picture suitable for
    use by the routine timout.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tpictr_c.html
    
    Inputs:
      string sample = A sample time string.
    
    Returns:
      string pictur = A format picture that describes sample.
    
    Note: Raise ValueError(INVALIDTIMESTRING) if the sample string is
    invalid.
    """
    return cs1.tpictr_error(sample)

__copy_attributes_from(tpictr, cs1.tpictr)
__copy_attributes_from(tpictr_error, cs1.tpictr_error)

#########################
# trace
#########################

def trace(matrix):
    """
    Return the trace of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/trace_c.html
    
    Inputs:
      float[3,3] matrix = 3x3 matrix.
    
    Returns:
      float      trace  = The trace of the matrix.
    """
    return cs1.trace(matrix)

def trace_vector(matrix):
    """
    Return the trace of a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/trace_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] matrix = 3x3 matrix.
    
    Returns:
      float[_]     trace  = The trace of the matrix.
    """
    return cs1.trace_vector(matrix)

__copy_attributes_from(trace, cs1.trace)
__copy_attributes_from(trace_vector, cs1.trace_vector)

#########################
# trcdep
#########################

def trcdep():
    """
    Return the number of modules in the traceback representation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/trcdep_c.html
    
    Inputs: none
    
    Returns:
      int depth = The number of modules in the traceback.
    """
    return cs1.trcdep()

__copy_attributes_from(trcdep, cs1.trcdep)

#########################
# trcnam
#########################

def trcnam(index):
    """
    Return the name of the module having the specified position in the trace
    representation. The first module to check in is at index 0.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/trcnam_c.html
    
    Inputs:
      int    index = The position of the requested module name.
    
    Returns:
      string name  = The name at position `index' in the traceback.
    """
    return cs1.trcnam(index)

__copy_attributes_from(trcnam, cs1.trcnam)

#########################
# trcoff
#########################

def trcoff():
    """
    Disable tracing.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/trcoff_c.html
    
    Inputs: none
    
    Returns: none
    """
    return cs1.trcoff()

__copy_attributes_from(trcoff, cs1.trcoff)

#########################
# trgsep
#########################

def trgsep(et, targ1, shape1, frame1, targ2, shape2, frame2, obsrvr, abcorr):
    """
    Compute the angular separation in radians between two spherical or point
    objects.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/trgsep_c.html
    
    Inputs:
      float  et     = Ephemeris seconds past J2000 TDB.
      string targ1  = First target body name.
      string shape1 = First target body shape.
      string frame1 = Reference frame of first target.
      string targ2  = Second target body name.
      string shape2 = First target body shape.
      string frame2 = Reference frame of second target.
      string obsrvr = Observing body name.
      string abcorr = Aberration corrections flag.
    
    Returns:
      float  sep    = Separation angle in radians.
    """
    return cs1.trgsep(et, targ1, shape1, frame1, targ2, shape2, frame2, obsrvr, abcorr)

def trgsep_vector(et, targ1, shape1, frame1, targ2, shape2, frame2, obsrvr, abcorr):
    """
    Compute the angular separation in radians between two spherical or point
    objects.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/trgsep_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] et     = Ephemeris seconds past J2000 TDB.
      string   targ1  = First target body name.
      string   shape1 = First target body shape.
      string   frame1 = Reference frame of first target.
      string   targ2  = Second target body name.
      string   shape2 = First target body shape.
      string   frame2 = Reference frame of second target.
      string   obsrvr = Observing body name.
      string   abcorr = Aberration corrections flag.
    
    Returns:
      float[_] sep    = Separation angle in radians.
    """
    return cs1.trgsep_vector(et, targ1, shape1, frame1, targ2, shape2, frame2, obsrvr, abcorr)

__copy_attributes_from(trgsep, cs1.trgsep)
__copy_attributes_from(trgsep_vector, cs1.trgsep_vector)

#########################
# tsetyr
#########################

def tsetyr(year):
    """
    Set the lower bound on the 100 year range.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tsetyr_c.html
    
    Inputs:
      int year = Lower bound on the 100 year interval of expansion. Default
                 is 1950.
    
    Returns: none
    """
    return cs1.tsetyr(year)

__copy_attributes_from(tsetyr, cs1.tsetyr)

#########################
# twopi
#########################

def twopi():
    """
    Return twice the value of pi (the ratio of the circumference of a circle
    to its diameter).
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/twopi_c.html
    
    Inputs: none
    
    Returns:
      float value = Twice the value of pi.
    """
    return cs1.twopi()

__copy_attributes_from(twopi, cs1.twopi)

#########################
# twovec
#########################

def twovec(axdef, indexa, plndef, indexp):
    """
    Find the transformation to the right-handed frame having a given vector
    as a specified axis and having a second given vector lying in a
    specified coordinate plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/twovec_c.html
    
    Inputs:
      float[3]   axdef  = Vector defining a principal axis.
      int        indexa = Principal axis number of axdef (X=1, Y=2, Z=3).
      float[3]   plndef = Vector defining (with axdef) a principal plane.
      int        indexp = Second axis number (with indexa) of principal
                          plane.
    
    Returns:
      float[3,3] matrix = Output rotation matrix.
    """
    return cs1.twovec(axdef, indexa, plndef, indexp)

def twovec_vector(axdef, indexa, plndef, indexp):
    """
    Find the transformation to the right-handed frame having a given vector
    as a specified axis and having a second given vector lying in a
    specified coordinate plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/twovec_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]   axdef  = Vector defining a principal axis.
      int          indexa = Principal axis number of axdef (X=1, Y=2, Z=3).
      float[_,3]   plndef = Vector defining (with axdef) a principal plane.
      int          indexp = Second axis number (with indexa) of principal
                            plane.
    
    Returns:
      float[_,3,3] matrix = Output rotation matrix.
    """
    return cs1.twovec_vector(axdef, indexa, plndef, indexp)

__copy_attributes_from(twovec, cs1.twovec)
__copy_attributes_from(twovec_vector, cs1.twovec_vector)

#########################
# twovxf
#########################

def twovxf(axdef, indexa, plndef, indexp):
    """
    Find the state transformation from a base frame to the right-handed
    frame defined by two state vectors: one state vector defining a
    specified axis and a second state vector defining a specified coordinate
    plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/twovxf_c.html
    
    Inputs:
      float[6]   axdef  = State defining a principal axis.
      int        indexa = Principal axis number of `axdef' (x=1, y=2, z=3).
      float[6]   plndef = State defining (with `axdef') a principal plane.
      int        indexp = Second axis number (with `indexa') of principal
                          plane.
    
    Returns:
      float[6,6] xform  = Output state transformation matrix.
    """
    return cs1.twovxf(axdef, indexa, plndef, indexp)

def twovxf_vector(axdef, indexa, plndef, indexp):
    """
    Find the state transformation from a base frame to the right-handed
    frame defined by two state vectors: one state vector defining a
    specified axis and a second state vector defining a specified coordinate
    plane.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/twovxf_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6]   axdef  = State defining a principal axis.
      int          indexa = Principal axis number of `axdef' (x=1, y=2,
                            z=3).
      float[_,6]   plndef = State defining (with `axdef') a principal plane.
      int          indexp = Second axis number (with `indexa') of principal
                            plane.
    
    Returns:
      float[_,6,6] xform  = Output state transformation matrix.
    """
    return cs1.twovxf_vector(axdef, indexa, plndef, indexp)

__copy_attributes_from(twovxf, cs1.twovxf)
__copy_attributes_from(twovxf_vector, cs1.twovxf_vector)

#########################
# tyear
#########################

def tyear():
    """
    Return the number of seconds in a tropical year.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/tyear_c.html
    
    Inputs: none
    
    Returns:
      float value = The number of seconds in a tropical year.
    """
    return cs1.tyear()

__copy_attributes_from(tyear, cs1.tyear)

#########################
# ucrss
#########################

def ucrss(v1, v2):
    """
    Compute the normalized cross product of two 3-vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ucrss_c.html
    
    Inputs:
      float[3] v1     = Left vector for cross product.
      float[3] v2     = Right vector for cross product.
    
    Returns:
      float[3] vector = Normalized cross product (v1xv2) / |v1xv2|.
    """
    return cs1.ucrss(v1, v2)

def ucrss_vector(v1, v2):
    """
    Compute the normalized cross product of two 3-vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ucrss_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1     = Left vector for cross product.
      float[_,3] v2     = Right vector for cross product.
    
    Returns:
      float[_,3] vector = Normalized cross product (v1xv2) / |v1xv2|.
    """
    return cs1.ucrss_vector(v1, v2)

__copy_attributes_from(ucrss, cs1.ucrss)
__copy_attributes_from(ucrss_vector, cs1.ucrss_vector)

#########################
# unitim
#########################

def unitim(epoch, insys, outsys):
    """
    Transform time from one uniform scale to another. The uniform time
    scales are TAI, TDT, TDB, ET, JED, JDTDB, JDTDT.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unitim_c.html
    
    Inputs:
      float  epoch  = An epoch to be converted.
      string insys  = The time scale associated with the input epoch.
      string outsys = The time scale associated with the function value.
    
    Returns:
      float  value  = The value in outsys that is equivalent to the epoch on
                      the insys time scale.
    """
    return cs1.unitim(epoch, insys, outsys)

def unitim_vector(epoch, insys, outsys):
    """
    Transform time from one uniform scale to another. The uniform time
    scales are TAI, TDT, TDB, ET, JED, JDTDB, JDTDT.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unitim_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_] epoch  = An epoch to be converted.
      string   insys  = The time scale associated with the input epoch.
      string   outsys = The time scale associated with the function value.
    
    Returns:
      float[_] value  = The value in outsys that is equivalent to the epoch
                        on the insys time scale.
    """
    return cs1.unitim_vector(epoch, insys, outsys)

__copy_attributes_from(unitim, cs1.unitim)
__copy_attributes_from(unitim_vector, cs1.unitim_vector)

#########################
# unload
#########################

def unload(file):
    """
    Unload a SPICE kernel.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unload_c.html
    
    Inputs:
      string file = The name of a kernel to unload.
    
    Returns: none
    """
    return cs1.unload(file)

__copy_attributes_from(unload, cs1.unload)

#########################
# unorm
#########################

def unorm(v1):
    """
    Normalize a 3-vector and return its magnitude.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unorm_c.html
    
    Inputs:
      float[3] v1     = Vector to be normalized.
    
    Returns:
      float[3] vector = Unit vector v1 / |v1|. If v1 is the zero vector,
                        then it will also be zero.
      float    vmag   = Magnitude of v1, i.e. |v1|.
    """
    return cs1.unorm(v1)

def unorm_vector(v1):
    """
    Normalize a 3-vector and return its magnitude.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unorm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1     = Vector to be normalized.
    
    Returns:
      float[_,3] vector = Unit vector v1 / |v1|. If v1 is the zero vector,
                          then it will also be zero.
      float[_]   vmag   = Magnitude of v1, i.e. |v1|.
    """
    return cs1.unorm_vector(v1)

__copy_attributes_from(unorm, cs1.unorm)
__copy_attributes_from(unorm_vector, cs1.unorm_vector)

#########################
# unormg
#########################

def unormg(v1):
    """
    Normalize a vector of arbitrary dimension and return its magnitude.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unormg_c.html
    
    Inputs:
      float[*] v1     = Vector to be normalized.
    
    Returns:
      float[*] vector = Unit vector v1 / |v1|. If v1 is the zero vector, the
                        returned vector will also be zero.
      float    vmag   = Magnitude of v1, that is, |v1|.
    """
    return cs1.unormg(v1)

def unormg_vector(v1):
    """
    Normalize a vector of arbitrary dimension and return its magnitude.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/unormg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1     = Vector to be normalized.
    
    Returns:
      float[_,*] vector = Unit vector v1 / |v1|. If v1 is the zero vector,
                          the returned vector will also be zero.
      float[_]   vmag   = Magnitude of v1, that is, |v1|.
    """
    return cs1.unormg_vector(v1)

__copy_attributes_from(unormg, cs1.unormg)
__copy_attributes_from(unormg_vector, cs1.unormg_vector)

#########################
# utc2et
#########################

def utc2et(utcstr):
    """
    Convert an input time from Calendar or Julian Date format, UTC, to
    ephemeris seconds past J2000.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/utc2et_c.html
    
    Inputs:
      string utcstr = Input time string, UTC.
    
    Returns:
      float  et     = Output epoch, ephemeris seconds past J2000.
    """
    return cs1.utc2et(utcstr)

__copy_attributes_from(utc2et, cs1.utc2et)

#########################
# vadd
#########################

def vadd(v1, v2):
    """
    Add two 3 dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vadd_c.html
    
    Inputs:
      float[3] v1 = First vector to be added.
      float[3] v2 = Second vector to be added.
    
    Returns:
      float[3] v3 = Sum vector, v1 + v2.
    """
    return cs1.vadd(v1, v2)

def vadd_vector(v1, v2):
    """
    Add two 3 dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vadd_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1 = First vector to be added.
      float[_,3] v2 = Second vector to be added.
    
    Returns:
      float[_,3] v3 = Sum vector, v1 + v2.
    """
    return cs1.vadd_vector(v1, v2)

__copy_attributes_from(vadd, cs1.vadd)
__copy_attributes_from(vadd_vector, cs1.vadd_vector)

#########################
# vaddg
#########################

def vaddg(v1, v2):
    """
    Add two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vaddg_c.html
    
    Inputs:
      float[*] v1 = First vector to be added.
      float[*] v2 = Second vector to be added.
    
    Returns:
      float[*] v3 = Sum vector, v1 + v2.
    """
    return cs1.vaddg(v1, v2)

def vaddg_vector(v1, v2):
    """
    Add two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vaddg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1 = First vector to be added.
      float[_,*] v2 = Second vector to be added.
    
    Returns:
      float[_,*] v3 = Sum vector, v1 + v2.
    """
    return cs1.vaddg_vector(v1, v2)

__copy_attributes_from(vaddg, cs1.vaddg)
__copy_attributes_from(vaddg_vector, cs1.vaddg_vector)

#########################
# vcrss
#########################

def vcrss(v1, v2):
    """
    Compute the cross product of two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vcrss_c.html
    
    Inputs:
      float[3] v1 = Left hand vector for cross product.
      float[3] v2 = Right hand vector for cross product.
    
    Returns:
      float[3] v3 = Cross product v1xv2.
    """
    return cs1.vcrss(v1, v2)

def vcrss_vector(v1, v2):
    """
    Compute the cross product of two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vcrss_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1 = Left hand vector for cross product.
      float[_,3] v2 = Right hand vector for cross product.
    
    Returns:
      float[_,3] v3 = Cross product v1xv2.
    """
    return cs1.vcrss_vector(v1, v2)

__copy_attributes_from(vcrss, cs1.vcrss)
__copy_attributes_from(vcrss_vector, cs1.vcrss_vector)

#########################
# vdist
#########################

def vdist(v1, v2):
    """
    Return the distance between two three-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdist_c.html
    
    Inputs:
      float[3] v1   = The first of two 3-vectors.
      float[3] v2   = The second of two 3-vectors.
    
    Returns:
      float    dist = The distance between v1 and v2.
    """
    return cs1.vdist(v1, v2)

def vdist_vector(v1, v2):
    """
    Return the distance between two three-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdist_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1   = The first of two 3-vectors.
      float[_,3] v2   = The second of two 3-vectors.
    
    Returns:
      float[_]   dist = The distance between v1 and v2.
    """
    return cs1.vdist_vector(v1, v2)

__copy_attributes_from(vdist, cs1.vdist)
__copy_attributes_from(vdist_vector, cs1.vdist_vector)

#########################
# vdistg
#########################

def vdistg(v1, v2):
    """
    Return the distance between two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdistg_c.html
    
    Inputs:
      float[*] v1   = The first of two vectors of arbitrary dimension.
      float[*] v2   = The second of two vectors of arbitrary dimension.
    
    Returns:
      float    dist = The distance between v1 and v2.
    """
    return cs1.vdistg(v1, v2)

def vdistg_vector(v1, v2):
    """
    Return the distance between two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdistg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1   = The first of two vectors of arbitrary dimension.
      float[_,*] v2   = The second of two vectors of arbitrary dimension.
    
    Returns:
      float[_]   dist = The distance between v1 and v2.
    """
    return cs1.vdistg_vector(v1, v2)

__copy_attributes_from(vdistg, cs1.vdistg)
__copy_attributes_from(vdistg_vector, cs1.vdistg_vector)

#########################
# vdot
#########################

def vdot(v1, v2):
    """
    Compute the dot product of two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdot_c.html
    
    Inputs:
      float[3] v1    = First vector in the dot product.
      float[3] v2    = Second vector in the dot product.
    
    Returns:
      float    value = The dot product of v1 and v2.
    """
    return cs1.vdot(v1, v2)

def vdot_vector(v1, v2):
    """
    Compute the dot product of two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdot_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1    = First vector in the dot product.
      float[_,3] v2    = Second vector in the dot product.
    
    Returns:
      float[_]   value = The dot product of v1 and v2.
    """
    return cs1.vdot_vector(v1, v2)

__copy_attributes_from(vdot, cs1.vdot)
__copy_attributes_from(vdot_vector, cs1.vdot_vector)

#########################
# vdotg
#########################

def vdotg(v1, v2):
    """
    Compute the dot product of two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdotg_c.html
    
    Inputs:
      float[*] v1    = First vector in the dot product.
      float[*] v2    = Second vector in the dot product.
    
    Returns:
      float    value = The dot product of v1 and v2.
    """
    return cs1.vdotg(v1, v2)

def vdotg_vector(v1, v2):
    """
    Compute the dot product of two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vdotg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1    = First vector in the dot product.
      float[_,*] v2    = Second vector in the dot product.
    
    Returns:
      float[_]   value = The dot product of v1 and v2.
    """
    return cs1.vdotg_vector(v1, v2)

__copy_attributes_from(vdotg, cs1.vdotg)
__copy_attributes_from(vdotg_vector, cs1.vdotg_vector)

#########################
# vequ
#########################

def vequ(v1):
    """
    Make one 3-dimensional vector equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vequ_c.html
    
    Inputs:
      float[3] v1 = 3-dimensional vector.
    
    Returns:
      float[3] v2 = 3-dimensional vector set equal to vin.
    """
    return cs1.vequ(v1)

def vequ_vector(v1):
    """
    Make one 3-dimensional vector equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vequ_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1 = 3-dimensional vector.
    
    Returns:
      float[_,3] v2 = 3-dimensional vector set equal to vin.
    """
    return cs1.vequ_vector(v1)

__copy_attributes_from(vequ, cs1.vequ)
__copy_attributes_from(vequ_vector, cs1.vequ_vector)

#########################
# vequg
#########################

def vequg(v1):
    """
    Make one vector of arbitrary dimension equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vequg_c.html
    
    Inputs:
      float[*] v1 = Input vector.
    
    Returns:
      float[*] v2 = Vector set equal to vin.
    """
    return cs1.vequg(v1)

def vequg_vector(v1):
    """
    Make one vector of arbitrary dimension equal to another.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vequg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1 = Input vector.
    
    Returns:
      float[_,*] v2 = Vector set equal to vin.
    """
    return cs1.vequg_vector(v1)

__copy_attributes_from(vequg, cs1.vequg)
__copy_attributes_from(vequg_vector, cs1.vequg_vector)

#########################
# vhat
#########################

def vhat(v1):
    """
    Find the unit vector along a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vhat_c.html
    
    Inputs:
      float[3] v1 = Vector to be unitized.
    
    Returns:
      float[3] v2 = Unit vector v1 / |v1|.
    """
    return cs1.vhat(v1)

def vhat_vector(v1):
    """
    Find the unit vector along a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vhat_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1 = Vector to be unitized.
    
    Returns:
      float[_,3] v2 = Unit vector v1 / |v1|.
    """
    return cs1.vhat_vector(v1)

__copy_attributes_from(vhat, cs1.vhat)
__copy_attributes_from(vhat_vector, cs1.vhat_vector)

#########################
# vhatg
#########################

def vhatg(v1):
    """
    Find the unit vector along a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vhatg_c.html
    
    Inputs:
      float[*] v1 = Vector to be normalized.
    
    Returns:
      float[*] v2 = Unit vector v1 / |v1|. If v1 is the zero vector, v2 will
                    also be zero.
    """
    return cs1.vhatg(v1)

def vhatg_vector(v1):
    """
    Find the unit vector along a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vhatg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1 = Vector to be normalized.
    
    Returns:
      float[_,*] v2 = Unit vector v1 / |v1|. If v1 is the zero vector, v2
                      will also be zero.
    """
    return cs1.vhatg_vector(v1)

__copy_attributes_from(vhatg, cs1.vhatg)
__copy_attributes_from(vhatg_vector, cs1.vhatg_vector)

#########################
# vlcom
#########################

def vlcom(a, v1, b, v2):
    """
    Compute a vector linear combination of two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vlcom_c.html
    
    Inputs:
      float    a   = Coefficient of v1.
      float[3] v1  = Vector in 3-space.
      float    b   = Coefficient of v2.
      float[3] v2  = Vector in 3-space.
    
    Returns:
      float[3] sum = Linear vector combination a*v1 + b*v2.
    """
    return cs1.vlcom(a, v1, b, v2)

def vlcom_vector(a, v1, b, v2):
    """
    Compute a vector linear combination of two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vlcom_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   a   = Coefficient of v1.
      float[_,3] v1  = Vector in 3-space.
      float[_]   b   = Coefficient of v2.
      float[_,3] v2  = Vector in 3-space.
    
    Returns:
      float[_,3] sum = Linear vector combination a*v1 + b*v2.
    """
    return cs1.vlcom_vector(a, v1, b, v2)

__copy_attributes_from(vlcom, cs1.vlcom)
__copy_attributes_from(vlcom_vector, cs1.vlcom_vector)

#########################
# vlcom3
#########################

def vlcom3(a, v1, b, v2, c, v3):
    """
    This subroutine computes the vector linear combination a*v1 + b*v2 +
    c*v3 of 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vlcom3_c.html
    
    Inputs:
      float    a   = Coefficient of v1.
      float[3] v1  = Vector in 3-space.
      float    b   = Coefficient of v2.
      float[3] v2  = Vector in 3-space.
      float    c   = Coefficient of v3.
      float[3] v3  = Vector in 3-space.
    
    Returns:
      float[3] sum = Linear vector combination a*v1 + b*v2 + c*v3.
    """
    return cs1.vlcom3(a, v1, b, v2, c, v3)

def vlcom3_vector(a, v1, b, v2, c, v3):
    """
    This subroutine computes the vector linear combination a*v1 + b*v2 +
    c*v3 of 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vlcom3_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   a   = Coefficient of v1.
      float[_,3] v1  = Vector in 3-space.
      float[_]   b   = Coefficient of v2.
      float[_,3] v2  = Vector in 3-space.
      float[_]   c   = Coefficient of v3.
      float[_,3] v3  = Vector in 3-space.
    
    Returns:
      float[_,3] sum = Linear vector combination a*v1 + b*v2 + c*v3.
    """
    return cs1.vlcom3_vector(a, v1, b, v2, c, v3)

__copy_attributes_from(vlcom3, cs1.vlcom3)
__copy_attributes_from(vlcom3_vector, cs1.vlcom3_vector)

#########################
# vlcomg
#########################

def vlcomg(a, v1, b, v2):
    """
    Compute a vector linear combination of two vectors of arbitrary
    dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vlcomg_c.html
    
    Inputs:
      float    a  = Coefficient of v1.
      float[*] v1 = Vector in n-space.
      float    b  = Coefficient of v2.
      float[*] v2 = Vector in n-space.
    
    Returns:
      float[*] v3 = Linear vector combination a*v1 + b*v2.
    """
    return cs1.vlcomg(a, v1, b, v2)

def vlcomg_vector(a, v1, b, v2):
    """
    Compute a vector linear combination of two vectors of arbitrary
    dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vlcomg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   a  = Coefficient of v1.
      float[_,*] v1 = Vector in n-space.
      float[_]   b  = Coefficient of v2.
      float[_,*] v2 = Vector in n-space.
    
    Returns:
      float[_,*] v3 = Linear vector combination a*v1 + b*v2.
    """
    return cs1.vlcomg_vector(a, v1, b, v2)

__copy_attributes_from(vlcomg, cs1.vlcomg)
__copy_attributes_from(vlcomg_vector, cs1.vlcomg_vector)

#########################
# vminug
#########################

def vminug(v1):
    """
    Negate a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vminug_c.html
    
    Inputs:
      float[*] v1 = Vector to be negated.
    
    Returns:
      float[*] v2 = Vector equal to -vin.
    """
    return cs1.vminug(v1)

def vminug_vector(v1):
    """
    Negate a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vminug_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1 = Vector to be negated.
    
    Returns:
      float[_,*] v2 = Vector equal to -vin.
    """
    return cs1.vminug_vector(v1)

__copy_attributes_from(vminug, cs1.vminug)
__copy_attributes_from(vminug_vector, cs1.vminug_vector)

#########################
# vminus
#########################

def vminus(v1):
    """
    Negate a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vminus_c.html
    
    Inputs:
      float[3] v1 = Vector to be negated.
    
    Returns:
      float[3] v2 = Negated vector -v1.
    """
    return cs1.vminus(v1)

def vminus_vector(v1):
    """
    Negate a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vminus_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1 = Vector to be negated.
    
    Returns:
      float[_,3] v2 = Negated vector -v1.
    """
    return cs1.vminus_vector(v1)

__copy_attributes_from(vminus, cs1.vminus)
__copy_attributes_from(vminus_vector, cs1.vminus_vector)

#########################
# vnorm
#########################

def vnorm(v1):
    """
    Compute the magnitude of a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vnorm_c.html
    
    Inputs:
      float[3] v1    = Vector whose magnitude is to be found.
    
    Returns:
      float    value = The norm of v1.
    """
    return cs1.vnorm(v1)

def vnorm_vector(v1):
    """
    Compute the magnitude of a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vnorm_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1    = Vector whose magnitude is to be found.
    
    Returns:
      float[_]   value = The norm of v1.
    """
    return cs1.vnorm_vector(v1)

__copy_attributes_from(vnorm, cs1.vnorm)
__copy_attributes_from(vnorm_vector, cs1.vnorm_vector)

#########################
# vnormg
#########################

def vnormg(v1):
    """
    Compute the magnitude of a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vnormg_c.html
    
    Inputs:
      float[*] v1    = Vector whose magnitude is to be found.
    
    Returns:
      float    value = The norm of v1.
    """
    return cs1.vnormg(v1)

def vnormg_vector(v1):
    """
    Compute the magnitude of a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vnormg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1    = Vector whose magnitude is to be found.
    
    Returns:
      float[_]   value = The norm of v1.
    """
    return cs1.vnormg_vector(v1)

__copy_attributes_from(vnormg, cs1.vnormg)
__copy_attributes_from(vnormg_vector, cs1.vnormg_vector)

#########################
# vpack
#########################

def vpack(x, y, z):
    """
    Pack three scalar components into a vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vpack_c.html
    
    Inputs:
      float    x = First scalar component of a 3-vector.
      float    y = Second scalar component of a 3-vector.
      float    z = Third scalar component of a 3-vector.
    
    Returns:
      float[3] v = Equivalent 3-vector.
    """
    return cs1.vpack(x, y, z)

def vpack_vector(x, y, z):
    """
    Pack three scalar components into a vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vpack_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   x = First scalar component of a 3-vector.
      float[_]   y = Second scalar component of a 3-vector.
      float[_]   z = Third scalar component of a 3-vector.
    
    Returns:
      float[_,3] v = Equivalent 3-vector.
    """
    return cs1.vpack_vector(x, y, z)

__copy_attributes_from(vpack, cs1.vpack)
__copy_attributes_from(vpack_vector, cs1.vpack_vector)

#########################
# vperp
#########################

def vperp(a, b):
    """
    Find the component of a vector that is perpendicular to a second vector.
    All vectors are 3-dimensional.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vperp_c.html
    
    Inputs:
      float[3] a = The vector whose orthogonal component is sought.
      float[3] b = The vector used as the orthogonal reference.
    
    Returns:
      float[3] p = The component of a orthogonal to b.
    """
    return cs1.vperp(a, b)

def vperp_vector(a, b):
    """
    Find the component of a vector that is perpendicular to a second vector.
    All vectors are 3-dimensional.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vperp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] a = The vector whose orthogonal component is sought.
      float[_,3] b = The vector used as the orthogonal reference.
    
    Returns:
      float[_,3] p = The component of a orthogonal to b.
    """
    return cs1.vperp_vector(a, b)

__copy_attributes_from(vperp, cs1.vperp)
__copy_attributes_from(vperp_vector, cs1.vperp_vector)

#########################
# vprjp
#########################

def vprjp(v1, plane):
    """
    Project a vector onto a specified plane, orthogonally.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vprjp_c.html
    
    Inputs:
      float[3]           v1    = Vector to be projected.
      ConstSpicePlane[*] plane = A CSPICE plane onto which vin is projected.
    
    Returns:
      float[3]           v2    = Vector resulting from projection.
    """
    return cs1.vprjp(v1, plane)

def vprjp_vector(v1, plane):
    """
    Project a vector onto a specified plane, orthogonally.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vprjp_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]         v1    = Vector to be projected.
      ConstSpicePlane[*] plane = A CSPICE plane onto which vin is projected.
    
    Returns:
      float[_,3]         v2    = Vector resulting from projection.
    """
    return cs1.vprjp_vector(v1, plane)

__copy_attributes_from(vprjp, cs1.vprjp)
__copy_attributes_from(vprjp_vector, cs1.vprjp_vector)

#########################
# vprjpi
#########################

def vprjpi(v1, projpl, invpl):
    """
    Find the vector in a specified plane that maps to a specified vector in
    another plane under orthogonal projection.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vprjpi_c.html
    
    Inputs:
      float[3]           v1     = The projected vector.
      ConstSpicePlane[*] projpl = Plane containing v1.
      ConstSpicePlane[*] invpl  = Plane containing inverse image of v1.
    
    Returns:
      float[3]           v2     = Inverse projection of v1.
      bool               found  = Flag indicating whether v2 could be
                                  calculated.
    """
    return cs1.vprjpi(v1, projpl, invpl)

def vprjpi_vector(v1, projpl, invpl):
    """
    Find the vector in a specified plane that maps to a specified vector in
    another plane under orthogonal projection.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vprjpi_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]         v1     = The projected vector.
      ConstSpicePlane[*] projpl = Plane containing v1.
      ConstSpicePlane[*] invpl  = Plane containing inverse image of v1.
    
    Returns:
      float[_,3]         v2     = Inverse projection of v1.
      bool               found  = Flag indicating whether v2 could be
                                  calculated.
    """
    return cs1.vprjpi_vector(v1, projpl, invpl)

__copy_attributes_from(vprjpi, cs1.vprjpi)
__copy_attributes_from(vprjpi_vector, cs1.vprjpi_vector)

#########################
# vproj
#########################

def vproj(a, b):
    """
    Find the projection of one vector onto another vector. All vectors are
    3-dimensional.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vproj_c.html
    
    Inputs:
      float[3] a = The vector to be projected.
      float[3] b = The vector onto which a is to be projected.
    
    Returns:
      float[3] p = The projection of a onto b.
    """
    return cs1.vproj(a, b)

def vproj_vector(a, b):
    """
    Find the projection of one vector onto another vector. All vectors are
    3-dimensional.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vproj_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] a = The vector to be projected.
      float[_,3] b = The vector onto which a is to be projected.
    
    Returns:
      float[_,3] p = The projection of a onto b.
    """
    return cs1.vproj_vector(a, b)

__copy_attributes_from(vproj, cs1.vproj)
__copy_attributes_from(vproj_vector, cs1.vproj_vector)

#########################
# vprojg
#########################

def vprojg(a, b):
    """
    Compute the projection of one vector onto another vector. All vectors
    are of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vprojg_c.html
    
    Inputs:
      float[*] a = The vector to be projected.
      float[*] b = The vector onto which `a' is to be projected.
    
    Returns:
      float[*] p = The projection of `a' onto `b'.
    """
    return cs1.vprojg(a, b)

def vprojg_vector(a, b):
    """
    Compute the projection of one vector onto another vector. All vectors
    are of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vprojg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] a = The vector to be projected.
      float[_,*] b = The vector onto which `a' is to be projected.
    
    Returns:
      float[_,*] p = The projection of `a' onto `b'.
    """
    return cs1.vprojg_vector(a, b)

__copy_attributes_from(vprojg, cs1.vprojg)
__copy_attributes_from(vprojg_vector, cs1.vprojg_vector)

#########################
# vrel
#########################

def vrel(v1, v2):
    """
    Return the relative difference between two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vrel_c.html
    
    Inputs:
      float[3] v1    = First input vector.
      float[3] v2    = Second input vector.
    
    Returns:
      float    value = The relative difference of v1 and v2.
    """
    return cs1.vrel(v1, v2)

def vrel_vector(v1, v2):
    """
    Return the relative difference between two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vrel_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1    = First input vector.
      float[_,3] v2    = Second input vector.
    
    Returns:
      float[_]   value = The relative difference of v1 and v2.
    """
    return cs1.vrel_vector(v1, v2)

__copy_attributes_from(vrel, cs1.vrel)
__copy_attributes_from(vrel_vector, cs1.vrel_vector)

#########################
# vrelg
#########################

def vrelg(v1, v2):
    """
    Return the relative difference between two vectors of general dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vrelg_c.html
    
    Inputs:
      float[*] v1    = First input vector.
      float[*] v2    = Second input vector.
    
    Returns:
      float    value = The relative difference of v1 and v2.
    """
    return cs1.vrelg(v1, v2)

def vrelg_vector(v1, v2):
    """
    Return the relative difference between two vectors of general dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vrelg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1    = First input vector.
      float[_,*] v2    = Second input vector.
    
    Returns:
      float[_]   value = The relative difference of v1 and v2.
    """
    return cs1.vrelg_vector(v1, v2)

__copy_attributes_from(vrelg, cs1.vrelg)
__copy_attributes_from(vrelg_vector, cs1.vrelg_vector)

#########################
# vrotv
#########################

def vrotv(v, axis, theta):
    """
    Rotate a vector about a specified axis vector by a specified angle and
    return the rotated vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vrotv_c.html
    
    Inputs:
      float[3] v     = Vector to be rotated.
      float[3] axis  = Axis of the rotation.
      float    theta = Angle of rotation (radians).
    
    Returns:
      float[3] r     = Result of rotating v about axis by theta.
    """
    return cs1.vrotv(v, axis, theta)

def vrotv_vector(v, axis, theta):
    """
    Rotate a vector about a specified axis vector by a specified angle and
    return the rotated vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vrotv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v     = Vector to be rotated.
      float[_,3] axis  = Axis of the rotation.
      float[_]   theta = Angle of rotation (radians).
    
    Returns:
      float[_,3] r     = Result of rotating v about axis by theta.
    """
    return cs1.vrotv_vector(v, axis, theta)

__copy_attributes_from(vrotv, cs1.vrotv)
__copy_attributes_from(vrotv_vector, cs1.vrotv_vector)

#########################
# vscl
#########################

def vscl(s, v1):
    """
    Multiply a scalar and a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vscl_c.html
    
    Inputs:
      float    s  = Scalar to multiply a vector.
      float[3] v1 = Vector to be multiplied.
    
    Returns:
      float[3] v2 = Product vector, s*v1.
    """
    return cs1.vscl(s, v1)

def vscl_vector(s, v1):
    """
    Multiply a scalar and a 3-dimensional vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vscl_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   s  = Scalar to multiply a vector.
      float[_,3] v1 = Vector to be multiplied.
    
    Returns:
      float[_,3] v2 = Product vector, s*v1.
    """
    return cs1.vscl_vector(s, v1)

__copy_attributes_from(vscl, cs1.vscl)
__copy_attributes_from(vscl_vector, cs1.vscl_vector)

#########################
# vsclg
#########################

def vsclg(s, v1):
    """
    Multiply a scalar and a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsclg_c.html
    
    Inputs:
      float    s  = Scalar to multiply a vector.
      float[*] v1 = Vector to be multiplied.
    
    Returns:
      float[*] v2 = Product vector, s*v1.
    """
    return cs1.vsclg(s, v1)

def vsclg_vector(s, v1):
    """
    Multiply a scalar and a vector of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsclg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_]   s  = Scalar to multiply a vector.
      float[_,*] v1 = Vector to be multiplied.
    
    Returns:
      float[_,*] v2 = Product vector, s*v1.
    """
    return cs1.vsclg_vector(s, v1)

__copy_attributes_from(vsclg, cs1.vsclg)
__copy_attributes_from(vsclg_vector, cs1.vsclg_vector)

#########################
# vsep
#########################

def vsep(v1, v2):
    """
    Find the separation angle in radians between two 3-dimensional vectors.
    This angle is defined as zero if either vector is zero.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsep_c.html
    
    Inputs:
      float[3] v1    = First vector.
      float[3] v2    = Second vector.
    
    Returns:
      float    value = The separation angle in radians.
    """
    return cs1.vsep(v1, v2)

def vsep_vector(v1, v2):
    """
    Find the separation angle in radians between two 3-dimensional vectors.
    This angle is defined as zero if either vector is zero.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsep_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1    = First vector.
      float[_,3] v2    = Second vector.
    
    Returns:
      float[_]   value = The separation angle in radians.
    """
    return cs1.vsep_vector(v1, v2)

__copy_attributes_from(vsep, cs1.vsep)
__copy_attributes_from(vsep_vector, cs1.vsep_vector)

#########################
# vsepg
#########################

def vsepg(v1, v2):
    """
    Find the separation angle in radians between two vectors of arbitrary
    dimension. This angle is defined as zero if either vector is zero.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsepg_c.html
    
    Inputs:
      float[*] v1    = First vector.
      float[*] v2    = Second vector.
    
    Returns:
      float    value = The separation angle in radians.
    """
    return cs1.vsepg(v1, v2)

def vsepg_vector(v1, v2):
    """
    Find the separation angle in radians between two vectors of arbitrary
    dimension. This angle is defined as zero if either vector is zero.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsepg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1    = First vector.
      float[_,*] v2    = Second vector.
    
    Returns:
      float[_]   value = The separation angle in radians.
    """
    return cs1.vsepg_vector(v1, v2)

__copy_attributes_from(vsepg, cs1.vsepg)
__copy_attributes_from(vsepg_vector, cs1.vsepg_vector)

#########################
# vsub
#########################

def vsub(v1, v2):
    """
    Compute the difference between two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsub_c.html
    
    Inputs:
      float[3] v1 = First vector (minuend).
      float[3] v2 = Second vector (subtrahend).
    
    Returns:
      float[3] v3 = Difference vector, v1 - v2.
    """
    return cs1.vsub(v1, v2)

def vsub_vector(v1, v2):
    """
    Compute the difference between two 3-dimensional vectors.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsub_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v1 = First vector (minuend).
      float[_,3] v2 = Second vector (subtrahend).
    
    Returns:
      float[_,3] v3 = Difference vector, v1 - v2.
    """
    return cs1.vsub_vector(v1, v2)

__copy_attributes_from(vsub, cs1.vsub)
__copy_attributes_from(vsub_vector, cs1.vsub_vector)

#########################
# vsubg
#########################

def vsubg(v1, v2):
    """
    Compute the difference between two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsubg_c.html
    
    Inputs:
      float[*] v1 = First vector (minuend).
      float[*] v2 = Second vector (subtrahend).
    
    Returns:
      float[*] v3 = Difference vector, v1 - v2.
    """
    return cs1.vsubg(v1, v2)

def vsubg_vector(v1, v2):
    """
    Compute the difference between two vectors of arbitrary dimension.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vsubg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1 = First vector (minuend).
      float[_,*] v2 = Second vector (subtrahend).
    
    Returns:
      float[_,*] v3 = Difference vector, v1 - v2.
    """
    return cs1.vsubg_vector(v1, v2)

__copy_attributes_from(vsubg, cs1.vsubg)
__copy_attributes_from(vsubg_vector, cs1.vsubg_vector)

#########################
# vtmv
#########################

def vtmv(v1, matrix, v2):
    """
    Multiply the transpose of a 3-dimensional column vector, a 3x3 matrix,
    and a 3-dimensional column vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vtmv_c.html
    
    Inputs:
      float[3]   v1     = 3 dimensional column vector.
      float[3,3] matrix = 3x3 matrix.
      float[3]   v2     = 3 dimensional column vector.
    
    Returns:
      float      value  = The result of (v1**t * matrix * v2).
    """
    return cs1.vtmv(v1, matrix, v2)

def vtmv_vector(v1, matrix, v2):
    """
    Multiply the transpose of a 3-dimensional column vector, a 3x3 matrix,
    and a 3-dimensional column vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vtmv_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3]   v1     = 3 dimensional column vector.
      float[_,3,3] matrix = 3x3 matrix.
      float[_,3]   v2     = 3 dimensional column vector.
    
    Returns:
      float[_]     value  = The result of (v1**t * matrix * v2).
    """
    return cs1.vtmv_vector(v1, matrix, v2)

__copy_attributes_from(vtmv, cs1.vtmv)
__copy_attributes_from(vtmv_vector, cs1.vtmv_vector)

#########################
# vtmvg
#########################

def vtmvg(v1, matrix, v2):
    """
    Multiply the transpose of a n-dimensional column vector, a nxm matrix,
    and a m-dimensional column vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vtmvg_c.html
    
    Inputs:
      float[*] v1     = n-dimensional column vector.
      float[*] matrix = nxm matrix.
      float[*] v2     = m-dimensional column vector.
    
    Returns:
      float    value  = The result of (v1**t * matrix * v2).
    """
    return cs1.vtmvg(v1, matrix, v2)

def vtmvg_vector(v1, matrix, v2):
    """
    Multiply the transpose of a n-dimensional column vector, a nxm matrix,
    and a m-dimensional column vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vtmvg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v1     = n-dimensional column vector.
      float[_,*] matrix = nxm matrix.
      float[_,*] v2     = m-dimensional column vector.
    
    Returns:
      float[_]   value  = The result of (v1**t * matrix * v2).
    """
    return cs1.vtmvg_vector(v1, matrix, v2)

__copy_attributes_from(vtmvg, cs1.vtmvg)
__copy_attributes_from(vtmvg_vector, cs1.vtmvg_vector)

#########################
# vupack
#########################

def vupack(v):
    """
    Unpack three scalar components from a vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vupack_c.html
    
    Inputs:
      float[3] v = 3-vector.
    
    Returns:
      float    x = First scalar component of the 3-vector.
      float    y = Second scalar component of the 3-vector.
      float    z = Third scalar component of the 3-vector.
    """
    return cs1.vupack(v)

def vupack_vector(v):
    """
    Unpack three scalar components from a vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vupack_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v = 3-vector.
    
    Returns:
      float[_]   x = First scalar component of the 3-vector.
      float[_]   y = Second scalar component of the 3-vector.
      float[_]   z = Third scalar component of the 3-vector.
    """
    return cs1.vupack_vector(v)

__copy_attributes_from(vupack, cs1.vupack)
__copy_attributes_from(vupack_vector, cs1.vupack_vector)

#########################
# vzero
#########################

def vzero(v):
    """
    Indicate whether a 3-vector is the zero vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vzero_c.html
    
    Inputs:
      float[3] v     = Vector to be tested.
    
    Returns:
      bool     value = True if and only if v is the zero vector.
    """
    return cs1.vzero(v)

def vzero_vector(v):
    """
    Indicate whether a 3-vector is the zero vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vzero_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3] v     = Vector to be tested.
    
    Returns:
      bool       value = True if and only if v is the zero vector.
    """
    return cs1.vzero_vector(v)

__copy_attributes_from(vzero, cs1.vzero)
__copy_attributes_from(vzero_vector, cs1.vzero_vector)

#########################
# vzerog
#########################

def vzerog(v):
    """
    Indicate whether a general-dimensional vector is the zero vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vzerog_c.html
    
    Inputs:
      float[*] v     = Vector to be tested.
    
    Returns:
      bool     value = True if and only if v is the zero vector.
    """
    return cs1.vzerog(v)

def vzerog_vector(v):
    """
    Indicate whether a general-dimensional vector is the zero vector.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/vzerog_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*] v     = Vector to be tested.
    
    Returns:
      bool       value = True if and only if v is the zero vector.
    """
    return cs1.vzerog_vector(v)

__copy_attributes_from(vzerog, cs1.vzerog)
__copy_attributes_from(vzerog_vector, cs1.vzerog_vector)

#########################
# wncomd
#########################

def wncomd(left, right, window, result = 2000):
    """
    Determine the complement of a floating-point window with respect to a
    specified interval.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wncomd_c.html
    
    Inputs:
      float        left   = Left endpoint of complement interval.
      float        right  = Right endpoint of complement interval.
      SpiceCell[*] window = Input window.
      SpiceCell    result = Complement of window with respect to
                            [left,right].
    
    Returns:
      SpiceCell    result = Complement of window with respect to
                            [left,right].
    """
    return cs1.wncomd(left, right, window, result)

__copy_attributes_from(wncomd, cs1.wncomd)

#########################
# wncond
#########################

def wncond(left, right, window):
    """
    Contract each of the intervals of a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wncond_c.html
    
    Inputs:
      float     left   = Amount added to each left endpoint.
      float     right  = Amount subtracted from each right endpoint.
      SpiceCell window = Window to be contracted.
    
    Returns:
      SpiceCell window = Window to be contracted.
    """
    return cs1.wncond(left, right, window)

__copy_attributes_from(wncond, cs1.wncond)

#########################
# wndifd
#########################

def wndifd(a, b, c = 2000):
    """
    Place the difference of two floating-point windows into a third window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wndifd_c.html
    
    Inputs:
      SpiceCell[*] a = First input window.
      SpiceCell[*] b = Second input windows.
      SpiceCell    c = Difference of `a' and `b'.
    
    Returns:
      SpiceCell    c = Difference of `a' and `b'.
    """
    return cs1.wndifd(a, b, c)

__copy_attributes_from(wndifd, cs1.wndifd)

#########################
# wnelmd
#########################

def wnelmd(point, window):
    """
    Determine whether a point is an element of a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnelmd_c.html
    
    Inputs:
      float        point  = Input point.
      SpiceCell[*] window = Input window.
    
    Returns:
      bool         flag   = True if the point is an element; False
                            otherwise.
    """
    return cs1.wnelmd(point, window)

__copy_attributes_from(wnelmd, cs1.wnelmd)

#########################
# wnexpd
#########################

def wnexpd(left, right, window):
    """
    Expand each of the intervals of a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnexpd_c.html
    
    Inputs:
      float     left   = Amount subtracted from each left endpoint.
      float     right  = Amount added to each right endpoint.
      SpiceCell window = Window to be expanded.
    
    Returns:
      SpiceCell window = Window to be expanded.
    """
    return cs1.wnexpd(left, right, window)

__copy_attributes_from(wnexpd, cs1.wnexpd)

#########################
# wnextd
#########################

def wnextd(side, window):
    """
    Extract the left or right endpoints from a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnextd_c.html
    
    Inputs:
      string    side   = Extract left ('L') or right ('R') endpoints.
      SpiceCell window = Window to be extracted.
    
    Returns:
      SpiceCell window = Window to be extracted.
    """
    return cs1.wnextd(side, window)

__copy_attributes_from(wnextd, cs1.wnextd)

#########################
# wnfild
#########################

def wnfild(smlgap, window):
    """
    Fill small gaps between adjacent intervals of a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnfild_c.html
    
    Inputs:
      float     smlgap = Limiting measure of small gaps.
      SpiceCell window = Window to be filled.
    
    Returns:
      SpiceCell window = Window to be filled.
    """
    return cs1.wnfild(smlgap, window)

__copy_attributes_from(wnfild, cs1.wnfild)

#########################
# wnfltd
#########################

def wnfltd(smlint, window):
    """
    Filter (remove) small intervals from a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnfltd_c.html
    
    Inputs:
      float     smlint = Limiting measure of small intervals.
      SpiceCell window = Window to be filtered.
    
    Returns:
      SpiceCell window = Window to be filtered.
    """
    return cs1.wnfltd(smlint, window)

__copy_attributes_from(wnfltd, cs1.wnfltd)

#########################
# wnincd
#########################

def wnincd(left, right, window):
    """
    Determine whether an interval is included in a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnincd_c.html
    
    Inputs:
      float        left   = Minimum of input interval.
      float        right  = Maximum of input interval.
      SpiceCell[*] window = Input window.
    
    Returns:
      bool         flag   = True if the interval is included; False
                            otherwise.
    """
    return cs1.wnincd(left, right, window)

__copy_attributes_from(wnincd, cs1.wnincd)

#########################
# wninsd
#########################

def wninsd(left, right, window):
    """
    Insert an interval into a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wninsd_c.html
    
    Inputs:
      float           left   = Left endpoint of new interval.
      float           right  = Right endpoint of new interval.
      SpiceCellDouble window = Input window.
    
    Returns:
      SpiceCellDouble window = Input window.
    """
    return cs1.wninsd(left, right, window)

__copy_attributes_from(wninsd, cs1.wninsd)

#########################
# wnintd
#########################

def wnintd(a, b, c = 2000):
    """
    Place the intersection of two floating-point windows into a third
    window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnintd_c.html
    
    Inputs:
      SpiceCell[*] a = First input window.
      SpiceCell[*] b = Second input window.
      SpiceCell    c = Intersection of `a' and `b'.
    
    Returns:
      SpiceCell    c = Intersection of `a' and `b'.
    """
    return cs1.wnintd(a, b, c)

__copy_attributes_from(wnintd, cs1.wnintd)

#########################
# wnreld
#########################

def wnreld(a, op, b):
    """
    Compare two floating-point windows.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnreld_c.html
    
    Inputs:
      SpiceCell[*] a    = First window.
      string       op   = Comparison operator: "=" for equal; "<>" for not
                          equal; "<=" for `a' a subset of `b'; "<" for `a' a
                          proper subset of `b'; ">=" for `b' a subset of
                          `a'; ">" for `b' a proper subset of `a'.
      SpiceCell[*] b    = Second window.
    
    Returns:
      bool         flag = True if the comparison is satisfied.
    """
    return cs1.wnreld(a, op, b)

__copy_attributes_from(wnreld, cs1.wnreld)

#########################
# wnsumd
#########################

def wnsumd(window):
    """
    Summarize the contents of a floating-point window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnsumd_c.html
    
    Inputs:
      SpiceCell[*] window = Window to be summarized.
    
    Returns:
      float        meas   = Total measure of intervals in window.
      float        avg    = Average measure.
      float        stddev = Standard deviation.
      int          idxsml = Location of shortest interval.
      int          idxlon = Location of longest interval.
    """
    return cs1.wnsumd(window)

__copy_attributes_from(wnsumd, cs1.wnsumd)

#########################
# wnunid
#########################

def wnunid(a, b, c = 2000):
    """
    Place the union of two floating-point windows into a third window.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/wnunid_c.html
    
    Inputs:
      SpiceCell[*] a = First input window.
      SpiceCell[*] b = Second input window.
      SpiceCell    c = Union of `a' and `b'.
    
    Returns:
      SpiceCell    c = Union of `a' and `b'.
    """
    return cs1.wnunid(a, b, c)

__copy_attributes_from(wnunid, cs1.wnunid)

#########################
# xf2eul
#########################

def xf2eul(xform, axisa, axisb, axisc):
    """
    Convert a state transformation matrix to Euler angles and their
    derivatives with respect to a specified set of axes. The companion
    routine eul2xf converts Euler angles and their derivatives with respect
    to a specified set of axes to a state transformation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xf2eul_c.html
    
    Inputs:
      float[6,6] xform  = A state transformation matrix.
      int        axisa  = Axis A of the Euler angle factorization.
      int        axisb  = Axis B of the Euler angle factorization.
      int        axisc  = Axis C of the Euler angle factorization.
    
    Returns:
      float[6]   eulang = An array of Euler angles and their derivatives.
      bool       unique = Indicates if eulang is a unique representation.
    """
    return cs1.xf2eul(xform, axisa, axisb, axisc)

def xf2eul_vector(xform, axisa, axisb, axisc):
    """
    Convert a state transformation matrix to Euler angles and their
    derivatives with respect to a specified set of axes. The companion
    routine eul2xf converts Euler angles and their derivatives with respect
    to a specified set of axes to a state transformation matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xf2eul_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6,6] xform  = A state transformation matrix.
      int          axisa  = Axis A of the Euler angle factorization.
      int          axisb  = Axis B of the Euler angle factorization.
      int          axisc  = Axis C of the Euler angle factorization.
    
    Returns:
      float[_,6]   eulang = An array of Euler angles and their derivatives.
      bool         unique = Indicates if eulang is a unique representation.
    """
    return cs1.xf2eul_vector(xform, axisa, axisb, axisc)

__copy_attributes_from(xf2eul, cs1.xf2eul)
__copy_attributes_from(xf2eul_vector, cs1.xf2eul_vector)

#########################
# xf2rav
#########################

def xf2rav(xform):
    """
    This routine determines from a state transformation matrix the
    associated rotation matrix and angular velocity of the rotation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xf2rav_c.html
    
    Inputs:
      float[6,6] xform = State transformation matrix.
    
    Returns:
      float[3,3] rot   = Rotation associated with xform.
      float[3]   av    = Angular velocity associated with xform.
    """
    return cs1.xf2rav(xform)

def xf2rav_vector(xform):
    """
    This routine determines from a state transformation matrix the
    associated rotation matrix and angular velocity of the rotation.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xf2rav_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6,6] xform = State transformation matrix.
    
    Returns:
      float[_,3,3] rot   = Rotation associated with xform.
      float[_,3]   av    = Angular velocity associated with xform.
    """
    return cs1.xf2rav_vector(xform)

__copy_attributes_from(xf2rav, cs1.xf2rav)
__copy_attributes_from(xf2rav_vector, cs1.xf2rav_vector)

#########################
# xfmsta
#########################

def xfmsta(state1, insys, outsys, body):
    """
    Transform a state between coordinate systems.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xfmsta_c.html
    
    Inputs:
      float[6] state1 = Input state.
      string   insys  = Current (input) coordinate system.
      string   outsys = Desired (output) coordinate system.
      string   body   = Name or NAIF ID of body with which coordinates are
                        associated (if applicable).
    
    Returns:
      float[6] state2 = Converted output state.
    """
    return cs1.xfmsta(state1, insys, outsys, body)

def xfmsta_vector(state1, insys, outsys, body):
    """
    Transform a state between coordinate systems.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xfmsta_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6] state1 = Input state.
      string     insys  = Current (input) coordinate system.
      string     outsys = Desired (output) coordinate system.
      string     body   = Name or NAIF ID of body with which coordinates are
                          associated (if applicable).
    
    Returns:
      float[_,6] state2 = Converted output state.
    """
    return cs1.xfmsta_vector(state1, insys, outsys, body)

__copy_attributes_from(xfmsta, cs1.xfmsta)
__copy_attributes_from(xfmsta_vector, cs1.xfmsta_vector)

#########################
# xpose
#########################

def xpose(m1):
    """
    Transpose a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xpose_c.html
    
    Inputs:
      float[3,3] m1     = 3x3 matrix to be transposed.
    
    Returns:
      float[3,3] matrix = Transpose of m1.
    """
    return cs1.xpose(m1)

def xpose_vector(m1):
    """
    Transpose a 3x3 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xpose_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,3,3] m1     = 3x3 matrix to be transposed.
    
    Returns:
      float[_,3,3] matrix = Transpose of m1.
    """
    return cs1.xpose_vector(m1)

__copy_attributes_from(xpose, cs1.xpose)
__copy_attributes_from(xpose_vector, cs1.xpose_vector)

#########################
# xpose6
#########################

def xpose6(m1):
    """
    Transpose a 6x6 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xpose6_c.html
    
    Inputs:
      float[6,6] m1     = 6x6 matrix to be transposed.
    
    Returns:
      float[6,6] matrix = Transpose of m1.
    """
    return cs1.xpose6(m1)

def xpose6_vector(m1):
    """
    Transpose a 6x6 matrix.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xpose6_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,6,6] m1     = 6x6 matrix to be transposed.
    
    Returns:
      float[_,6,6] matrix = Transpose of m1.
    """
    return cs1.xpose6_vector(m1)

__copy_attributes_from(xpose6, cs1.xpose6)
__copy_attributes_from(xpose6_vector, cs1.xpose6_vector)

#########################
# xposeg
#########################

def xposeg(matrix):
    """
    Transpose a matrix of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xposeg_c.html
    
    Inputs:
      float[*,*] matrix = Matrix to be transposed.
    
    Returns:
      float[*,*] xposem = Transposed matrix.
    """
    return cs1.xposeg(matrix)

def xposeg_vector(matrix):
    """
    Transpose a matrix of arbitrary size.
    
    https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/xposeg_c.html
    
    In this vectorized version, any or all of the floating-point inputs can
    have an extra leading dimension. The function will loop over this axis
    and return arrays of the results. If no inputs have an extra dimension,
    it returns results identical to the un-vectorized version.
    
    Inputs:
      float[_,*,*] matrix = Matrix to be transposed.
    
    Returns:
      float[_,*,*] xposem = Transposed matrix.
    """
    return cs1.xposeg_vector(matrix)

__copy_attributes_from(xposeg, cs1.xposeg)
__copy_attributes_from(xposeg_vector, cs1.xposeg_vector)

erract('SET', 'EXCEPTION')
